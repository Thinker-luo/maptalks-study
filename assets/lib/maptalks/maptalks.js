/*!
 * maptalks v1.0.0-rc.33
 * LICENSE : BSD-3-Clause
 * (c) 2016-2024 maptalks.org
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.maptalks = {}));
})(this, (function (exports) { 'use strict';

  var version = "1.0.0-rc.33";

  /**
   * from detect-node
   * https://github.com/iliakan/detect-node
   *
   * @property {boolean} IS_NODE - whether running in nodejs but not on electron,node-webkit
   * @global
   * @name IS_NODE
   */
  var IS_NODE = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && !process.versions['electron'] && !process.versions['nw'] && !process.versions['node-webkit'];
  function getGlobalThis() {
      return typeof globalThis !== 'undefined' ? globalThis : global || self;
  }

  /**
   * global config
   * idle/worker etc
   */
  var GlobalConfig = {
      //test env
      isTest: false,
      //idle logging
      idleLog: false,
      //idle 申请不到idle时,强制执行时间阈值
      idleForceTimeThreshold: 48,
      //worker 数量
      workerCount: (getGlobalThis().MAPTALKS_WORKER_COUNT) || 0,
      //每个Worker Message中封装的task message数量
      messagePostRatioPerWorker: 0.3,
      //当前运行环境的最大FPS,用户可以手动配置，否则将自动检测并赋值,为地图锁帧渲染准备
      maxFPS: 0
  };

  /* eslint-disable @typescript-eslint/ban-types */
  function now() {
      return Date.now();
  }
  function extend$2(dest) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
      }
      for (var i = 0; i < args.length; i++) {
          var src = args[i];
          for (var k in src) {
              dest[k] = src[k];
          }
      }
      return dest;
  }
  /**
   * Whether the object is null or undefined.
   * @param  obj - object
   * @return
   * @memberOf Util
   */
  function isNil(obj) {
      return obj == null;
  }
  /**
   * Whether val is a number and not a NaN.
   * @param  val - val
   * @return
   * @memberOf Util
   */
  function isNumber(val) {
      return (typeof val === 'number') && !isNaN(val);
  }
  /**
   * Whether a number is an integer
   * @param  n
   * @return
   * @memberOf Util
   */
  function isInteger(n) {
      return (n | 0) === n;
  }
  /**
   * Whether the obj is a javascript object.
   * @param obj  - object
   * @return
   * @memberOf Util
   */
  function isObject$1(obj) {
      return typeof obj === 'object' && !!obj;
  }
  /**
   * Check whether the object is a string
   * @param obj
   * @return
   * @memberOf Util
   */
  function isString(obj) {
      if (isNil(obj)) {
          return false;
      }
      return typeof obj === 'string' || (obj.constructor !== null && obj.constructor === String);
  }
  /**
   * Check whether the object is a function
   * @param {Object} obj
   * @return {Boolean}
   * @memberOf Util
   */
  function isFunction(obj) {
      if (isNil(obj)) {
          return false;
      }
      return typeof obj === 'function' || (obj.constructor !== null && obj.constructor === Function);
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check whether the object owns the property.
   * @param obj - object
   * @param key - property
   * @return
   * @memberOf Util
   */
  function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
  }
  /**
   * Join an array, standard or a typed one.
   * @param  arr       array to join
   * @param  seperator  seperator
   * @return  result string
   * @private
   * @memberOf Util
   */
  function join(arr, seperator) {
      if (arr.join) {
          return arr.join(seperator || ',');
      }
      else {
          return Array.prototype.join.call(arr, seperator || ',');
      }
  }
  /**
   * Determine if an object has any properties.
   * @param object The object to check.
   * @returns The object is empty
   * @memberOf Util
   */
  function isEmpty(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }
  var pi = Math.PI / 180;
  function toRadian(d) {
      return d * pi;
  }
  function toDegree(r) {
      return r / pi;
  }

  /* eslint-disable @typescript-eslint/ban-ts-comment */
  var Browser = {};
  // const maps = {};
  function getDevicePixelRatio() {
      // @ts-ignore
      return (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI));
  }
  if (!IS_NODE) {
      var ua = navigator.userAgent.toLowerCase(), doc = document.documentElement || { style: {} }, ie = 'ActiveXObject' in window, webkit = ua.indexOf('webkit') !== -1, phantomjs = ua.indexOf('phantom') !== -1, android23 = ua.search('android [23]') !== -1, chrome = ua.indexOf('chrome') !== -1, gecko = ua.indexOf('gecko') !== -1 && !webkit && !window.opera && !ie, iosWeixin = /iphone/i.test(ua) && /micromessenger/i.test(ua), mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1, msPointer = !window.PointerEvent && window.MSPointerEvent, 
      // @ts-ignore
      pointer = (window.PointerEvent && navigator.pointerEnabled) || msPointer, ie3d = ie && ('transition' in doc.style), webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23, gecko3d = 'MozPerspective' in doc.style, opera12 = 'OTransition' in doc.style, any3d = (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs, 
      // https://developer.mozilla.org/zh-CN/docs/Web/API/ImageBitmap
      // this will Improve performance 2-3FPS
      imageBitMap = typeof window !== 'undefined' && isFunction(window.createImageBitmap), resizeObserver = typeof window !== 'undefined' && isFunction(window.ResizeObserver), btoa_1 = typeof window !== 'undefined' && isFunction(window.btoa), proxy = typeof window !== 'undefined' && isFunction(window.Proxy), requestIdleCallback_1 = typeof window !== 'undefined' && isFunction(window.requestIdleCallback);
      var chromeVersion = 0;
      if (chrome) {
          chromeVersion = ua.match(/chrome\/([\d.]+)/)[1];
      }
      var touch = !phantomjs && (pointer || 'ontouchstart' in window ||
          (window.DocumentTouch && document instanceof window.DocumentTouch));
      // let webgl;
      // try {
      //     const canvas = document.createElement('canvas');
      //     const gl = canvas.getContext('webgl') ||
      //         canvas.getContext('experimental-webgl');
      //     webgl = gl && gl instanceof WebGLRenderingContext;
      // } catch (err) {
      //     webgl = false;
      // }
      var webgl = typeof window !== 'undefined' && ('WebGLRenderingContext' in window);
      var devicePixelRatio_1 = getDevicePixelRatio();
      var decodeImageInWorker = false;
      try {
          var offCanvas = new OffscreenCanvas(2, 2);
          offCanvas.getContext('2d');
          decodeImageInWorker = true;
      }
      catch (err) {
          decodeImageInWorker = false;
      }
      // https://github.com/Modernizr/Modernizr/issues/1894
      /* Add feature test for passive event listener support */
      var supportsPassive_1 = false;
      try {
          window.addEventListener('testPassive', function () {
          }, {
              get passive() {
                  supportsPassive_1 = true;
                  return true;
              }
          });
          /*eslint-disable no-empty */
      }
      catch (e) {
      }
      Browser = {
          IS_NODE: IS_NODE,
          isTest: false,
          ie: ie,
          ielt9: ie && !document.addEventListener,
          edge: 'msLaunchUri' in navigator && !('documentMode' in document),
          webkit: webkit,
          gecko: gecko,
          android: ua.indexOf('android') !== -1,
          android23: android23,
          chrome: chrome,
          chromeVersion: chromeVersion,
          safari: !chrome && ua.indexOf('safari') !== -1,
          phantomjs: phantomjs,
          ie3d: ie3d,
          webkit3d: webkit3d,
          gecko3d: gecko3d,
          opera12: opera12,
          any3d: any3d,
          iosWeixin: iosWeixin,
          mobile: mobile,
          mobileWebkit: mobile && webkit,
          mobileWebkit3d: mobile && webkit3d,
          mobileOpera: mobile && window.opera,
          mobileGecko: mobile && gecko,
          touch: !!touch,
          msPointer: !!msPointer,
          pointer: !!pointer,
          retina: devicePixelRatio_1 > 1,
          devicePixelRatio: devicePixelRatio_1,
          // @ts-ignore
          language: navigator.browserLanguage ? navigator.browserLanguage : navigator.language,
          // @ts-ignore
          ie9: (ie && document.documentMode === 9),
          // @ts-ignore
          ie10: (ie && document.documentMode === 10),
          webgl: webgl,
          imageBitMap: imageBitMap,
          resizeObserver: resizeObserver,
          btoa: btoa_1,
          decodeImageInWorker: decodeImageInWorker,
          monitorDPRChange: true,
          supportsPassive: supportsPassive_1,
          proxy: proxy,
          requestIdleCallback: requestIdleCallback_1,
          // removeDPRListening: (map) => {
          //     // if (map) {
          //     //     delete maps[map.id];
          //     // }
          // },
          checkDevicePixelRatio: function () {
              if (typeof window !== 'undefined' && Browser.monitorDPRChange) {
                  var devicePixelRatio_2 = getDevicePixelRatio();
                  var changed = devicePixelRatio_2 !== Browser.devicePixelRatio;
                  if (changed) {
                      Browser.devicePixelRatio = devicePixelRatio_2;
                  }
                  return changed;
              }
              return false;
          },
          // addDPRListening: (map) => {
          //     // if (map) {
          //     //     maps[map.id] = map;
          //     // }
          // }
      };
  }
  var Browser$1 = Browser;

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  /**
   * `Point` 和 `Coordinate` 的抽象类
   * @english
   *
   * Abstract parent class for Point and Coordinate
   * @category basic types
   */
  var Position = /** @class */ (function () {
      function Position(x, y, z) {
          if (!isNil(x) && !isNil(y)) {
              /**
               * @property x {Number} - x value
               */
              this.x = +(x);
              /**
               * @property y {Number} - y value
               */
              this.y = +(y);
              /**
               * @property z {Number} - z value, it's a pure property and doesn't take part in caculation for now.
               */
              this.z = z;
          }
          else if (!isNil(x.x) && !isNil(x.y)) {
              this.x = +(x.x);
              this.y = +(x.y);
              this.z = x.z;
          }
          else if (Array.isArray(x)) {
              this.x = +(x[0]);
              this.y = +(x[1]);
              this.z = x[2];
          }
          if (this._isNaN()) {
              throw new Error('Position is NaN');
          }
      }
      /**
       * 设置点或坐标的 x、y 值
       *
       * @english
       *
       * Set point or coordinate's x, y value
       * @param x - x value
       * @param y - y value
       * @param z - z value
       */
      Position.prototype.set = function (x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z || 0;
          return this;
      };
      /**
       * 修改原数据的绝对值
       *
       * @english
       * destructive abs
       */
      Position.prototype._abs = function () {
          this.x = Math.abs(this.x);
          this.y = Math.abs(this.y);
          return this;
      };
      /**
       * 对原数据的 x 和 y 四舍五入
       *
       * @english
       * destructive round
       */
      Position.prototype._round = function () {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
      };
      /**
       * 对原数据的 x 和 y 进行向上取整
       *
       * @english
       * destructive ceil
       */
      Position.prototype._ceil = function () {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
      };
      /**
       * 返回当前点与给定点之间的距离
       *
       * @english
       *
       * Returns the distance between the current and the given point.
       * @param  point - another point
       * @returns distance
       */
      Position.prototype.distanceTo = function (point) {
          var x = point.x - this.x, y = point.y - this.y;
          return Math.sqrt(x * x + y * y);
      };
      /**
       * 返回该点的大小：这是从 0,0 坐标到该点的 x 和 y 坐标的欧几里得距离
       *
       * @english
       *
       * Return the magnitude of this point: this is the Euclidean
       * distance from the 0, 0 coordinate to this point's x and y
       * coordinates.
       * @returns magnitude
       */
      Position.prototype.mag = function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
      };
      /**
       * 对原数据的 x 和 y 进行向下取整
       *
       * @english
       * destructive floor
       */
      Position.prototype._floor = function () {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
      };
      /**
       * 对原数据的 x 和 y 与传入坐标相加
       *
       * @english
       *
       * destructive add
       *
       * @param x
       * @param y
       */
      Position.prototype._add = function (x, y) {
          if (!isNil(x.x)) {
              this.x += x.x;
              this.y += x.y;
          }
          else if (!isNil(x[0])) {
              this.x += x[0];
              this.y += x[1];
          }
          else {
              this.x += x;
              this.y += y;
          }
          return this;
      };
      /**
       * 对原数据的 x 和 y 与传入坐标相减
       *
       * @english
       *
       * destructive substract
       *
       * @param x
       * @param y
       */
      Position.prototype._sub = function (x, y) {
          if (!isNil(x.x)) {
              this.x -= x.x;
              this.y -= x.y;
          }
          else if (!isNil(x[0])) {
              this.x -= x[0];
              this.y -= x[1];
          }
          else {
              this.x -= x;
              this.y -= y;
          }
          return this;
      };
      /**
       * `_sub` 方法的别名
       *
       * @english
       *
       * Alias for _sub
       *
       * @param x
       * @param y
       */
      Position.prototype._substract = function (x, y) {
          if (isNumber(y)) {
              return this._sub(x, y);
          }
          return this._sub(x);
      };
      /**
       * `sub` 方法的别名。
       *
       * @english
       *
       * Alias for sub
       * @returns result
       * @param x
       * @param y
       */
      Position.prototype.substract = function (x, y) {
          return this.sub(x, y);
      };
      Position.prototype._multi = function (ratio) {
          this.x *= ratio;
          this.y *= ratio;
          return this;
      };
      /**
       * 返回当前坐标除以给定数字
       *
       * @english
       *
       * Returns the result of division of the current point by the given number.
       * @param n - number to div
       * @returns result
       */
      Position.prototype.div = function (n) {
          return this.multi(1 / n);
      };
      /**
       * 除以给定的数字
       *
       * @english
       *
       * div by the given number
       * @param n
       */
      Position.prototype._div = function (n) {
          return this._multi(1 / n);
      };
      /**
       * `Coordinate` / `Point`是否是 `NaN`
       *
       * @english
       *
       * Whether the coordinate is NaN
       * @returns
       */
      Position.prototype._isNaN = function () {
          return isNaN(this.x) || isNaN(this.y) || isNumber(this.z) && isNaN(this.z);
      };
      /**
       * `Coordinate` / `Point`是否为零
       *
       * @english
       *
       * Whether the coordinate/point is zero
       */
      Position.prototype.isZero = function () {
          return this.x === 0 && this.y === 0;
      };
      /**
       * 转换为数组形式
       *
       * @english
       *
       * Convert to a number array [x, y]
       * @returns number array
       */
      Position.prototype.toArray = function () {
          if (isNumber(this.z)) {
              return [this.x, this.y, this.z];
          }
          return [this.x, this.y];
      };
      /**
       * 转换到 json 对象
       *
       * @english
       * Convert to a json object {x : .., y : ..}
       * @returns json
       */
      Position.prototype.toJSON = function () {
          var json = {
              x: this.x,
              y: this.y
          };
          if (isNumber(this.z)) {
              json.z = this.z;
          }
          return json;
      };
      return Position;
  }());

  /**
   * 2D 点实现
   * @english
   * Represents a 2d point.<br>
   * Can be created in serveral ways:
   *
   * @example
   *
   * ```ts
   *
   * var point = new Point(1000, 1000);
   *
   * var point = new Point([1000, 1000]);
   *
   * var point = new Point({ x:1000, y:1000 });
   * ```
   *
   * @category basic types
   */
  var Point = /** @class */ (function (_super) {
      __extends(Point, _super);
      function Point() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * 使用差值与另一个点进行比较，判断是否临近
       *
       * @english
       *
       * Compare with another point with a delta
       * @param p
       * @param delta
       */
      Point.prototype.closeTo = function (p, delta) {
          if (!delta) {
              delta = 0;
          }
          return this.x >= (p.x - delta) && this.x <= (p.x + delta) &&
              this.y >= (p.y - delta) && this.y <= (p.y + delta);
      };
      /**
       * 计算对应的单位向量
       * 这意味着计算点到[0, 0]坐标的距离将等于1，并且从计算点到[0, 0]坐标的角度与之前相同
       * @english
       *
       * Calculate this point but as a unit vector from 0, 0, meaning
       * that the distance from the resulting point to the 0, 0
       * coordinate will be equal to 1 and the angle from the resulting
       * point to the 0, 0 coordinate will be the same as before.
       * @returns unit vector point
       */
      Point.prototype.unit = function () {
          return this.copy()._unit();
      };
      Point.prototype._unit = function () {
          this._div(this.mag());
          return this;
      };
      /**
       * 计算一个垂直点，其中新的y坐标是旧的x坐标，而新的x坐标是旧的y坐标乘以-1。
       *
       * @english
       *
       * Compute a perpendicular point, where the new y coordinate
       * is the old x coordinate and the new x coordinate is the old y
       * coordinate multiplied by -1
       * @returns perpendicular point
       */
      Point.prototype.perp = function () {
          return this.copy()._perp();
      };
      Point.prototype._perp = function () {
          var _a;
          _a = __read([-this.y, this.x], 2), this.x = _a[0], this.y = _a[1];
          return this;
      };
      /**
       * 获取这个点与另一个点之间的角度，单位为弧度
       *
       * @english
       *
       * Get the angle between this point and another point, in radians
       * from mapbox/point-geometry
       * @param b - the other point
       * @returns angle
       */
      Point.prototype.angleWith = function (b) {
          return this.angleWithSep(b.x, b.y);
      };
      /**
       * 找到两个向量之间的角度
       *
       * @english
       *
       * Find the angle of the two vectors, solving the formula for
       * the cross product a x b = |a||b|sin(θ) for θ.
       * from mapbox/point-geometry
       *
       * @param x the x-coordinate
       * @param y the y-coordinate
       * @returns the angle in radians
       */
      Point.prototype.angleWithSep = function (x, y) {
          return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
      };
      Point.prototype._rotate = function (angle) {
          var cos = Math.cos(angle), sin = Math.sin(angle), x = cos * this.x - sin * this.y, y = sin * this.x + cos * this.y;
          this.x = x;
          this.y = y;
          return this;
      };
      /**
       * 围绕0,0原点旋转这个点，旋转角度a以弧度为单位
       *
       * @english
       *
       * Rotate this point around the 0, 0 origin by an angle a,
       * given in radians
       * from mapbox/point-geometry
       *
       * @param a angle to rotate around, in radians
       * @returns output point
       */
      Point.prototype.rotate = function (a) {
          return this.copy()._rotate(a);
      };
      /**
       * 返回该点绝对值的 `Point` 对象（不会改变原始数据）
       *
       * @english
       *
       * Return abs value of the point
       * @returns abs point
       */
      Point.prototype.abs = function () {
          return new Point(Math.abs(this.x), Math.abs(this.y));
      };
      /**
       * 类似于数学中的四舍五入，对点的 x 和 y 坐标进行舍入，返回一个新 Point
       *
       * @english
       *
       * Like math.round, rounding the point's xy.
       * @returns rounded point
       */
      Point.prototype.round = function () {
          return new Point(Math.round(this.x), Math.round(this.y));
      };
      /**
       * 对点的 x 和 y 坐标向上取整，返回一个新 Point
       *
       * @english
       *
       * Like math.ceil, ceil the point's xy.
       * @returns ceiled point
       */
      Point.prototype.ceil = function () {
          return new Point(Math.ceil(this.x), Math.ceil(this.y));
      };
      /**
       * 对点的 x 和 y 坐标向下取整，返回一个新 Point
       *
       * @english
       *
       * Like math.floor, floor the point's xy.
       * @returns floored point
       */
      Point.prototype.floor = function () {
          return new Point(Math.floor(this.x), Math.floor(this.y));
      };
      /**
       * 返回当前点的 copy
       *
       * @english
       *
       * Returns a copy of the point
       * @returns copy
       */
      Point.prototype.copy = function () {
          return new Point(this.x, this.y, this.z);
      };
      /**
       * 坐标数字保留指定位数的小数
       *
       * @english
       *
       * Formats point number using fixed-point notation.
       * @param n - The number of digits to appear after the decimal point
       * @returns fixed point
       */
      Point.prototype.toFixed = function (n) {
          return new Point(this.x.toFixed(n), this.y.toFixed(n), isNumber(this.z) ? this.z.toFixed(n) : undefined);
      };
      /**
       * 与传入坐标相加，返回一个新 Point
       *
       * @english
       *
       * Returns the result of addition of another coordinate.
       * @param x - point to add
       * @param y - point to add
       * @returns result
       */
      Point.prototype.add = function (x, y) {
          var nx, ny;
          if (!isNil(x.x)) {
              nx = this.x + x.x;
              ny = this.y + x.y;
          }
          else if (!isNil(x[0])) {
              nx = this.x + x[0];
              ny = this.y + x[1];
          }
          else {
              nx = this.x + x;
              ny = this.y + y;
          }
          return new Point(nx, ny);
      };
      /**
       * 与传入坐标相减，返回一个新 Point。
       *
       * @english
       *
       * Returns the result of subtraction of another point.
       * @param x - point to add
       * @param [y=undefined] - optional, point to add
       * @returns result
       */
      Point.prototype.sub = function (x, y) {
          var nx, ny;
          if (!isNil(x.x)) {
              nx = this.x - x.x;
              ny = this.y - x.y;
          }
          else if (!isNil(x[0])) {
              nx = this.x - x[0];
              ny = this.y - x[1];
          }
          else {
              nx = this.x - x;
              ny = this.y - y;
          }
          return new Point(nx, ny);
      };
      /**
       * Returns the result of multiplication of the current coordinate by the given number.
       * @param ratio - ratio to multi
       * @returns result
       */
      Point.prototype.multi = function (ratio) {
          return new Point(this.x * ratio, this.y * ratio);
      };
      /**
       * 与另外一个 point 进行比较，以查看它们是否相等
       *
       * @english
       *
       * Compare with another point to see whether they are equal.
       * @param c - point to compare
       */
      Point.prototype.equals = function (c) {
          if (!(c instanceof this.constructor)) {
              return false;
          }
          return this.x === c.x && this.y === c.y && this.z === c.z;
      };
      return Point;
  }(Position));

  /* eslint-disable @typescript-eslint/ban-ts-comment */
  /* eslint-disable @typescript-eslint/ban-types */
  // RequestAnimationFrame, inspired by Leaflet
  var requestAnimFrame, cancelAnimFrame;
  /* istanbul ignore next */
  (function () {
      if (IS_NODE) {
          requestAnimFrame = function (fn) {
              return setTimeout(fn, 16);
          };
          cancelAnimFrame = clearTimeout;
          return;
      }
      var requestFn, cancelFn;
      // slow down fps in IE9 for performance
      var timeToCall = 1000 / 30;
      function timeoutDefer(fn) {
          return setTimeout(fn, timeToCall);
      }
      function getPrefixed(name) {
          return window['webkit' + name] || window['moz' + name] || window['ms' + name];
      }
      if (typeof (window) != 'undefined') {
          // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/
          requestFn = window['requestAnimationFrame'] || getPrefixed('RequestAnimationFrame') || timeoutDefer;
          cancelFn = window['cancelAnimationFrame'] || getPrefixed('CancelAnimationFrame') ||
              getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };
      }
      else {
          requestFn = timeoutDefer;
          cancelFn = clearTimeout;
      }
      /**
       * Polyfill of RequestAnimationFrame
       * @param  {Function} fn callback
       * @return {Number}  request id
       * @memberOf Util
       */
      requestAnimFrame = function (fn) {
          return requestFn(fn);
      };
      /**
       * Polyfill of cancelAnimationFrame
       * @param id id
       * @memberOf Util
       */
      cancelAnimFrame = function (id) {
          if (id) {
              cancelFn(id);
          }
      };
  })();
  function isSVG(url) {
      var prefix = 'data:image/svg+xml';
      if (url.length > 4 && url.slice(-4) === '.svg') {
          return 1;
      }
      else if (url.slice(0, prefix.length) === prefix) {
          return 2;
      }
      return 0;
  }
  /**
   * Load a image, can be a remote one or a local file. <br>
   * If in node, a SVG image will be converted to a png file by [svg2img]{@link https://github.com/FuZhenn/node-svg2img}<br>
   * @param img  - the image object to load.
   * @param imgDesc - image's descriptor, it's an array. imgUrl[0] is the url string, imgUrl[1] is the width, imgUrl[2] is the height.
   * @private
   * @memberOf Util
   */
  function loadImage(img, imgDesc) {
      /* istanbul ignore next */
      // @ts-expect-error
      if (IS_NODE && loadImage.node) {
          // @ts-expect-error
          loadImage.node(img, imgDesc);
          return;
      }
      img.src = imgDesc[0];
  }
  var uid = 0;
  function UID() {
      return uid++;
  }
  var GUID = UID;
  /**
   * Parse a JSON string to a object
   * @param str   - a JSON string
   * @return
   * @memberOf Util
   */
  function parseJSON(str) {
      if (!str || !isString(str)) {
          return str;
      }
      return JSON.parse(str);
  }
  function pushIn() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var dest = args[0];
      for (var i = 1; i < args.length; i++) {
          var src = args[i];
          if (src && src.length) {
              for (var ii = 0, ll = src.length; ii < ll; ii++) {
                  dest.push(src[ii]);
              }
          }
      }
      return dest.length;
  }
  function removeFromArray(obj, array) {
      var i = array.indexOf(obj);
      if (i > -1) {
          array.splice(i, 1);
      }
  }
  function forEachCoord(arr, fn, context) {
      if (!Array.isArray(arr)) {
          return context ? fn.call(context, arr) : fn(arr);
      }
      var result = [];
      var p, pp;
      for (var i = 0, len = arr.length; i < len; i++) {
          p = arr[i];
          if (isNil(p)) {
              result.push(null);
              continue;
          }
          if (Array.isArray(p)) {
              result.push(forEachCoord(p, fn, context));
          }
          else {
              pp = context ? fn.call(context, p) : fn(p);
              result.push(pp);
          }
      }
      return result;
  }
  function getValueOrDefault(v, d) {
      return v === undefined ? d : v;
  }
  /**
   * Polyfill for Math.sign
   * @param  x
   * @return
   * @memberOf Util
   */
  /* istanbul ignore next */
  function sign(x) {
      if (Math.sign) {
          return Math.sign(x);
      }
      x = +x; // convert to a number
      if (x === 0 || isNaN(x)) {
          return Number(x);
      }
      return x > 0 ? 1 : -1;
  }
  function log2(x) {
      if (Math.log2) {
          return Math.log2(x);
      }
      var v = Math.log(x) * Math.LOG2E;
      var rounded = Math.round(v);
      if (Math.abs(rounded - v) < 1E-14) {
          return rounded;
      }
      else {
          return v;
      }
  }
  /**
   * Interpolate between two number.
   *
   * @param from
   * @param to
   * @param t interpolation factor between 0 and 1
   * @returns interpolated color
   */
  function interpolate$3(a, b, t) {
      return (a * (1 - t)) + (b * t);
  }
  /**
   * constrain n to the given range, via modular arithmetic
   * @param n value
   * @param min the minimum value to be returned, inclusive
   * @param max the maximum value to be returned, inclusive
   * @returns constrained number
   * @private
   */
  function wrap(n, min, max) {
      if (n === max || n === min) {
          return n;
      }
      var d = max - min;
      var w = ((n - min) % d + d) % d + min;
      return w;
  }
  /**
   * constrain n to the given range via min + max
   *
   * @param n value
   * @param min the minimum value to be returned
   * @param max the maximum value to be returned
   * @returns the clamped value
   * @private
   */
  function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
  }
  /**
   * Is object an array and not empty.
   * @param obj
   * @return true|false
   * @private
   * @memberOf Util
   */
  function isArrayHasData(obj) {
      return Array.isArray(obj) && obj.length > 0;
  }
  var urlPattern = /^([a-z][a-z\d+\-.]*:)?\/\//i;
  /**
   * Whether the input string is a valid url.
   * form: https://github.com/axios/axios/blob/master/lib/helpers/isAbsoluteURL.js
   * @param url - url to check
   * @return
   * @memberOf Util
   * @private
   */
  function isURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      // eslint-disable-next-line no-useless-escape
      return urlPattern.test(url);
  }
  //改原先的regex名字为xWithQuote；不带引号的regex，/^url\(([^\'\"].*[^\'\"])\)$/i，为xWithoutQuote。然后在is函数里||测试，extract函数里if...else处理。没引号的匹配后，取matches[1]
  // match: url('x'), url("x").
  // TODO: url(x)
  var cssUrlReWithQuote = /^url\((['"])(.+)\1\)$/i;
  var cssUrlRe = /^url\(([^'"].*[^'"])\)$/i;
  function isCssUrl(str) {
      if (!isString(str)) {
          return 0;
      }
      if (cssUrlRe.test(str)) {
          return 1;
      }
      if (cssUrlReWithQuote.test(str)) {
          return 2;
      }
      return 3;
  }
  function extractCssUrl(str) {
      var test = isCssUrl(str);
      var matches;
      if (test === 3) {
          return str;
      }
      else if (test === 1) {
          matches = cssUrlRe.exec(str);
          return matches[1];
      }
      else if (test === 2) {
          matches = cssUrlReWithQuote.exec(str);
          return matches[2];
      }
      else {
          // return as is if not an css url
          return str;
      }
  }
  var b64chrs = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  /**
   * btoa or a polyfill in old browsers. <br>
   * Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.<br>
   * From https://github.com/davidchambers/Base64.js
   * @param input - input string to convert
   * @return ascii
   * @memberOf Util
   * @example
   *     const encodedData = Util.btoa(stringToEncode);
   */
  /* istanbul ignore next */
  /* eslint-disable no-sequences */
  function btoa(input) {
      if (Browser$1.btoa) {
          return window.btoa(input);
      }
      var str = String(input);
      var output = '';
      for (
      // initialize result and counter
      var block = void 0, charCode = void 0, idx = 0, map = b64chrs; 
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1); 
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
          charCode = str.charCodeAt(idx += 3 / 4);
          if (charCode > 0xFF) {
              throw new Error('\'btoa\' failed: The string to be encoded contains characters outside of the Latin1 range.');
          }
          block = block << 8 | charCode;
      }
      return output;
  }
  /* eslint-enable no-sequences */
  function b64toBlob(b64Data, contentType) {
      var byteCharacters = atob(b64Data);
      var arraybuffer = new ArrayBuffer(byteCharacters.length);
      var view = new Uint8Array(arraybuffer);
      for (var i = 0; i < byteCharacters.length; i++) {
          view[i] = byteCharacters.charCodeAt(i) & 0xff;
      }
      var blob = new Blob([arraybuffer], { type: contentType });
      return blob;
  }
  /**
   * Compute degree bewteen 2 points.
   * @param  x0
   * @param  y0
   * @param  x1
   * @param  y1
   * @return    degree between 2 points
   * @memberOf Util
   */
  function computeDegree(x0, y0, x1, y1) {
      var dx = x1 - x0;
      var dy = y1 - y0;
      return Math.atan2(dy, dx);
  }
  /**
   * Transparent 1X1 gif image
   * from https://css-tricks.com/snippets/html/base64-encode-of-1x1px-transparent-gif/
   * @memberOf Util
   */
  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
  /**
   * shallow equal
   * @param  obj1
   * @param  obj2
   * @return
   * @private
   * @memberOf Util
   */
  function equalMapView(obj1, obj2) {
      if (!obj1 && !obj2) {
          return true;
      }
      else if (!obj1 || !obj2) {
          return false;
      }
      for (var p in obj1) {
          if (p === 'center') {
              if (!obj2[p] || !approx(obj1[p][0], obj2[p][0]) || !approx(obj1[p][1], obj2[p][1])) {
                  return false;
              }
          }
          else if (obj1[p] !== obj2[p]) {
              return false;
          }
      }
      return true;
  }
  function approx(val, expected, delta) {
      if (delta == null) {
          delta = 1e-6;
      }
      return val >= expected - delta && val <= expected + delta;
  }
  /**
   * Flash something, show and hide by certain internal for times of count.
   *
   * @param interval   - interval of flash, in millisecond (ms)
   * @param count      - flash times
   * @param cb         - callback function when flash ended
   * @param context    - callback context
   * @return this
   * @private
   * @memberOf Util
   */
  function flash(interval, count, cb, context) {
      if (interval === void 0) { interval = 100; }
      if (count === void 0) { count = 4; }
      if (cb === void 0) { cb = null; }
      if (context === void 0) { context = null; }
      if (!interval) {
          interval = 100;
      }
      if (!count) {
          count = 4;
      }
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var me = this;
      var initVisible = this.isVisible();
      count *= 2;
      if (this._flashTimeout) {
          clearTimeout(this._flashTimeout);
      }
      function flashGeo() {
          if (count === 0) {
              if (initVisible) {
                  me.show();
              }
              else {
                  me.hide();
              }
              if (cb) {
                  if (context) {
                      cb.call(context);
                  }
                  else {
                      cb();
                  }
              }
              return;
          }
          if (count % 2 === 0) {
              me.hide();
          }
          else {
              me.show();
          }
          count--;
          me._flashTimeout = setTimeout(flashGeo, interval);
      }
      this._flashTimeout = setTimeout(flashGeo, interval);
      return this;
  }
  function _defaults(obj, defaults) {
      var keys = Object.getOwnPropertyNames(defaults);
      for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = Object.getOwnPropertyDescriptor(defaults, key);
          if (value && value.configurable && obj[key] === undefined) {
              Object.defineProperty(obj, key, value);
          }
      }
      return obj;
  }
  function getPointsResultPts(points, ptKey) {
      if (points === void 0) { points = []; }
      if (ptKey === void 0) { ptKey = '_pt'; }
      var resultPoints = [];
      for (var i = 0, len = points.length; i < len; i++) {
          var point = points[i];
          if (!point) {
              resultPoints.push(null);
              continue;
          }
          if (!point[ptKey]) {
              point[ptKey] = new Point(0, 0);
          }
          var pt = point[ptKey];
          pt.x = 0;
          pt.y = 0;
          resultPoints.push(pt);
      }
      return resultPoints;
  }
  // let BITMAP_CTX;
  // if (Browser.decodeImageInWorker) {
  //     const canvas = document.createElement('canvas');
  //     canvas.width = 1;
  //     canvas.height = 1;
  //     BITMAP_CTX = canvas.getContext('2d');
  // }
  function getImageBitMap(data, cb) {
      cb(data.data);
      // const imageData = BITMAP_CTX.createImageData(data.width, data.height);
      // imageData.data.set(data.data);
      // createImageBitmap(imageData).then(bitmap => {
      //     cb(bitmap);
      // });
  }
  function getAbsoluteURL(url) {
      if (url && url.indexOf('http://') === 0 || url.indexOf('https://') === 0) {
          return url;
      }
      var a = document.createElement('a');
      a.href = url;
      url = a.href;
      a = null;
      return url;
  }
  var CANVAS_SIZE_TEMP = {
      cssWidth: '1px',
      cssHeight: '1px',
      width: 1,
      height: 1
  };
  function calCanvasSize(size, devicePixelRatio) {
      if (devicePixelRatio === void 0) { devicePixelRatio = 1; }
      var width = size.width, height = size.height;
      CANVAS_SIZE_TEMP.cssWidth = width + 'px';
      CANVAS_SIZE_TEMP.cssHeight = height + 'px';
      CANVAS_SIZE_TEMP.width = Math.round(width * devicePixelRatio);
      CANVAS_SIZE_TEMP.height = Math.round(height * devicePixelRatio);
      return CANVAS_SIZE_TEMP;
  }

  /**
   * INTERNAL_LAYER_PREFIX The id prefix of internal layers
   * @global
   */
  var INTERNAL_LAYER_PREFIX = '_maptalks__internal_layer_';
  var GEOMETRY_COLLECTION_TYPES = [
      'MultiPoint',
      'MultiLineString',
      'MultiPolygon',
      'GeometryCollection'
  ];
  var GEOJSON_TYPES = ['FeatureCollection', 'Feature', 'Point', 'LineString', 'Polygon'].concat(GEOMETRY_COLLECTION_TYPES);
  /**
   * Symbol properties containing external resources
   */
  var RESOURCE_PROPERTIES = [
      'markerFile', 'polygonPatternFile', 'linePatternFile', 'markerFillPatternFile', 'markerLinePatternFile'
  ];
  /**
   * Corresponding size properties for the above resource properties
   */
  var RESOURCE_SIZE_PROPERTIES = [
      ['markerWidth', 'markerHeight'],
      [],
      [null, 'lineWidth'],
      [],
      [null, 'markerLineWidth']
  ];
  /**
   * numeric symbol properties
   */
  var NUMERICAL_PROPERTIES = {
      'lineWidth': 1,
      'lineOpacity': 1,
      'lineDx': 1,
      'lineDy': 1,
      'polygonOpacity': 1,
      'markerWidth': 1,
      'markerHeight': 1,
      'markerDx': 1,
      'markerDy': 1,
      'markerOpacity': 1,
      'markerFillOpacity': 1,
      'markerLineWidth': 1,
      'markerLineOpacity': 1,
      'textSize': 1,
      'textOpacity': 1,
      'textHaloRadius': 1,
      'textWrapWidth': 1,
      'textLineSpacing': 1,
      'textDx': 1,
      'textDy': 1
  };
  /**
   *  color symbol properties
   */
  var COLOR_PROPERTIES = [
      'lineColor', 'polygonFill', 'markerFill', 'markerLineColor', 'textFill'
  ];
  var DEFAULT_TEXT_SIZE = 14;

  /**
   * 表示一个大小的实现类
   *
   * @english
   * Represents a size.
   * @category basic types
   *
   * @example
   *
   * ```ts
   * const a1 = new Size(1, 2);
   * const a2 = new Size([1, 2]);
   * const a3 = new Size({ width: 1, height: 2 });
   * const a4 = new Size(a3);
   * ```
   */
  var Size = /** @class */ (function () {
      function Size(width, height) {
          if (isNumber(width) && isNumber(height)) {
              /**
               * @property width - width
               */
              this.width = width;
              /**
               * @property height - height
               */
              this.height = height;
          }
          else if (isNumber(width['width'])) {
              this.width = width.width;
              this.height = width.height;
          }
          else if (Array.isArray(width)) {
              this.width = width[0];
              this.height = width[1];
          }
      }
      /**
       * 返回 `Size` 的拷贝
       * @english
       * Returns a copy of the size
       */
      Size.prototype.copy = function () {
          return new Size(this['width'], this['height']);
      };
      /**
       * 返回当前`Size` 与另一个 `Size` 相加的结果
       *
       * @english
       * Returns the result of addition of another size.
       * @param x - x value
       * @param y - y value
       * @returns result
       */
      Size.prototype.add = function (x, y) {
          var w, h;
          if (x instanceof Size) {
              w = this.width + x.width;
              h = this.height + x.height;
          }
          else {
              w = this.width + x;
              h = this.height + y;
          }
          return new Size(w, h);
      };
      /**
       * 与另一个 `Size` 进行比较，以判断它们是否相等。
       *
       * @english
       * Compare with another size to see whether they are equal.
       * @param size - size to compare
       */
      Size.prototype.equals = function (size) {
          return this['width'] === size['width'] && this['height'] === size['height'];
      };
      /**
       * 返回当前大小与给定数字相乘的结果，返回一个新的 Size 对象
       * @english
       * Returns the result of multiplication of the current size by the given number.
       * @param ratio - ratio to multi
       * @returns result
       */
      Size.prototype.multi = function (ratio) {
          return new Size(this['width'] * ratio, this['height'] * ratio);
      };
      /**
       * 返回当前大小与给定数字相乘的结果
       * @english
       * Returns the result of multiplication of the current size by the given number.
       * @param ratio - ratio to multi
       * @returns result
       */
      Size.prototype._multi = function (ratio) {
          this['width'] *= ratio;
          this['height'] *= ratio;
          return this;
      };
      Size.prototype._round = function () {
          this['width'] = Math.round(this['width']);
          this['height'] = Math.round(this['height']);
          return this;
      };
      /**
       * 将当前 `Size` 对象转为一个点对象 {@link Point}
       * @english
       * Converts the size object to a {@link Point}
       * @returns point
       */
      Size.prototype.toPoint = function () {
          return new Point(this['width'], this['height']);
      };
      /**
       * 将 `Size` 对象转换为数组
       * @english
       * Converts the size object to an array [width, height]
       */
      Size.prototype.toArray = function () {
          return [this['width'], this['height']];
      };
      /**
       * 将 `Size` 实例对象转换为 包含 `width` 和 `height` 的 json 对象
       * @english
       * Convert the size object to a json object {width : ., height : .}
       * @returns json
       */
      Size.prototype.toJSON = function () {
          return {
              'width': this['width'],
              'height': this['height']
          };
      };
      return Size;
  }());

  /**
   * @classdesc
   * Utilities methods for Strings used internally. It is static and should not be initiated.
   * @class
   * @static
   * @category core
   * @name StringUtil
   */
  var EMPTY_STRING$1 = '';
  /**
   * Trim the string
   * @param str
   * @return
   * @memberOf StringUtil
   */
  function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  }
  function replaceAll(str, key, value) {
      if (!str) {
          return str;
      }
      while (str.indexOf(key) > -1) {
          str = str.replace(key, value);
      }
      return str;
  }
  var specialPattern = /[\b\t\r\v\f]/igm;
  /**
   * Escape special characters from string.
   * Including: \b \t \r \v \f
   * @param str string to escape
   * @return
   * @memberOf StringUtil
   */
  function escapeSpecialChars(str) {
      if (!isString(str)) {
          return str;
      }
      return str.replace(specialPattern, EMPTY_STRING$1);
  }
  /**
   * Split string by specified char
   * @param chr - char to split
   * @return
   * @memberOf StringUtil
   */
  function splitWords(chr) {
      return trim(chr).split(/\s+/);
  }
  var rulerCtx = typeof document !== 'undefined' ? document.createElement('canvas').getContext('2d') : null;
  /**
   * Gets width of the text with a certain font.
   * More performant than stringLength.
   * @param text - text to measure
   * @param font - font of the text, same as the CSS font.
   * @return
   * @memberOf StringUtil
   */
  function stringWidth(text, font) {
      // @ts-expect-error
      if (stringWidth.node) {
          // @ts-expect-error
          return stringWidth.node(text, font);
      }
      rulerCtx.font = font;
      return rulerCtx.measureText(text).width;
  }
  // const fontHeight = {};
  /**
   * Gets size in pixel of the text with a certain font.
   * @param text - text to measure
   * @param font - font of the text, same as the CSS font.
   * @return
   * @memberOf StringUtil
   */
  function stringLength(text, font, size) {
      var w = stringWidth(text, font);
      // if (!font) {
      //     font = '_default_';
      // }
      // if (!fontHeight[font]) {
      //     fontHeight[font] = getFontHeight(font);
      // }
      // return new Size(w, fontHeight[font]);
      return new Size(w, size || DEFAULT_TEXT_SIZE);
  }
  // export function getFontHeight(font) {
  //     //dom
  //     const domRuler = getDomRuler('span');
  //     if (font !== '_default_') {
  //         domRuler.style.font = font;
  //     }
  //     domRuler.innerHTML = '秦';
  //     const h = domRuler.clientHeight;
  //     //if not removed, the canvas container on chrome will turn to unexpected blue background.
  //     // Reason is unknown.
  //     removeDomNode(domRuler);
  //     return h;
  // }
  /**
   * Split text content by dom.
   * @param content - content to split
   * @param font - font of the text, same as the CSS font.
   * @return wrapWidth - width to wrap
   * @return {String[]}
   * @memberOf StringUtil
   */
  function splitContent(content, font, wrapWidth, textWidth) {
      if (!content || content.length === 0) {
          return [{ 'text': '', 'width': 0 }];
      }
      var width = isNil(textWidth) ? stringWidth(content, font) : textWidth;
      var chrWidth = width / content.length, minChrCount = Math.floor(wrapWidth / chrWidth / 2);
      if (chrWidth >= wrapWidth || minChrCount <= 0) {
          return [{ 'text': '', 'width': wrapWidth }];
      }
      if (width <= wrapWidth)
          return [{ 'text': content, 'width': width }];
      var result = [];
      var testStr = content.substring(0, minChrCount), prew = chrWidth * minChrCount;
      for (var i = minChrCount, l = content.length; i < l; i++) {
          var chr = content[i];
          var w = stringWidth(testStr + chr);
          if (w >= wrapWidth) {
              result.push({ 'text': testStr, 'width': prew });
              testStr = content.substring(i, minChrCount + i);
              i += (minChrCount - 1);
              prew = chrWidth * minChrCount;
          }
          else {
              testStr += chr;
              prew = w;
          }
          if (i >= l - 1) {
              prew = stringWidth(testStr);
              result.push({ 'text': testStr, 'width': prew });
          }
      }
      return result;
  }
  // const contentExpRe = /\{([\w_]+)\}/g;
  // export const CONTENT_EXPRE = /{([^}.]+)}/;
  // export const CONTENT_EXPRE = /{([\u0000-\u0019\u0021-\uFFFF]+)}/g;
  // export const CONTENT_EXPRE = /\{([\w_]+)\}/g;
  var TEMPLATE_CHARS = ['{', '}'];
  /**
   * Replace variables wrapped by square brackets ({foo}) with actual values in props.
   * @example
   *     // will returns 'John is awesome'
   *     const actual = replaceVariable('{foo} is awesome', {'foo' : 'John'});
   * @param str      - string to replace
   * @param props    - variable value properties
   * @return
   * @memberOf StringUtil
   */
  function replaceVariable(str, props) {
      if (!isString(str)) {
          return str;
      }
      function getValue(key) {
          if (!props) {
              return EMPTY_STRING$1;
          }
          var value = props[key];
          if (isNil(value)) {
              return EMPTY_STRING$1;
          }
          else if (Array.isArray(value)) {
              return value.join();
          }
          return value;
      }
      var _a = __read(TEMPLATE_CHARS, 2), left = _a[0], right = _a[1];
      var keys = templateKeys(str);
      for (var i = 0, len = keys.length; i < len; i++) {
          var key = keys[i];
          var value = getValue(key);
          str = replaceAll(str, "".concat(left).concat(key).concat(right), value);
      }
      return str;
  }
  function templateKeys(str) {
      str += EMPTY_STRING$1;
      var _a = __read(TEMPLATE_CHARS, 2), left = _a[0], right = _a[1];
      var keys = [];
      var start = false;
      var key = EMPTY_STRING$1;
      for (var i = 0, len = str.length; i < len; i++) {
          var char = str[i];
          if (!start && char === left) {
              start = true;
          }
          if (char === left && start) {
              key = EMPTY_STRING$1;
          }
          if (start && (char !== left && char !== right)) {
              key += char;
          }
          if (char === right && key) {
              start = false;
              keys.push(key);
              key = EMPTY_STRING$1;
          }
      }
      return keys;
  }
  /**
   * Generate text descriptors according to symbols
   * @return {Object} text descriptor
   * @memberOf StringUtil
   */
  function describeText(textContent, symbol) {
      if (isNumber(textContent)) {
          textContent += '';
      }
      textContent = textContent || '';
      var maxHeight = symbol['textMaxHeight'] || 0;
      var textDesc = splitTextToRow(textContent, symbol);
      if (maxHeight && maxHeight < textDesc.size.height) {
          textDesc.size.height = maxHeight;
      }
      return textDesc;
  }
  /**
   * Gets text's align point according to the horizontalAlignment and verticalAlignment
   * @param  {Size} size                  - text size
   * @param  {String} horizontalAlignment - horizontalAlignment: left/middle/right
   * @param  {String} verticalAlignment   - verticalAlignment: top/middle/bottom
   * @return {Point}
   * @memberOf StringUtil
   */
  function getAlignPoint(size, horizontalAlignment, verticalAlignment) {
      var width = size['width'], height = size['height'];
      var alignW, alignH;
      if (horizontalAlignment === 'left') {
          alignW = -width;
      }
      else if (horizontalAlignment === 'right') {
          alignW = 0;
      }
      else {
          alignW = -width / 2;
      }
      if (verticalAlignment === 'top') {
          alignH = -height;
      }
      else if (verticalAlignment === 'bottom') {
          alignH = 0;
      }
      else {
          alignH = -height / 2;
      }
      return new Point(alignW, alignH);
  }
  //export it for plugin develop
  var DEFAULT_FONT = 'sans-serif';
  var DEFAULT_TEXTSIZE = 14;
  /**
   * Returns CSS Font from a symbol with text styles.
   * @param  {Object} style symbol with text styles
   * @return {String}       CSS Font String
   * @memberOf StringUtil
   */
  function getFont(style) {
      if (style['textFont']) {
          return style['textFont'];
      }
      else {
          var textSize = style.textSize;
          if (isNil(textSize)) {
              textSize = DEFAULT_TEXTSIZE;
          }
          return (style['textStyle'] && style['textStyle'] !== 'normal' ? style['textStyle'] + ' ' : '') +
              (style['textWeight'] && style['textWeight'] !== 'normal' ? style['textWeight'] + ' ' : '') +
              textSize + 'px ' +
              (style['textFaceName'] && formatFontFamily(style['textFaceName']) || DEFAULT_FONT);
      }
  }
  function formatFontFamily(font) {
      var fonts = font.split(',');
      for (var i = 0; i < fonts.length; i++) {
          if (fonts[i].trim) {
              fonts[i] = fonts[i].trim();
          }
          // quote font name with space
          // e.g. "Gill Sans Extrabold", sans-serif
          if (fonts[i].indexOf(' ') > 0 && fonts[i][0] !== '"' && fonts[i][0] !== '\'') {
              fonts[i] = '"' + fonts[i] + '"';
          }
      }
      return fonts.join(',');
  }
  /**
   * Split a text to multiple rows according to the style.
   * @param {String} text     - text to split
   * @param {Object} style    - text style
   * @return {Object[]} the object's structure: { rowNum: rowNum, textSize: textSize, rows: textRows, rawSize : rawSize }
   * @memberOf StringUtil
   */
  function splitTextToRow(text, style) {
      var font = getFont(style), lineSpacing = style['textLineSpacing'] || 0, size = stringLength(text, font, style['textSize']), textWidth = size['width'], textHeight = size['height'], wrapChar = style['textWrapCharacter'] || '\n', textRows = [];
      var wrapWidth = style['textWrapWidth'];
      if (!wrapWidth || wrapWidth > textWidth) {
          wrapWidth = textWidth;
      }
      if (!isString(text)) {
          // @ts-expect-error
          text += '';
      }
      var actualWidth = 0;
      if (wrapChar && text.indexOf(wrapChar) >= 0) {
          var texts = text.split(wrapChar);
          for (var i = 0, l = texts.length; i < l; i++) {
              var t = texts[i];
              var tWidth = stringWidth(t, font);
              if (tWidth > wrapWidth) {
                  var contents = splitContent(t, font, wrapWidth, tWidth);
                  for (var ii = 0, ll = contents.length; ii < ll; ii++) {
                      var w = contents[ii].width;
                      if (w > actualWidth) {
                          actualWidth = w;
                      }
                      textRows.push({
                          'text': contents[ii].text,
                          'size': new Size(w, textHeight)
                      });
                  }
              }
              else {
                  if (tWidth > actualWidth) {
                      actualWidth = tWidth;
                  }
                  textRows.push({
                      'text': t,
                      'size': new Size(tWidth, textHeight)
                  });
              }
          }
      }
      else if (textWidth > wrapWidth) {
          var contents = splitContent(text, font, wrapWidth, textWidth);
          for (var i = 0; i < contents.length; i++) {
              var w = contents[i].width;
              if (w > actualWidth) {
                  actualWidth = w;
              }
              textRows.push({
                  'text': contents[i].text,
                  'size': new Size(w, textHeight)
              });
          }
      }
      else {
          if (textWidth > actualWidth) {
              actualWidth = textWidth;
          }
          textRows.push({
              'text': text,
              'size': size
          });
      }
      var rowNum = textRows.length;
      var textSize = new Size(actualWidth, textHeight * rowNum + lineSpacing * (rowNum - 1));
      return {
          'total': rowNum,
          'size': textSize,
          'rows': textRows,
          'rawSize': size
      };
  }
  function hashCode(s) {
      var hash = 0;
      var strlen = s && s.length || 0;
      if (!strlen) {
          return hash;
      }
      var c;
      for (var i = 0; i < strlen; i++) {
          c = s.charCodeAt(i);
          hash = ((hash << 5) - hash) + c;
          hash = hash & hash; // Convert to 32bit integer
      }
      return hash;
  }

  var strings = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_FONT: DEFAULT_FONT,
    DEFAULT_TEXTSIZE: DEFAULT_TEXTSIZE,
    EMPTY_STRING: EMPTY_STRING$1,
    describeText: describeText,
    escapeSpecialChars: escapeSpecialChars,
    getAlignPoint: getAlignPoint,
    getFont: getFont,
    hashCode: hashCode,
    replaceAll: replaceAll,
    replaceVariable: replaceVariable,
    splitContent: splitContent,
    splitTextToRow: splitTextToRow,
    splitWords: splitWords,
    stringLength: stringLength,
    stringWidth: stringWidth,
    trim: trim
  });

  /* eslint-disable @typescript-eslint/ban-types */
  /* eslint-disable @typescript-eslint/ban-ts-comment */
  /**
   * DOM utilities used internally.
   * Learned a lot from Leaflet.DomUtil
   * @class
   * @category core
   */
  var first = function (props) {
      return props[0];
  };
  /**
   * From Leaflet.DomUtil
   * Goes through the array of style names and returns the first name
   * that is a valid style name for an element. If no such name is found,
   * it returns false. Useful for vendor-prefixed styles like `transform`.
   * @param  {String[]} props
   * @return {Boolean}
   * @private
   */
  var testProp = IS_NODE ? first : function (props) {
      var style = (document.documentElement && document.documentElement.style) || {};
      for (var i = 0; i < props.length; i++) {
          if (props[i] in style) {
              return props[i];
          }
      }
      return false;
  };
  // prefix style property names
  /**
   * Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
   * @property {String} TRANSFORM
   */
  var TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);
  /**
   * Vendor-prefixed tfransform-origin name (e.g. `'webkitTransformOrigin'` for WebKit).
   * @property {String} TRANSFORMORIGIN
   */
  var TRANSFORMORIGIN = testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);
  /**
   * Vendor-prefixed transition name (e.g. `'WebkitTransition'` for WebKit).
   * @property {String} TRANSITION
   */
  var TRANSITION = testProp(['transition', 'WebkitTransition', 'OTransition', 'MozTransition', 'msTransition']);
  /**
   * Vendor-prefixed filter name (e.g. `'WebkitFilter'` for WebKit).
   * @property {String} FILTER
   */
  var CSSFILTER = testProp(['filter', 'WebkitFilter', 'OFilter', 'MozFilter', 'msFilter']);
  /**
   * Create a html element.
   * @param tagName
   * @param className
   * @returns
   */
  function createEl(tagName, className) {
      var el = document.createElement(tagName);
      if (className) {
          setClass(el, className);
      }
      return el;
  }
  /**
   * Create a html element on the specified container
   * @param tagName
   * @param style - css styles
   * @param container
   * @return
   */
  function createElOn(tagName, style, container) {
      var el = createEl(tagName);
      if (style) {
          setStyle(el, style);
      }
      if (container) {
          container.appendChild(el);
      }
      return el;
  }
  /**
   * Removes a html element.
   * @param node
   */
  /* istanbul ignore next */
  function removeDomNode(node) {
      if (!node) {
          return this;
      }
      if (Browser$1.ielt9 || Browser$1.ie9) {
          //fix memory leak in IE9-
          //http://com.hemiola.com/2009/11/23/memory-leaks-in-ie8/
          var d = createEl('div');
          d.appendChild(node);
          d.innerHTML = '';
          d = null;
      }
      else if (node.parentNode) {
          node.parentNode.removeChild(node);
      }
      return this;
  }
  /**
   * Adds a event listener to the dom element.
   * @param  obj     - dom element to listen on
   * @param  typeArr      - event types, seperated by space
   * @param  handler    - listener function
   * @param  context      - function context
   */
  function addDomEvent(obj, typeArr, handler, context) {
      if (!obj || !obj.addEventListener || !typeArr || !handler) {
          return this;
      }
      var eventHandler = function (e) {
          if (!e) {
              e = window.event;
          }
          handler.call(context || obj, e);
          return;
      };
      var types = typeArr.split(' ');
      for (var i = types.length - 1; i >= 0; i--) {
          var type = types[i];
          if (!type) {
              continue;
          }
          if (!obj['Z__' + type]) {
              obj['Z__' + type] = [];
          }
          var hit = listensDomEvent(obj, type, handler);
          if (hit >= 0) {
              console.warn(obj, "find '".concat(type, "' handler:"), handler, ' The old listener function will be removed');
              removeDomEvent(obj, type, handler);
          }
          obj['Z__' + type].push({
              callback: eventHandler,
              src: handler
          });
          // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
          obj.addEventListener(type, eventHandler, Browser$1.supportsPassive ? { capture: false, passive: false } : false);
      }
      return this;
  }
  /**
   * Removes event listener from a dom element
   * @param  obj         - dom element
   * @param  typeArr          - event types, separated by space
   * @param  handler        - listening function
   */
  function removeDomEvent(obj, typeArr, handler) {
      function doRemove(type, callback) {
          //mouse wheel in firefox
          if (type === 'mousewheel' && Browser$1.gecko) {
              type = 'DOMMouseScroll';
          }
          obj.removeEventListener(type, callback, false);
      }
      if (!obj || !obj.removeEventListener || !typeArr) {
          return this;
      }
      var types = typeArr.split(' ');
      for (var i = types.length - 1; i >= 0; i--) {
          var type = types[i];
          if (!type) {
              continue;
          }
          //remove all the listeners if handler is not given.
          if (!handler && obj['Z__' + type]) {
              var handlers = obj['Z__' + type];
              for (var j = 0, jlen = handlers.length; j < jlen; j++) {
                  doRemove(handlers[j].callback);
              }
              delete obj['Z__' + type];
              return this;
          }
          var hit = listensDomEvent(obj, type, handler);
          if (hit < 0) {
              return this;
          }
          var hitHandler = obj['Z__' + type][hit];
          doRemove(type, hitHandler.callback);
          obj['Z__' + type].splice(hit, 1);
      }
      return this;
  }
  /**
   * Check if event type of the dom is listened by the handler
   * @param  obj     - dom element to check
   * @param  typeArr      - event
   * @param  handler    - the listening function
   * @return {Number} - the handler's index in the listener chain, returns -1 if not.
   */
  function listensDomEvent(obj, type, handler) {
      if (!obj || !obj['Z__' + type] || !handler) {
          return -1;
      }
      var handlers = obj['Z__' + type];
      for (var i = 0, len = handlers.length; i < len; i++) {
          if (handlers[i].src === handler) {
              return i;
          }
      }
      return -1;
  }
  /**
   * Prevent default behavior of the browser. <br/>
   * preventDefault Cancels the event if it is cancelable, without stopping further propagation of the event.
   * @param {Event} event - browser event
   */
  function preventDefault(event) {
      if (event.preventDefault) {
          event.preventDefault();
      }
      else {
          event.returnValue = false;
      }
      return this;
  }
  /**
   * Stop browser event propagation
   * @param   e - browser event.
   */
  function stopPropagation(e) {
      // @ts-expect-error
      e._cancelBubble = true;
      if (e.stopPropagation) {
          e.stopPropagation();
      }
      else {
          e.cancelBubble = true;
      }
      return this;
  }
  function preventSelection(dom) {
      dom.onselectstart = function () {
          return false;
      };
      dom.ondragstart = function () {
          return false;
      };
      dom.setAttribute('unselectable', 'on');
      return this;
  }
  /**
   * Get the dom element's current position or offset its position by offset
   * @param  dom - HTMLElement
   * @param  offset - position to set.
   * @return  dom element's current position if offset is null.
   */
  function offsetDom(dom, offset) {
      if (!dom) {
          return null;
      }
      if (Browser$1.any3d) {
          setTransform(dom, offset);
      }
      else {
          dom.style.left = offset.x + 'px';
          dom.style.top = offset.y + 'px';
      }
      return offset;
  }
  /**
   * Compute dom's position
   * @param  dom
   * @return
   */
  function computeDomPosition(dom) {
      var style = window.getComputedStyle(dom);
      var padding = [
          parseInt(style['padding-left']),
          parseInt(style['padding-top'])
      ];
      var rect = dom.getBoundingClientRect();
      //fix #450, inspired by https://github.com/Leaflet/Leaflet/pull/5794/files
      var offsetWidth = dom.offsetWidth, offsetHeight = dom.offsetHeight;
      var scaleX = offsetWidth ? rect.width / offsetWidth : 1, scaleY = offsetHeight ? rect.height / offsetHeight : 1;
      // @ts-expect-error
      dom.__position = [rect.left + padding[0], rect.top + padding[1], scaleX, scaleY];
      // @ts-expect-error
      return dom.__position;
  }
  /**
   * Get event's position from the top-left corner of the dom container
   * @param ev    event
   * @return
   */
  function getEventContainerPoint(ev, dom) {
      if (!ev) {
          // @ts-expect-error
          ev = window.event;
      }
      // @ts-expect-error
      var domPos = dom.__position;
      if (!domPos) {
          domPos = computeDomPosition(dom);
      }
      //in mobile #1720
      var toucheEvent = ev;
      //touchevent
      if (toucheEvent.touches && toucheEvent.touches.length) {
          ev = toucheEvent.touches[0];
      }
      //touchendevent
      if (toucheEvent.changedTouches && toucheEvent.changedTouches.length) {
          ev = toucheEvent.changedTouches[0];
      }
      // div by scaleX, scaleY to fix #450
      return new Point((ev.clientX - domPos[0] - dom.clientLeft) / domPos[2], (ev.clientY - domPos[1] - dom.clientTop) / domPos[3]);
  }
  function endsWith(str, suffix) {
      var l = str.length - suffix.length;
      return l >= 0 && str.indexOf(suffix, l) === l;
  }
  /**
   * set css style to the dom element
   * @param dom dom element
   * @param strCss css text
   */
  function setStyle(dom, strCss) {
      var cssText = dom.style.cssText;
      if (!endsWith(cssText, ';')) {
          cssText += ';';
      }
      dom.style.cssText = cssText + strCss;
      return this;
  }
  /**
   * Whether the dom has the given css class.
   * @param el HTML Element
   * @param name css class
   */
  function hasClass(el, name) {
      if (el.classList !== undefined) {
          return el.classList.contains(name);
      }
      var className = getClass(el);
      return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  }
  /**
   * add css class to dom element
   * @param el HTML Element
   * @param name css class
   */
  function addClass(el, name) {
      if (el.classList !== undefined && !hasClass(el, name)) {
          var classes = splitWords(name);
          for (var i = 0, len = classes.length; i < len; i++) {
              el.classList.add(classes[i]);
          }
      }
      else {
          var className = getClass(el);
          setClass(el, (className ? className + ' ' : '') + name);
      }
      return this;
  }
  /**
   * Set dom's css class
   * @param el HTML Element
   * @param name css class
   */
  function setClass(el, name) {
      // @ts-expect-error
      if (isNil(el.className.baseVal)) {
          el.className = name;
      }
      else {
          // @ts-expect-error
          el.className.baseVal = name;
      }
      return this;
  }
  /**
   * Get dom's css class
   * @param name css class
   * @retrun class字符串
   */
  function getClass(el) {
      // @ts-expect-error
      return isNil(el.className.baseVal) ? el.className : el.className.baseVal;
  }
  function setOpacity(el, value) {
      el.style.opacity = value;
      return this;
  }
  // export function copyCanvas(src) {
  //     if (IS_NODE) {
  //         return null;
  //     }
  //     const target = createEl('canvas');
  //     target.width = src.width;
  //     target.height = src.height;
  //     target.getContext('2d').drawImage(src, 0, 0);
  //     return target;
  // }
  /**
   * Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
   * @param el
   * @param offset
   */
  function setTransform(el, offset) {
      var pos = offset || new Point(0, 0);
      el.style[TRANSFORM] =
          Browser$1.any3d ?
              'translate3d(' + pos.x + 'px,' + pos.y + 'px,0px)' :
              'translate(' + pos.x + 'px,' + pos.y + 'px)';
      return this;
  }
  function setTransformMatrix(el, m) {
      var text = 'matrix(' + (isString(m) ? m : m.join()) + ')';
      if (el.style[TRANSFORM] !== text) {
          el.style[TRANSFORM] = text;
      }
      return this;
  }
  function removeTransform(el) {
      if (el.style[TRANSFORM]) {
          el.style[TRANSFORM] = '';
      }
      return this;
  }
  function isHTML(str) {
      return /<[a-z\][\s\S]*>/i.test(str);
  }
  function measureDom(parentTag, dom) {
      var ruler = getDomRuler(parentTag);
      if (isString(dom)) {
          ruler.innerHTML = dom;
      }
      else {
          ruler.appendChild(dom);
      }
      var result = new Size(ruler.clientWidth, ruler.clientHeight);
      removeDomNode(ruler);
      return result;
  }
  function getDomRuler(tag) {
      var span = document.createElement(tag);
      span.style.cssText = 'position:absolute;left:-10000px;top:-10000px;';
      document.body.appendChild(span);
      return span;
  }
  /**
   * Alias for [addDomEvent]{@link DomUtil.addDomEvent}
   * @param {HTMLElement} obj     - dom element to listen on
   * @param {String} typeArr      - event types, seperated by space
   * @param {Function} handler    - listener function
   * @param {Object} context      - function context
   * @static
   * @function
   * @return {DomUtil}
   */
  var on = addDomEvent;
  /**
   * Alias for [removeDomEvent]{@link DomUtil.removeDomEvent}
   * @param {HTMLElement} obj         - dom element
   * @param {String} typeArr          - event types, separated by space
   * @param {Function} handler        - listening function
   * @static
   * @function
   * @return {DomUtil}
   */
  var off = removeDomEvent;
  function isMoveEvent(type) {
      return type && (type === 'mousemove' || type === 'touchmove');
  }
  var MOUSEMOVE_THROTTLE_TIME = 48;
  function isMousemoveEventBlocked(target, mousemoveThrottleTime) {
      var currentTime = now();
      var TIME = mousemoveThrottleTime || MOUSEMOVE_THROTTLE_TIME;
      if (target._mousemoveTime && currentTime - target._mousemoveTime < TIME) {
          return true;
      }
      target._mousemoveTime = currentTime;
      return false;
  }

  var dom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CSSFILTER: CSSFILTER,
    MOUSEMOVE_THROTTLE_TIME: MOUSEMOVE_THROTTLE_TIME,
    TRANSFORM: TRANSFORM,
    TRANSFORMORIGIN: TRANSFORMORIGIN,
    TRANSITION: TRANSITION,
    addClass: addClass,
    addDomEvent: addDomEvent,
    computeDomPosition: computeDomPosition,
    createEl: createEl,
    createElOn: createElOn,
    getClass: getClass,
    getDomRuler: getDomRuler,
    getEventContainerPoint: getEventContainerPoint,
    hasClass: hasClass,
    isHTML: isHTML,
    isMousemoveEventBlocked: isMousemoveEventBlocked,
    isMoveEvent: isMoveEvent,
    listensDomEvent: listensDomEvent,
    measureDom: measureDom,
    off: off,
    offsetDom: offsetDom,
    on: on,
    preventDefault: preventDefault,
    preventSelection: preventSelection,
    removeDomEvent: removeDomEvent,
    removeDomNode: removeDomNode,
    removeTransform: removeTransform,
    setClass: setClass,
    setOpacity: setOpacity,
    setStyle: setStyle,
    setTransform: setTransform,
    setTransformMatrix: setTransformMatrix,
    stopPropagation: stopPropagation
  });

  /* eslint-disable @typescript-eslint/ban-ts-comment */
  /**
   * @classdesc
   * Ajax Utilities. It is static and should not be initiated.
   * @class
   * @static
   * @category core
   */
  var Ajax = {
      /**
       * Get JSON data by jsonp
       * from https://gist.github.com/gf3/132080/110d1b68d7328d7bfe7e36617f7df85679a08968
       * @param url - resource url
       * @param callback  - callback function when completed
       */
      jsonp: function (url, callback) {
          // INIT
          var name = '_maptalks_jsonp_' + UID();
          if (url.match(/\?/))
              url += '&callback=' + name;
          else
              url += '?callback=' + name;
          // Create script
          var script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          // Setup handler
          window[name] = function (data) {
              callback(null, data);
              document.getElementsByTagName('head')[0].removeChild(script);
              script = null;
              delete window[name];
          };
          // Load JSON
          document.getElementsByTagName('head')[0].appendChild(script);
          return this;
      },
      /**
       * Fetch remote resource by HTTP "GET" method
       * @param  {String}   url - resource url
       * @param  {Object}   [options=null] - request options
       * @param  {Object}   [options.headers=null] - HTTP headers
       * @param  {String}   [options.responseType=null] - responseType
       * @param  {String}   [options.credentials=null]  - if with credentials, set it to "include"
       * @param  {Function} cb  - callback function when completed
       * @return {Ajax}  Ajax
       * @example
       * maptalks.Ajax.get(
       *     'url/to/resource',
       *     (err, data) => {
       *         if (err) {
       *             throw new Error(err);
       *         }
       *         // do things with data
       *     }
       * );
       */
      get: function (url, options, cb) {
          if (isFunction(options)) {
              var t = cb;
              cb = options;
              options = t;
          }
          // @ts-ignore
          if (IS_NODE && Ajax.get.node) {
              // @ts-ignore
              return Ajax.get.node(url, cb, options);
          }
          var client = Ajax._getClient(cb);
          client.open('GET', url, true);
          if (options) {
              for (var k in options.headers) {
                  client.setRequestHeader(k, options.headers[k]);
              }
              client.withCredentials = options.credentials === 'include';
              if (options['responseType']) {
                  client.responseType = options['responseType'];
              }
          }
          client.send(null);
          return client;
      },
      /**
       * Fetch remote resource by HTTP "POST" method
       * @param  {String}   url - resource url
       * @param  {Object}   options - request options
       * @param  {String|Object}  options.postData - post data
       * @param  {Object}   [options.headers=null]  - HTTP headers
       * @param  {Function} cb  - callback function when completed
       * @return {Ajax}  Ajax
       * @example
       * maptalks.Ajax.post(
       *   'url/to/post',
       *   {
       *     postData : {
       *       'param0' : 'val0',
       *       'param1' : 1
       *     }
       *   },
       *   (err, data) => {
       *     if (err) {
       *       throw new Error(err);
       *     }
       *     // do things with data
       *   }
       * );
       */
      post: function (url, options, cb) {
          var postData;
          if (!isString(url)) {
              //for compatible
              //options, postData, cb
              var t = cb;
              postData = options;
              options = url;
              url = options.url;
              cb = t;
          }
          else {
              if (isFunction(options)) {
                  var t = cb;
                  cb = options;
                  options = t;
              }
              options = options || {};
              postData = options.postData;
          }
          // @ts-ignore
          if (IS_NODE && Ajax.post.node) {
              options.url = url;
              // @ts-ignore
              return Ajax.post.node(options, postData, cb);
          }
          var client = Ajax._getClient(cb);
          client.open('POST', options.url, true);
          if (!options.headers) {
              options.headers = {};
          }
          if (!options.headers['Content-Type']) {
              options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
          }
          if ('setRequestHeader' in client) {
              for (var p in options.headers) {
                  if (options.headers.hasOwnProperty(p)) {
                      client.setRequestHeader(p, options.headers[p]);
                  }
              }
          }
          if (!isString(postData)) {
              postData = JSON.stringify(postData);
          }
          client.send(postData);
          return client;
      },
      //@internal
      _wrapCallback: function (client, cb) {
          return function () {
              if (client.readyState === 4) {
                  if (client.status === 200) {
                      if (client.responseType === 'arraybuffer') {
                          var response = client.response;
                          if (response.byteLength === 0) {
                              cb(new Error('http status 200 returned without content.'));
                          }
                          else {
                              cb(null, {
                                  data: client.response,
                                  cacheControl: client.getResponseHeader('Cache-Control'),
                                  expires: client.getResponseHeader('Expires'),
                                  contentType: client.getResponseHeader('Content-Type')
                              });
                          }
                      }
                      else {
                          cb(null, client.responseText);
                      }
                  }
                  else {
                      cb(new Error(client.statusText + ',' + client.status));
                  }
              }
          };
      },
      //@internal
      _getClient: function (cb) {
          /*eslint-disable no-empty, no-undef*/
          var client;
          try {
              client = new XMLHttpRequest();
          }
          catch (e) {
              try {
                  client = new ActiveXObject('Msxml2.XMLHTTP');
              }
              catch (e) {
                  try {
                      client = new ActiveXObject('Microsoft.XMLHTTP');
                  }
                  catch (e) { }
              }
          }
          client.onreadystatechange = Ajax._wrapCallback(client, cb);
          return client;
          /*eslint-enable no-empty, no-undef*/
      },
      /**
       * Fetch resource as arraybuffer.
       * @param {String} url    - url
       * @param {Object} [options=null] - options, same as Ajax.get
       * @param {Function} cb   - callback function when completed.
       * @example
       * maptalks.Ajax.getArrayBuffer(
       *     'url/to/resource.bin',
       *     (err, data) => {
       *         if (err) {
       *             throw new Error(err);
       *         }
       *         // data is a binary array
       *     }
       * );
       */
      getArrayBuffer: function (url, options, cb) {
          if (isFunction(options)) {
              var t = cb;
              cb = options;
              options = t;
          }
          if (!options) {
              options = {};
          }
          options['responseType'] = 'arraybuffer';
          return Ajax.get(url, options, cb);
      },
      // from mapbox-gl-js
      getImage: function (img, url, options) {
          return Ajax.getArrayBuffer(url, options, function (err, imgData) {
              if (err) {
                  if (img.onerror) {
                      img.onerror(err);
                  }
              }
              else if (imgData) {
                  var URL_1 = window.URL || window.webkitURL;
                  var onload_1 = img.onload;
                  img.onload = function () {
                      if (onload_1) {
                          onload_1();
                      }
                      URL_1.revokeObjectURL(img.src);
                  };
                  var blob = new Blob([new Uint8Array(imgData.data)], { type: imgData.contentType });
                  img.cacheControl = imgData.cacheControl;
                  img.expires = imgData.expires;
                  img.src = imgData.data.byteLength ? URL_1.createObjectURL(blob) : emptyImageUrl;
              }
          });
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getJSON: function (url, options, cb) { }
  };
  /**
   * Fetch resource as a JSON Object.
   * @param {String} url          - json's url
   * @param {Object} [options=null]        - optional options
   * @param {String} [options.jsonp=false] - fetch by jsonp, false by default
   * @param {Function} cb   - callback function when completed.
   * @example
   * maptalks.Ajax.getJSON(
   *     'url/to/resource.json',
   *     { jsonp : true },
   *     (err, json) => {
   *         if (err) {
   *             throw new Error(err);
   *         }
   *         // json is a JSON Object
   *         console.log(json.foo);
   *     }
   * );
   * @static
   */
  Ajax.getJSON = function (url, options, cb) {
      if (isFunction(options)) {
          var t = cb;
          cb = options;
          options = t;
      }
      var callback = function (err, resp) {
          var data = resp ? parseJSON(resp) : null;
          cb(err, data);
      };
      if (options && options['jsonp']) {
          return Ajax.jsonp(url, callback);
      }
      return Ajax.get(url, options, callback);
  };

  var EMPTY_STRING = '';
  var BASE64_REG = /data:image\/.*;base64,/;
  function createCanvas() {
      var canvas;
      if (Browser$1.IS_NODE) {
          console.error('Current environment does not support canvas dom');
      }
      else {
          canvas = createEl('canvas');
      }
      return canvas;
  }
  function createOffscreenCanvas() {
      var offscreenCanvas;
      if (Browser$1.decodeImageInWorker) {
          offscreenCanvas = new OffscreenCanvas(2, 2);
      }
      return offscreenCanvas;
  }
  function isBase64URL(path) {
      return BASE64_REG.test(path);
  }
  function isBlobURL(path) {
      return path.indexOf('blob:') === 0;
  }
  function strContains(str1, str2) {
      if (isNumber(str1)) {
          str1 += EMPTY_STRING;
      }
      if (isNumber(str2)) {
          str2 += EMPTY_STRING;
      }
      if (!str1 || !str2) {
          return false;
      }
      if (str1.includes) {
          return str1.includes(str2);
      }
      return str1.indexOf(str2) > -1;
  }
  function handlerURL(path, configs) {
      if (configs === void 0) { configs = {}; }
      for (var local in configs) {
          var obj = configs[local];
          if (!obj || !obj.target) {
              continue;
          }
          if (strContains(path, local)) {
              var target = obj.target;
              return path.replace(local, target);
          }
      }
      return EMPTY_STRING;
  }
  function loadSprite(options) {
      if (options === void 0) { options = { imgUrl: '', jsonUrl: '' }; }
      return new Promise(function (resolve, reject) {
          var imgUrl = options.imgUrl, jsonUrl = options.jsonUrl;
          if (!imgUrl || !jsonUrl) {
              reject(new Error('not find imgUrl/jsonUrl from options'));
              console.error(options);
              return;
          }
          function getCtx(canvas, width, height) {
              canvas.width = width;
              canvas.height = height;
              var ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, width, height);
              return ctx;
          }
          function parseSprite(json, image) {
              if (json === void 0) { json = {}; }
              var canvas = createCanvas();
              if (!canvas) {
                  reject(new Error('can not create canvas'));
                  return;
              }
              var icons = [];
              for (var name_1 in json) {
                  var spriteItem = json[name_1];
                  icons.push({
                      name: name_1,
                      spriteItem: spriteItem
                  });
              }
              var offscreenCanvas = createOffscreenCanvas();
              var sourceName = options.sourceName || "";
              icons.forEach(function (icon) {
                  var name = icon.name, spriteItem = icon.spriteItem;
                  var x = spriteItem.x, y = spriteItem.y, width = spriteItem.width, height = spriteItem.height;
                  var resource;
                  if (offscreenCanvas) {
                      var ctx = getCtx(offscreenCanvas, width, height);
                      ctx.drawImage(image, x, y, width, height, 0, 0, width, height);
                      resource = offscreenCanvas.transferToImageBitmap();
                  }
                  else {
                      var ctx = getCtx(canvas, width, height);
                      ctx.drawImage(image, x, y, width, height, 0, 0, width, height);
                      resource = canvas.toDataURL();
                  }
                  icon.resource = resource;
                  ResourceProxy.addResource(sourceName + name, resource);
              });
              resolve(icons);
          }
          Ajax.getJSON(jsonUrl, {}, function (err, json) {
              if (err) {
                  reject(err);
                  return;
              }
              var img = new Image();
              img.onload = function () {
                  parseSprite(json, img);
              };
              img.onerror = function (err) {
                  reject(err);
                  return;
              };
              Ajax.getImage(img, imgUrl, {});
          });
      });
  }
  function loadSvgs(svgs) {
      return new Promise(function (resolve, reject) {
          var url = '', symbols = [], fillColor = '', strokeColor = '', sourceName = '';
          if (Array.isArray(svgs) || (svgs instanceof NodeList)) {
              symbols = svgs;
          }
          else if (isObject$1(svgs)) {
              var opts = svgs;
              url = opts.url;
              symbols = opts.symbols;
              fillColor = opts.fill;
              strokeColor = opts.stroke;
              sourceName = opts.sourceName || '';
          }
          else if (isString(svgs)) {
              url = svgs;
          }
          if (!url && (symbols && symbols.length === 0)) {
              reject(new Error('not find svgs data'));
              return;
          }
          var result = [];
          var addToCache = function (name, body) {
              var paths = parseSVG(body);
              if (paths) {
                  paths.forEach(function (path) {
                      if (fillColor) {
                          path.fill = fillColor;
                      }
                      if (strokeColor) {
                          path.stroke = strokeColor;
                      }
                  });
                  ResourceProxy.addResource(sourceName + name, paths);
              }
              var data = {
                  name: name,
                  paths: paths,
                  body: body
              };
              result.push(data);
          };
          //svg json collection
          if (url && isString(url)) {
              fetch(url).then(function (res) { return res.json(); }).then(function (json) {
                  json.forEach(function (svg) {
                      var name = svg.name, body = svg.body;
                      addToCache(name, body);
                  });
                  resolve(result);
              }).catch(function (err) {
                  console.log(err);
                  reject(err);
              });
              return;
          }
          //support svg symbols
          // https://developer.mozilla.org/en-US/docs/web/svg/element/symbol
          if (symbols) {
              for (var i = 0, len = symbols.length; i < len; i++) {
                  var symbolNode = symbols[i];
                  var name_2 = symbolNode.id;
                  var html = symbolNode.innerHTML;
                  var body = "<xml><svg>".concat(html, "</svg></xml>");
                  if (name_2) {
                      addToCache(name_2, body);
                  }
              }
              resolve(result);
              return;
          }
          reject(new Error('not support svgs params type'));
      });
  }
  /**
   * simple Resouce Proxy implementation
   *
   * https://www.webpackjs.com/configuration/dev-server/#devserverproxy
   */
  // const { ResourceProxy, formatResouceUrl } = maptalks;
  // function test1() {
  //     ResourceProxy.proxy = {
  //         '/geojson/': {
  //             target: 'https://geo.datav.aliyun.com/areas_v3/bound/'
  //         }
  //     }
  //     const url = formatResouceUrl('/geojson/350000_full.json');
  //     console.log(url);
  // }
  // function test2() {
  //     ResourceProxy.origin = {
  //         'https://www.maptalks.com/': {
  //             target: 'https://geo.datav.aliyun.com/areas_v3/'
  //         }
  //     }
  //     const url = formatResouceUrl('https://www.maptalks.com/bound/350000_full.json');
  //     console.log(url);
  // }
  // function test3() {
  //     ResourceProxy.host = 'https://geo.datav.aliyun.com/areas_v3/bound'
  //     const url = formatResouceUrl('/350000_full.json');
  //     console.log(url);
  // }
  // function test4() {
  //     const url = formatResouceUrl('./苏州.geojson');
  //     console.log(url);
  // }
  var ResourceProxy = {
      host: EMPTY_STRING,
      resources: {},
      proxy: {
      // '/api/': {
      //     target: 'https://www.maptalks.com/api/'
      // },
      // '/doc/': {
      //     target: 'https://www.maptalks.com/doc/'
      // }
      },
      origin: {
      // 'https://www.maptalks.com/api/': {
      //     target: 'https://www.deyihu.com/api/'
      // },
      // 'https://www.maptalks.com/doc/': {
      //     target: 'https://www.deyihu.com/doc/'
      // }
      },
      fromJSON: function (json) {
          try {
              if (isString(json)) {
                  json = JSON.parse(json);
              }
              if (isObject$1(json)) {
                  extend$2(ResourceProxy, json);
              }
          }
          catch (error) {
              console.error(error);
          }
      },
      toJSON: function () {
          return {
              host: ResourceProxy.host,
              proxy: extend$2({}, ResourceProxy.proxy || {}),
              origin: extend$2({}, ResourceProxy.origin || {})
          };
      },
      getResource: function (name) {
          return ResourceProxy.resources[name];
      },
      /**
       * remove resource
       * @param {String} name
       */
      removeResource: function (name) {
          delete ResourceProxy.resources[name];
      },
      /**
       * add resource
       * @param {String} name
       * @param {Object} res
       */
      addResource: function (name, res) {
          if (ResourceProxy.resources[name]) {
              console.warn("".concat(name, " resource Already exists,the ").concat(name, " Cannot be added,the resource name Cannot repeat "));
              return;
          }
          ResourceProxy.resources[name] = res;
      },
      /**
      * update  resource (remove and add)
       * @param {String} name
       * @param {Object} res
       */
      updateResource: function (name, res) {
          ResourceProxy.resources[name] = res;
      },
      /**
       * get all resource [key,value]
       * @returns {Object} source
       */
      allResource: function () {
          return ResourceProxy.resources;
      },
      loadSprite: loadSprite,
      loadSvgs: loadSvgs
  };
  function formatResourceUrl(path) {
      if (isNumber(path)) {
          path += EMPTY_STRING;
      }
      if (!path) {
          console.error('resouce path is null,path:', path);
          return path;
      }
      if (!isString(path)) {
          return path;
      }
      if (isBase64URL(path) || isBlobURL(path)) {
          return path;
      }
      if (path[0] === '$') {
          return ResourceProxy.getResource(path.substring(1, Infinity)) || '';
      }
      var origin = ResourceProxy.origin || {};
      //is isAbsoluteURL
      var isAbsoluteURL = isURL(path);
      if (isAbsoluteURL && isObject$1(origin)) {
          var url = handlerURL(path, origin);
          if (url) {
              return url;
          }
          return path;
      }
      //relative URL
      var proxys = ResourceProxy.proxy || {};
      if (isObject$1(proxys)) {
          var url = handlerURL(path, proxys);
          if (url) {
              return url;
          }
      }
      var host = ResourceProxy.host;
      if (!isAbsoluteURL && host && isString(host)) {
          return "".concat(host).concat(path);
      }
      return getAbsoluteURL(path);
  }
  var parser = new DOMParser();
  function getAttr(attributes, key) {
      if (!attributes) {
          return null;
      }
      return attributes[key] && attributes[key].value;
  }
  function parseSVG(str) {
      var xmlDoc = parser.parseFromString(str, 'text/xml');
      var root = xmlDoc.querySelector('svg');
      if (!root) {
          return null;
      }
      //parse all node,not only path node
      var paths = root.childNodes;
      var data = [];
      var rootAttribute = root.attributes;
      var rootFill = getAttr(rootAttribute, 'fill');
      var rootFillOpacity = getAttr(rootAttribute, 'fill-opacity');
      var rootStroke = getAttr(rootAttribute, 'stroke');
      var rootStrokeOpacity = getAttr(rootAttribute, 'stroke-opacity');
      var rootStrokeWidth = getAttr(rootAttribute, 'stroke-width');
      for (var i = 0, len = paths.length; i < len; i++) {
          var dom = paths[i];
          var attributes = dom.attributes;
          if (!attributes) {
              continue;
          }
          var d = void 0;
          var tagName = dom.tagName || '';
          var isPath = tagName.toLowerCase() === 'path';
          //非path节点直接拿dom节点 作为path参数
          if (!isPath) {
              d = dom;
          }
          else {
              d = getAttr(attributes, 'd');
          }
          if (!d) {
              continue;
          }
          var fill = getAttr(attributes, 'fill') || rootFill;
          var stroke = getAttr(attributes, 'stroke') || rootStroke;
          var pathData = {
              path: d
          };
          if (fill) {
              pathData.fill = fill;
              pathData['fill-opacity'] = getAttr(attributes, 'fill-opacity') || rootFillOpacity || 1;
          }
          if (stroke) {
              pathData.stroke = stroke;
              pathData['stroke-opacity'] = getAttr(attributes, 'stroke-opacity') || rootStrokeOpacity || 1;
              pathData['stroke-width'] = getAttr(attributes, 'stroke-width') || rootStrokeWidth || 1;
          }
          data.push(pathData);
          if (!isPath) {
              for (var p in pathData) {
                  if (p === 'path') {
                      continue;
                  }
                  if (pathData.hasOwnProperty(p)) {
                      dom.setAttribute(p, pathData[p]);
                  }
              }
          }
      }
      return data;
  }

  let canvas;
  const OPTIONS = {
      width: 100,
      height: 10
  };

  function getCanvas() {
      if (!canvas) {
          const { width, height } = OPTIONS;
          if (OffscreenCanvas) {
              canvas = new OffscreenCanvas(width, height);
          } else {
              canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
          }
      }
      return canvas;
  }

  class ColorIn {
      constructor(colors, options = {}) {
          if (!Array.isArray(colors)) {
              console.error('colors is not array');
              return;
          }
          if (colors.length < 2) {
              console.error('colors.length should >1');
              return;
          }
          this.colors = colors;
          let min = Infinity, max = -Infinity;
          for (let i = 0, len = colors.length; i < len; i++) {
              const value = colors[i][0];
              min = Math.min(value, min);
              max = Math.max(value, max);
          }
          this.min = min;
          this.max = max;
          this.valueOffset = this.max - this.min;
          this.options = Object.assign({}, OPTIONS, options);
          this._initImgData();
      }

      getImageData() {
          return this.imgData;
      }

      _initImgData() {
          const canvas = getCanvas();
          const { width, height } = this.options;
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          const { colors, valueOffset } = this;
          for (let i = 0, len = colors.length; i < len; i++) {
              const [stop, color] = colors[i];
              const s = (stop - this.min) / valueOffset;
              gradient.addColorStop(s, color);
          }
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          this.imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }

      getColor(stop) {
          stop = Math.max(this.min, stop);
          stop = Math.min(stop, this.max);
          const s = (stop - this.min) / this.valueOffset;
          let x = Math.round(s * this.imgData.width);
          x = Math.min(x, this.imgData.width - 1);
          const idx = x * 4;
          const r = this.imgData.data[idx];
          const g = this.imgData.data[idx + 1];
          const b = this.imgData.data[idx + 2];
          const a = this.imgData.data[idx + 3];
          return [r, g, b, a];
      }
  }

  var isMapSupported$1 = typeof Map === 'function';
  var colorInCache;
  if (isMapSupported$1) {
      colorInCache = new Map();
  }

  /*eslint-disable no-var, prefer-const*/
  function createFunction(parameters, defaultType) {
      var fun;
      var isFeatureConstant, isZoomConstant;
      if (!isFunctionDefinition(parameters)) {
          fun = function () { return parameters; };
          isFeatureConstant = true;
          isZoomConstant = true;

      } else {
          var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
          var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
          var zoomDependent = zoomAndFeatureDependent || !featureDependent;
          var type = parameters.type || defaultType || 'exponential';

          var innerFun;
          if (type === 'exponential') {
              innerFun = evaluateExponentialFunction;
          } else if (type === 'interval') {
              innerFun = evaluateIntervalFunction;
          } else if (type === 'categorical') {
              innerFun = evaluateCategoricalFunction;
          } else if (type === 'identity') {
              innerFun = evaluateIdentityFunction;
          } else if (type === 'color-interpolate') {
              innerFun = evaluateColorInterpolateFunction;
          } else {
              throw new Error('Unknown function type "' + type + '"');
          }

          if (zoomAndFeatureDependent) {
              var featureFunctions = {};
              var featureFunctionStops = [];
              for (let s = 0; s < parameters.stops.length; s++) {
                  var stop = parameters.stops[s];
                  if (featureFunctions[stop[0].zoom] === undefined) {
                      featureFunctions[stop[0].zoom] = {
                          zoom: stop[0].zoom,
                          type: parameters.type,
                          property: parameters.property,
                          default: parameters.default,
                          stops: []
                      };
                  }
                  featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
              }

              for (let z in featureFunctions) {
                  featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
              }
              fun = function (zoom, feature) {
                  const value = evaluateExponentialFunction({ stops: featureFunctionStops, base: parameters.base }, zoom)(zoom, feature);
                  return typeof value === 'function' ? value(zoom, feature) : value;
              };
              isFeatureConstant = false;
              isZoomConstant = false;

          } else if (zoomDependent) {
              fun = function (zoom) {
                  const value = innerFun(parameters, zoom);
                  return typeof value === 'function' ? value(zoom) : value;
              };
              isFeatureConstant = true;
              isZoomConstant = false;
          } else {
              fun = function (zoom, feature) {
                  const value = innerFun(parameters, feature ? feature[parameters.property] : null);
                  return typeof value === 'function' ? value(zoom, feature) : value;
              };
              isFeatureConstant = false;
              isZoomConstant = true;
          }
      }
      fun.isZoomConstant = isZoomConstant;
      fun.isFeatureConstant = isFeatureConstant;
      return fun;
  }

  function coalesce(a, b, c) {
      if (a !== undefined) return a;
      if (b !== undefined) return b;
      return null;
  }

  function evaluateCategoricalFunction(parameters, input) {
      for (let i = 0; i < parameters.stops.length; i++) {
          if (input === parameters.stops[i][0]) {
              return parameters.stops[i][1];
          }
      }
      return parameters.default;
  }

  function evaluateIntervalFunction(parameters, input) {
      for (var i = 0; i < parameters.stops.length; i++) {
          if (input < parameters.stops[i][0]) break;
      }
      return parameters.stops[Math.max(i - 1, 0)][1];
  }

  function evaluateExponentialFunction(parameters, input) {
      var base = parameters.base !== undefined ? parameters.base : 1;

      var i = 0;
      while (true) {
          if (i >= parameters.stops.length) break;
          else if (input <= parameters.stops[i][0]) break;
          else i++;
      }

      if (i === 0) {
          return parameters.stops[i][1];

      } else if (i === parameters.stops.length) {
          return parameters.stops[i - 1][1];

      } else {
          return interpolate$2(
              input,
              base,
              parameters.stops[i - 1][0],
              parameters.stops[i][0],
              parameters.stops[i - 1][1],
              parameters.stops[i][1]
          );
      }
  }
  const COLORIN_OPTIONS = {
      width: 100,
      height: 1
  };
  function evaluateColorInterpolateFunction(parameters, input) {
      const stops = parameters.stops;
      if (stops && stops.length > 1) {
          let colorIn;
          if (colorInCache) {
              const key = JSON.stringify(stops);
              if (!colorInCache.has(key)) {
                  const colorIn = new ColorIn(stops, COLORIN_OPTIONS);
                  colorInCache.set(key, colorIn);
              }
              colorIn = colorInCache.get(key);
          } else {
              colorIn = new ColorIn(stops, COLORIN_OPTIONS);
          }
          const [r, g, b, a] = colorIn.getColor(input);
          return [r / 255, g / 255, b / 255, a / 255];
      } else if (stops && stops.length === 1) {
          return stops[0][1];
      }
      return null;
  }

  function evaluateIdentityFunction(parameters, input) {
      return coalesce(input, parameters.default);
  }

  function interpolate$2(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      if (typeof outputLower === 'function') {
          return function () {
              var evaluatedLower = outputLower.apply(undefined, arguments);
              var evaluatedUpper = outputUpper.apply(undefined, arguments);
              return interpolate$2(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
          };
      } else if (outputLower.length) {
          return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
      } else {
          return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
      }
  }

  function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      var difference = inputUpper - inputLower;
      var progress = input - inputLower;

      var ratio;
      if (base === 1) {
          ratio = progress / difference;
      } else {
          ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
      }

      return (outputLower * (1 - ratio)) + (outputUpper * ratio);
  }

  function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      var output = [];
      for (let i = 0; i < outputLower.length; i++) {
          output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
      }
      return output;
  }

  /**
   * Check if object is a definition of function type
   * @param  {Object}  obj object
   * @return {Boolean}
   * @memberOf MapboxUtil
   */
  function isFunctionDefinition(obj) {
      return obj && typeof obj === 'object' && (obj.stops || obj.property && obj.type === 'identity');
  }

  /**
   * Check if obj's properties has function definition
   * @param  {Object}  obj object to check
   * @return {Boolean}
   * @memberOf MapboxUtil
   */
  function hasFunctionDefinition(obj) {
      for (const p in obj) {
          if (isFunctionDefinition(obj[p])) {
              return true;
          }
      }
      return false;
  }

  function interpolated(parameters) {
      return createFunction1(parameters, 'exponential');
  }

  /**
   * Load function types defined in object
   * @param  {Object[]} parameters parameters
   * @return {Object}   loaded object
   * @memberOf MapboxUtil
   */
  function loadFunctionTypes(obj, argFn) {
      if (!obj) {
          return null;
      }
      var hit = false;
      if (Array.isArray(obj)) {
          var multResult = [],
              loaded;
          for (let i = 0; i < obj.length; i++) {
              loaded = loadFunctionTypes(obj[i], argFn);
              if (!loaded) {
                  multResult.push(obj[i]);
              } else {
                  multResult.push(loaded);
                  hit = true;
              }
          }
          return hit ? multResult : obj;
      }
      var result = { '__fn_types_loaded': true },
          props = [],
          p;
      for (p in obj) {
          if (obj.hasOwnProperty(p)) {
              props.push(p);
          }
      }

      const buildFn = function (p) {
          Object.defineProperty(result, p, {
              get: function () {
                  if (!this['__fn_' + p]) {
                      this['__fn_' + p] = interpolated(this['_' + p]);
                  }
                  return this['__fn_' + p].apply(this, argFn());
              },
              set: function (v) {
                  this['_' + p] = v;
              },
              configurable: true,
              enumerable: true
          });
      };

      for (let i = 0, len = props.length; i < len; i++) {
          p = props[i];
          if (isFunctionDefinition(obj[p])) {
              hit = true;
              result['_' + p] = obj[p];
              buildFn(p);
          } else {
              result[p] = obj[p];
          }
      }
      return hit ? result : obj;
  }

  /**
   * Get external resources in the function type
   * @param  {Object} t Function type definition
   * @return {String[]}   resouces
   * @memberOf MapboxUtil
   */
  function getFunctionTypeResources(t) {
      if (!t || !t.stops) {
          return [];
      }
      const res = [];
      for (let i = 0, l = t.stops.length; i < l; i++) {
          res.push(t.stops[i][1]);
      }
      return res;
  }
  /*eslint-enable no-var, prefer-const*/

  function createFunction1(parameters, defaultType) {
      if (!isFunctionDefinition(parameters)) {
          return function () { return parameters; };
      }
      parameters = JSON.parse(JSON.stringify(parameters));
      let isZoomConstant = true;
      let isFeatureConstant = true;
      const stops = parameters.stops;
      if (stops) {
          for (let i = 0; i < stops.length; i++) {
              if (isFunctionDefinition(stops[i][1])) {
                  const fn = createFunction1(stops[i][1], defaultType);
                  isZoomConstant = isZoomConstant && fn.isZoomConstant;
                  isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;
                  stops[i] = [stops[i][0], fn];
              }
          }
      }
      const fn = createFunction(parameters, defaultType);
      fn.isZoomConstant = isZoomConstant && fn.isZoomConstant;
      fn.isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;
      return fn;
  }

  /*!
      Feature Filter by

      (c) mapbox 2016 and maptalks 2018
      www.mapbox.com | www.maptalks.org
      License: MIT, header required.
  */
  const types$1 = ['Unknown', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];

  function isObject(obj) {
      return typeof obj === 'object' && !!obj;
  }

  /**
   * Given a filter expressed as nested arrays, return a new function
   * that evaluates whether a given feature (with a .properties or .tags property)
   * passes its test.
   *
   * @param {Array} filter mapbox gl filter
   * @returns {Function} filter-evaluating function
   */
  function createFilter(filter) {
      return new Function('f', `var p = (f && f.properties || {}); return ${compile(filter)}`);
  }

  function isFeatureFilter(filter) {
      if (filter === true || filter === false) {
          return true;
      }
      if (!Array.isArray(filter) || filter.length === 0) {
          return false;
      }
      switch (filter[0]) {
      case 'has':
      case '!has':
          return filter.length === 2 && (typeof filter[1] === 'string' || filter[1].property && filter[1].op);
      case 'in':
      case '!in':
          return filter.length >= 2 && (typeof filter[1] === 'string' || filter[1].property && filter[1].op);
      case '==':
      case '!=':
      case '>':
      case '>=':
      case '<':
      case '<=':
          return filter.length === 3 && (typeof filter[1] === 'string' || filter[1].property && filter[1].op);
      case 'none':
      case 'any':
      case 'all':
          for (const f of filter.slice(1)) {
              if (!isFeatureFilter(f) && typeof f !== 'boolean') {
                  return false;
              }
          }
          return true;
      case 'contains':
          return true;
      default:
          return false;
      }
  }

  function compile(filter) {
      if (!filter) return 'true';
      const op = filter[0];
      if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
      const str =
          op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) :
              op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) :
                  op === '<' ||
                      op === '>' ||
                      op === '<=' ||
                      op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) :
                      op === 'any' ? compileLogicalOp(filter.slice(1), '||') :
                          op === 'all' ? compileLogicalOp(filter.slice(1), '&&') :
                              op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) :
                                  op === 'in' ? compileInOp(filter[1], filter.slice(2)) :
                                      op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) :
                                          op === 'has' ? compileHasOp(filter[1]) :
                                              op === '!has' ? compileNegation(compileHasOp(filter[1])) :
                                                  // op === 'test' ? compileRegex(filter[1], filter[2]) :
                                                  op === 'contains' ? compileContains(filter[1], filter[2], filter[3]) :
                                                      'true';
      return `(${str})`;
  }

  function compileFunction(propertyObj, value, op, checkType) {
      const property = propertyObj.property, funName = propertyObj.op;
      let left = compilePropertyReference(property);
      if (funName === 'length') {
          left = `((${left}+='').length)`;
      } else {
          // TODO
          //  other functions
          console.error(`not support ${funName} op`);
          return 'false';
      }
      return getComparisonCode(left, property, value, op, checkType);

  }

  function compileContains(property, str, index) {
      const prop = compilePropertyReference(property);
      if (index !== undefined) {
          return `(${prop} + '').indexOf("${str}") === ${index}`;
      } else {
          return `(${prop} + '').indexOf("${str}") >= 0`;
      }
  }

  // function compileRegex(property, regex) {
  //     const prop = compilePropertyReference(property);
  //     return `new RegExp("${regex}").test(${prop})`;
  // }

  function compilePropertyReference(property) {
      // const ref =
      //     property === '$type' ? 'f.type' :
      //         property === '$id' ? 'f.id' : `p[${JSON.stringify(property)}]`;
      // return ref;
      return property[0] === '$' ? 'f.' + property.substring(1) : 'p[' + JSON.stringify(property) + ']';
  }

  function compileComparisonOp(property, value, op, checkType) {
      if (isObject(property) && property.op) {
          return compileFunction(property, value, op, checkType);
      }
      const left = compilePropertyReference(property);
      return getComparisonCode(left, property, value, op, checkType);
  }

  function getComparisonCode(left, property, value, op, checkType) {
      const right = property === '$type' ? types$1.indexOf(value) : JSON.stringify(value);
      return (checkType ? `typeof ${left}=== typeof ${right}&&` : '') + left + op + right;
  }

  function compileLogicalOp(expressions, op) {
      return expressions.map(compile).join(op);
  }

  function compileInOp(property, values) {
      if (property === '$type') values = values.map((value) => {
          return types$1.indexOf(value);
      });
      const left = JSON.stringify(values.sort(compare));
      const right = compilePropertyReference(property);

      if (values.length <= 200) return `${left}.indexOf(${right}) !== -1`;

      return `function(v, a, i, j) {
        while (i <= j) { var m = (i + j) >> 1;
            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;
        }
    return false; }(${right}, ${left},0,${values.length - 1})`;
  }

  function compileHasOp(property) {
      return property === '$id' ? '"id" in f' : `${JSON.stringify(property)} in p`;
  }

  function compileNegation(expression) {
      return `!(${expression})`;
  }

  // Comparison function to sort numbers and strings
  function compare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  /**
   * Get feature object from a geometry for filter functions.
   * @param  {Geometry} geometry geometry
   * @return {Object}          feature for filter functions
   */
  function getFilterFeature(geometry) {
      const json = geometry._toJSON(),
          g = json['feature'];
      g['type'] = types$1.indexOf(g['geometry']['type']);
      g['subType'] = json['subType'];
      return g;
  }

  /**
   * Compile layer's style, styles to symbolize layer's geometries, e.g.<br>
   * <pre>
   * [
   *   {
   *     'filter' : ['==', 'foo', 'val'],
   *     'symbol' : {'markerFile':'foo.png'}
   *   }
   * ]
   * </pre>
   * @param  {Object|Object[]} styles - style to compile
   * @return {Object[]}       compiled styles
   */
  function compileStyle(styles) {
      if (!Array.isArray(styles)) {
          return compileStyle([styles]);
      }
      const compiled = [];
      for (let i = 0; i < styles.length; i++) {
          let filter;
          if (styles[i]['filter'] === true) {
              filter = function () { return true; };
          } else {
              filter = createFilter(styles[i]['filter']);
          }
          compiled.push(extend$1({}, styles[i], {
              filter: filter
          }));
      }
      return compiled;
  }

  function extend$1(dest) { // (Object[, Object, ...]) ->
      for (let i = 1; i < arguments.length; i++) {
          const src = arguments[i];
          for (const k in src) {
              dest[k] = src[k];
          }
      }
      return dest;
  }

  var arr = [], prop = {};
  function loadGeoSymbol(symbol, geo) {
      return loadFunctionTypes(symbol, function () {
          var map = geo.getMap();
          return set$1(arr, map ? map.getZoom() : 12, extend$2({}, geo.getProperties(), setProp(prop, map && map.getBearing() || 0, map && map.getPitch() || 0, map ? map.getZoom() : 10)));
      });
  }
  function set$1(arr, a0, a1) {
      arr[0] = a0;
      arr[1] = a1;
      return arr;
  }
  function setProp(prop, b, p, z) {
      prop['{bearing}'] = b;
      prop['{pitch}'] = p;
      prop['{zoom}'] = z;
      return prop;
  }

  var index$6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    compileStyle: compileStyle,
    createFilter: createFilter,
    getFilterFeature: getFilterFeature,
    getFunctionTypeResources: getFunctionTypeResources,
    hasFunctionDefinition: hasFunctionDefinition,
    interpolated: interpolated,
    isFeatureFilter: isFeatureFilter,
    isFunctionDefinition: isFunctionDefinition,
    loadFunctionTypes: loadFunctionTypes,
    loadGeoSymbol: loadGeoSymbol
  });

  /* eslint-disable @typescript-eslint/ban-types */
  /**
   * Translate symbol properties to SVG properties
   * @param s - object with symbol properties
   * @return  object with SVG properties
   * @memberOf Util
   */
  function translateToSVGStyles(s) {
      var result = {
          'stroke': {
              'stroke': s['markerLineColor'],
              'stroke-width': s['markerLineWidth'],
              'stroke-opacity': s['markerLineOpacity'],
              'stroke-dasharray': null,
              'stroke-linecap': 'butt',
              'stroke-linejoin': 'round'
          },
          'fill': {
              'fill': s['markerFill'],
              'fill-opacity': s['markerFillOpacity']
          }
      };
      if (result['stroke']['stroke-width'] === 0) {
          result['stroke']['stroke-opacity'] = 0;
      }
      return result;
  }
  /**
   * Get SVG Base64 String from a marker symbol with (markerType : path)
   * @param  symbol - symbol with markerType of path
   * @param  width
   * @param  height
   * @return SVG Base64 String
   * @memberOf Util
   */
  function getMarkerPathBase64(symbol, width, height) {
      if (!symbol['markerPath']) {
          return null;
      }
      var op = 1;
      var styles = translateToSVGStyles(symbol);
      //context.globalAlpha doesn't take effect with drawing SVG in IE9/10/11 and EGDE, so set opacity in SVG element.
      if (isNumber(symbol['markerOpacity'])) {
          op = symbol['markerOpacity'];
      }
      if (isNumber(symbol['opacity'])) {
          op *= symbol['opacity'];
      }
      var svgStyles = {};
      if (styles) {
          for (var p in styles['stroke']) {
              if (styles['stroke'].hasOwnProperty(p)) {
                  if (!isNil(styles['stroke'][p])) {
                      svgStyles[p] = styles['stroke'][p];
                  }
              }
          }
          for (var p in styles['fill']) {
              if (styles['fill'].hasOwnProperty(p)) {
                  if (!isNil(styles['fill'][p])) {
                      svgStyles[p] = styles['fill'][p];
                  }
              }
          }
      }
      var pathes;
      var markerPath = symbol.markerPath;
      if (isString(markerPath) && markerPath[0] === '$') {
          pathes = ResourceProxy.getResource(markerPath.substring(1, Infinity)) || [];
      }
      else {
          pathes = Array.isArray(symbol['markerPath']) ? symbol['markerPath'] : [symbol['markerPath']];
      }
      var path;
      var pathesToRender = [];
      for (var i = 0; i < pathes.length; i++) {
          path = isString(pathes[i]) ? {
              'path': pathes[i]
          } : pathes[i];
          path = extend$2({}, path, svgStyles);
          path['d'] = path['path'];
          delete path['path'];
          pathesToRender.push(path);
      }
      var svg = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];
      if (op < 1) {
          svg.push('opacity="' + op + '"');
      }
      // if (symbol['markerWidth'] && symbol['markerHeight']) {
      //     svg.push('height="' + symbol['markerHeight'] + '" width="' + symbol['markerWidth'] + '"');
      // }
      if (symbol['markerPathWidth'] && symbol['markerPathHeight']) {
          svg.push('viewBox="0 0 ' + symbol['markerPathWidth'] + ' ' + symbol['markerPathHeight'] + '"');
      }
      svg.push('preserveAspectRatio="none"');
      if (width) {
          svg.push('width="' + width + '"');
      }
      if (height) {
          svg.push('height="' + height + '"');
      }
      svg.push('><defs></defs>');
      for (var i = 0; i < pathesToRender.length; i++) {
          //非path节点的直接 out dom html,such: circle rect,polygon,polyline etc
          if (pathesToRender[i].d instanceof Element) {
              svg.push(pathesToRender[i].d.outerHTML);
              continue;
          }
          var strPath = '<path ';
          for (var p in pathesToRender[i]) {
              if (pathesToRender[i].hasOwnProperty(p)) {
                  strPath += ' ' + p + '="' + pathesToRender[i][p] + '"';
              }
          }
          strPath += '></path>';
          svg.push(strPath);
      }
      svg.push('</svg>');
      var b64 = 'data:image/svg+xml;base64,' + btoa(svg.join(' '));
      return b64;
  }
  /**
   * Get external resources from the given symbol
   * @param symbol     - symbol
   * @param toAbsolute - whether convert url to aboslute
   * @return resource urls
   * @memberOf Util
   */
  function getExternalResources(symbol, toAbsolute) {
      if (!symbol) {
          return [];
      }
      var symbols = symbol;
      if (!Array.isArray(symbol)) {
          symbols = [symbol];
      }
      var resources = [];
      var props = RESOURCE_PROPERTIES;
      var res, resSizeProp;
      var w, h;
      for (var i = symbols.length - 1; i >= 0; i--) {
          symbol = symbols[i];
          if (!symbol) {
              continue;
          }
          if (toAbsolute) {
              symbol = convertResourceUrl(symbol);
          }
          for (var ii = 0; ii < props.length; ii++) {
              res = symbol[props[ii]];
              if (isFunctionDefinition(res)) {
                  res = getFunctionTypeResources(res);
              }
              if (!res) {
                  continue;
              }
              if (!Array.isArray(res)) {
                  res = [res];
              }
              for (var iii = 0; iii < res.length; iii++) {
                  if (res[iii].slice(0, 4) === 'url(') {
                      res[iii] = extractCssUrl(res[iii]);
                  }
                  resSizeProp = RESOURCE_SIZE_PROPERTIES[ii];
                  resources.push([res[iii], symbol[resSizeProp[0]], symbol[resSizeProp[1]]]);
              }
          }
          if (symbol['markerType'] === 'path' && symbol['markerPath']) {
              w = isFunctionDefinition(symbol['markerWidth']) ? 200 : symbol['markerWidth'];
              h = isFunctionDefinition(symbol['markerHeight']) ? 200 : symbol['markerHeight'];
              if (isFunctionDefinition(symbol['markerPath'])) {
                  res = getFunctionTypeResources(symbol['markerPath']);
                  var path = symbol['markerPath'];
                  for (var iii = 0; iii < res.length; iii++) {
                      symbol['markerPath'] = res[iii];
                      resources.push([getMarkerPathBase64(symbol), w, h]);
                  }
                  symbol['markerPath'] = path;
              }
              else {
                  resources.push([getMarkerPathBase64(symbol), w, h]);
              }
          }
      }
      return resources;
  }
  /**
   * Convert symbol's resources' urls from relative path to an absolute path.
   * @param symbol
   * @private
   * @memberOf Util
   */
  function convertResourceUrl(symbol) {
      if (!symbol) {
          return null;
      }
      var s = symbol;
      if (IS_NODE) {
          return s;
      }
      var props = RESOURCE_PROPERTIES;
      var res;
      for (var ii = 0, len = props.length; ii < len; ii++) {
          res = s[props[ii]];
          if (!res) {
              continue;
          }
          s[props[ii]] = _convertUrl(res);
      }
      return s;
  }
  function _convertUrl(res) {
      if (isFunctionDefinition(res) && res.stops) {
          var stops = res.stops;
          for (var i = 0; i < stops.length; i++) {
              stops[i][1] = _convertUrl(stops[i][1]);
          }
          return res;
      }
      if (res.slice(0, 4) === 'url(') {
          res = extractCssUrl(res);
      }
      return res;
  }
  function isImageBitMap(img) {
      return img && Browser$1.decodeImageInWorker && img instanceof ImageBitmap;
  }

  /* eslint-disable @typescript-eslint/ban-types */
  /**
   * Whether the color is a gradient
   * @param g - color to test
   * @return
   * @memberOf Util
   */
  function isGradient(g) {
      return g && g['colorStops'];
  }
  /**
   * Get stamp of a gradient color object.
   * @param g gradient color object
   * @return gradient stamp
   * @memberOf Util
   */
  function getGradientStamp(g) {
      var keys = [g['type']];
      if (g['places']) {
          keys.push(g['places'].join());
      }
      if (g['colorStops']) {
          var stops = [];
          for (var i = g['colorStops'].length - 1; i >= 0; i--) {
              stops.push(g['colorStops'][i].join());
          }
          keys.push(stops.join(','));
      }
      return keys.join('_');
  }
  // back-compatibility alias
  function getSymbolStamp(symbol, prefix) {
      return getSymbolHash(symbol, prefix);
  }
  /**
   * Get stamp of a symbol
   * @param symbol symbol
   * @return symbol's stamp
   * @memberOf Util
   */
  function getSymbolHash(symbol, prefix) {
      if (!symbol) {
          return 1;
      }
      var keys = [];
      if (Array.isArray(symbol)) {
          for (var i = 0; i < symbol.length; i++) {
              keys.push(getSymbolHash(symbol[i], prefix));
          }
          return keys.sort().join(',');
      }
      var sortedKeys = Object.keys(symbol).sort();
      var sortedSymbol = sortedKeys.reduce(function (accumulator, curValue) {
          if (!prefix || curValue.indexOf(prefix) === 0) {
              accumulator[curValue] = symbol[curValue];
          }
          return accumulator;
      }, {});
      var hash = hashCode(JSON.stringify(sortedSymbol));
      return hash;
  }
  /**
   * Reduce opacity of the color by ratio
   * @param symbol symbols to set
   * @param ratio  ratio of opacity to reduce
   * @return new symbol or symbols
   * @memberOf Util
   */
  function lowerSymbolOpacity(symbol, ratio) {
      function s(_symbol, _ratio) {
          var op = _symbol['opacity'];
          if (isNil(op)) {
              _symbol['opacity'] = _ratio;
          }
          else {
              _symbol['opacity'] *= _ratio;
          }
      }
      var lower;
      if (Array.isArray(symbol)) {
          lower = [];
          for (var i = 0; i < symbol.length; i++) {
              var d = extend$2({}, symbol[i]);
              s(d, ratio);
              lower.push(d);
          }
      }
      else {
          lower = extend$2({}, symbol);
          s(lower, ratio);
      }
      return lower;
  }
  /**
   * Merges the properties of sources into the symbol. <br>
   * @param args - sources
   * @return merged symbol
   * @memberOf Util
   */
  function extendSymbol() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var symbol = args[0];
      var sources = Array.prototype.slice.call(args, 1);
      if (!sources || !sources.length) {
          sources = [{}];
      }
      if (Array.isArray(symbol)) {
          var s = void 0, dest = void 0;
          var result = [];
          for (var i = 0, l = symbol.length; i < l; i++) {
              s = symbol[i];
              dest = {};
              for (var ii = 0, ll = sources.length; ii < ll; ii++) {
                  if (!Array.isArray(sources[ii])) {
                      extend$2(dest, s, sources[ii] ? sources[ii] : {});
                  }
                  else if (!isNil(sources[ii][i])) {
                      extend$2(dest, s, sources[ii][i]);
                  }
                  else {
                      extend$2(dest, s ? s : {});
                  }
              }
              result.push(dest);
          }
          return result;
      }
      else {
          var args_1 = [{}, symbol];
          // eslint-disable-next-line prefer-spread
          args_1.push.apply(args_1, sources);
          return extend$2.apply(this, args_1);
      }
  }
  function parseStyleRootPath(style) {
      if (style.symbol) {
          style = [style];
      }
      if (Array.isArray(style)) {
          return style;
      }
      var root = style['$root'];
      var iconset = style['$iconset'];
      style = style.style;
      if (root || iconset) {
          if (root && root[root.length - 1] === '/') {
              root = root.substring(0, root.length - 1);
          }
          if (iconset && iconset[iconset.length - 1] === '/') {
              iconset = iconset.substring(0, iconset.length - 1);
          }
          var replacer = function replacer(match) {
              if (match === '{$root}') {
                  return root;
              }
              else if (match === '{$iconset}') {
                  return iconset;
              }
              return null;
          };
          convertStylePath(style, replacer);
      }
      return style;
  }
  function convertStylePath(styles, replacer) {
      for (var i = 0; i < styles.length; i++) {
          var symbol = styles[i].symbol;
          if (symbol) {
              parseSymbolPath(symbol, replacer);
          }
      }
  }
  var URL_PATTERN$1 = /(\{\$root\}|\{\$iconset\})/g;
  function parseSymbolPath(symbol, replacer) {
      for (var p in symbol) {
          if (symbol.hasOwnProperty(p) && p !== 'textName') {
              if (isString(symbol[p]) && symbol[p].length > 2) {
                  symbol[p] = symbol[p].replace(URL_PATTERN$1, replacer);
              }
              else if (isFunctionDefinition(symbol[p])) {
                  symbol[p] = parseStops(symbol[p], replacer);
              }
              else if (isObject$1(symbol[p])) {
                  parseSymbolPath(symbol[p], replacer);
              }
          }
      }
  }
  function parseStops(value, replacer) {
      var defaultValue = value['default'];
      if (isString(defaultValue)) {
          value['default'] = defaultValue.replace(URL_PATTERN$1, replacer);
      }
      var stops = value.stops;
      if (!stops) {
          return value;
      }
      for (var i = 0; i < stops.length; i++) {
          if (!Array.isArray(stops[i])) {
              continue;
          }
          if (isString(stops[i][1])) {
              stops[i][1] = stops[i][1].replace(URL_PATTERN$1, replacer);
          }
          else if (isFunctionDefinition(stops[i][1])) {
              stops[i][1] = parseStops(stops[i][1], replacer);
          }
      }
      return value;
  }
  /**
   * geometry symbol has lineDasharray
   * @memberOf Util
   */
  function isDashLine(symbolizers) {
      if (symbolizers === void 0) { symbolizers = []; }
      if (!Array.isArray(symbolizers)) {
          symbolizers = [symbolizers];
      }
      var len = symbolizers.length;
      for (var i = 0; i < len; i++) {
          var symbolizer = symbolizers[i];
          if (!symbolizer.style) {
              continue;
          }
          var _a = symbolizer.style, lineDasharray = _a.lineDasharray, lineWidth = _a.lineWidth;
          if (lineWidth && isNumber(lineWidth) && lineWidth > 0 && lineDasharray && Array.isArray(lineDasharray) && lineDasharray.length) {
              return true;
          }
      }
      return false;
  }

  /*eslint-disable no-var*/
  // Contains code from glmatrix.js
  function perspective(out, fovy, aspect, near, far) {
      var f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = 2 * far * near * nf;
      out[15] = 0;
      return out;
  }
  function translate(out, a, v) {
      var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
      if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      }
      else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }
      return out;
  }
  function scale$1(out, a, v) {
      var x = v[0], y = v[1], z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
  }
  function rotateX(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
      if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
      }
      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
  }
  function rotateZ(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
      if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
      }
      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
  }
  /* export function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
  } */
  function multiply(out, a, b) {
      var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
      // Cache only the current line of the second matrix
      var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
  }
  function invert(out, a) {
      var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, 
      // Calculate the determinant
      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
          return null;
      }
      det = 1.0 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
  }
  /**
   * Set a mat4 to the identity matrix
   * @ignore
   * @param out the receiving matrix
   * @returns out
   */
  function identity$1(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
  }
  /**
   * Copy the values from one mat4 to another
   * @ignore
   * @param out the receiving matrix
   * @param a the source matrix
   * @returns out
   */
  function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
  }
  /*eslint-enable no-var*/

  var index$5 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DEFAULT_FONT: DEFAULT_FONT,
    DEFAULT_TEXTSIZE: DEFAULT_TEXTSIZE,
    EMPTY_STRING: EMPTY_STRING$1,
    GUID: GUID,
    IS_NODE: IS_NODE,
    UID: UID,
    _defaults: _defaults,
    b64toBlob: b64toBlob,
    btoa: btoa,
    calCanvasSize: calCanvasSize,
    get cancelAnimFrame () { return cancelAnimFrame; },
    clamp: clamp,
    computeDegree: computeDegree,
    convertResourceUrl: convertResourceUrl,
    convertStylePath: convertStylePath,
    copy: copy,
    describeText: describeText,
    emptyImageUrl: emptyImageUrl,
    equalMapView: equalMapView,
    escapeSpecialChars: escapeSpecialChars,
    extend: extend$2,
    extendSymbol: extendSymbol,
    extractCssUrl: extractCssUrl,
    flash: flash,
    forEachCoord: forEachCoord,
    getAbsoluteURL: getAbsoluteURL,
    getAlignPoint: getAlignPoint,
    getExternalResources: getExternalResources,
    getFont: getFont,
    getGlobalThis: getGlobalThis,
    getGradientStamp: getGradientStamp,
    getImageBitMap: getImageBitMap,
    getMarkerPathBase64: getMarkerPathBase64,
    getPointsResultPts: getPointsResultPts,
    getSymbolHash: getSymbolHash,
    getSymbolStamp: getSymbolStamp,
    getValueOrDefault: getValueOrDefault,
    hasOwn: hasOwn,
    hashCode: hashCode,
    identity: identity$1,
    interpolate: interpolate$3,
    invert: invert,
    isArrayHasData: isArrayHasData,
    isCssUrl: isCssUrl,
    isDashLine: isDashLine,
    isEmpty: isEmpty,
    isFunction: isFunction,
    isGradient: isGradient,
    isImageBitMap: isImageBitMap,
    isInteger: isInteger,
    isNil: isNil,
    isNumber: isNumber,
    isObject: isObject$1,
    isSVG: isSVG,
    isString: isString,
    isURL: isURL,
    join: join,
    loadImage: loadImage,
    log2: log2,
    lowerSymbolOpacity: lowerSymbolOpacity,
    multiply: multiply,
    now: now,
    parseJSON: parseJSON,
    parseStyleRootPath: parseStyleRootPath,
    parseSymbolPath: parseSymbolPath,
    perspective: perspective,
    pushIn: pushIn,
    removeFromArray: removeFromArray,
    replaceAll: replaceAll,
    replaceVariable: replaceVariable,
    get requestAnimFrame () { return requestAnimFrame; },
    rotateX: rotateX,
    rotateZ: rotateZ,
    scale: scale$1,
    sign: sign,
    splitContent: splitContent,
    splitTextToRow: splitTextToRow,
    splitWords: splitWords,
    stringLength: stringLength,
    stringWidth: stringWidth,
    toDegree: toDegree,
    toRadian: toRadian,
    translate: translate,
    translateToSVGStyles: translateToSVGStyles,
    trim: trim,
    wrap: wrap
  });

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var lineclip_1 = lineclip;

  lineclip.polyline = lineclip;
  lineclip.polygon = polygonclip;


  // Cohen-Sutherland line clippign algorithm, adapted to efficiently
  // handle polylines rather than just segments

  function lineclip(points, bbox, result) {

      var len = points.length,
          codeA = bitCode(points[0], bbox),
          part = [],
          i, a, b, codeB, lastCode;

      if (!result) result = [];

      for (i = 1; i < len; i++) {
          a = points[i - 1];
          b = points[i];
          codeB = lastCode = bitCode(b, bbox);

          while (true) {

              if (!(codeA | codeB)) { // accept
                  part.push(a);

                  if (codeB !== lastCode) { // segment went outside
                      part.push(b);

                      if (i < len - 1) { // start a new line
                          result.push(part);
                          part = [];
                      }
                  } else if (i === len - 1) {
                      part.push(b);
                  }
                  break;

              } else if (codeA & codeB) { // trivial reject
                  break;

              } else if (codeA) { // a outside, intersect with clip edge
                  a = intersect(a, b, codeA, bbox);
                  codeA = bitCode(a, bbox);

              } else { // b outside
                  b = intersect(a, b, codeB, bbox);
                  codeB = bitCode(b, bbox);
              }
          }

          codeA = lastCode;
      }

      if (part.length) result.push(part);

      return result;
  }

  // Sutherland-Hodgeman polygon clipping algorithm

  function polygonclip(points, bbox) {

      var result, edge, prev, prevInside, i, p, inside;

      // clip against each side of the clip rectangle
      for (edge = 1; edge <= 8; edge *= 2) {
          result = [];
          prev = points[points.length - 1];
          prevInside = !(bitCode(prev, bbox) & edge);

          for (i = 0; i < points.length; i++) {
              p = points[i];
              inside = !(bitCode(p, bbox) & edge);

              // if segment goes through the clip window, add an intersection
              if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

              if (inside) result.push(p); // add a point if it's inside

              prev = p;
              prevInside = inside;
          }

          points = result;

          if (!points.length) break;
      }

      return result;
  }

  // intersect a segment against one of the 4 lines that make up the bbox

  function intersect(a, b, edge, bbox) {
      return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
             edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
             edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
             edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
             null;
  }

  // bit code reflects the point position relative to the bbox:

  //         left  mid  right
  //    top  1001  1000  1010
  //    mid  0001  0000  0010
  // bottom  0101  0100  0110

  function bitCode(p, bbox) {
      var code = 0;

      if (p[0] < bbox[0]) code |= 1; // left
      else if (p[0] > bbox[2]) code |= 2; // right

      if (p[1] < bbox[1]) code |= 4; // bottom
      else if (p[1] > bbox[3]) code |= 8; // top

      return code;
  }

  var lineclip$1 = /*@__PURE__*/getDefaultExportFromCjs(lineclip_1);

  var minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
  function getDefaultBBOX() {
      return [minx, miny, maxx, maxy];
  }
  var BBOX_TEMP = getDefaultBBOX();
  /**
   * 重置bbox
   *
   * @english
   * reset bbox
   * @param bbox
   */
  function resetBBOX(bbox) {
      bbox[0] = minx;
      bbox[1] = miny;
      bbox[2] = maxx;
      bbox[3] = maxy;
  }
  function pointsBBOX(points, out) {
      if (!points) {
          return;
      }
      if (Array.isArray(points[0])) {
          for (var i = 0, len = points.length; i < len; i++) {
              pointsBBOX(points[i], out);
          }
      }
      else if (Array.isArray(points)) {
          for (var i = 0, len = points.length; i < len; i++) {
              var _a = points[i], x = _a.x, y = _a.y;
              out[0] = Math.min(x, out[0]);
              out[1] = Math.min(y, out[1]);
              out[2] = Math.max(x, out[2]);
              out[3] = Math.max(y, out[3]);
          }
      }
      else {
          var x = points.x, y = points.y;
          out[0] = Math.min(x, out[0]);
          out[1] = Math.min(y, out[1]);
          out[2] = Math.max(x, out[2]);
          out[3] = Math.max(y, out[3]);
      }
  }
  function setBBOX(bbox, x1, y1, x2, y2) {
      if (x1 !== 0 && !x1) {
          return;
      }
      //x1 is bbox array
      if (Array.isArray(x1)) {
          y1 = x1[1];
          x2 = x1[2];
          y2 = x1[3];
          x1 = x1[0];
      }
      bbox[0] = Math.min(x1, bbox[0]);
      bbox[1] = Math.min(y1, bbox[1]);
      bbox[2] = Math.max(x2, bbox[2]);
      bbox[3] = Math.max(y2, bbox[3]);
  }
  function validateBBOX(bbox) {
      return bbox && bbox[0] !== Infinity && bbox[0] !== undefined;
  }
  function bufferBBOX(bbox, bufferSize) {
      if (bufferSize === void 0) { bufferSize = 0; }
      bbox[0] -= bufferSize;
      bbox[1] -= bufferSize;
      bbox[2] += bufferSize;
      bbox[3] += bufferSize;
  }
  function bboxIntersect(bbox1, bbox2) {
      if (bbox1[2] < bbox2[0]) {
          return false;
      }
      if (bbox1[1] > bbox2[3]) {
          return false;
      }
      if (bbox1[0] > bbox2[2]) {
          return false;
      }
      if (bbox1[3] < bbox2[1]) {
          return false;
      }
      return true;
  }
  function bboxInBBOX(bbox1, bbox2) {
      var _a = __read(bbox1, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
      return x1 >= bbox2[0] && x2 <= bbox2[2] && y1 >= bbox2[1] && y2 <= bbox2[3];
  }
  /**
   * bbox Intersect Mask
   * apply on TileLayer,VectorTileLayer,Geo3DTileLayer Layers
   * @param bbox
   * @param maskGeoJSON(Polygon/MultiPolygon GeoJSON)
   * @returns
   */
  function bboxInMask(bbox, maskGeoJSON) {
      //geojson bbox
      var maskBBOX = maskGeoJSON.bbox;
      if (!maskBBOX) {
          console.error('maskGeoJSON bbox is null:', maskGeoJSON);
          return false;
      }
      if (!bboxIntersect(maskBBOX, bbox)) {
          return false;
      }
      else {
          var geometry = maskGeoJSON.geometry;
          if (!geometry) {
              console.error('maskGeoJSON is error,not find geometry.', maskGeoJSON);
              return false;
          }
          var coordinates = geometry.coordinates;
          var type = geometry.type;
          if (type === 'Polygon') {
              coordinates = [coordinates];
          }
          for (var i = 0, len = coordinates.length; i < len; i++) {
              var rings = coordinates[i];
              var outRing = rings[0];
              var result = lineclip$1.polygon(outRing, bbox);
              if (result.length > 0) {
                  var minx_1 = Infinity, maxx_1 = -Infinity, miny_1 = Infinity, maxy_1 = -Infinity;
                  for (var j = 0, len1 = result.length; j < len1; j++) {
                      var _a = __read(result[j], 2), x = _a[0], y = _a[1];
                      minx_1 = Math.min(x, minx_1);
                      miny_1 = Math.min(y, miny_1);
                      maxx_1 = Math.max(x, maxx_1);
                      maxy_1 = Math.max(y, maxy_1);
                  }
                  if (minx_1 !== maxx_1 && miny_1 !== maxy_1) {
                      return true;
                  }
              }
          }
          return false;
      }
  }

  var bbox = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BBOX_TEMP: BBOX_TEMP,
    bboxInBBOX: bboxInBBOX,
    bboxInMask: bboxInMask,
    bboxIntersect: bboxIntersect,
    bufferBBOX: bufferBBOX,
    getDefaultBBOX: getDefaultBBOX,
    pointsBBOX: pointsBBOX,
    resetBBOX: resetBBOX,
    setBBOX: setBBOX,
    validateBBOX: validateBBOX
  });

  var imageFetchWorkerKey = 'core-fetch-image';
  var globalWorkerPool$1;
  function setWorkerPool(pool) {
      globalWorkerPool$1 = pool;
  }
  function getWorkerPool() {
      return globalWorkerPool$1;
  }
  var workersCreated = false;
  function setWorkersCreated() {
      workersCreated = true;
  }
  function workersHasCreated() {
      return workersCreated;
  }
  var ADAPTER_CREATED_LIST = [];
  function adapterHasCreated(workerKey) {
      return ADAPTER_CREATED_LIST.indexOf(workerKey) > -1;
  }
  function pushAdapterCreated(workerKey) {
      if (!adapterHasCreated(workerKey)) {
          ADAPTER_CREATED_LIST.push(workerKey);
      }
  }

  /* eslint-disable @typescript-eslint/ban-types */
  var adapters = {};
  /**
   * Register a worker adapter
   * @param {String} workerKey  - an unique key name of the worker adapter
   * @param {Function} adapter  - the worker adapter function, it must be a complete packaged function with no dependency of other functions
   * @example
   * maptalks.registerWorkerAdapter('foo', function (exports, global) {
          //will be called only for once when loaded in worker thread
          exports.initialize = function () {
            console.log('[worker] initialized');
          };
          //to receive message from main thread sent by maptalks.worker.Actor
          exports.onmessage = function (message, postResponse) {
            const data = message.data;
            console.log(`[worker] received data : ` + data);
            //send message back to main thread
            //the parameters:
            //error, data, buffers (arraybuffers in data)
            postResponse(null, 'message from worker thread', null);
          };
       });
      @global
      @static
   */
  function registerWorkerAdapter(workerKey, adapter) {
      adapters[workerKey] = adapter;
  }
  var header = "\n    var adapters = {};\n    // Dynamic Create Adapter\n    function createAdapter(key,code){\n        if(adapters[key]||!code){\n            return;\n        }\n        var func=new Function('exports',code+'(exports)');\n        var workerExports={};\n        func(workerExports,self);\n        adapters[key]=workerExports;\n        workerExports.initialize && workerExports.initialize(self);\n\n    }\n    onmessage = function (msg) {\n        msg = msg.data;\n        //createAdapter\n        if (msg.messageType === 'createAdapter') {\n           var key=msg.key;\n           var code=msg.code;\n           createAdapter(key,code);\n           postMessage({adapterName:key});\n           return;\n        }\n        // postMessage when main thread idle\n        if(msg.messageType==='idle'){\n            var messageRatio = msg.messageRatio;\n            handleMessageQueue(messageRatio);\n            return;\n        }\n        if (msg.messageType === 'batch') {\n            const messages = msg.messages;\n            if (messages) {\n                for (let i = 0; i < messages.length; i++) {\n                    dispatch(messages[i]);\n                }\n            }\n        } else {\n            dispatch(msg);\n        }\n    };\n\n    function dispatch(msg) {\n        var workerKey = msg.workerKey;\n        var adapter = adapters[workerKey];\n        if (!adapter) {\n            post(msg.callback, 'Unregistered worker adapters for ' + workerKey);\n            return;\n        }\n        try {\n            adapter.onmessage(msg, wrap(msg.callback));\n        } catch (err) {\n            post(msg.callback, workerKey + ':' + err.message);\n            console.error(err);\n            throw err;\n        }\n    }\n\n    var messageResultQueue = [];\n\n    function handleMessageQueue(messageRatio){\n       if(messageResultQueue.length===0){\n          return;\n       }\n       var count = Math.ceil((messageRatio || 1) * messageResultQueue.length);\n       var queues = messageResultQueue.slice(0, count);\n       queues.forEach(function(queue){\n          post(queue.callback,queue.err,queue.data,queue.buffers);\n       });\n       messageResultQueue=messageResultQueue.slice(count, Infinity);\n    }\n\n    function post(callback, err, data, buffers) {\n        var msg = {\n            callback : callback\n        };\n        if (err) {\n            msg.error = err;\n        } else {\n            msg.data = data;\n        }\n        if (buffers && buffers.length > 0) {\n            postMessage(msg, buffers);\n        } else {\n            postMessage(msg);\n        }\n    }\n\n    function joinQueue(callback,err,data,buffers){\n        messageResultQueue.push({\n            callback:callback,\n            err:err,\n            data:data,\n            buffers:buffers\n        });\n    }\n\n    function wrap(callback) {\n        return function (err, data, buffers) {\n            joinQueue(callback, err, data, buffers);\n        };\n    }\n    var workerExports;\n";
  var footer = "\n    workerExports = null;\n";
  function compileWorkerSource() {
      var source = header;
      for (var p in adapters) {
          var adapter = adapters[p];
          pushAdapterCreated(p);
          if (isFunction(adapter)) {
              if (adapter.length === 0) {
                  // new definition form of worker source
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-expect-error
                  adapter = adapter();
              }
          }
          source += "\n    workerExports = {};\n    (".concat(adapter, ")(workerExports, self);\n    adapters['").concat(p, "'] = workerExports");
          source += "\n    workerExports.initialize && workerExports.initialize(self);\n        ";
      }
      source += footer;
      return source;
  }
  var url;
  function getWorkerSourcePath() {
      if (typeof window === 'undefined') {
          return null;
      }
      if (!url) {
          var source = compileWorkerSource();
          url = window.URL.createObjectURL(new Blob([source], { type: 'text/javascript' }));
          //clear cached worker adapters
          adapters = {};
      }
      return url;
  }
  // Dynamic Create Adapter
  //利用worker通信向每个workerPool里的每个worker注入新的code
  //注意注入的代码在worker code里不是明文的，是个匿名函数挂到adapters,代码层面是看不到改段代码的
  function createAdapter(key, cb) {
      if (!adapters[key]) {
          console.error("not find ".concat(key, " adapter"));
          return;
      }
      var adapter = adapters[key];
      if (isFunction(adapter)) {
          if (adapter.length === 0) {
              // new definition form of worker source
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              adapter = adapter();
          }
      }
      adapter = "(".concat(adapter, ")");
      var workerPool = getWorkerPool();
      if (!workerPool) {
          return;
      }
      var workers = workerPool.workers || [];
      if (workers.length === 0) {
          console.error('workerpool workers count is 0');
      }
      var count = 0;
      var messageCB = function (msg) {
          msg = msg.data || {};
          if (msg.adapterName === key) {
              count++;
              if (count === workers.length) {
                  workers.forEach(function (worker) {
                      worker.removeEventListener('message', messageCB);
                  });
                  delete adapters[key];
                  cb();
              }
          }
      };
      workers.forEach(function (worker) {
          worker.addEventListener('message', messageCB);
          worker.postMessage({ key: key, code: adapter, messageType: 'createAdapter' });
      });
  }

  // import { requestAnimFrame } from '../util';
  var hardwareConcurrency = typeof window !== 'undefined' ? (window.navigator.hardwareConcurrency || 4) : 0;
  var hardwareWorkerCount = Math.max(Math.floor(hardwareConcurrency / 2), 1);
  var MessageBatch = /** @class */ (function () {
      function MessageBatch(limit) {
          if (limit === void 0) { limit = 50; }
          this._limit = limit;
          this._messages = [];
          this.buffers = [];
      }
      MessageBatch.prototype.addMessage = function (msg, buffers) {
          this._messages.push(msg);
          if (!Array.isArray(buffers)) {
              return;
          }
          for (var i = 0; i < buffers.length; i++) {
              if (this.buffers.indexOf(buffers[i]) < 0) {
                  this.buffers.push(buffers[i]);
              }
          }
      };
      MessageBatch.prototype.isFull = function () {
          return this._messages.length >= this._limit;
      };
      MessageBatch.prototype.getMessage = function () {
          return { messageType: 'batch', messages: this._messages };
      };
      return MessageBatch;
  }());
  /**
   * Worker Pool
   * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)
   * @private
   */
  var WorkerPool = /** @class */ (function () {
      function WorkerPool() {
          this.active = {};
          this.workerCount = typeof window !== 'undefined' ? (GlobalConfig.workerCount || hardwareWorkerCount) : 0;
          this._messages = [];
          this._messageBuffers = [];
      }
      WorkerPool.prototype.acquire = function (id) {
          if (!this.workers) {
              this.workers = [];
              var url = getWorkerSourcePath();
              for (var i = 0; i < this.workerCount; i++) {
                  var worker = new Worker(url);
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-expect-error
                  worker.id = i;
                  this.workers.push(worker);
              }
              URL.revokeObjectURL(url);
              setWorkersCreated();
          }
          this.active[id] = true;
          return this.workers.slice();
      };
      WorkerPool.prototype.release = function (id) {
          delete this.active[id];
          if (Object.keys(this.active).length === 0) {
              this.workers.forEach(function (w) {
                  w.terminate();
              });
              this.workers = null;
          }
      };
      WorkerPool.prototype.addMessage = function (workerId, data, buffers) {
          var batches = this._messages[workerId];
          if (!batches || !batches.length) {
              batches = this._messages[workerId] = [new MessageBatch()];
          }
          var batch = batches[batches.length - 1];
          if (batch.isFull()) {
              batch = new MessageBatch();
              this._messages[workerId].push(batch);
          }
          batch.addMessage(data, buffers);
      };
      WorkerPool.prototype.commit = function () {
          if (!this.workers) {
              return;
          }
          if (this._messages.length) {
              for (var i = 0; i < this._messages.length; i++) {
                  if (!this._messages[i] || !this._messages[i].length) {
                      continue;
                  }
                  var batch = this._messages[i].shift();
                  this.workers[i].postMessage(batch.getMessage(), batch.buffers);
              }
          }
      };
      WorkerPool.prototype.getWorkers = function () {
          return this.workers || [];
      };
      WorkerPool.prototype.broadcastIdleMessage = function (messageRatio) {
          var workers = this.getWorkers();
          workers.forEach(function (worker) {
              worker.postMessage({ messageType: 'idle', messageRatio: messageRatio });
          });
          return this;
      };
      return WorkerPool;
  }());
  var globalWorkerPool;
  function getGlobalWorkerPool() {
      if (!globalWorkerPool) {
          globalWorkerPool = new WorkerPool();
          setWorkerPool(globalWorkerPool);
      }
      return globalWorkerPool;
  }
  // function frameLoop() {
  //     getGlobalWorkerPool().commit();
  //     requestAnimFrame(frameLoop);
  // }
  // if (requestAnimFrame) {
  //     requestAnimFrame(frameLoop);
  // }

  var tasks = [];
  var loopHooks = [];
  /**
   *
   * @param {Object|Function} task  - a micro task(Promise)
   * @param {Number} task.count - task run count
   * @param {Function} task.run - task run function
   * @return {Promise}
   * @example
   * const run =()=>{
   * //do some things
   * };
   * runTaskAsync({count:4,run}).then(result=>{})
   * runTaskAsync(run).then(result=>{})
   */
  function runTaskAsync(task) {
      startTasks();
      var promise = new Promise(function (resolve, reject) {
          if (!task) {
              reject(new Error('task is null'));
              return;
          }
          if (isFunction(task)) {
              task = { count: 1, run: task };
          }
          if (!task.run) {
              reject(new Error('task.run is null'));
              return;
          }
          if (isNil(task.count)) {
              task.count = 1;
          }
          task.count = Math.ceil(task.count);
          if (!isNumber(task.count)) {
              reject(new Error('task.count is not number'));
              return;
          }
          var taskItem = task;
          taskItem.results = [];
          tasks.push(taskItem);
          taskItem.resolve = resolve;
      });
      return promise;
  }
  function executeMicroTasks() {
      if (tasks.length === 0) {
          return;
      }
      var runingTasks = [], endTasks = [];
      var len = tasks.length;
      for (var i = 0; i < len; i++) {
          var task = tasks[i];
          task.count--;
          if (task.count === -1) {
              endTasks.push(task);
          }
          else {
              runingTasks.push(task);
              var result = task.run();
              task.results.push(result);
          }
      }
      tasks = runingTasks;
      len = endTasks.length;
      for (var i = 0; i < len; i++) {
          var task = endTasks[i];
          if (task.resolve) {
              task.resolve(task.results);
          }
      }
  }
  function loop(isBusy) {
      var messageRatio = GlobalConfig.messagePostRatioPerWorker * (isBusy ? 0.5 : 1);
      getGlobalWorkerPool().commit();
      getGlobalWorkerPool().broadcastIdleMessage(messageRatio);
      executeMicroTasks();
      loopHooks.forEach(function (func) {
          func();
      });
  }
  var idleCallTime = now();
  function idleFrameLoop() {
      loop();
      idleCallTime = now();
      requestIdleCallback(idleFrameLoop);
  }
  function animFrameLoop() {
      if (Browser$1.requestIdleCallback) {
          var idleForceTimeThreshold = GlobalConfig.idleForceTimeThreshold, idleLog = GlobalConfig.idleLog;
          var time = now();
          if (time - idleCallTime > idleForceTimeThreshold) {
              loop(true);
              idleCallTime = now();
              if (idleLog) {
                  console.warn("did not apply for availability, forced run idle");
              }
          }
      }
      else {
          loop();
      }
      requestAnimFrame(animFrameLoop);
  }
  var started = false;
  function startTasks() {
      if (started) {
          return;
      }
      started = true;
      if (Browser$1.requestIdleCallback) {
          requestIdleCallback(idleFrameLoop);
      }
      //always run requestAnimFrame
      requestAnimFrame(animFrameLoop);
  }
  function pushLoopHook(func) {
      if (loopHooks.indexOf(func) > -1) {
          return;
      }
      if (isFunction(func)) {
          loopHooks.push(func);
      }
  }

  var MicroTask = /*#__PURE__*/Object.freeze({
    __proto__: null,
    pushLoopHook: pushLoopHook,
    runTaskAsync: runTaskAsync,
    startTasks: startTasks
  });

  /* eslint-disable @typescript-eslint/ban-types */
  var isMapSupported = typeof Map === 'function';
  var nullOnRemove = function () { };
  /**
   * from mapbox-gl-js
   * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
   * with hash lookup made possible by keeping a list of keys in parallel to
   * an array of dictionary of values
   *
   * @public
   */
  var ArrayLRUCache = /** @class */ (function () {
      /**
       * @param max number of permitted values
       * @param onRemove callback called with items when they expire
       */
      function ArrayLRUCache(max, onRemove) {
          this.max = max;
          this.onRemove = onRemove || nullOnRemove;
          this.reset();
      }
      /**
       * Clear the cache
       *
       * @returns this cache
       */
      ArrayLRUCache.prototype.reset = function () {
          for (var key in this.data) {
              this.onRemove(this.data[key]);
          }
          this.data = {};
          this.order = [];
          return this;
      };
      ArrayLRUCache.prototype.clear = function () {
          this.reset();
          delete this.onRemove;
      };
      /**
       * Add a key, value combination to the cache, trimming its size if this pushes
       * it over max length.
       *
       * @param key lookup key for the item
       * @param data any value
       * @returns this cache
       */
      ArrayLRUCache.prototype.add = function (key, data) {
          if (this.has(key)) {
              this.order.splice(this.order.indexOf(key), 1);
              this.data[key] = data;
              this.order.push(key);
          }
          else {
              this.data[key] = data;
              this.order.push(key);
              if (this.order.length > this.max) {
                  var removedData = this.getAndRemove(this.order[0]);
                  if (removedData)
                      this.onRemove(removedData);
              }
          }
          return this;
      };
      /**
       * Determine whether the value attached to `key` is present
       *
       * @param key the key to be looked-up
       * @returns whether the cache has this value
       */
      ArrayLRUCache.prototype.has = function (key) {
          return key in this.data;
      };
      /**
       * List all keys in the cache
       *
       * @returns an array of keys in this cache.
       */
      ArrayLRUCache.prototype.keys = function () {
          return this.order;
      };
      /**
       * Get the value attached to a specific key and remove data from cache.
       * If the key is not found, returns `null`
       *
       * @param key the key to look up
       * @returns the data, or null if it isn't found
       */
      ArrayLRUCache.prototype.getAndRemove = function (key) {
          if (!this.has(key)) {
              return null;
          }
          var data = this.data[key];
          delete this.data[key];
          this.order.splice(this.order.indexOf(key), 1);
          return data;
      };
      /**
       * Get the value attached to a specific key without removing data
       * from the cache. If the key is not found, returns `null`
       *
       * @param key the key to look up
       * @returns the data, or null if it isn't found
       */
      ArrayLRUCache.prototype.get = function (key) {
          if (!this.has(key)) {
              return null;
          }
          var data = this.data[key];
          return data;
      };
      /**
       * Remove a key/value combination from the cache.
       *
       * @param key the key for the pair to delete
       * @returns this cache
       */
      ArrayLRUCache.prototype.remove = function (key) {
          if (!this.has(key)) {
              return this;
          }
          var data = this.data[key];
          delete this.data[key];
          this.onRemove(data);
          this.order.splice(this.order.indexOf(key), 1);
          return this;
      };
      /**
       * Change the max size of the cache.
       *
       * @param max the max size of the cache
       * @returns this cache
       */
      ArrayLRUCache.prototype.setMaxSize = function (max) {
          this.max = max;
          while (this.order.length > this.max) {
              var removedData = this.getAndRemove(this.order[0]);
              if (removedData)
                  this.onRemove(removedData);
          }
          return this;
      };
      return ArrayLRUCache;
  }());
  var MapLRUCache;
  if (isMapSupported) {
      MapLRUCache = /** @class */ (function () {
          function class_1(max, onRemove) {
              this.max = max;
              this.onRemove = onRemove || nullOnRemove;
              this.reset();
          }
          class_1.prototype.reset = function () {
              var e_1, _a;
              if (this.data) {
                  var values = this.data.values();
                  try {
                      for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                          var p = values_1_1.value;
                          this.onRemove(p);
                      }
                  }
                  catch (e_1_1) { e_1 = { error: e_1_1 }; }
                  finally {
                      try {
                          if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                  }
              }
              this.data = new Map();
              return this;
          };
          class_1.prototype.clear = function () {
              this.reset();
              delete this.onRemove;
          };
          class_1.prototype.add = function (key, data) {
              if (!data) {
                  return this;
              }
              if (this.has(key)) {
                  this.data.delete(key);
                  this.data.set(key, data);
                  // if (this.data.size > this.max) {
                  //     this.shrink();
                  // }
              }
              else {
                  this.data.set(key, data);
                  // if (this.data.size > this.max) {
                  //     this.shrink();
                  // }
              }
              return this;
          };
          class_1.prototype.keys = function () {
              var e_2, _a;
              var keys = new Array(this.data.size);
              var i = 0;
              var iterator = this.data.keys();
              try {
                  for (var iterator_1 = __values(iterator), iterator_1_1 = iterator_1.next(); !iterator_1_1.done; iterator_1_1 = iterator_1.next()) {
                      var k = iterator_1_1.value;
                      keys[i++] = k;
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) _a.call(iterator_1);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
              return keys;
          };
          class_1.prototype.shrink = function () {
              var iterator = this.data.keys();
              var item = iterator.next();
              while (this.data.size > this.max) {
                  var removedData = this.getAndRemove(item.value);
                  if (removedData) {
                      this.onRemove(removedData);
                  }
                  item = iterator.next();
              }
          };
          class_1.prototype.has = function (key) {
              return this.data.has(key);
          };
          class_1.prototype.getAndRemove = function (key) {
              if (!this.has(key)) {
                  return null;
              }
              var data = this.data.get(key);
              this.data.delete(key);
              return data;
          };
          class_1.prototype.get = function (key) {
              if (!this.has(key)) {
                  return null;
              }
              var data = this.data.get(key);
              return data;
          };
          class_1.prototype.remove = function (key) {
              if (!this.has(key)) {
                  return this;
              }
              var data = this.data.get(key);
              this.data.delete(key);
              this.onRemove(data);
              return this;
          };
          class_1.prototype.setMaxSize = function (max) {
              this.max = max;
              if (this.data.size > this.max) {
                  this.shrink();
              }
              return this;
          };
          return class_1;
      }());
  }
  var LRUCache = isMapSupported ? MapLRUCache : ArrayLRUCache;

  var DEFAULT_STROKE_COLOR = '#000';
  var DEFAULT_FILL_COLOR = 'rgba(255,255,255,0)';
  var DEFAULT_TEXT_COLOR = '#000';
  var hitTesting = false;
  var TEMP_CANVAS = null;
  var RADIAN$1 = Math.PI / 180;
  var textOffsetY = 1;
  var TEXT_BASELINE = 'top';
  //推算 cubic 贝塞尔曲线片段的起终点和控制点坐标
  //t0: 片段起始比例 0-1
  //t1: 片段结束比例 0-1
  //x1, y1, 曲线起点
  //bx1, by1, bx2, by2，曲线控制点
  //x2, y2  曲线终点
  //结果是曲线片段的起点，2个控制点坐标和终点坐标
  //https://stackoverflow.com/questions/878862/drawing-part-of-a-b%C3%A9zier-curve-by-reusing-a-basic-b%C3%A9zier-curve-function/879213#879213
  function interpolate$1(t0, t1, x1, y1, bx1, by1, bx2, by2, x2, y2) {
      var u0 = 1.0 - t0;
      var u1 = 1.0 - t1;
      var qxa = x1 * u0 * u0 + bx1 * 2 * t0 * u0 + bx2 * t0 * t0;
      var qxb = x1 * u1 * u1 + bx1 * 2 * t1 * u1 + bx2 * t1 * t1;
      var qxc = bx1 * u0 * u0 + bx2 * 2 * t0 * u0 + x2 * t0 * t0;
      var qxd = bx1 * u1 * u1 + bx2 * 2 * t1 * u1 + x2 * t1 * t1;
      var qya = y1 * u0 * u0 + by1 * 2 * t0 * u0 + by2 * t0 * t0;
      var qyb = y1 * u1 * u1 + by1 * 2 * t1 * u1 + by2 * t1 * t1;
      var qyc = by1 * u0 * u0 + by2 * 2 * t0 * u0 + y2 * t0 * t0;
      var qyd = by1 * u1 * u1 + by2 * 2 * t1 * u1 + y2 * t1 * t1;
      // const xa = qxa * u0 + qxc * t0;
      var xb = qxa * u1 + qxc * t1;
      var xc = qxb * u0 + qxd * t0;
      var xd = qxb * u1 + qxd * t1;
      // const ya = qya * u0 + qyc * t0;
      var yb = qya * u1 + qyc * t1;
      var yc = qyb * u0 + qyd * t0;
      var yd = qyb * u1 + qyd * t1;
      return [xb, yb, xc, yc, xd, yd];
  }
  //from http://www.antigrain.com/research/bezier_interpolation/
  function getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, t) {
      // Assume we need to calculate the control
      // points between (x1,y1) and (x2,y2).
      // Then x0,y0 - the previous vertex,
      //      x3,y3 - the next one.
      var xc1 = (x0 + x1) / 2.0, yc1 = (y0 + y1) / 2.0;
      var xc2 = (x1 + x2) / 2.0, yc2 = (y1 + y2) / 2.0;
      var xc3 = (x2 + x3) / 2.0, yc3 = (y2 + y3) / 2.0;
      var len1 = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
      var len2 = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var len3 = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));
      var k1 = len1 / (len1 + len2);
      var k2 = len2 / (len2 + len3);
      var xm1 = xc1 + (xc2 - xc1) * k1, ym1 = yc1 + (yc2 - yc1) * k1;
      var xm2 = xc2 + (xc3 - xc2) * k2, ym2 = yc2 + (yc3 - yc2) * k2;
      // Resulting control points. Here smoothValue is mentioned
      // above coefficient K whose value should be in range [0...1].
      var ctrl1X = xm1 + (xc2 - xm1) * smoothValue + x1 - xm1, ctrl1Y = ym1 + (yc2 - ym1) * smoothValue + y1 - ym1, ctrl2X = xm2 + (xc2 - xm2) * smoothValue + x2 - xm2, ctrl2Y = ym2 + (yc2 - ym2) * smoothValue + y2 - ym2;
      var ctrlPoints = [ctrl1X, ctrl1Y, ctrl2X, ctrl2Y];
      if (t < 1) {
          return interpolate$1(0, t, x1, y1, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, x2, y2);
      }
      else {
          return ctrlPoints;
      }
  }
  var Canvas = {
      getCanvas2DContext: function (canvas) {
          return canvas.getContext('2d', { willReadFrequently: true });
      },
      setHitTesting: function (testing) {
          hitTesting = testing;
      },
      createCanvas: function (width, height, canvasClass) {
          var canvas;
          if (!IS_NODE) {
              canvas = createEl('canvas');
              canvas.width = width;
              canvas.height = height;
          }
          else {
              //can be node-canvas or any other canvas mock
              canvas = new canvasClass(width, height);
          }
          return canvas;
      },
      prepareCanvasFont: function (ctx, style) {
          if (ctx.textBaseline !== TEXT_BASELINE) {
              ctx.textBaseline = TEXT_BASELINE;
          }
          var font = getFont(style);
          if (ctx.font !== font) {
              ctx.font = font;
          }
          var fill = style['textFill'];
          if (!fill) {
              fill = DEFAULT_TEXT_COLOR;
          }
          var fillStyle = Canvas.getRgba(fill, style['textOpacity']);
          if (ctx.fillStyle !== fillStyle) {
              ctx.fillStyle = fillStyle;
          }
      },
      /**
       * Set canvas's fill and stroke style
       * @param {CanvasRenderingContext2D} ctx
       * @param {Object} style
       * @param {Object} resources
       * @param {Boolean} testing  - paint for testing, ignore stroke and fill patterns
       */
      prepareCanvas: function (ctx, style, resources, testing) {
          if (!style) {
              return;
          }
          var strokeWidth = style['lineWidth'];
          if (!isNil(strokeWidth) && ctx.lineWidth !== strokeWidth) {
              ctx.lineWidth = strokeWidth;
          }
          var strokePattern = style['linePatternFile'];
          var strokeColor = style['lineColor'] || DEFAULT_STROKE_COLOR;
          if (testing) {
              ctx.strokeStyle = '#000';
          }
          else if (strokePattern && resources) {
              var patternOffset = void 0;
              if (style['linePatternDx'] || style['linePatternDy']) {
                  patternOffset = [style['linePatternDx'], style['linePatternDy']];
              }
              Canvas._setStrokePattern(ctx, strokePattern, strokeWidth, patternOffset, resources);
              //line pattern will override stroke-dasharray
              style['lineDasharray'] = [];
          }
          else if (isGradient(strokeColor)) {
              if (style['lineGradientExtent']) {
                  ctx.strokeStyle = Canvas._createGradient(ctx, strokeColor, style['lineGradientExtent']);
              }
              else {
                  ctx.strokeStyle = DEFAULT_STROKE_COLOR;
              }
          }
          else /*if (ctx.strokeStyle !== strokeColor)*/ {
              if (Array.isArray(strokeColor)) {
                  strokeColor = Canvas.normalizeColorToRGBA(strokeColor);
              }
              ctx.strokeStyle = strokeColor;
          }
          if (style['lineJoin']) {
              ctx.lineJoin = style['lineJoin'];
          }
          if (style['lineCap']) {
              ctx.lineCap = style['lineCap'];
          }
          if (ctx.setLineDash && isArrayHasData(style['lineDasharray'])) {
              ctx.setLineDash(style['lineDasharray']);
          }
          var polygonPattern = style['polygonPatternFile'];
          var fill = style['polygonFill'] || DEFAULT_FILL_COLOR;
          if (testing) {
              ctx.fillStyle = '#000';
          }
          else if (polygonPattern && resources) {
              var fillImgUrl = extractImageUrl(polygonPattern);
              var fillTexture = resources.getImage([fillImgUrl, null, null]);
              if (!fillTexture) {
                  //if the linestring has a arrow and a linePatternFile, polygonPatternFile will be set with the linePatternFile.
                  fillTexture = resources.getImage([fillImgUrl + '-texture', null, strokeWidth]);
              }
              if (isSVG(fillImgUrl) && (fillTexture instanceof Image) && (Browser$1.edge || Browser$1.ie)) {
                  //opacity of svg img painted on canvas is always 1, so we paint svg on a canvas at first.
                  var w = fillTexture.width || 20, h = fillTexture.height || 20;
                  var canvas = Canvas.createCanvas(w, h);
                  Canvas.image(canvas.getContext('2d'), fillTexture, 0, 0, w, h);
                  fillTexture = canvas;
              }
              if (!fillTexture) {
                  if (typeof console !== 'undefined') {
                      console.warn('img not found for', fillImgUrl);
                  }
              }
              else {
                  ctx.fillStyle = ctx.createPattern(fillTexture, 'repeat');
                  if (style['polygonPatternDx'] || style['polygonPatternDy']) {
                      ctx.fillStyle['polygonPatternOffset'] = [style['polygonPatternDx'], style['polygonPatternDy']];
                  }
              }
          }
          else if (isGradient(fill)) {
              if (style['polygonGradientExtent']) {
                  ctx.fillStyle = Canvas._createGradient(ctx, fill, style['polygonGradientExtent']);
              }
              else {
                  ctx.fillStyle = 'rgba(255,255,255,0)';
              }
          }
          else /*if (ctx.fillStyle !== fill)*/ {
              if (Array.isArray(fill)) {
                  fill = Canvas.normalizeColorToRGBA(fill);
              }
              ctx.fillStyle = fill;
          }
      },
      //@internal
      _createGradient: function (ctx, g, extent) {
          var gradient = null, places = g['places'];
          var min = extent.getMin(), max = extent.getMax(), width = extent.getWidth(), height = extent.getHeight();
          if (!g['type'] || g['type'] === 'linear') {
              if (!places) {
                  places = [min.x, min.y, max.x, min.y];
              }
              else {
                  if (places.length !== 4) {
                      throw new Error('A linear gradient\'s places should have 4 numbers.');
                  }
                  places = [
                      min.x + places[0] * width, min.y + places[1] * height,
                      min.x + places[2] * width, min.y + places[3] * height
                  ];
              }
              // eslint-disable-next-line prefer-spread
              gradient = ctx.createLinearGradient.apply(ctx, places);
          }
          else if (g['type'] === 'radial') {
              if (!places) {
                  var c = extent.getCenter()._round();
                  places = [c.x, c.y, Math.abs(c.x - min.x), c.x, c.y, 0];
              }
              else {
                  if (places.length !== 6) {
                      throw new Error('A radial gradient\'s places should have 6 numbers.');
                  }
                  places = [
                      min.x + places[0] * width, min.y + places[1] * height, width * places[2],
                      min.x + places[3] * width, min.y + places[4] * height, width * places[5]
                  ];
              }
              // eslint-disable-next-line prefer-spread
              gradient = ctx.createRadialGradient.apply(ctx, places);
          }
          g['colorStops'].forEach(function (stop) {
              // eslint-disable-next-line prefer-spread
              gradient.addColorStop.apply(gradient, stop);
          });
          return gradient;
      },
      //@internal
      _setStrokePattern: function (ctx, strokePattern, strokeWidth, linePatternOffset, resources) {
          var imgUrl = extractImageUrl(strokePattern);
          var imageTexture;
          if (IS_NODE) {
              imageTexture = resources.getImage([imgUrl, null, strokeWidth]);
          }
          else {
              var key = imgUrl + '-texture-' + strokeWidth;
              imageTexture = resources.getImage(key);
              if (!imageTexture) {
                  var imageRes = resources.getImage([imgUrl, null, null]);
                  if (imageRes) {
                      var w = void 0;
                      if (!imageRes.width || !imageRes.height) {
                          w = strokeWidth;
                      }
                      else {
                          w = Math.round(imageRes.width * strokeWidth / imageRes.height);
                      }
                      var patternCanvas = Canvas.createCanvas(w, strokeWidth, ctx.canvas.constructor);
                      Canvas.image(patternCanvas.getContext('2d'), imageRes, 0, 0, w, strokeWidth);
                      resources.addResource([key, null, strokeWidth], patternCanvas);
                      imageTexture = patternCanvas;
                  }
              }
          }
          if (imageTexture) {
              ctx.strokeStyle = ctx.createPattern(imageTexture, 'repeat');
              ctx.strokeStyle['linePatternOffset'] = linePatternOffset;
          }
          else if (typeof console !== 'undefined') {
              console.warn('img not found for', imgUrl);
          }
      },
      clearRect: function (ctx, x1, y1, x2, y2) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ctx.canvas._drawn = false;
          ctx.clearRect(x1, y1, x2, y2);
      },
      fillCanvas: function (ctx, fillOpacity, x, y) {
          if (hitTesting) {
              fillOpacity = 1;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ctx.canvas._drawn = true;
          if (fillOpacity === 0) {
              return;
          }
          var isPattern = Canvas._isPattern(ctx.fillStyle);
          var offset = ctx.fillStyle && ctx.fillStyle['polygonPatternOffset'];
          var dx = offset ? offset[0] : 0, dy = offset ? offset[1] : 0;
          if (isNil(fillOpacity)) {
              fillOpacity = 1;
          }
          var alpha;
          if (fillOpacity < 1) {
              alpha = ctx.globalAlpha;
              ctx.globalAlpha *= fillOpacity;
          }
          if (isPattern) {
              x = x || 0;
              y = y || 0;
              // x = round(x);
              // y = round(y);
              ctx.translate(x + dx, y + dy);
          }
          ctx.fill();
          if (isPattern) {
              ctx.translate(-x - dx, -y - dy);
          }
          if (fillOpacity < 1) {
              ctx.globalAlpha = alpha;
          }
      },
      // hexColorRe: /^#([0-9a-f]{6}|[0-9a-f]{3})$/i,
      // support #RRGGBB/#RGB now.
      // if color was like [red, orange...]/rgb(a)/hsl(a), op will not combined to result
      getRgba: function (color, op) {
          if (isNil(op)) {
              op = 1;
          }
          if (color[0] !== '#') {
              if (Array.isArray(color)) {
                  color = Canvas.normalizeColorToRGBA(color, op);
              }
              return color;
          }
          var r, g, b;
          if (color.length === 7) {
              r = parseInt(color.substring(1, 3), 16);
              g = parseInt(color.substring(3, 5), 16);
              b = parseInt(color.substring(5, 7), 16);
          }
          else {
              r = parseInt(color.substring(1, 2), 16) * 17;
              g = parseInt(color.substring(2, 3), 16) * 17;
              b = parseInt(color.substring(3, 4), 16) * 17;
          }
          return 'rgba(' + r + ',' + g + ',' + b + ',' + op + ')';
      },
      normalizeColorToRGBA: function (fill, opacity) {
          if (opacity === void 0) { opacity = 1; }
          return "rgba(".concat(fill[0] * 255, ",").concat(fill[1] * 255, ",").concat(fill[2] * 255, ",").concat((fill.length === 4 ? fill[3] : 1) * opacity, ")");
      },
      image: function (ctx, img, x, y, width, height) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ctx.canvas._drawn = true;
          try {
              if (isNumber(width) && isNumber(height)) {
                  ctx.drawImage(img, x, y, width, height);
              }
              else {
                  ctx.drawImage(img, x, y);
              }
          }
          catch (error) {
              if (console) {
                  console.warn('error when drawing image on canvas:', error);
                  console.warn(img);
              }
          }
      },
      text: function (ctx, text, pt, style, textDesc) {
          return Canvas._textOnMultiRow(ctx, textDesc['rows'], style, pt, textDesc['size'], textDesc['rawSize']);
      },
      //@internal
      _textOnMultiRow: function (ctx, texts, style, point, splitTextSize, textSize) {
          var ptAlign = getAlignPoint(splitTextSize, style['textHorizontalAlignment'], style['textVerticalAlignment']), lineHeight = textSize['height'] + style['textLineSpacing'], basePoint = point.add(0, ptAlign.y), maxHeight = style['textMaxHeight'];
          var text, rowAlign, height = 0;
          resetBBOX(BBOX_TEMP);
          for (var i = 0, len = texts.length; i < len; i++) {
              text = texts[i]['text'];
              rowAlign = getAlignPoint(texts[i]['size'], style['textHorizontalAlignment'], style['textVerticalAlignment']);
              var point_1 = basePoint.add(rowAlign.x, i * lineHeight);
              Canvas._textOnLine(ctx, text, point_1, style['textHaloRadius'], style['textHaloFill'], style['textHaloOpacity']);
              var textSize_1 = texts[i].size;
              var minx = point_1.x, miny = point_1.y, maxx = minx + textSize_1.width, maxy = miny + textSize_1.height;
              setBBOX(BBOX_TEMP, minx, miny, maxx, maxy);
              if (maxHeight > 0) {
                  height += lineHeight;
                  if (height + textSize_1['height'] >= maxHeight) {
                      break;
                  }
              }
          }
          return BBOX_TEMP;
      },
      //@internal
      _textOnLine: function (ctx, text, pt, textHaloRadius, textHaloFill, textHaloAlpha) {
          if (hitTesting) {
              textHaloAlpha = 1;
          }
          var drawHalo = textHaloAlpha !== 0 && textHaloRadius !== 0;
          // pt = pt._round();
          ctx.textBaseline = 'top';
          var gco, fill;
          var shadowBlur = ctx.shadowBlur, shadowOffsetX = ctx.shadowOffsetX, shadowOffsetY = ctx.shadowOffsetY;
          if (drawHalo) {
              var alpha = ctx.globalAlpha;
              //http://stackoverflow.com/questions/14126298/create-text-outline-on-canvas-in-javascript
              //根据text-horizontal-alignment和text-vertical-alignment计算绘制起始点偏移量
              ctx.globalAlpha *= textHaloAlpha;
              ctx.miterLimit = 2;
              ctx.lineJoin = 'round';
              ctx.lineCap = 'round';
              ctx.lineWidth = textHaloRadius * 2;
              if (Array.isArray(textHaloFill)) {
                  textHaloFill = Canvas.normalizeColorToRGBA(textHaloFill);
              }
              ctx.strokeStyle = textHaloFill;
              ctx.strokeText(text, pt.x, pt.y + textOffsetY);
              ctx.miterLimit = 10; //default
              ctx.globalAlpha = alpha;
              gco = ctx.globalCompositeOperation;
              ctx.globalCompositeOperation = 'destination-out';
              fill = ctx.fillStyle;
              ctx.fillStyle = '#000';
          }
          if (shadowBlur && drawHalo) {
              ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
          }
          Canvas.fillText(ctx, text, pt);
          if (gco) {
              ctx.globalCompositeOperation = gco;
              Canvas.fillText(ctx, text, pt, fill);
              if (shadowBlur) {
                  ctx.shadowBlur = shadowBlur;
                  ctx.shadowOffsetX = shadowOffsetX;
                  ctx.shadowOffsetY = shadowOffsetY;
              }
          }
      },
      fillText: function (ctx, text, pt, rgba) {
          ctx.canvas._drawn = true;
          if (rgba) {
              ctx.fillStyle = rgba;
          }
          ctx.fillText(text, pt.x, pt.y + textOffsetY);
      },
      //@internal
      _stroke: function (ctx, strokeOpacity, x, y) {
          if (hitTesting) {
              strokeOpacity = 1;
          }
          ctx.canvas._drawn = true;
          if (strokeOpacity === 0) {
              return;
          }
          var offset = ctx.strokeStyle && ctx.strokeStyle['linePatternOffset'];
          var dx = offset ? offset[0] : 0, dy = offset ? offset[1] : 0;
          var isPattern = Canvas._isPattern(ctx.strokeStyle) && (!isNil(x) && !isNil(y) || !isNil(dx) && !isNil(dy));
          if (isNil(strokeOpacity)) {
              strokeOpacity = 1;
          }
          var alpha;
          if (strokeOpacity < 1) {
              alpha = ctx.globalAlpha;
              ctx.globalAlpha *= strokeOpacity;
          }
          if (isPattern) {
              x = x || 0;
              y = y || 0;
              // x = round(x);
              // y = round(y);
              ctx.translate(x + dx, y + dy);
          }
          ctx.stroke();
          if (isPattern) {
              ctx.translate(-x - dx, -y - dy);
          }
          if (strokeOpacity < 1) {
              ctx.globalAlpha = alpha;
          }
      },
      //@internal
      _path: function (ctx, points, lineDashArray, lineOpacity, ignoreStrokePattern) {
          if (!isArrayHasData(points)) {
              return;
          }
          function fillWithPattern(p1, p2) {
              var degree = computeDegree(p1.x, p1.y, p2.x, p2.y);
              ctx.save();
              var cosd = Math.cos(degree);
              if (Math.abs(cosd) < 1E-7) {
                  //a vertical line
                  ctx.translate(p1.x - ctx.lineWidth / 2, p1.y);
              }
              else {
                  ctx.translate(p1.x, p1.y - ctx.lineWidth / 2 / cosd);
              }
              ctx.rotate(degree);
              Canvas._stroke(ctx, lineOpacity);
              ctx.restore();
          }
          var isDashed = isArrayHasData(lineDashArray);
          var isPatternLine = (ignoreStrokePattern === true ? false : Canvas._isPattern(ctx.strokeStyle));
          var point, prePoint, nextPoint;
          for (var i = 0, len = points.length; i < len; i++) {
              point = points[i];
              if (!isDashed || ctx.setLineDash) { //IE9+
                  ctx.lineTo(point.x, point.y);
                  if (isPatternLine && i > 0) {
                      prePoint = points[i - 1];
                      fillWithPattern(prePoint, point);
                      ctx.beginPath();
                      ctx.moveTo(point.x, point.y);
                  }
              }
              else if (isDashed) {
                  if (i === len - 1) {
                      break;
                  }
                  nextPoint = points[i + 1];
                  // drawDashLine(ctx, point, nextPoint, lineDashArray, isPatternLine);
                  drawDashLine(ctx, point, nextPoint, lineDashArray);
              }
          }
      },
      path: function (ctx, points, lineOpacity, fillOpacity, lineDashArray) {
          if (!isArrayHasData(points)) {
              return;
          }
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          Canvas._path(ctx, points, lineDashArray, lineOpacity);
          Canvas._stroke(ctx, lineOpacity);
      },
      //@internal
      _multiClip: function (ctx, points) {
          if (!points || points.length === 0)
              return;
          points.forEach(function (pts) {
              for (var i = 0, len = pts.length; i < len; i++) {
                  var point = pts[i];
                  var x = point.x, y = point.y;
                  if (i === 0) {
                      ctx.moveTo(x, y);
                  }
                  else {
                      ctx.lineTo(x, y);
                  }
                  if (i === len - 1) {
                      x = pts[0].x;
                      y = pts[0].y;
                      ctx.lineTo(x, y);
                  }
              }
          });
      },
      polygon: function (ctx, points, lineOpacity, fillOpacity, lineDashArray, smoothness) {
          // if MultiPolygon clip
          if (ctx.isMultiClip) {
              Canvas._multiClip(ctx, points);
              return;
          }
          //polygon clip
          if (ctx.isClip) {
              // if points[0] is array ,the polygon has hole,ignore holes
              Canvas._multiClip(ctx, Array.isArray(points[0]) ? points : [points]);
              return;
          }
          if (!isArrayHasData(points)) {
              return;
          }
          var isPatternLine = Canvas._isPattern(ctx.strokeStyle), fillFirst = (isArrayHasData(lineDashArray) && !ctx.setLineDash) || isPatternLine && !smoothness;
          if (!isArrayHasData(points[0])) {
              points = [points];
          }
          var savedCtx = ctx;
          var dpr = ctx.dpr || 1;
          var needScale = dpr !== 1;
          if (points.length > 1 && !IS_NODE) {
              if (!TEMP_CANVAS) {
                  TEMP_CANVAS = Canvas.createCanvas(1, 1);
              }
              ctx.canvas._drawn = false;
              TEMP_CANVAS.width = ctx.canvas.width;
              TEMP_CANVAS.height = ctx.canvas.height;
              ctx = TEMP_CANVAS.getContext('2d');
              //reset lineDashArray
              setLineDash(ctx, []);
              setLineDash(ctx, lineDashArray);
              copyProperties(ctx, savedCtx);
              if (needScale) {
                  ctx.scale(dpr, dpr);
              }
          }
          // function fillPolygon(points, i, op) {
          //     Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);
          // }
          var op, i, len;
          if (fillFirst) {
              //因为canvas只填充moveto,lineto,lineto的空间, 而dashline的moveto不再构成封闭空间, 所以重新绘制图形轮廓用于填充
              ctx.save();
              for (i = 0, len = points.length; i < len; i++) {
                  if (!isArrayHasData(points[i])) {
                      continue;
                  }
                  Canvas._ring(ctx, points[i], null, 0, true);
                  op = fillOpacity;
                  if (i > 0) {
                      ctx.globalCompositeOperation = 'destination-out';
                      op = 1;
                  }
                  Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);
                  if (i > 0) {
                      ctx.globalCompositeOperation = 'source-over';
                  }
                  else if (len > 1) {
                      // make sure 'destination-out'
                      ctx.fillStyle = '#fff';
                  }
                  Canvas._stroke(ctx, 0);
              }
              ctx.restore();
          }
          var fillStyle = ctx.fillStyle;
          for (i = 0, len = points.length; i < len; i++) {
              if (!isArrayHasData(points[i])) {
                  continue;
              }
              if (smoothness) {
                  Canvas.paintSmoothLine(ctx, points[i], lineOpacity, smoothness, true);
                  ctx.closePath();
              }
              else {
                  Canvas._ring(ctx, points[i], lineDashArray, lineOpacity);
              }
              if (!fillFirst) {
                  op = fillOpacity;
                  if (i > 0) {
                      ctx.globalCompositeOperation = 'destination-out';
                      op = 1;
                  }
                  Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);
                  if (i > 0) {
                      //return to default compositeOperation to display strokes.
                      ctx.globalCompositeOperation = 'source-over';
                  }
                  else if (len > 1) {
                      // make sure 'destination-out'
                      ctx.fillStyle = '#fff';
                  }
              }
              Canvas._stroke(ctx, lineOpacity);
          }
          //还原fillStyle
          if (ctx.fillStyle !== fillStyle) {
              ctx.fillStyle = fillStyle;
          }
          if (points.length > 1 && !IS_NODE) {
              if (needScale) {
                  var rScale = 1 / dpr;
                  savedCtx.scale(rScale, rScale);
              }
              savedCtx.drawImage(TEMP_CANVAS, 0, 0);
              if (needScale) {
                  savedCtx.scale(dpr, dpr);
              }
              savedCtx.canvas._drawn = ctx.canvas._drawn;
              copyProperties(savedCtx, ctx);
          }
      },
      //@internal
      _ring: function (ctx, ring, lineDashArray, lineOpacity, ignorePattern) {
          var isPattern = Canvas._isPattern(ctx.strokeStyle);
          if (!ignorePattern && isPattern && !ring[0].equals(ring[ring.length - 1])) {
              ring = ring.concat([ring[0]]);
          }
          ctx.beginPath();
          ctx.moveTo(ring[0].x, ring[0].y);
          Canvas._path(ctx, ring, lineDashArray, lineOpacity, ignorePattern);
          if (!isPattern) {
              ctx.closePath();
          }
      },
      //备份老的方法
      paintSmoothLine_bak: function (ctx, points, lineOpacity, smoothValue, close, tailIdx, tailRatio) {
          if (!points) {
              return;
          }
          if (points.length <= 2 || !smoothValue) {
              Canvas.path(ctx, points, lineOpacity);
              return;
          }
          var count = points.length;
          var l = close ? count : count - 1;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          if (tailRatio !== undefined)
              l -= Math.max(l - tailIdx - 1, 0);
          var preCtrlPoints;
          for (var i = 0; i < l; i++) {
              var x1 = points[i].x, y1 = points[i].y;
              var x0 = void 0, y0 = void 0, x2 = void 0, y2 = void 0, x3 = void 0, y3 = void 0;
              if (i - 1 < 0) {
                  if (!close) {
                      x0 = points[i + 1].x;
                      y0 = points[i + 1].y;
                  }
                  else {
                      x0 = points[l - 1].x;
                      y0 = points[l - 1].y;
                  }
              }
              else {
                  x0 = points[i - 1].x;
                  y0 = points[i - 1].y;
              }
              if (i + 1 < count) {
                  x2 = points[i + 1].x;
                  y2 = points[i + 1].y;
              }
              else {
                  x2 = points[i + 1 - count].x;
                  y2 = points[i + 1 - count].y;
              }
              if (i + 2 < count) {
                  x3 = points[i + 2].x;
                  y3 = points[i + 2].y;
              }
              else if (!close) {
                  x3 = points[i].x;
                  y3 = points[i].y;
              }
              else {
                  x3 = points[i + 2 - count].x;
                  y3 = points[i + 2 - count].y;
              }
              var ctrlPoints = getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, i === l - 1 ? tailRatio : 1);
              if (i === l - 1 && tailRatio >= 0 && tailRatio < 1) {
                  ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], ctrlPoints[4], ctrlPoints[5]);
                  points.splice(l - 1, count - (l - 1) - 1);
                  var lastPoint = new Point(ctrlPoints[4], ctrlPoints[5]);
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore
                  lastPoint.prevCtrlPoint = new Point(ctrlPoints[2], ctrlPoints[3]);
                  points.push(lastPoint);
                  count = points.length;
              }
              else {
                  ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], x2, y2);
              }
              points[i].nextCtrlPoint = ctrlPoints.slice(0, 2);
              points[i].prevCtrlPoint = preCtrlPoints ? preCtrlPoints.slice(2) : null;
              preCtrlPoints = ctrlPoints;
          }
          if (!close && points[1].prevCtrlPoint) {
              points[0].nextCtrlPoint = points[1].prevCtrlPoint;
              delete points[0].prevCtrlPoint;
          }
          if (!points[count - 1].prevCtrlPoint) {
              points[count - 1].prevCtrlPoint = points[count - 2].nextCtrlPoint;
          }
          Canvas._stroke(ctx, lineOpacity);
      },
      paintSmoothLine: function (ctx, points, lineOpacity, smoothValue, close, tailIdx, tailRatio) {
          if (!points) {
              return;
          }
          if (points.length <= 2 || !smoothValue) {
              Canvas.path(ctx, points, lineOpacity);
              return;
          }
          var count = points.length;
          var l = close ? count : count - 1;
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          if (tailRatio !== undefined)
              l -= Math.max(l - tailIdx - 1, 0);
          var preX, preY;
          for (var i = 0; i < l; i++) {
              var x1 = points[i].x, y1 = points[i].y;
              var x0 = void 0, y0 = void 0, x2 = void 0, y2 = void 0, x3 = void 0, y3 = void 0;
              if (i - 1 < 0) {
                  if (!close) {
                      x0 = points[i + 1].x;
                      y0 = points[i + 1].y;
                  }
                  else {
                      x0 = points[l - 1].x;
                      y0 = points[l - 1].y;
                  }
              }
              else {
                  x0 = points[i - 1].x;
                  y0 = points[i - 1].y;
              }
              if (i + 1 < count) {
                  x2 = points[i + 1].x;
                  y2 = points[i + 1].y;
              }
              else {
                  x2 = points[i + 1 - count].x;
                  y2 = points[i + 1 - count].y;
              }
              if (i + 2 < count) {
                  x3 = points[i + 2].x;
                  y3 = points[i + 2].y;
              }
              else if (!close) {
                  x3 = points[i].x;
                  y3 = points[i].y;
              }
              else {
                  x3 = points[i + 2 - count].x;
                  y3 = points[i + 2 - count].y;
              }
              var point = points[i];
              var ctrlPoints = getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, i === l - 1 ? tailRatio : 1);
              if (i === l - 1 && tailRatio >= 0 && tailRatio < 1) {
                  ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], ctrlPoints[4], ctrlPoints[5]);
                  points.splice(l - 1, count - (l - 1) - 1);
                  var lastPoint = new Point(ctrlPoints[4], ctrlPoints[5]);
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore
                  // lastPoint.prevCtrlPoint = new Point(ctrlPoints[2], ctrlPoints[3]);
                  points.push(lastPoint);
                  count = points.length;
              }
              else {
                  ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], x2, y2);
              }
              if (i === 0) {
                  //第一个点添加一个Point作为箭头方向使用
                  // p0--arrowNextPoint------------p1;
                  point.arrowNextPoint = point.arrowNextPoint || new Point(0, 0);
                  preX = ctrlPoints[2];
                  preY = ctrlPoints[3];
                  point.arrowNextPoint.x = preX;
                  point.arrowNextPoint.y = preY;
              }
              else {
                  //其他的点，添加一个前置节点作为箭头方向使用
                  // p0--------arrowPrePoint--p1;
                  point.arrowPrePoint = point.arrowPrePoint || new Point(0, 0);
                  point.arrowPrePoint.x = preX;
                  point.arrowPrePoint.y = preY;
                  preX = ctrlPoints[2];
                  preY = ctrlPoints[3];
                  if (i === l - 1 && points[i + 1]) {
                      //最后一个节点添加一个前置节点作为箭头方向使用
                      points[i + 1].arrowPrePoint = points[i + 1].arrowPrePoint || new Point(0, 0);
                      points[i + 1].arrowPrePoint.x = ctrlPoints[0];
                      points[i + 1].arrowPrePoint.y = ctrlPoints[1];
                  }
              }
          }
          Canvas._stroke(ctx, lineOpacity);
      },
      /**
       * draw an arc from p1 to p2 with degree of (p1, center) and (p2, center)
       * @param  {Context} ctx    canvas context
       * @param  {Point} p1      point 1
       * @param  {Point} p2      point 2
       * @param  {Number} degree arc degree between p1 and p2
       */
      //@internal
      _arcBetween: function (ctx, p1, p2, degree) {
          //degree可能是负角度
          var a = Math.abs(degree), dist = p1.distanceTo(p2), 
          //radius of circle
          r = Math.abs(dist / 2 / Math.sin(a / 2));
          //angle between p1 and p2
          var p1p2 = Math.asin((p2.y - p1.y) / dist);
          if (p1.x > p2.x) {
              p1p2 = Math.PI - p1p2;
          }
          //angle between circle center and p2
          var cp2 = 90 * RADIAN$1 - a / 2, da = p1p2 - cp2;
          var dx = Math.cos(da) * r, dy = Math.sin(da) * r;
          var cx = p1.x + dx, cy = p1.y + dy;
          var startAngle = Math.asin((p2.y - cy) / r);
          if (cx > p2.x) {
              startAngle = Math.PI - startAngle;
          }
          var endAngle = startAngle + a;
          //负角度
          if (degree < 0) {
              //旋转整个弧线PI
              startAngle += Math.PI;
              endAngle += Math.PI;
              //translate center 平移中线点,以p1,p2的中心点向相反方向取新的中心点
              var middleX = (p1.x + p2.x) / 2, middleY = (p1.y + p2.y) / 2;
              var dx_1 = cx - middleX, dy_1 = cy - middleY;
              cx = middleX - dx_1;
              cy = middleY - dy_1;
          }
          ctx.beginPath();
          ctx.arc(cx, cy, r, startAngle, endAngle);
          //cal arrow achor
          //不在使用控制点,使用箭头专用ArrowPoint,在开始角度和结束角度附件取个点
          var aAngle = (endAngle - startAngle) / 100;
          var x1 = Math.cos(startAngle + aAngle) * r + cx;
          var y1 = Math.sin(startAngle + aAngle) * r + cy;
          var x2 = Math.cos(endAngle - aAngle) * r + cx;
          var y2 = Math.sin(endAngle - aAngle) * r + cy;
          /**
           *
           * P1-arrowNextPoint------------------arrowNextPoint-P2
           *
           */
          p1.arrowNextPoint = p1.arrowNextPoint || new Point(0, 0);
          p2.arrowPrePoint = p2.arrowPrePoint || new Point(0, 0);
          if (degree < 0) {
              p1.arrowNextPoint.x = x1;
              p1.arrowNextPoint.y = y1;
              p2.arrowPrePoint.x = x2;
              p2.arrowPrePoint.y = y2;
          }
          else {
              p1.arrowNextPoint.x = x2;
              p1.arrowNextPoint.y = y2;
              p2.arrowPrePoint.x = x1;
              p2.arrowPrePoint.y = y1;
          }
          return [cx, cy];
      },
      //@internal
      _lineTo: function (ctx, p) {
          ctx.lineTo(p.x, p.y);
      },
      bezierCurveAndFill: function (ctx, points, lineOpacity, fillOpacity) {
          ctx.beginPath();
          var start = points[0];
          ctx.moveTo(start.x, start.y);
          var args = [ctx];
          // eslint-disable-next-line prefer-spread
          args.push.apply(args, points.splice(1));
          // eslint-disable-next-line prefer-spread
          Canvas._bezierCurveTo.apply(Canvas, args);
          Canvas.fillCanvas(ctx, fillOpacity);
          Canvas._stroke(ctx, lineOpacity);
      },
      //@internal
      _bezierCurveTo: function (ctx, p1, p2, p3) {
          ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      },
      //各种图形的绘制方法
      ellipse: function (ctx, pt, width, heightTop, heightBottom, lineOpacity, fillOpacity) {
          function bezierEllipse(x, y, a, b, b1) {
              var k = 0.5522848, ox = a * k, oy = b * k, oy1 = b1 * k;
              ctx.moveTo(x - a, y);
              ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
              ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
              ctx.bezierCurveTo(x + a, y + oy1, x + ox, y + b1, x, y + b1);
              ctx.bezierCurveTo(x - ox, y + b1, x - a, y + oy1, x - a, y);
              ctx.closePath();
          }
          ctx.beginPath();
          if (width === heightTop && width === heightBottom) {
              ctx.arc(pt.x, pt.y, width, 0, 2 * Math.PI);
          }
          else if (ctx.ellipse) {
              if (heightTop !== heightBottom) {
                  // the order is clockwise
                  ctx.ellipse(pt.x, pt.y, width, heightTop, 0, RADIAN$1 * 180, RADIAN$1 * 360, false);
                  ctx.ellipse(pt.x, pt.y, width, heightBottom, 0, 0, RADIAN$1 * 180, false);
              }
              else {
                  ctx.ellipse(pt.x, pt.y, width, heightTop, 0, 0, RADIAN$1 * 360, false);
              }
          }
          else {
              // IE
              bezierEllipse(pt.x, pt.y, width, heightTop, heightBottom);
          }
          Canvas.fillCanvas(ctx, fillOpacity, pt.x - width, pt.y - heightTop);
          Canvas._stroke(ctx, lineOpacity, pt.x - width, pt.y - heightTop);
      },
      rectangle: function (ctx, pt, size, lineOpacity, fillOpacity) {
          // pt = pt._round();
          var x = pt.x, y = pt.y;
          ctx.beginPath();
          ctx.rect(x, y, size['width'], size['height']);
          Canvas.fillCanvas(ctx, fillOpacity, x, y);
          Canvas._stroke(ctx, lineOpacity, x, y);
      },
      sector: function (ctx, pt, size, angles, lineOpacity, fillOpacity) {
          var rad = RADIAN$1;
          var startAngle = angles[0], endAngle = angles[1];
          function sector(ctx, x, y, radius, startAngle, endAngle) {
              var sDeg = rad * -endAngle;
              var eDeg = rad * -startAngle;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.arc(x, y, radius, sDeg, eDeg);
              ctx.lineTo(x, y);
              Canvas.fillCanvas(ctx, fillOpacity, x - radius, y - radius);
              Canvas._stroke(ctx, lineOpacity, x - radius, y - radius);
          }
          sector(ctx, pt.x, pt.y, size, startAngle, endAngle);
      },
      //@internal
      _isPattern: function (style) {
          return !isString(style) && !('addColorStop' in style);
      },
      drawCross: function (ctx, x, y, lineWidth, color) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ctx.canvas._drawn = true;
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(x - 5, y);
          ctx.lineTo(x + 5, y);
          ctx.moveTo(x, y - 5);
          ctx.lineTo(x, y + 5);
          ctx.stroke();
      },
      copy: function (canvas, c) {
          var target = c || createEl('canvas');
          target.width = canvas.width;
          target.height = canvas.height;
          target.getContext('2d').drawImage(canvas, 0, 0);
          return target;
      },
      // pixel render
      pixelRect: function (ctx, point, lineOpacity, fillOpacity) {
          var lineWidth = ctx.lineWidth;
          var alpha = ctx.globalAlpha;
          var isStroke = false;
          if (lineWidth > 0 && lineOpacity > 0) {
              isStroke = true;
              if (lineOpacity < 1) {
                  ctx.globalAlpha *= lineOpacity;
              }
          }
          else if (fillOpacity > 0) {
              if (fillOpacity < 1) {
                  ctx.globalAlpha *= fillOpacity;
              }
          }
          else {
              return;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ctx.canvas._drawn = true;
          if (isStroke) {
              ctx.strokeRect(point[0], point[1], 1, 1);
          }
          else {
              ctx.fillRect(point[0], point[1], 1, 1);
          }
          if (ctx.globalAlpha !== alpha) {
              ctx.globalAlpha = alpha;
          }
      }
  };
  /* istanbul ignore next */
  function drawDashLine(ctx, startPoint, endPoint, dashArray) {
      //https://davidowens.wordpress.com/2010/09/07/html-5-canvas-and-dashed-lines/
      //
      // Our growth rate for our line can be one of the following:
      //   (+,+), (+,-), (-,+), (-,-)
      // Because of this, our algorithm needs to understand if the x-coord and
      // y-coord should be getting smaller or larger and properly cap the values
      // based on (x,y).
      var fromX = startPoint.x, fromY = startPoint.y, toX = endPoint.x, toY = endPoint.y;
      var pattern = dashArray;
      var lt = function (a, b) {
          return a <= b;
      };
      var gt = function (a, b) {
          return a >= b;
      };
      var capmin = function (a, b) {
          return Math.min(a, b);
      };
      var capmax = function (a, b) {
          return Math.max(a, b);
      };
      var checkX = {
          thereYet: gt,
          cap: capmin
      };
      var checkY = {
          thereYet: gt,
          cap: capmin
      };
      if (fromY - toY > 0) {
          checkY.thereYet = lt;
          checkY.cap = capmax;
      }
      if (fromX - toX > 0) {
          checkX.thereYet = lt;
          checkX.cap = capmax;
      }
      ctx.moveTo(fromX, fromY);
      var offsetX = fromX;
      var offsetY = fromY;
      var idx = 0, dash = true;
      var ang, len;
      while (!(checkX.thereYet(offsetX, toX) && checkY.thereYet(offsetY, toY))) {
          ang = Math.atan2(toY - fromY, toX - fromX);
          len = pattern[idx];
          offsetX = checkX.cap(toX, offsetX + (Math.cos(ang) * len));
          offsetY = checkY.cap(toY, offsetY + (Math.sin(ang) * len));
          if (dash) {
              ctx.lineTo(offsetX, offsetY);
          }
          else {
              ctx.moveTo(offsetX, offsetY);
          }
          idx = (idx + 1) % pattern.length;
          dash = !dash;
      }
  }
  var prefix = 'data:image/';
  function extractImageUrl(url) {
      if (url.substring(0, prefix.length) === prefix) {
          return url;
      }
      return extractCssUrl(url);
  }
  function copyProperties(ctx, savedCtx) {
      ctx.filter = savedCtx.filter;
      ctx.fillStyle = savedCtx.fillStyle;
      ctx.globalAlpha = savedCtx.globalAlpha;
      ctx.lineCap = savedCtx.lineCap;
      ctx.lineDashOffset = savedCtx.lineDashOffset;
      ctx.lineJoin = savedCtx.lineJoin;
      ctx.lineWidth = savedCtx.lineWidth;
      ctx.shadowBlur = savedCtx.shadowBlur;
      ctx.shadowColor = savedCtx.shadowColor;
      ctx.shadowOffsetX = savedCtx.shadowOffsetX;
      ctx.shadowOffsetY = savedCtx.shadowOffsetY;
      ctx.strokeStyle = savedCtx.strokeStyle;
  }
  function setLineDash(ctx, lineDashArray) {
      if (!lineDashArray || !ctx.setLineDash || !Array.isArray(lineDashArray)) {
          return;
      }
      ctx.setLineDash(lineDashArray);
  }

  /**
   * This provides methods used for event handling. It's a mixin and not meant to be used directly.
   * @mixin Eventable
   */
  function generateWrapKey(eventType) {
      return 'Z__' + eventType;
  }
  function Eventable (Base) {
      return /** @class */ (function (_super) {
          __extends(EventableMixin, _super);
          function EventableMixin() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          /**
           * 注册事件的监听
           *
           * @english
           * Register a handler function to be called whenever this event is fired.
           *
           * @param eventsOn           - event types to register, seperated by space if more than one.
           * @param handler            - handler function to be called
           * @param context            - the context of the handler
           * @example
           * foo.on('mousedown mousemove mouseup', onMouseEvent, foo);
           */
          EventableMixin.prototype.on = function (eventsOn, handler, context) {
              if (!eventsOn) {
                  return this;
              }
              if (!isString(eventsOn)) {
                  return this._switch('on', eventsOn, handler);
              }
              if (!handler) {
                  return this;
              }
              if (!this._eventMap) {
                  this._eventMap = {};
              }
              eventsOn = eventsOn;
              var eventTypes = eventsOn.toLowerCase().split(' ');
              var evtType;
              if (!context) {
                  /* eslint-disable @typescript-eslint/no-this-alias */
                  context = this;
                  /* eslint-enable @typescript-eslint/no-this-alias */
              }
              //检测handler是否被监听过
              // const handler = handlerFn as any;
              var isAdd = isNumber(handler._id);
              handler._id = UID();
              var handlerChain;
              for (var ii = 0, ll = eventTypes.length; ii < ll; ii++) {
                  evtType = eventTypes[ii];
                  var wrapKey = generateWrapKey(evtType);
                  if (handler[wrapKey]) {
                      handler[wrapKey]._id = handler._id;
                  }
                  handlerChain = this._eventMap[evtType];
                  if (!handlerChain) {
                      handlerChain = [];
                      this._eventMap[evtType] = handlerChain;
                  }
                  //没有监听过的handler直接入列
                  if (!isAdd) {
                      handlerChain.push({
                          handler: handler,
                          context: context
                      });
                      continue;
                  }
                  var l = handlerChain.length;
                  if (l > 0) {
                      for (var i = 0; i < l; i++) {
                          if (handler === handlerChain[i].handler && handlerChain[i].context === context) {
                              if (!GlobalConfig.isTest) {
                                  console.warn(this, "find '".concat(eventsOn, "' handler:"), handler, ' The old listener function will be removed');
                              }
                              return this;
                          }
                      }
                  }
                  handlerChain.push({
                      handler: handler,
                      context: context
                  });
              }
              return this;
          };
          /**
           * on方法的alias
           *
           * @english
           * Alias for [on]{@link Eventable.on}
           *
           * @param eventTypes     - event types to register, seperated by space if more than one.
           * @param handler        - handler function to be called
           * @param context        - the context of the handler
           */
          EventableMixin.prototype.addEventListener = function () {
              var _a;
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              return (_a = this.on).call.apply(_a, __spreadArray([this], __read(args), false));
          };
          /**
           * 与on方法作用类似，但监听方法只会执行一次
           *
           * @english
           * Same as on, except the listener will only get fired once and then removed.
           *
           * @param eventTypes         - event types to register, seperated by space if more than one.
           * @param handler            - listener handler
           * @param context            - the context of the handler
           * @example
           * foo.once('mousedown mousemove mouseup', onMouseEvent, foo);
           */
          EventableMixin.prototype.once = function (eventTypes, handler, context) {
              if (!isString(eventTypes)) {
                  eventTypes = eventTypes;
                  var once = {};
                  for (var p in eventTypes) {
                      if (eventTypes.hasOwnProperty(p)) {
                          once[p] = this._wrapOnceHandler(p, eventTypes[p], handler);
                      }
                  }
                  return this._switch('on', once);
              }
              eventTypes = eventTypes;
              var evetTypes = eventTypes.split(' ');
              for (var i = 0, l = evetTypes.length; i < l; i++) {
                  this.on(evetTypes[i], this._wrapOnceHandler(evetTypes[i], handler, context));
              }
              return this;
          };
          /**
           *
           * 取消对事件的监听
           *
           * @english
           * Unregister the event handler for the specified event types.
           *
           * @param eventsOff         - event types to unregister, seperated by space if more than one.
           * @param handler           - listener handler
           * @param context           - the context of the handler
           * @example
           * foo.off('mousedown mousemove mouseup', onMouseEvent, foo);
           */
          EventableMixin.prototype.off = function (eventsOff, handler, context) {
              if (!this._eventMap || !eventsOff) {
                  return this;
              }
              if (!isString(eventsOff)) {
                  return this._switch('off', eventsOff, handler);
              }
              if (!handler) {
                  return this;
              }
              //没有监听过的handler直接忽略
              if (!isNumber(handler._id)) {
                  return this;
              }
              eventsOff = eventsOff;
              var eventTypes = eventsOff.split(' ');
              var eventType, listeners, wrapKey;
              if (!context) {
                  /* eslint-disable @typescript-eslint/no-this-alias */
                  context = this;
                  /* eslint-enable @typescript-eslint/no-this-alias */
              }
              for (var j = 0, jl = eventTypes.length; j < jl; j++) {
                  eventType = eventTypes[j].toLowerCase();
                  wrapKey = generateWrapKey(eventType);
                  listeners = this._eventMap[eventType];
                  if (!listeners) {
                      continue;
                  }
                  for (var i = listeners.length - 1; i >= 0; i--) {
                      var listener = listeners[i];
                      if ((handler === listener.handler || handler === listener.handler[wrapKey]) && listener.context === context) {
                          delete listener.handler[wrapKey];
                          listeners.splice(i, 1);
                      }
                  }
                  if (!listeners.length) {
                      delete this._eventMap[eventType];
                  }
              }
              return this;
          };
          /**
           * off方法的别名 alias
           *
           * @english
           * Alias for [off]{@link Eventable.off}
           *
           * @param eventTypes       - event types to unregister, seperated by space if more than one.
           * @param handler          - listener handler
           * @param context          - the context of the handler
           */
          EventableMixin.prototype.removeEventListener = function () {
              var _a;
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              return (_a = this.off).call.apply(_a, __spreadArray([this], __read(args), false));
          };
          /**
           * 是否监听了指定的事件
           *
           * @english
           * Returns listener's count registered for the event type.
           *
           * @param eventType       - an event type
           * @param hanlder         - listener function
           * @param context         - the context of the handler
           */
          EventableMixin.prototype.listens = function (eventType, handler, context) {
              if (!this._eventMap || !isString(eventType)) {
                  return 0;
              }
              var handlerChain = this._eventMap[eventType.toLowerCase()];
              if (!handlerChain || !handlerChain.length) {
                  return 0;
              }
              if (!handler) {
                  return handlerChain.length;
              }
              for (var i = 0, len = handlerChain.length; i < len; i++) {
                  if (handler === handlerChain[i].handler &&
                      (isNil(context) || handlerChain[i].context === context)) {
                      return 1;
                  }
              }
              return 0;
          };
          /**
           * 返回所有监听的事件
           * @english
           * Get all the listening event types
           */
          EventableMixin.prototype.getListeningEvents = function () {
              if (!this._eventMap) {
                  return [];
              }
              return Object.keys(this._eventMap);
          };
          /**
           * 把事件监听拷贝给给定的目标对象
           * @english
           * Copy all the event listener to the target object
           * @param target - target object to copy to.
           */
          EventableMixin.prototype.copyEventListeners = function (target) {
              var eventMap = target._eventMap;
              if (!eventMap) {
                  return this;
              }
              var handlerChain;
              for (var eventType in eventMap) {
                  handlerChain = eventMap[eventType];
                  for (var i = 0, len = handlerChain.length; i < len; i++) {
                      this.on(eventType, handlerChain[i].handler, handlerChain[i].context);
                  }
              }
              return this;
          };
          /**
           * 触发一个事件，并执行所有监听该事件的handler方法
           *
           * @english
           * Fire an event, causing all handlers for that event name to run.
           *
           * @param  eventType - an event type to fire
           * @param  param     - parameters for the listener function.
           */
          EventableMixin.prototype.fire = function (eventType, param) {
              if (this._eventParent) {
                  return this._eventParent.fire.call(this._eventParent, eventType, param);
              }
              return this._fire.call(this, eventType, param);
          };
          //@internal
          EventableMixin.prototype._wrapOnceHandler = function (evtType, handler, context) {
              // const me = this;
              var key = generateWrapKey(evtType);
              var called = false;
              var fn = function onceHandler() {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i] = arguments[_i];
                  }
                  if (called) {
                      return;
                  }
                  delete fn[key];
                  called = true;
                  if (context) {
                      handler.call.apply(handler, __spreadArray([context], __read(args), false));
                  }
                  else {
                      handler.call.apply(handler, __spreadArray([this], __read(args), false));
                  }
                  onceHandler._called = true;
                  // me.off(evtType, onceHandler, this);
              };
              fn[key] = handler;
              return fn;
          };
          //@internal
          EventableMixin.prototype._switch = function (to, eventRecords, context) {
              for (var p in eventRecords) {
                  if (eventRecords.hasOwnProperty(p)) {
                      this[to](p, eventRecords[p], context);
                  }
              }
              return this;
          };
          //@internal
          EventableMixin.prototype._clearListeners = function (eventType) {
              if (!this._eventMap || !isString(eventType)) {
                  return;
              }
              var handlerChain = this._eventMap[eventType.toLowerCase()];
              if (!handlerChain) {
                  return;
              }
              this._eventMap[eventType] = null;
          };
          //@internal
          EventableMixin.prototype._clearAllListeners = function () {
              this._eventMap = null;
          };
          /**
           * 设置一个事件父级对象，用来代替执行所有的事件监听
           *
           * @english
           * Set a event parent to handle all the events
           * @param parent - event parent
           * @private
           * @internal
           */
          EventableMixin.prototype._setEventParent = function (parent) {
              this._eventParent = parent;
              return this;
          };
          //@internal
          EventableMixin.prototype._setEventTarget = function (target) {
              this._eventTarget = target;
              return this;
          };
          //@internal
          EventableMixin.prototype._fire = function (eventType, param) {
              if (!this._eventMap) {
                  return this;
              }
              eventType = eventType.toLowerCase();
              var handlerChain = this._eventMap[eventType];
              if (!handlerChain) {
                  return this;
              }
              if (!param) {
                  param = {
                      type: eventType,
                      target: this._eventTarget || this
                  };
              }
              param['type'] = eventType;
              param['target'] = this._eventTarget || this;
              //in case of deleting a listener in a execution, copy the handlerChain to execute.
              var queue = handlerChain.slice(0);
              var context, bubble, passed;
              for (var i = 0, len = queue.length; i < len; i++) {
                  if (!queue[i]) {
                      continue;
                  }
                  var handler = queue[i].handler;
                  if (handler._called) {
                      continue;
                  }
                  context = queue[i].context;
                  bubble = true;
                  passed = extend$2({}, param);
                  if (context) {
                      bubble = queue[i].handler.call(context, passed);
                  }
                  else {
                      bubble = queue[i].handler(passed);
                  }
                  //stops the event propagation if the handler returns false.
                  if (bubble === false) {
                      if (param['domEvent']) {
                          stopPropagation(param['domEvent']);
                      }
                  }
              }
              var eventQueue = this._eventMap[eventType];
              if (eventQueue) {
                  var queueExcludeOnce = [];
                  for (var i = 0, len = eventQueue.length; i < len; i++) {
                      var handler = eventQueue[i].handler;
                      if (!handler._called) {
                          queueExcludeOnce.push(eventQueue[i]);
                      }
                  }
                  this._eventMap[eventType] = queueExcludeOnce;
              }
              return this;
          };
          return EventableMixin;
      }(Base));
  }

  var Base$1 = /** @class */ (function () {
      function Base() {
      }
      return Base;
  }());
  /**
   * 所有交互Handler类的基类
   *
   * @english
   * Base class for all the interaction handlers
   * @category handler
   * @abstract
   * @protected
   */
  var Handler = /** @class */ (function (_super) {
      __extends(Handler, _super);
      function Handler(target) {
          var _this = _super.call(this) || this;
          //@internal
          _this._enabled = false;
          _this.target = target;
          return _this;
      }
      /**
       * 启用Handler
       *
       * @english
       * Enables the handler
       */
      Handler.prototype.enable = function () {
          if (this._enabled) {
              return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
      };
      /**
       * 停用Handler
       *
       * @english
       * Disables the handler
       */
      Handler.prototype.disable = function () {
          if (!this._enabled) {
              return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
      };
      /**
       * 检查Handler是否启用
       *
       * @english
       * Returns true if the handler is enabled.
       */
      Handler.prototype.enabled = function () {
          return !!this._enabled;
      };
      /**
       * 从target上移除Handler
       *
       * @english
       * remove handler from target
       */
      Handler.prototype.remove = function () {
          this.disable();
          delete this.target;
          delete this.dom;
      };
      return Handler;
  }(Eventable(Base$1)));

  /**
   *
   * 基类（Class）
   * 该库中所有的类都继承于该基类。
   * 该类提供了定义新类时常用的工具方法，如管理配置options，添加 init hooks 等。
   *
   * @english
   * This library uses ES2015 class system.
   * Class is the root class of class hierachy.
   * It provides utility methods to make it easier to manage configration options, merge mixins and add init hooks.
   *
   * @example
   * const defaultOptions = {
   *     'foo' : 'bar'
   * };
   * class Foo extends maptalks.Class {
   *     constructor(id, options) {
   *         super(options);
   *         this.setId(id);
   *     }
   *
   *     setId(id) {
   *         this.id = id;
   *     }
   *
   *     whenCreated() {
   *         // .....
   *     }
   * }
   *
   * Foo.mergeOptions(defaultOptions);
   *
   * Foo.addInitHook('whenCreated');
   * @category core
   */
  var Class = /** @class */ (function () {
      /**
       *
       * @english
       * Create an object, set options if given and call all the init hooks.<br />
       * Options is where the object manages its configuration. Options passed to the object will be merged with parent's instead of overriding it.
       *
       * @param options - options to set
       */
      function Class(options) {
          if (!this || !this.setOptions) {
              throw new Error('Class instance is being created without "new" operator.');
          }
          this.setOptions(options);
          this.callInitHooks();
          this._isUpdatingOptions = false;
      }
      Class.prototype.proxyOptions = function () {
          var _this = this;
          if (!Browser$1.proxy) {
              return this;
          }
          this.options = new Proxy(this.options, {
              set: function (target, key, value) {
                  key = key;
                  if (target[key] === value) {
                      return true;
                  }
                  target[key] = value;
                  if (_this._isUpdatingOptions) {
                      return true;
                  }
                  var opts = {};
                  opts[key] = value;
                  _this.config(opts);
                  return true;
              }
          });
          return this;
      };
      /**
       * 遍历并执行该类或父类用 addInitHook 添加的 init hooks
       *
       * @english
       * Visit and call all the init hooks defined on Class and its parents.
       */
      Class.prototype.callInitHooks = function () {
          var proto = Object.getPrototypeOf(this);
          this._visitInitHooks(proto);
          return this;
      };
      /**
       * 设置新的配置 options
       *
       * @english
       * Merges options with the default options of the object.
       * @param options - options to set
       */
      Class.prototype.setOptions = function (options) {
          if (!this.hasOwnProperty('options')) {
              this.options = this.options ? Object.create(this.options) : {};
          }
          if (!options) {
              return this;
          }
          for (var i in options) {
              this.options[i] = options[i];
          }
          return this;
      };
      /**
       *
       * 更新options中指定的配置项。
       * 1. 如果没有提供参数，则返回options配置对象
       * 2. 如果配置项有对应的handler，handler会被启用或停用，例如draggable
       *
       * @english
       * 1. Return object's options if no parameter is provided. <br/>
       * 2. update an option and enable/disable the handler if a handler with the same name existed.
       *
       * @example
       * // Get marker's options;
       * const options = marker.config();
       * // Set map's option "draggable" to false and disable map's draggable handler.
       * map.config('draggable', false);
       * // You can update more than one options like this:
       * map.config({
       *     'scrollWheelZoom' : false,
       *     'doubleClickZoom' : false
       * });
       * @param conf - config to update
       * @return
       */
      Class.prototype.config = function (conf, value) {
          this._isUpdatingOptions = true;
          if (!conf) {
              var config = {};
              for (var p in this.options) {
                  if (this.options.hasOwnProperty(p)) {
                      config[p] = this.options[p];
                  }
              }
              this._isUpdatingOptions = false;
              return config;
          }
          else {
              if (arguments.length === 2 && typeof conf === 'string') {
                  var t = {};
                  t[conf] = value;
                  conf = t;
              }
              conf = conf;
              for (var i in conf) {
                  this.options[i] = conf[i];
                  // enable/disable handler
                  if (this[i] && (this[i] instanceof Handler)) {
                      if (conf[i]) {
                          this[i].enable();
                      }
                      else {
                          this[i].disable();
                      }
                  }
              }
              // callback when set config
              this.onConfig(conf);
              this._isUpdatingOptions = false;
          }
          return this;
      };
      /* eslint-disable @typescript-eslint/no-unused-vars */
      /**
       * options被更新时的回调函数
       *
       * @english
       * Default callback when config is called
       *
       * @param conf - updated options
       */
      Class.prototype.onConfig = function (conf) {
      };
      /* eslint-enable @typescript-eslint/no-unused-vars */
      //@internal
      Class.prototype._visitInitHooks = function (proto) {
          if (this._initHooksCalled) {
              return;
          }
          var parentProto = Object.getPrototypeOf(proto);
          if (parentProto._visitInitHooks) {
              parentProto._visitInitHooks.call(this, parentProto);
          }
          this._initHooksCalled = true;
          var hooks = proto._initHooks;
          if (hooks && hooks !== parentProto._initHooks) {
              for (var i = 0; i < hooks.length; i++) {
                  hooks[i].call(this);
              }
          }
      };
      /**
       * 添加一个初始化钩子（init hook）方法，实例化时会被调用。
       * 该方法一般用于插件开发，利用初始化钩子，子类无需重载父类的构造函数（constructor），就可以在实例化时执行一些必要的逻辑
       *
       * @english
       * Add an init hook, which will be called when the object is initiated. <br>
       * It is useful in plugin developing to do things when creating objects without changing class's constructor.
       * @param fn - a hook function or name of the hook function
       * @param args - arguments for the init hook function
       */
      Class.addInitHook = function (fn) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          var init = typeof fn === 'function' ? fn : function () {
              var _a;
              (_a = this[fn]).call.apply(_a, __spreadArray([this], __read(args), false));
          };
          var proto = this.prototype;
          var parentProto = Object.getPrototypeOf(proto);
          if (!proto._initHooks || proto._initHooks === parentProto._initHooks) {
              proto._initHooks = [];
          }
          proto._initHooks.push(init);
          return this;
      };
      /**
       * 将一个或多个，sources中定义的方法或属性，mixin到该类的prototype中
       *
       * @english
       * Mixin the specified objects into the class as prototype properties or methods.
       * @param sources - objects to mixin
       */
      Class.include = function () {
          var sources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              sources[_i] = arguments[_i];
          }
          for (var i = 0; i < sources.length; i++) {
              extend$2(this.prototype, sources[i]);
          }
          return this;
      };
      /**
       * 用参数中的options定义扩展默认的options
       *
       * @english
       * Mixin options with the class's default options.
       * @param options - options to merge.
       */
      Class.mergeOptions = function (options) {
          var proto = this.prototype;
          var parentProto = Object.getPrototypeOf(proto);
          if (!proto.options || proto.options === parentProto.options) {
              proto.options = proto.options ? Object.create(proto.options) : {};
          }
          extend$2(proto.options, options);
          return this;
      };
      return Class;
  }());
  /* eslint-enable @typescript-eslint/ban-types */

  var Base = /** @class */ (function () {
      function Base() {
      }
      return Base;
  }());
  var GlobalEventable = /** @class */ (function (_super) {
      __extends(GlobalEventable, _super);
      function GlobalEventable() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return GlobalEventable;
  }(Eventable(Base)));
  // this is global event bus for doc state change
  // such as : devicePixelRatio ,visibilitychange,... etc
  var GlobalEvent = new GlobalEventable();
  var EVENT_DPR_CHANGE = 'dprchange';
  var EVENT_DOC_VISIBILITY_CHANGE = 'docvisibilitychange';
  var EVENT_DOC_DRAGSTART = 'dragstart';
  var EVENT_DOC_DRAGEND = 'dragend';
  //monitor devicePixelRatio change
  if (typeof window !== 'undefined' && window.matchMedia) {
      for (var i$1 = 1; i$1 < 500; i$1++) {
          var dpi = (i$1 * 0.01).toFixed(2);
          var screen_1 = window.matchMedia("screen and (resolution: ".concat(dpi, "dppx)"));
          if (screen_1) {
              if (screen_1.addEventListener) {
                  screen_1.addEventListener('change', Browser$1.checkDevicePixelRatio);
              }
              else if (screen_1.addListener) {
                  screen_1.addListener(Browser$1.checkDevicePixelRatio);
              }
          }
      }
  }
  if (Browser$1.devicePixelRatio) {
      var tempDPI_1 = Browser$1.devicePixelRatio;
      Object.defineProperty(Browser$1, 'devicePixelRatio', {
          get: function () {
              return tempDPI_1;
          },
          set: function (value) {
              if (value === tempDPI_1) {
                  return;
              }
              //when devicePixelRatio change force resize all layers
              tempDPI_1 = value;
              if (!Browser$1.monitorDPRChange) {
                  return;
              }
              GlobalEvent.fire(EVENT_DPR_CHANGE, { devicePixelRatio: value });
          }
      });
  }
  //monitor document visibilitychange change
  if (Browser$1.webgl && typeof document !== 'undefined') {
      addDomEvent(document, 'visibilitychange', function () {
          GlobalEvent.fire(EVENT_DOC_VISIBILITY_CHANGE, { visibilityState: document.visibilityState });
      });
      addDomEvent(document, 'dragstart', function () {
          GlobalEvent.fire(EVENT_DOC_DRAGSTART);
      });
      addDomEvent(document, 'dragend', function () {
          GlobalEvent.fire(EVENT_DOC_DRAGEND);
      });
  }

  var registeredTypes = {};
  /**
   * A helper mixin for JSON serialization.
   * @mixin JSONAble
   */
  function JSONAble (Base) {
      return /** @class */ (function (_super) {
          __extends(JSONAble, _super);
          function JSONAble() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          /**
           * 静态方法，用于将该类注册用于JSON序列化与反序列化
           *
           * @english
           * It is a static method. <br>
           * Register class for JSON serialization and assign a JSON type.
           * @param  type - JSON type
           */
          JSONAble.registerJSONType = function (type) {
              if (!type) {
                  return;
              }
              if (registeredTypes[type]) {
                  console.error("".concat(type, " has register. please use Different name for:"), this);
                  return;
              }
              registeredTypes[type] = this;
              return;
          };
          /**
           * 静态方法，返回type对应的注册类
           * @english
           * It is a static method. <br>
           * Get class of input JSON type
           * @param  type - JSON type
           */
          JSONAble.getJSONClass = function (type) {
              if (!type) {
                  return null;
              }
              return registeredTypes[type];
          };
          /**
           * 返回该类的JSON type
           * @english
           * Get object's JSON Type
           */
          JSONAble.prototype.getJSONType = function () {
              if (this._jsonType === undefined) {
                  var clazz = Object.getPrototypeOf(this).constructor;
                  for (var p in registeredTypes) {
                      if (registeredTypes[p] === clazz) {
                          this._jsonType = p;
                          break;
                      }
                  }
              }
              if (!this._jsonType) {
                  throw new Error('Found an unregistered Layer/Geometry class!');
              }
              return this._jsonType;
          };
          return JSONAble;
      }(Base));
  }

  var rbush$2 = {exports: {}};

  var quickselect$1 = {exports: {}};

  (function (module, exports) {
  	(function (global, factory) {
  		module.exports = factory() ;
  	}(commonjsGlobal, (function () {
  	function quickselect(arr, k, left, right, compare) {
  	    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  	}

  	function quickselectStep(arr, k, left, right, compare) {

  	    while (right > left) {
  	        if (right - left > 600) {
  	            var n = right - left + 1;
  	            var m = k - left + 1;
  	            var z = Math.log(n);
  	            var s = 0.5 * Math.exp(2 * z / 3);
  	            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
  	            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
  	            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
  	            quickselectStep(arr, k, newLeft, newRight, compare);
  	        }

  	        var t = arr[k];
  	        var i = left;
  	        var j = right;

  	        swap(arr, left, k);
  	        if (compare(arr[right], t) > 0) swap(arr, left, right);

  	        while (i < j) {
  	            swap(arr, i, j);
  	            i++;
  	            j--;
  	            while (compare(arr[i], t) < 0) i++;
  	            while (compare(arr[j], t) > 0) j--;
  	        }

  	        if (compare(arr[left], t) === 0) swap(arr, left, j);
  	        else {
  	            j++;
  	            swap(arr, j, right);
  	        }

  	        if (j <= k) left = j + 1;
  	        if (k <= j) right = j - 1;
  	    }
  	}

  	function swap(arr, i, j) {
  	    var tmp = arr[i];
  	    arr[i] = arr[j];
  	    arr[j] = tmp;
  	}

  	function defaultCompare(a, b) {
  	    return a < b ? -1 : a > b ? 1 : 0;
  	}

  	return quickselect;

  	}))); 
  } (quickselect$1));

  var quickselectExports = quickselect$1.exports;

  rbush$2.exports = rbush;
  rbush$2.exports.default = rbush;

  var quickselect = quickselectExports;

  function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format);

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
          this._initFormat(format);
      }

      this.clear();
  }

  rbush.prototype = {

      all: function () {
          return this._all(this.data, []);
      },

      search: function (bbox) {

          var node = this.data,
              result = [],
              toBBox = this.toBBox;

          if (!intersects(bbox, node)) return result;

          var nodesToSearch = [],
              i, len, child, childBBox;

          while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf) result.push(child);
                      else if (contains(bbox, childBBox)) this._all(child, result);
                      else nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return result;
      },

      collides: function (bbox) {

          var node = this.data,
              toBBox = this.toBBox;

          if (!intersects(bbox, node)) return false;

          var nodesToSearch = [],
              i, len, child, childBBox;

          while (node) {
              for (i = 0, len = node.children.length; i < len; i++) {

                  child = node.children[i];
                  childBBox = node.leaf ? toBBox(child) : child;

                  if (intersects(bbox, childBBox)) {
                      if (node.leaf || contains(bbox, childBBox)) return true;
                      nodesToSearch.push(child);
                  }
              }
              node = nodesToSearch.pop();
          }

          return false;
      },

      load: function (data) {
          if (!(data && data.length)) return this;

          if (data.length < this._minEntries) {
              for (var i = 0, len = data.length; i < len; i++) {
                  this.insert(data[i]);
              }
              return this;
          }

          // recursively build the tree with the given data from scratch using OMT algorithm
          var node = this._build(data.slice(), 0, data.length - 1, 0);

          if (!this.data.children.length) {
              // save as is if tree is empty
              this.data = node;

          } else if (this.data.height === node.height) {
              // split root if trees have the same height
              this._splitRoot(this.data, node);

          } else {
              if (this.data.height < node.height) {
                  // swap trees if inserted one is bigger
                  var tmpNode = this.data;
                  this.data = node;
                  node = tmpNode;
              }

              // insert the small tree into the large tree at appropriate level
              this._insert(node, this.data.height - node.height - 1, true);
          }

          return this;
      },

      insert: function (item) {
          if (item) this._insert(item, this.data.height - 1);
          return this;
      },

      clear: function () {
          this.data = createNode([]);
          return this;
      },

      remove: function (item, equalsFn) {
          if (!item) return this;

          var node = this.data,
              bbox = this.toBBox(item),
              path = [],
              indexes = [],
              i, parent, index, goingUp;

          // depth-first iterative tree traversal
          while (node || path.length) {

              if (!node) { // go up
                  node = path.pop();
                  parent = path[path.length - 1];
                  i = indexes.pop();
                  goingUp = true;
              }

              if (node.leaf) { // check current node
                  index = findItem(item, node.children, equalsFn);

                  if (index !== -1) {
                      // item found, remove the item and condense tree upwards
                      node.children.splice(index, 1);
                      path.push(node);
                      this._condense(path);
                      return this;
                  }
              }

              if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                  path.push(node);
                  indexes.push(i);
                  i = 0;
                  parent = node;
                  node = node.children[0];

              } else if (parent) { // go right
                  i++;
                  node = parent.children[i];
                  goingUp = false;

              } else node = null; // nothing found
          }

          return this;
      },

      toBBox: function (item) { return item; },

      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,

      toJSON: function () { return this.data; },

      fromJSON: function (data) {
          this.data = data;
          return this;
      },

      _all: function (node, result) {
          var nodesToSearch = [];
          while (node) {
              if (node.leaf) result.push.apply(result, node.children);
              else nodesToSearch.push.apply(nodesToSearch, node.children);

              node = nodesToSearch.pop();
          }
          return result;
      },

      _build: function (items, left, right, height) {

          var N = right - left + 1,
              M = this._maxEntries,
              node;

          if (N <= M) {
              // reached leaf level; return leaf
              node = createNode(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
          }

          if (!height) {
              // target height of the bulk-loaded tree
              height = Math.ceil(Math.log(N) / Math.log(M));

              // target number of root entries to maximize storage utilization
              M = Math.ceil(N / Math.pow(M, height - 1));
          }

          node = createNode([]);
          node.leaf = false;
          node.height = height;

          // split the items into M mostly square tiles

          var N2 = Math.ceil(N / M),
              N1 = N2 * Math.ceil(Math.sqrt(M)),
              i, j, right2, right3;

          multiSelect(items, left, right, N1, this.compareMinX);

          for (i = left; i <= right; i += N1) {

              right2 = Math.min(i + N1 - 1, right);

              multiSelect(items, i, right2, N2, this.compareMinY);

              for (j = i; j <= right2; j += N2) {

                  right3 = Math.min(j + N2 - 1, right2);

                  // pack each entry recursively
                  node.children.push(this._build(items, j, right3, height - 1));
              }
          }

          calcBBox(node, this.toBBox);

          return node;
      },

      _chooseSubtree: function (bbox, node, level, path) {

          var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

          while (true) {
              path.push(node);

              if (node.leaf || path.length - 1 === level) break;

              minArea = minEnlargement = Infinity;

              for (i = 0, len = node.children.length; i < len; i++) {
                  child = node.children[i];
                  area = bboxArea(child);
                  enlargement = enlargedArea(bbox, child) - area;

                  // choose entry with the least area enlargement
                  if (enlargement < minEnlargement) {
                      minEnlargement = enlargement;
                      minArea = area < minArea ? area : minArea;
                      targetNode = child;

                  } else if (enlargement === minEnlargement) {
                      // otherwise choose one with the smallest area
                      if (area < minArea) {
                          minArea = area;
                          targetNode = child;
                      }
                  }
              }

              node = targetNode || node.children[0];
          }

          return node;
      },

      _insert: function (item, level, isNode) {

          var toBBox = this.toBBox,
              bbox = isNode ? item : toBBox(item),
              insertPath = [];

          // find the best node for accommodating the item, saving all nodes along the path too
          var node = this._chooseSubtree(bbox, this.data, level, insertPath);

          // put the item into the node
          node.children.push(item);
          extend(node, bbox);

          // split on node overflow; propagate upwards if necessary
          while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                  this._split(insertPath, level);
                  level--;
              } else break;
          }

          // adjust bboxes along the insertion path
          this._adjustParentBBoxes(bbox, insertPath, level);
      },

      // split overflowed node into two
      _split: function (insertPath, level) {

          var node = insertPath[level],
              M = node.children.length,
              m = this._minEntries;

          this._chooseSplitAxis(node, m, M);

          var splitIndex = this._chooseSplitIndex(node, m, M);

          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;

          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);

          if (level) insertPath[level - 1].children.push(newNode);
          else this._splitRoot(node, newNode);
      },

      _splitRoot: function (node, newNode) {
          // split root node
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
      },

      _chooseSplitIndex: function (node, m, M) {

          var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

          minOverlap = minArea = Infinity;

          for (i = m; i <= M - m; i++) {
              bbox1 = distBBox(node, 0, i, this.toBBox);
              bbox2 = distBBox(node, i, M, this.toBBox);

              overlap = intersectionArea(bbox1, bbox2);
              area = bboxArea(bbox1) + bboxArea(bbox2);

              // choose distribution with minimum overlap
              if (overlap < minOverlap) {
                  minOverlap = overlap;
                  index = i;

                  minArea = area < minArea ? area : minArea;

              } else if (overlap === minOverlap) {
                  // otherwise choose distribution with minimum area
                  if (area < minArea) {
                      minArea = area;
                      index = i;
                  }
              }
          }

          return index;
      },

      // sorts node children by the best axis for split
      _chooseSplitAxis: function (node, m, M) {

          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
              compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
              xMargin = this._allDistMargin(node, m, M, compareMinX),
              yMargin = this._allDistMargin(node, m, M, compareMinY);

          // if total distributions margin value is minimal for x, sort by minX,
          // otherwise it's already sorted by minY
          if (xMargin < yMargin) node.children.sort(compareMinX);
      },

      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function (node, m, M, compare) {

          node.children.sort(compare);

          var toBBox = this.toBBox,
              leftBBox = distBBox(node, 0, m, toBBox),
              rightBBox = distBBox(node, M - m, M, toBBox),
              margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
              i, child;

          for (i = m; i < M - m; i++) {
              child = node.children[i];
              extend(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
          }

          for (i = M - m - 1; i >= m; i--) {
              child = node.children[i];
              extend(rightBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(rightBBox);
          }

          return margin;
      },

      _adjustParentBBoxes: function (bbox, path, level) {
          // adjust bboxes along the given tree path
          for (var i = level; i >= 0; i--) {
              extend(path[i], bbox);
          }
      },

      _condense: function (path) {
          // go through the path, removing empty nodes and updating bboxes
          for (var i = path.length - 1, siblings; i >= 0; i--) {
              if (path[i].children.length === 0) {
                  if (i > 0) {
                      siblings = path[i - 1].children;
                      siblings.splice(siblings.indexOf(path[i]), 1);

                  } else this.clear();

              } else calcBBox(path[i], this.toBBox);
          }
      },

      _initFormat: function (format) {
          // data format (minX, minY, maxX, maxY accessors)

          // uses eval-type function compilation instead of just accepting a toBBox function
          // because the algorithms are very sensitive to sorting functions performance,
          // so they should be dead simple and without inner calls

          var compareArr = ['return a', ' - b', ';'];

          this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
          this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

          this.toBBox = new Function('a',
              'return {minX: a' + format[0] +
              ', minY: a' + format[1] +
              ', maxX: a' + format[2] +
              ', maxY: a' + format[3] + '};');
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) return i;
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) continue;

          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  var rbushExports = rbush$2.exports;
  var rbush$1 = /*@__PURE__*/getDefaultExportFromCjs(rbushExports);

  //global temparary variables
  var search = {};
  /**
   * 碰撞检测的实现思路：
   * 1. 选择 collsionIndex
   *    1.1 如果 collision scope 是 layer，则在layer上创建
   *    1.2 如果 collision scope 是 map, 则直接使用map的collisionIndex
   * 2. painter中查询collisionIndex中是否有命中
   *   2.1 如果有，则从 elements 中删除当前item
   *   2.2 如果没有，如果需要的，insert到collisionIndex中
   */
  var CollisionIndex = /** @class */ (function () {
      function CollisionIndex() {
          this._tree = rbush$1(9, ['[0]', '[1]', '[2]', '[3]']);
      }
      /**
       * Test if given box is collided with any other
       * @param {Number[]} box - [minx, miny, maxx, maxy]
       * @returns {Boolean}
       */
      CollisionIndex.prototype.collides = function (box) {
          var _a;
          _a = __read(box, 4), search.minX = _a[0], search.minY = _a[1], search.maxX = _a[2], search.maxY = _a[3];
          return this._tree.collides(search);
      };
      /**
       * Insert box in collision index
       * @param {Number[]} box - [minx, miny, maxx, maxy]
       * @returns {CollisionIndex} this
       */
      CollisionIndex.prototype.insertBox = function (box) {
          var tree = this._tree;
          tree.insert(box);
          return this;
      };
      /**
       * Bulk insert boxes in collision index
       * Powered by rbush, it will perform better in subsquent query
       * @param {Number[][]} boxes - [[minx, miny, maxx, maxy], ...]
       * @returns {CollisionIndex} this
       */
      CollisionIndex.prototype.bulkInsertBox = function (boxes) {
          this._tree.load(boxes);
          return this;
      };
      /**
       * Clear the collision index
       * @returns {CollisionIndex} this
       */
      CollisionIndex.prototype.clear = function () {
          this._tree.clear();
          return this;
      };
      return CollisionIndex;
  }());

  /**
   * A mixin, to enable a class with [interaction handlers]{@link Handler}
   * @protected
   * @category handler
   * @mixin Handlerable
   */
  function Handlerable (Base) {
      return /** @class */ (function (_super) {
          __extends(Handlerable, _super);
          function Handlerable() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          /**
           * Register a handler
           * @param {String} name       - name of the handler
           * @param {Handler}           - handler class
           * @return {*} this
           * @protected
           * @function Handerable.addHandler
           */
          Handlerable.prototype.addHandler = function (name, handlerClass) {
              if (!handlerClass) {
                  return this;
              }
              if (!this._handlers) {
                  this._handlers = [];
              }
              //handler已经存在
              if (this[name]) {
                  this[name].enable();
                  return this;
              }
              var handler = this[name] = new handlerClass(this);
              this._handlers.push(handler);
              if (this.options[name]) {
                  handler.enable();
              }
              return this;
          };
          /**
           * Removes a handler
           * @param {String} name       - name of the handler
           * @return {*} this
           * @protected
           * @function Handerable.removeHandler
           */
          Handlerable.prototype.removeHandler = function (name) {
              if (!name) {
                  return this;
              }
              var handler = this[name];
              if (handler) {
                  //handler registered
                  var hit = this._handlers.indexOf(handler);
                  if (hit >= 0) {
                      this._handlers.splice(hit, 1);
                  }
                  this[name].remove();
                  delete this[name];
              }
              return this;
          };
          //@internal
          Handlerable.prototype._clearHandlers = function () {
              for (var i = 0, len = this._handlers.length; i < len; i++) {
                  this._handlers[i].remove();
              }
              this._handlers = [];
          };
          return Handlerable;
      }(Base));
  }

  var START_EVENTS = 'touchstart mousedown';
  var MOVE_EVENTS = {
      mousedown: 'mousemove',
      touchstart: 'touchmove',
      pointerdown: 'touchmove',
      MSPointerDown: 'touchmove'
  };
  var END_EVENTS = {
      mousedown: 'mouseup',
      touchstart: 'touchend',
      pointerdown: 'touchend',
      MSPointerDown: 'touchend'
  };
  /**
   * Drag handler
   * @category handler
   * @protected
   * @extends Handler
   */
  var DragHandler = /** @class */ (function (_super) {
      __extends(DragHandler, _super);
      function DragHandler(dom, options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, null) || this;
          _this.dom = dom;
          _this.options = options;
          return _this;
      }
      DragHandler.prototype.addHooks = function () {
          // throw new Error('Method not implemented.');
      };
      DragHandler.prototype.removeHooks = function () {
          // throw new Error('Method not implemented.');
      };
      DragHandler.prototype.enable = function () {
          if (!this.dom) {
              return this;
          }
          //create a dynamic method to resolve conflicts with other drag handler
          this._onMouseDown = function (e) {
              return this.onMouseDown(e);
          };
          on(this.dom, START_EVENTS, this._onMouseDown, this);
          return this;
      };
      DragHandler.prototype.disable = function () {
          if (!this.dom) {
              return this;
          }
          this._offEvents();
          off(this.dom, START_EVENTS, this._onMouseDown);
          delete this._onMouseDown;
          return this;
      };
      DragHandler.prototype.onMouseDown = function (event) {
          if (!this.options['rightclick'] && event.button === 2) {
              //ignore right mouse down
              return;
          }
          var toucheEvent = event;
          if (toucheEvent.touches && toucheEvent.touches.length > 1) {
              return;
          }
          if (this.options['cancelOn'] && this.options['cancelOn'](event) === true) {
              return;
          }
          var dom = this.dom;
          if (dom.setCapture) {
              dom.setCapture();
          }
          else if (window.captureEvents) {
              window.captureEvents();
              // window.captureEvents((window['Event'].MOUSEMOVE | window['Event'].MOUSEUP));
          }
          dom['ondragstart'] = function () {
              return false;
          };
          delete this.moved;
          var actual = toucheEvent.touches ? toucheEvent.touches[0] : event;
          this.startPos = new Point(actual.clientX, actual.clientY);
          off(document, MOVE_EVENTS[event.type], this.onMouseMove);
          off(document, END_EVENTS[event.type], this.onMouseUp);
          on(document, MOVE_EVENTS[event.type], this.onMouseMove, this);
          on(document, END_EVENTS[event.type], this.onMouseUp, this);
          if (!this.options['ignoreMouseleave']) {
              off(this.dom, 'mouseleave', this.onMouseUp);
              on(this.dom, 'mouseleave', this.onMouseUp, this);
          }
          this.fire('mousedown', {
              'domEvent': event,
              'mousePos': new Point(actual.clientX, actual.clientY)
          });
      };
      DragHandler.prototype.onMouseMove = function (event) {
          var toucheEvent = event;
          if (toucheEvent.touches && toucheEvent.touches.length > 1) {
              if (this.moved) {
                  this.interupted = true;
                  this.onMouseUp(event);
              }
              return;
          }
          var actual = toucheEvent.touches ? toucheEvent.touches[0] : event;
          var newPos = new Point(actual.clientX, actual.clientY), offset = newPos.sub(this.startPos);
          if (!offset.x && !offset.y) {
              return;
          }
          if (!this.moved) {
              this.fire('dragstart', {
                  'domEvent': event,
                  'mousePos': this.startPos.copy()
              });
              this.moved = true;
          }
          else {
              this.fire('dragging', {
                  'domEvent': event,
                  'mousePos': new Point(actual.clientX, actual.clientY)
              });
          }
      };
      DragHandler.prototype.onMouseUp = function (event) {
          var toucheEvent = event;
          var actual = toucheEvent.changedTouches ? toucheEvent.changedTouches[0] : event;
          this._offEvents();
          var param = {
              'domEvent': event
          };
          if (isNumber(actual.clientX)) {
              param['mousePos'] = new Point(parseInt(actual.clientX + '', 0), parseInt(actual.clientY + '', 0));
          }
          if (this.moved /* && this.moving*/) {
              param.interupted = this.interupted;
              this.fire('dragend', param);
              delete this.interupted;
              delete this.moved;
          }
          this.fire('mouseup', param);
      };
      //@internal
      DragHandler.prototype._offEvents = function () {
          var dom = this.dom;
          off(dom, 'mouseleave', this.onMouseUp);
          if ((typeof document === 'undefined') || (typeof window === 'undefined')) {
              return;
          }
          for (var i in MOVE_EVENTS) {
              off(document, MOVE_EVENTS[i], this.onMouseMove);
              off(document, END_EVENTS[i], this.onMouseUp);
          }
          if (dom['releaseCapture']) {
              dom['releaseCapture']();
          }
          else if (window.captureEvents) {
              window.captureEvents();
              // window.captureEvents(window['Event'].MOUSEMOVE | window['Event'].MOUSEUP);
          }
      };
      return DragHandler;
  }(Handler));

  /**
   * 坐标 `Coordinate` 的实现，例如一个地理坐标点（经度，纬度）
   *
   * @english
   *
   * Represents a coordinate point <br>
   * e.g. <br>
   * A geographical point (longitude, latitude)
   * @example
   *
   * ```ts
   * const coord = new Coordinate(0, 0);
   * ```
   * @example
   *
   * ```ts
   * const coord = new Coordinate([ 0, 0 ]);
   * ```
   * @example
   *
   * ```ts
   * const coord = new Coordinate({ x : 0, y : 0 });
   * ```
   * @category basic types
   */
  var Coordinate = /** @class */ (function (_super) {
      __extends(Coordinate, _super);
      function Coordinate() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Coordinate.toNumberArrays = function (coordinates) {
          if (!Array.isArray(coordinates)) {
              return coordinates.toArray();
          }
          return forEachCoord(coordinates, function (coord) {
              return coord.toArray();
          });
      };
      /**
       * 将一个或多个GeoJSON风格的坐标转换为坐标对象。
       *
       * @english
       *
       * Convert one or more GeoJSON style coordiantes to Coordinate objects
       * @param coordinates - coordinates to convert
       * @example
       *
       * ```ts
       * const coordinates = Coordinate.toCoordinates([[100,0], [101,1]]);
       * ```
       */
      Coordinate.toCoordinates = function (coordinates) {
          if (isNumber(coordinates[0]) && isNumber(coordinates[1])) {
              return new Coordinate(coordinates);
          }
          if (coordinates instanceof Coordinate) {
              return coordinates;
          }
          var result = [];
          for (var i = 0, len = coordinates.length; i < len; i++) {
              var child = coordinates[i];
              if (Array.isArray(child)) {
                  if (isNumber(child[0])) {
                      result.push(new Coordinate(child));
                  }
                  else {
                      result.push(Coordinate.toCoordinates(child));
                  }
              }
              else if (child instanceof Coordinate) {
                  result.push(child);
              }
              else {
                  result.push(new Coordinate(child));
              }
          }
          return result;
      };
      /**
       * 使用差值与另一个坐标进行比较，判断是否临近
       *
       * @english
       *
       * Compare with another Coordinate with a delta
       * @param p
       * @param delta
       */
      Coordinate.prototype.closeTo = function (p, delta) {
          if (!delta) {
              delta = 0;
          }
          return this.x >= (p.x - delta) && this.x <= (p.x + delta) &&
              this.y >= (p.y - delta) && this.y <= (p.y + delta);
      };
      /**
       * 返回该坐标的经纬度绝对值的坐标对象（不会改变原始数据）
       *
       * @english
       *
       * Return abs value of the coordinate
       * @returns abs Coordinate
       */
      Coordinate.prototype.abs = function () {
          return new Coordinate(Math.abs(this.x), Math.abs(this.y));
      };
      /**
       * 类似于数学中的四舍五入，对坐标的 x 和 y 进行舍入，返回一个新 Coordinate
       *
       * @english
       *
       * Like math.round, rounding the coordinate's xy.
       * @returns rounded coordinate
       */
      Coordinate.prototype.round = function () {
          return new Coordinate(Math.round(this.x), Math.round(this.y));
      };
      /**
       * 对坐标的 x 和 y 向上取整，返回一个新 Coordinate
       *
       * @english
       *
       * Like math.ceil, ceil the coordinate's xy.
       * @returns ceiled coordinate
       */
      Coordinate.prototype.ceil = function () {
          return new Coordinate(Math.ceil(this.x), Math.ceil(this.y));
      };
      /**
       * 对坐标的 x 和 y 向下取整，返回一个新 Coordinate
       *
       * @english
       *
       * Like math.floor, floor the coordinate's xy.
       * @returns floored coordinate
       */
      Coordinate.prototype.floor = function () {
          return new Coordinate(Math.floor(this.x), Math.floor(this.y));
      };
      /**
       * 返回当前坐标的 copy
       *
       * @english
       *
       * Returns a copy of the coordinate
       * @returns copy
       */
      Coordinate.prototype.copy = function () {
          return new Coordinate(this.x, this.y, this.z);
      };
      /**
       * 坐标数字保留指定位数的小数
       *
       * @english
       *
       * Formats coordinate number using fixed-coordinate notation.
       * @param n - The number of digits to appear after the decimal coordinate
       * @returns fixed coordinate
       */
      Coordinate.prototype.toFixed = function (n) {
          return new Coordinate(this.x.toFixed(n), this.y.toFixed(n), isNumber(this.z) ? this.z.toFixed(n) : undefined);
      };
      /**
       * 与传入坐标相加，返回一个新 Coordinate
       *
       * @english
       *
       * Returns the result of addition of another coordinate.
       * @param x - coordinate to add
       * @param y - coordinate to add
       * @returns result
       */
      Coordinate.prototype.add = function (x, y) {
          var nx, ny;
          if (!isNil(x.x)) {
              nx = this.x + x.x;
              ny = this.y + x.y;
          }
          else if (!isNil(x[0])) {
              nx = this.x + x[0];
              ny = this.y + x[1];
          }
          else {
              nx = this.x + x;
              ny = this.y + y;
          }
          return new Coordinate(nx, ny);
      };
      /**
       * 与传入坐标相减，返回一个新 Coordinate。
       *
       * @english
       *
       * Returns the result of subtraction of another coordinate.
       * @param x - coordinate to add
       * @param [y=undefined] - optional, coordinate to add
       * @returns result
       */
      Coordinate.prototype.sub = function (x, y) {
          var nx, ny;
          if (!isNil(x.x)) {
              nx = this.x - x.x;
              ny = this.y - x.y;
          }
          else if (!isNil(x[0])) {
              nx = this.x - x[0];
              ny = this.y - x[1];
          }
          else {
              nx = this.x - x;
              ny = this.y - y;
          }
          return new Coordinate(nx, ny);
      };
      /**
       * Returns the result of multiplication of the current coordinate by the given number.
       * @param ratio - ratio to multi
       * @returns result
       */
      Coordinate.prototype.multi = function (ratio) {
          return new Coordinate(this.x * ratio, this.y * ratio);
      };
      /**
       * 与另外一个 coordinate 进行比较，以查看它们是否相等
       *
       * @english
       *
       * Compare with another coordinate to see whether they are equal.
       * @param c - coordinate to compare
       */
      Coordinate.prototype.equals = function (c) {
          if (!(c instanceof this.constructor)) {
              return false;
          }
          return this.x === c.x && this.y === c.y && this.z === c.z;
      };
      return Coordinate;
  }(Position));

  /**
   * 表示由 [GeoJSON](http://geojson.org/geojson-spec.html#coordinate-reference-system-objects)定义的 CRS
   * @english
   *
   * Represent CRS defined by [GeoJSON]{@link http://geojson.org/geojson-spec.html#coordinate-reference-system-objects}
   *
   * @category geo
   */
  var CRS = /** @class */ (function () {
      /**
       * @param type type of the CRS
       * @param properties CRS's properties
       */
      function CRS(type, properties) {
          this.type = type;
          this.properties = properties;
      }
      /**
       * 使用 maptalks 创建 [proj4](https://github.com/OSGeo/proj.4) 形式的 CRS
       * @english
       * Create a [proj4](https://github.com/OSGeo/proj.4) style CRS used by maptalks <br>
       * @example
       * {
       *     "type"       : "proj4",
       *     "properties" : {
       *         "proj"   : "+proj=longlat +datum=WGS84 +no_defs"
       *     }
       * }
       * var crs_wgs84 = CRS.createProj4("+proj=longlat +datum=WGS84 +no_defs");
       * @param proj a proj4 projection string.
       */
      CRS.createProj4 = function (proj) {
          return new CRS('proj4', {
              'proj': proj
          });
      };
      /**
       * 使用 maptalks 创建 [epsg](https://spatialreference.org/ref/epsg/) 形式的 CRS
       * @english
       * Create a [epsg](https://spatialreference.org/ref/epsg/) style CRS used by maptalks <br>
       * @example
       * var crs_wgs84 = CRS.createProj4("EPSG:4326");
       * @param code a proj4 projection string.
       */
      CRS.fromProjectionCode = function (code) {
          if (!code) {
              return null;
          }
          code = code.toUpperCase().replace(':', '');
          return CRS[code] || null;
      };
      /* some common CRS definitions */
      /**
       * 预定义的WGS84坐标参考系统（也称为EPSG:4326）。
       * @english
       * Predefined CRS of well-known WGS84 (aka EPSG:4326)
       */
      CRS.WGS84 = CRS.createProj4('+proj=longlat +datum=WGS84 +no_defs');
      /**
       * 谷歌地图使用的投影坐标系统具有以下别名：'EPSG:3785'、'GOOGLE'、'EPSG:900913'。
       * @english
       * Projected Coordinate System used by google maps that has the following alias: 'EPSG:3785', 'GOOGLE', 'EPSG:900913'
       */
      CRS.EPSG3857 = CRS.createProj4('+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs');
      /**
       * 一个代表简单的笛卡尔坐标系统。<br>
       * 它直接映射x、y坐标，对于平面地图（例如室内地图、游戏地图）非常有用。
       *
       * @english
       * A CRS represents a simple Cartesian coordinate system. <br>
       * Maps x, y directly, is useful for maps of flat surfaces (e.g. indoor maps, game maps).
       */
      CRS.IDENTITY = CRS.createProj4('+proj=identity +no_defs');
      /**
       * 中国官方坐标系统（即EPSG:4490），在大多数情况下，可以认为与WGS84相同。
       *
       * @english
       * Official coordinate system in China (aka EPSG:4490), in most cases, it can be considered the same with WGS84.
       * @see  [7408](http://spatialreference.org/ref/sr-org/7408/)
       */
      CRS.CGCS2000 = CRS.createProj4('+proj=longlat +datum=CGCS2000');
      /**
       * CRS.CGCS2000 的别名
       *
       * @english
       * Alias for CRS.CGCS2000
       */
      CRS.EPSG4490 = CRS.CGCS2000;
      /**
       * 百度地图使用的投影坐标系统。
       *
       * @english
       * Projection used by [Baidu Map](http://map.baidu.com), a popular web map service in China.
       */
      CRS.BD09LL = CRS.createProj4('+proj=longlat +datum=BD09');
      /**
       * 中国的大多数在线地图服务中所使用一种加密的坐标参考系统（CRS）。
       *
       * @english
       * A encrypted CRS usded in the most online map services in China.
       * @see [Restrictions_on_geographic_data_in_China](https://en.wikipedia.org/wiki/Restrictions_on_geographic_data_in_China)
       */
      CRS.GCJ02 = CRS.createProj4('+proj=longlat +datum=GCJ02');
      return CRS;
  }());

  // temparary variables
  var TEMP_POINT0$4 = new Point(0, 0);
  var TEMP_COORD0$1 = new Coordinate(0, 0);
  var TEMP_COORD1$1 = new Coordinate(0, 0);
  var TEMP_COORD2 = new Coordinate(0, 0);
  var TEMP_COORD3 = new Coordinate(0, 0);
  var TEMP_COORD4 = new Coordinate(0, 0);
  var TEMP_COORD5 = new Coordinate(0, 0);
  var TEMP_COORD6 = new Coordinate(0, 0);
  var TEMP_COORD7 = new Coordinate(0, 0);
  var MINMAX = [];
  /* eslint-disable prefer-const */
  var TEMP_EXTENT$9;
  /* eslint-enable prefer-const */
  var TEMP_COMBINE = [];
  /**
   * 表示地图上的边界框，即具有最小和最大坐标的矩形地理区域。 <br>
   * 有多种方法可以创建范围：
   *
   * @english
   *
   * Represent a bounding box on the map, a rectangular geographical area with minimum and maximum coordinates. <br>
   * There are serveral ways to create a extent:
   * @category basic types
   * @example
   *
   * ```ts
   * //with 4 numbers: xmin, ymin, xmax and ymax
   * var extent = new Extent(100, 10, 120, 20);
   *
   * //with 2 coordinates
   * var extent = new Extent(new Coordinate(100, 10), new Coordinate(120, 20));
   *
   * //with a json object containing xmin, ymin, xmax and ymax
   * var extent = new Extent({xmin : 100, ymin: 10, xmax: 120, ymax:20});
   *
   * var extent1 = new Extent(100, 10, 120, 20);
   * //with another extent
   * var extent2 = new Extent(extent1);
   * ```
   */
  var Extent = /** @class */ (function () {
      function Extent() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          this._clazz = Coordinate;
          var l = args.length; // tip 最后一个参数是投影
          var proj = l > 0 ? args[l - 1] : null;
          if (proj && proj.unproject) {
              this.projection = args[l - 1];
          }
          this._dirty = true;
          this.antiMeridian = false;
          this._initialize(args[0], args[1], args[2], args[3]);
      }
      Extent.prototype._initialize = function (p1, p2, p3, p4) {
          /**
           * @property xmin - minimum x
           */
          this.xmin = null;
          /**
           * @property xmax - maximum x
           */
          this.xmax = null;
          /**
           * @property ymin - minimum y
           */
          this.ymin = null;
          /**
           * @property ymax - maximum y
           */
          this.ymax = null;
          if (isNil(p1)) {
              return;
          }
          var projection = this.projection;
          // Constructor 1: all numbers
          if (isNumber(p1) &&
              isNumber(p2) &&
              isNumber(p3) &&
              isNumber(p4)) {
              if (projection) {
                  this.set(p1, p2, p3, p4);
              }
              else {
                  this.set(Math.min(p1, p3), Math.min(p2, p4), Math.max(p1, p3), Math.max(p2, p4));
              }
              return;
          }
          else if (Array.isArray(p1)) {
              if (projection) {
                  this.set(p1[0], p1[1], p1[2], p1[3]);
              }
              else {
                  this.set(Math.min(p1[0], p1[2]), Math.min(p1[1], p1[3]), Math.max(p1[0], p1[2]), Math.max(p1[1], p1[3]));
              }
          }
          else if (isNumber(p1.x) &&
              isNumber(p2.x) &&
              isNumber(p1.y) &&
              isNumber(p2.y)) {
              // Constructor 2: two coordinates
              var tp1 = p1;
              var tp2 = p2;
              if (projection) {
                  this.set(tp1.x, tp1.y, tp2.x, tp2.y);
              }
              else {
                  if (tp1.x > tp2.x) {
                      this['xmin'] = tp2.x;
                      this['xmax'] = tp1.x;
                  }
                  else {
                      this['xmin'] = tp1.x;
                      this['xmax'] = tp2.x;
                  }
                  if (tp1.y > tp2.y) {
                      this['ymin'] = tp2.y;
                      this['ymax'] = tp1.y;
                  }
                  else {
                      this['ymin'] = tp1.y;
                      this['ymax'] = tp2.y;
                  }
              }
              // constructor 3: another extent or a object containing xmin, ymin, xmax and ymax
          }
          else if (isNumber(p1['xmin']) &&
              isNumber(p1['xmax']) &&
              isNumber(p1['ymin']) &&
              isNumber(p1['ymax'])) {
              this.set(p1['xmin'], p1['ymin'], p1['xmax'], p1['ymax']);
          }
      };
      Extent.prototype._add = function (p) {
          this._dirty = true;
          if (!isNil(p.x)) {
              this['xmin'] += p.x;
              this['ymin'] += p.y;
              this['xmax'] += p.x;
              this['ymax'] += p.y;
          }
          else if (!isNil(p.xmin)) {
              this['xmin'] += p.xmin;
              this['ymin'] += p.ymin;
              this['xmax'] += p.xmax;
              this['ymax'] += p.ymax;
          }
          else if (!isNil(p[0])) {
              this['xmin'] += p[0];
              this['ymin'] += p[1];
              this['xmax'] += p[0];
              this['ymax'] += p[1];
          }
          return this;
      };
      Extent.prototype.add = function (p) {
          var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
          return e._add(p);
      };
      /**
       * 缩放当前 extent
       *
       * @english
       *
       * scale extent
       *
       * @param s
       */
      Extent.prototype._scale = function (s) {
          this._dirty = true;
          this['xmin'] *= s;
          this['ymin'] *= s;
          this['xmax'] *= s;
          this['ymax'] *= s;
          return this;
      };
      Extent.prototype._sub = function (p) {
          this._dirty = true;
          if (!isNil(p.x)) {
              this['xmin'] -= p.x;
              this['ymin'] -= p.y;
              this['xmax'] -= p.x;
              this['ymax'] -= p.y;
          }
          else if (!isNil(p.xmin)) {
              this['xmin'] -= p.xmin;
              this['ymin'] -= p.ymin;
              this['xmax'] -= p.xmax;
              this['ymax'] -= p.ymax;
          }
          else if (!isNil(p[0])) {
              this['xmin'] -= p[0];
              this['ymin'] -= p[1];
              this['xmax'] -= p[0];
              this['ymax'] -= p[1];
          }
          return this;
      };
      Extent.prototype._substract = function (p) {
          return this._sub(p);
      };
      Extent.prototype.sub = function (p) {
          var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
          return e._sub(p);
      };
      Extent.prototype.substract = function (p) {
          return this.sub(p);
      };
      /**
       * 对 Extent 边界值进行四舍五入，返回一个新的 Extent
       *
       * @english
       *
       * Round the extent
       * @returns rounded extent
       */
      Extent.prototype.round = function () {
          return new this.constructor(Math.round(this['xmin']), Math.round(this['ymin']), Math.round(this['xmax']), Math.round(this['ymax']), this.projection);
      };
      /**
       * 对当前 Extent 边界值进行四舍五入
       *
       * @english
       *
       * Round the extent
       * @returns rounded extent
       */
      Extent.prototype._round = function () {
          this._dirty = true;
          this['xmin'] = Math.round(this['xmin']);
          this['ymin'] = Math.round(this['ymin']);
          this['xmax'] = Math.round(this['xmax']);
          this['ymax'] = Math.round(this['ymax']);
          return this;
      };
      Extent.prototype.getMin = function (out) {
          if (out) {
              out.set(this['xmin'], this['ymin']);
              return out;
          }
          return new this._clazz(this['xmin'], this['ymin']);
      };
      Extent.prototype.getMax = function (out) {
          if (out) {
              out.set(this['xmax'], this['ymax']);
              return out;
          }
          return new this._clazz(this['xmax'], this['ymax']);
      };
      /**
       * 获取 Extent 的中心点
       *
       * @english
       * Get center of the extent.
       * @params [out=undefined] - optional point to receive result
       */
      Extent.prototype.getCenter = function (out) {
          var x = (this['xmin'] + this['xmax']) / 2;
          var y = (this['ymin'] + this['ymax']) / 2;
          if (out) {
              out.set(x, y);
              return out;
          }
          return new this._clazz(x, y);
      };
      /**
       * 检查 Extent 是否有效
       *
       * @english
       * Whether the extent is valid
       * @protected
       */
      Extent.prototype.isValid = function () {
          return !isNil(this['xmin']) &&
              !isNil(this['ymin']) &&
              !isNil(this['xmax']) &&
              !isNil(this['ymax']);
      };
      /**
       * 与另一个 extent 进行比较它们是否相等
       *
       * @english
       *
       * Compare with another extent to see whether they are equal.
       * @param ext2 - extent to compare
       */
      Extent.prototype.equals = function (ext2) {
          return (this['xmin'] === ext2['xmin'] &&
              this['xmax'] === ext2['xmax'] &&
              this['ymin'] === ext2['ymin'] &&
              this['ymax'] === ext2['ymax']);
      };
      /**
       * 是否与另一个范围相交
       * @english
       *
       * Whether it intersects with another extent
       * @param ext2 - another extent
       */
      Extent.prototype.intersects = function (ext2) {
          this._project(this);
          this._project(ext2);
          var rxmin = Math.max(this['pxmin'], ext2['pxmin']);
          var rymin = Math.max(this['pymin'], ext2['pymin']);
          var rxmax = Math.min(this['pxmax'], ext2['pxmax']);
          var rymax = Math.min(this['pymax'], ext2['pymax']);
          return !((rxmin > rxmax) || (rymin > rymax));
      };
      /**
       * 判断当前 extent 是否在其他 extent 范围内
       * @english
       *
       * Whether the extent is within another extent
       * @param extent - another extent
       */
      Extent.prototype.within = function (extent) {
          this._project(this);
          this._project(extent);
          return this.pxmin >= extent.pxmin && this.pxmax <= extent.pxmax && this.pymin >= extent.pymin && this.pymax <= extent.pymax;
      };
      Extent.prototype.contains = function (c) {
          if (!c) {
              return false;
          }
          this._project(this);
          var proj = this.projection;
          if (proj) {
              var coord = TEMP_COORD0$1;
              if (Array.isArray(c)) {
                  coord.x = c[0];
                  coord.y = c[1];
                  c = proj.project(coord, coord);
              }
              else if (c.x !== undefined) {
                  coord.x = c.x;
                  coord.y = c.y;
                  c = proj.project(coord, coord);
              }
              else if (c.xmin !== undefined) {
                  this._project(c);
              }
          }
          return ((c.x || c.pxmin || 0) >= this.pxmin) &&
              ((c.x || c.pxmax || 0) <= this.pxmax) &&
              ((c.y || c.pymin || 0) >= this.pymin) &&
              ((c.y || c.pymax || 0) <= this.pymax);
      };
      /**
       * 获取Extent的宽度
       *
       * @english
       * Get the width of the Extent
       */
      Extent.prototype.getWidth = function () {
          return Math.abs(this['xmax'] - this['xmin']);
      };
      /**
       * 获取Extent的高度
       *
       * @english
       * Get the height of the Extent
       */
      Extent.prototype.getHeight = function () {
          return Math.abs(this['ymax'] - this['ymin']);
      };
      /**
       * 获取Extent的大小 - 高度和宽度构造的 Size 对象
       *
       * @english
       * Get size of the Extent
       */
      Extent.prototype.getSize = function () {
          return new Size(this.getWidth(), this.getHeight());
      };
      /**
       * 设置 extent 的边界值
       *
       * @english
       *
       * set extent value
       *
       * @param xmin
       * @param ymin
       * @param xmax
       * @param ymax
       */
      Extent.prototype.set = function (xmin, ymin, xmax, ymax) {
          this.xmin = xmin;
          this.ymin = ymin;
          this.xmax = xmax;
          this.ymax = ymax;
          this._dirty = true;
          return this;
      };
      Extent.prototype.__combine = function (extent) {
          if (extent.x !== undefined) {
              TEMP_EXTENT$9.xmin = TEMP_EXTENT$9.xmax = extent.x;
              TEMP_EXTENT$9.ymin = TEMP_EXTENT$9.ymax = extent.y;
              extent = TEMP_EXTENT$9;
          }
          this._project(extent);
          this._project(this);
          var inited = isNumber(this.pxmin);
          var xmin, ymin, xmax, ymax;
          if (!inited) {
              xmin = extent['pxmin'];
              ymin = extent['pymin'];
              xmax = extent['pxmax'];
              ymax = extent['pymax'];
          }
          else {
              xmin = Math.min(this['pxmin'], extent['pxmin']);
              ymin = Math.min(this['pymin'], extent['pymin']);
              xmax = Math.max(this['pxmax'], extent['pxmax']);
              ymax = Math.max(this['pymax'], extent['pymax']);
          }
          var proj = this.projection;
          if (proj) {
              TEMP_COORD1$1.set(xmin, ymin);
              TEMP_COORD2.set(xmax, ymax);
              var min = proj.unproject(TEMP_COORD1$1, TEMP_COORD1$1), max = proj.unproject(TEMP_COORD2, TEMP_COORD2);
              xmin = min.x;
              ymin = min.y;
              xmax = max.x;
              ymax = max.y;
          }
          TEMP_COMBINE[0] = xmin;
          TEMP_COMBINE[1] = ymin;
          TEMP_COMBINE[2] = xmax;
          TEMP_COMBINE[3] = ymax;
          return TEMP_COMBINE;
      };
      /**
       * 与其他 extent 合并
       * @english
       * Combine it with another extent to a larger extent.
       * @param extent - extent/coordinate/point to combine into
       * @returns extent combined
       */
      Extent.prototype._combine = function (extent) {
          // 传入的对象如果判断是非法的直接返回，不继续计算
          if (!extent || extent.isValid && !extent.isValid()) {
              return this;
          }
          var ext = this.__combine(extent);
          this.set(ext[0], ext[1], ext[2], ext[3]);
          this._dirty = true;
          return this;
      };
      /**
       * 与其他 extent 合并到一个更大的 extent，返回一个新 extent
       * @english
       * Combine it with another extent to a larger extent.
       * @param extent - extent/coordinate/point to combine into
       * @returns extent combined
       */
      Extent.prototype.combine = function (extent) {
          // 传入的对象如果判断是非法的直接返回，不继续计算
          if (!extent || extent.isValid && !extent.isValid()) {
              return this;
          }
          var ext = this.__combine(extent);
          return new this.constructor(ext[0], ext[1], ext[2], ext[3], this.projection);
      };
      /**
       * 获取当前 extent 与另一个 extent 的交集范围
       *
       * @english
       *
       * Gets the intersection extent of this and another extent.
       * @param extent - another extent
       * @returns intersection extent
       */
      Extent.prototype.intersection = function (extent) {
          if (!this.intersects(extent)) {
              return null;
          }
          TEMP_COORD3.x = Math.max(this['pxmin'], extent['pxmin']);
          TEMP_COORD3.y = Math.max(this['pymin'], extent['pymin']);
          TEMP_COORD4.x = Math.min(this['pxmax'], extent['pxmax']);
          TEMP_COORD4.y = Math.min(this['pymax'], extent['pymax']);
          var min = TEMP_COORD3, max = TEMP_COORD4;
          var proj = this.projection;
          if (proj) {
              min = proj.unproject(min, min);
              max = proj.unproject(max, max);
          }
          return new this.constructor(min, max, proj);
      };
      /**
       * 扩大 extent，返回一个新 Extent
       * @english
       *
       * Expand the extent by distance
       * @param distance  - distance to expand
       * @returns a new extent expanded from
       */
      Extent.prototype.expand = function (distance) {
          var w, h;
          if (!isNumber(distance)) {
              w = distance['width'] || distance['x'] || distance[0] || 0;
              h = distance['height'] || distance['y'] || distance[1] || 0;
          }
          else {
              w = h = distance;
          }
          return new this.constructor(this['xmin'] - w, this['ymin'] - h, this['xmax'] + w, this['ymax'] + h, this.projection);
      };
      /**
       * 扩大 extent
       * @english
       * Expand the extent by distance
       * @param distance  - distance to expand
       */
      Extent.prototype._expand = function (distance) {
          var w, h;
          if (!isNumber(distance)) {
              w = distance['width'] || distance['x'] || distance[0] || 0;
              h = distance['height'] || distance['y'] || distance[1] || 0;
          }
          else {
              w = h = distance;
          }
          this['xmin'] -= w;
          this['ymin'] -= h;
          this['xmax'] += w;
          this['ymax'] += h;
          this._dirty = true;
          return this;
      };
      /**
       * 获取 extent 的 JSON 对象。
       *
       * @english
       * Get extent's JSON object.
       * @returns jsonObject
       * @example
       *
       * ```ts
       * // {xmin : 100, ymin: 10, xmax: 120, ymax:20}
       * var json = extent.toJSON();
       * ```
       */
      Extent.prototype.toJSON = function () {
          return {
              'xmin': this['xmin'],
              'ymin': this['ymin'],
              'xmax': this['xmax'],
              'ymax': this['ymax']
          };
      };
      /**
       * 获取extent矩形区域的坐标数组，包含5个坐标，第一个坐标与最后一个坐标相等。
       * @english
       * Get a coordinate array of extent's rectangle area, containing 5 coordinates in which the first equals with the last.
       * @returns coordinates array
       */
      Extent.prototype.toArray = function (out) {
          var xmin = this['xmin'], ymin = this['ymin'], xmax = this['xmax'], ymax = this['ymax'];
          if (!out) {
              return [
                  new this._clazz([xmin, ymax]), new this._clazz([xmax, ymax]),
                  new this._clazz([xmax, ymin]), new this._clazz([xmin, ymin]),
                  new this._clazz([xmin, ymax])
              ];
          }
          else {
              out[0].x = xmin;
              out[0].y = ymax;
              out[1].x = xmax;
              out[1].y = ymax;
              out[2].x = xmax;
              out[2].y = ymin;
              out[3].x = xmin;
              out[3].y = ymin;
              out[4].x = xmin;
              out[4].y = ymax;
              return out;
          }
      };
      /**
       * 获取 extent 的 xmin、ymin、xmax、ymax 组成的字符串
       *
       * @english
       *
       * Get the string consisting of xmin, ymin, xmax, and ymax of extent
       */
      Extent.prototype.toString = function () {
          return "".concat(this.xmin, ",").concat(this.ymin, ",").concat(this.xmax, ",").concat(this.ymax);
      };
      /**
       * 复制 extent
       *
       * @english
       *
       * Get a copy of the extent.
       * @returns copy
       */
      Extent.prototype.copy = function () {
          return new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
      };
      Extent.prototype.convertTo = function (fn, out) {
          if (!this.isValid()) {
              return null;
          }
          var e = out || new this.constructor();
          if (out) {
              e.set(null, null, null, null);
          }
          var coord;
          if (this._clazz === Coordinate) {
              coord = TEMP_COORD5;
          }
          else if (this._clazz === Point) {
              coord = TEMP_POINT0$4;
          }
          coord.x = this.xmin;
          coord.y = this.ymax;
          e._combine(fn(coord));
          coord.x = this.xmax;
          e._combine(fn(coord));
          coord.y = this.ymin;
          e._combine(fn(coord));
          coord.x = this.xmin;
          e._combine(fn(coord));
          return e;
      };
      /**
       * 计算给定 Extent 的投影范围
       *
       * @english
       *
       * Calculate the projected range of the given Extent
       * @param ext extent
       */
      Extent.prototype._project = function (ext) {
          if (!ext || !ext.isValid()) {
              if (ext) {
                  ext.pxmin = ext.pxmax = ext.pymin = ext.pymax = null;
              }
              return;
          }
          var proj = this.projection;
          if (proj) {
              //FIXME a rare but potential bug:
              //An extent may be projected by multiple projection
              if (ext._dirty) {
                  TEMP_COORD6.set(ext.xmin, ext.ymin);
                  TEMP_COORD7.set(ext.xmax, ext.ymax);
                  MINMAX[0] = TEMP_COORD6;
                  MINMAX[1] = TEMP_COORD7;
                  var minmax = proj.projectCoords(MINMAX, this.antiMeridian);
                  var min = minmax[0], max = minmax[1];
                  ext.pxmin = Math.min(min.x, max.x);
                  ext.pymin = Math.min(min.y, max.y);
                  ext.pxmax = Math.max(min.x, max.x);
                  ext.pymax = Math.max(min.y, max.y);
              }
              delete ext._dirty;
          }
          else {
              ext.pxmin = ext.xmin;
              ext.pxmax = ext.xmax;
              ext.pymin = ext.ymin;
              ext.pymax = ext.ymax;
          }
      };
      return Extent;
  }());
  TEMP_EXTENT$9 = new Extent(0, 0, 0, 0);

  /**
   * 表示二维表面上的边界框，即具有最小点和最大点的矩形区域。 <br>
   * 有多种方法可以创建 PointExtent：
   *
   * @english
   * Represent a bounding box on 2d surface , a rectangular area with minimum and maximum points. <br>
   * There are serveral ways to create a PointExtent:
   * @category basic types
   * @example
   *
   * ```ts
   * // with 4 numbers
   * var extent = new PointExtent(100, 10, 120, 20);
   *
   * // with 2 points
   * var extent = new PointExtent(new Point(100, 10), new Point(120, 20));
   *
   * // with a json object containing xmin, ymin, xmax and ymax
   * var extent = new PointExtent({xmin : 100, ymin: 10, xmax: 120, ymax:20});
   *
   * var extent1 = new PointExtent(100, 10, 120, 20);
   * // with another extent
   * var extent2 = new PointExtent(extent1);
   * ```
   */
  var PointExtent = /** @class */ (function (_super) {
      __extends(PointExtent, _super);
      function PointExtent() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
          _this._clazz = Point;
          return _this;
      }
      return PointExtent;
  }(Extent));

  /**
   * 投影坐标和基础二维点系统之间的转换。
   * 内部使用的核心类，用于将地图（通常是地理）坐标映射到 2d 点
   *
   * @english
   * Transformation between projected coordinates and base 2d point system.
   * A core class used internally for mapping map's (usually geographical) coordinates to 2d points.<br>
   *
   * @category geo
   * @protected
   */
  var Transformation = /** @class */ (function () {
      /**
       * The base 2d point system is a fixed system that is consistent with HTML coordinate system: on X-Axis, left is smaller and right is larger; on Y-Axis, top is smaller and bottom is larger. <br>
       * As map's coordinates may not be in the same order(e.g. on a mercator projected earth, top is larger and bottom is smaller), <br>
       * transformation provides mapping functions to map arbitrary coordinates system to the fixed 2d point system. <br>
       * How to transform is decided by the constructor parameters which is a 4 number array [a, b, c, d]:<br>
       * a : the order scale of X-axis values 1 means right is larger and -1 means the reverse, left is larger;<br>
       * b : the order scale of Y-axis values 1 means bottom is larger and -1 means the reverse, top is larger;<br>
       * c : x of the origin point of the projected coordinate system <br>
       * d : y of the origin point of the projected coordinate system <br>
       * e.g.: Transformation parameters for Google map: [1, -1, -20037508.34, 20037508.34] <br>
       * @param  matrix transformation array
       */
      function Transformation(matrix) {
          this.matrix = matrix;
      }
      /**
       * 将投影坐标变换为二维点，
       * 变换/非变换方法中的参数scale用于在地图的不同缩放级别上缩放结果2d点。
       *
       * @english
       * Transform a projected coordinate to a 2d point. <br>
       * Parameter scale in transform/untransform method is used to scale the result 2d points on map's different zoom levels.
       * @param coordinates - projected coordinate to transform
       * @param scale - transform scale
       * @param out - tmp point
       * @returns 2d point.
       */
      Transformation.prototype.transform = function (coordinates, scale, out) {
          var x = this.matrix[0] * (coordinates.x - this.matrix[2]) / scale;
          var y = -this.matrix[1] * (coordinates.y - this.matrix[3]) / scale;
          if (out) {
              out.x = x;
              out.y = y;
              return out;
          }
          return new Point(x, y);
      };
      /**
       * 将 2d 点变换为投影坐标。
       *
       * @english
       *
       * Transform a 2d point to a projected coordinate.
       * @param point - 2d point
       * @param scale - transform scale
       * @param out tmp coordinates
       * @returns projected coordinate.
       */
      Transformation.prototype.untransform = function (point, scale, out) {
          var x = point.x * scale / this.matrix[0] + this.matrix[2];
          var y = point.y * scale / -this.matrix[1] + this.matrix[3];
          if (out) {
              out.x = x;
              out.y = y;
              return out;
          }
          return new Coordinate(x, y);
      };
      return Transformation;
  }());

  var CommonProjection = {
      code: '',
      is: function (code) {
          if (this.code === code) {
              return true;
          }
          if (!this.aliases) {
              return false;
          }
          for (var i = 0; i < this.aliases.length; i++) {
              if (this.aliases[i] === code) {
                  return true;
              }
          }
          return false;
      },
      /**
       * 将地理坐标投影到投影坐标（二维坐标）
       * @english
       * Project a geographical coordinate to a projected coordinate (2d coordinate)
       * @param p - coordinate to project
       * @function projection.Common.project
       */
      project: function (p) {
          return p;
      },
      /**
       * 将投影坐标转到地理坐标（二维坐标）
       *
       * @english
       * Unproject a projected coordinate to a geographical coordinate (2d coordinate)
       * @param p - coordinate to project
       * @function projection.Common.unproject
       */
      unproject: function (p) {
          return p;
      },
      /**
       * 批量将地理坐标投影到投影坐标
       *
       * @english
       * Project a group of geographical coordinates to projected coordinates.
       * @param coordinates - coordinates to project
       * @function projection.Common.projectCoords
       */
      projectCoords: function (coordinates, antiMeridian) {
          var _this = this;
          if (!coordinates) {
              return [];
          }
          if (!Array.isArray(coordinates)) {
              return this.project(coordinates);
          }
          if (coordinates.length === 0) {
              return [];
          }
          if (!this.isSphere()) {
              return forEachCoord(coordinates, this.project, this);
          }
          if (Array.isArray(coordinates[0])) {
              return coordinates.map(function (coords) { return _this.projectCoords(coords, antiMeridian); });
          }
          else {
              var antiMeridianEnable = antiMeridian;
              var circum = this.getCircum();
              // const extent = this.getSphereExtent(),
              //     sx = extent.sx,
              //     sy = extent.sy;
              // let wrapX, wrapY;
              var extent = this.getSphereExtent();
              var sy = extent.sy;
              var wrapY = void 0;
              var pre = coordinates[0], current = void 0, dx = void 0, dy = void 0, p = void 0;
              var prj = [this.project(pre)];
              for (var i = 1, l = coordinates.length; i < l; i++) {
                  current = coordinates[i];
                  dx = current.x - pre.x;
                  dy = current.y - pre.y;
                  p = this.project(current);
                  var isAntiMeridian = false;
                  if (Math.abs(dx) > 180 && antiMeridianEnable) {
                      //正轴无限扩展
                      // [[170, 80], [-170, 80]]
                      if (dx < 0) {
                          current.x = 180 + 180 - Math.abs(current.x);
                      }
                      else {
                          //负轴无限扩展
                          // [[-170, 80], [170, 80]]
                          current.x = -180 - (180 - Math.abs(current.x));
                      }
                      isAntiMeridian = true;
                      // if (wrapX === undefined) {
                      //     wrapX = current.x > pre.x;
                      // }
                      // if (wrapX) {
                      //     // p._add(-circum.x * sign(dx) * sx, 0);
                      //     // current._add(-360 * sign(dx), 0);
                      // }
                  }
                  if (Math.abs(dy) > 90 && antiMeridianEnable) {
                      if (wrapY === undefined) {
                          wrapY = current.y < pre.y;
                      }
                      if (wrapY) {
                          p._add(0, -circum.y * sign(dy) * sy);
                          current._add(0, -180 * sign(dy));
                      }
                  }
                  if (isAntiMeridian) {
                      p = this.project(current);
                  }
                  pre = current;
                  prj.push(p);
              }
              return prj;
          }
      },
      /**
       * 批量将投影坐标转到地理坐标
       *
       * @english
       * Unproject a group of projected coordinates to geographical coordinates.
       * @param projCoords - projected coordinates to unproject
       * @function projection.Common.unprojectCoords
       */
      unprojectCoords: function (projCoords) {
          if (!projCoords) {
              return [];
          }
          if (!Array.isArray(projCoords)) {
              return this.unproject(projCoords);
          }
          return forEachCoord(projCoords, this.unproject, this);
      },
      /**
       * 投影是否为球面
       *
       * @english
       * Whether the projection is spherical
       */
      isSphere: function () {
          return !!this.sphere;
      },
      /**
       * 判断传入的投影坐标是否超出椭球体范围
       *
       * @english
       * If the projected coord out of the sphere
       * @param pcoord projected coord
       * @return {Boolean}
       */
      isOutSphere: function (pcoord) {
          if (!this.isSphere()) {
              return false;
          }
          var extent = this.getSphereExtent();
          return !extent.contains(pcoord);
      },
      /**
       * 限制投影坐标在球体中
       *
       * @english
       * Wrap the projected coord in the sphere
       * @param pcoord projected coord
       * @returns wrapped projected coord
       */
      wrapCoord: function (pcoord) {
          if (!this.isSphere()) {
              return pcoord;
          }
          var extent = this.getSphereExtent();
          var wrapped = new Coordinate(pcoord);
          if (!extent.contains(wrapped)) {
              wrapped.x = wrap(pcoord.x, extent.xmin, extent.xmax);
              wrapped.y = wrap(pcoord.y, extent.ymin, extent.ymax);
          }
          return wrapped;
      },
      getCircum: function () {
          if (!this.circum && this.isSphere()) {
              var extent = this.getSphereExtent();
              this.circum = {
                  x: extent.getWidth(),
                  y: extent.getHeight()
              };
          }
          return this.circum;
      },
      getSphereExtent: function () {
          if (!this.extent && this.isSphere()) {
              var max = this.project(new Coordinate(180, 90)), min = this.project(new Coordinate(-180, -90));
              this.extent = new Extent(min, max, this);
              this.extent.sx = max.x > min.x ? 1 : -1;
              this.extent.sy = max.y > min.y ? 1 : -1;
          }
          return this.extent;
      }
  };

  var common = {
      /**
       * 测量两点之间的距离
       *
       * @english
       * Measure length between coordinate c1 and coordinate c2
       * @param c1 coordinate
       * @param c2 coordinate
       * @returns length
       */
      measureLength: function (c1, c2) {
          if (!Array.isArray(c1)) {
              return this.measureLenBetween(c1, c2);
          }
          var len = 0;
          for (var i = 0, l = c1.length; i < l - 1; i++) {
              len += this.measureLenBetween(c1[i], c1[i + 1]);
          }
          return len;
      }
  };

  var identity = {
      /**
       * the code of the measurer
       */
      'measure': 'IDENTITY',
      /**
       * 计算两个坐标之间的距离
       *
       * @english
       * Measure the length between 2 coordinates.
       * @param c1
       * @param c2
       */
      measureLenBetween: function (c1, c2) {
          if (!c1 || !c2) {
              return 0;
          }
          try {
              return Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
          }
          catch (err) {
              return 0;
          }
      },
      /**
       * 测量给定闭合坐标的面积
       *
       * @english
       * Measure the area closed by the given coordinates.
       * @param coordinates
       */
      measureArea: function (coordinates) {
          if (!Array.isArray(coordinates)) {
              return 0;
          }
          var area = 0;
          for (var i = 0, len = coordinates.length; i < len; i++) {
              var c1 = coordinates[i];
              var c2 = null;
              if (i === len - 1) {
                  c2 = coordinates[0];
              }
              else {
                  c2 = coordinates[i + 1];
              }
              area += c1.x * c2.y - c1.y * c2.x;
          }
          return Math.abs(area / 2);
      },
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c
       * @param xDist
       * @param yDist
       * @param out
       */
      locate: function (c, xDist, yDist, out) {
          out = out || new Coordinate(0, 0);
          out.set(c.x, c.y);
          return this._locate(out, xDist, yDist);
      },
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标（这是一个私有方法）
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c     - source coordinate
       * @param xDist     - x-axis distance
       * @param yDist     - y-axis distance
       * @private
       */
      _locate: function (c, xDist, yDist) {
          if (!c) {
              return null;
          }
          if (!xDist) {
              xDist = 0;
          }
          if (!yDist) {
              yDist = 0;
          }
          if (!xDist && !yDist) {
              return c;
          }
          c.x = c.x + xDist;
          c.y = c.y + yDist;
          return c;
      },
      /**
       * 绕枢轴旋转给定角度的坐标
       *
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       */
      rotate: function (c, pivot, angle) {
          c = new Coordinate(c.x, c.y);
          return this._rotate(c, pivot, angle);
      },
      /**
       * 绕枢轴旋转给定角度的坐标
       *
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       * @private
       */
      _rotate: function () {
          var tmp = new Point(0, 0);
          return function (c, pivot, angle) {
              tmp.x = c.x - pivot.x;
              tmp.y = c.y - pivot.y;
              tmp._rotate(angle * Math.PI / 180);
              c.x = pivot.x + tmp.x;
              c.y = pivot.y + tmp.y;
              return c;
          };
      }()
  };
  var extended = extend$2(identity, common);

  /**
   * 具有 Sphere 通用测量方法的辅助类。
   *
   * @english
   * A helper class with common measure methods for Sphere.
   * @group measurer
   * @private
   */
  var Sphere = /** @class */ (function () {
      /**
       * @param radius Sphere's radius
       */
      function Sphere(radius) {
          this.radius = radius;
      }
      /**
       * 计算两个坐标之间的距离
       *
       * @english
       * Measure the length between 2 coordinates.
       * @param c1
       * @param c2
       */
      Sphere.prototype.measureLenBetween = function (c1, c2) {
          if (!c1 || !c2) {
              return 0;
          }
          var b = toRadian(c1.y);
          var d = toRadian(c2.y), e = b - d, f = toRadian(c1.x) - toRadian(c2.x);
          b = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(e / 2), 2) + Math.cos(b) * Math.cos(d) * Math.pow(Math.sin(f / 2), 2)));
          b *= this.radius;
          return b;
      };
      /**
       * 测量给定闭合坐标的面积
       *
       * @english
       * Measure the area closed by the given coordinates.
       * @param coordinates
       */
      Sphere.prototype.measureArea = function (coordinates) {
          var a = toRadian(this.radius);
          var b = 0;
          var c = coordinates;
          var d = c.length;
          if (d < 3) {
              return 0;
          }
          var i;
          for (i = 0; i < d - 1; i++) {
              var e_1 = c[i], f_1 = c[i + 1];
              b += e_1.x * a * Math.cos(toRadian(e_1.y)) * f_1.y * a - f_1.x * a * Math.cos(toRadian(f_1.y)) * e_1.y * a;
          }
          var e = c[i];
          var f = c[0];
          b += e.x * a * Math.cos(toRadian(e.y)) * f.y * a - f.x * a * Math.cos(toRadian(f.y)) * e.y * a;
          return 0.5 * Math.abs(b);
      };
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c
       * @param xDist
       * @param yDist
       * @param out
       */
      Sphere.prototype.locate = function (c, xDist, yDist, out) {
          out = out || new Coordinate(0, 0);
          out.set(c.x, c.y);
          return this._locate(out, xDist, yDist);
      };
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c     - source coordinate
       * @param xDist     - x-axis distance
       * @param yDist     - y-axis distance
       * @private
       */
      Sphere.prototype._locate = function (c, xDist, yDist) {
          if (!c) {
              return null;
          }
          if (!xDist) {
              xDist = 0;
          }
          if (!yDist) {
              yDist = 0;
          }
          if (!xDist && !yDist) {
              return c;
          }
          var x, y;
          var ry = toRadian(c.y);
          if (yDist !== 0) {
              var dy = Math.abs(yDist);
              var sy = Math.sin(dy / (2 * this.radius)) * 2;
              ry = ry + sy * (yDist > 0 ? 1 : -1);
              y = wrap(ry * 180 / Math.PI, -90, 90);
          }
          else {
              y = c.y;
          }
          if (xDist !== 0) {
              // distance per degree
              var dx = Math.abs(xDist);
              var rx = toRadian(c.x);
              var sx = 2 * Math.sqrt(Math.pow(Math.sin(dx / (2 * this.radius)), 2) / Math.pow(Math.cos(ry), 2));
              rx = rx + sx * (xDist > 0 ? 1 : -1);
              x = wrap(rx * 180 / Math.PI, -180, 180);
          }
          else {
              x = c.x;
          }
          c.x = x;
          c.y = y;
          return c;
      };
      /**
       * 绕枢轴旋转给定角度的坐标
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       */
      Sphere.prototype.rotate = function (c, pivot, angle) {
          var coordinate = new Coordinate(c);
          return this._rotate(coordinate, pivot, angle);
      };
      /**
       * 绕枢轴旋转给定角度的坐标
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       * @private
       */
      Sphere.prototype._rotate = function (c, pivot, angle) {
          var initialAngle = rhumbBearing(pivot, c);
          var finalAngle = initialAngle - angle;
          var distance = this.measureLenBetween(pivot, c);
          c.x = pivot.x;
          c.y = pivot.y;
          return calculateRhumbDestination(c, distance, finalAngle, this.radius);
      };
      return Sphere;
  }());
  // from turf.js
  function rhumbBearing(start, end, options) {
      if (options === void 0) { options = {}; }
      var bear360;
      if (options.final)
          bear360 = calculateRhumbBearing(end, start);
      else
          bear360 = calculateRhumbBearing(start, end);
      return (bear360 > 180) ? -(360 - bear360) : bear360;
  }
  function calculateRhumbBearing(from, to) {
      // φ => phi
      // Δλ => deltaLambda
      // Δψ => deltaPsi
      // θ => theta
      var phi1 = toRadian(from.y);
      var phi2 = toRadian(to.y);
      var deltaLambda = toRadian((to.x - from.x));
      // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:
      if (deltaLambda > Math.PI)
          deltaLambda -= 2 * Math.PI;
      if (deltaLambda < -Math.PI)
          deltaLambda += 2 * Math.PI;
      var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var theta = Math.atan2(deltaLambda, deltaPsi);
      return (toDegree(theta) + 360) % 360;
  }
  function calculateRhumbDestination(origin, distance, bearing, radius) {
      // φ => phi
      // λ => lambda
      // ψ => psi
      // Δ => Delta
      // δ => delta
      // θ => theta
      var delta = distance / radius; // angular distance in radians
      var lambda1 = origin.x * Math.PI / 180; // to radians, but without normalize to 𝜋
      var phi1 = toRadian(origin.y);
      var theta = toRadian(bearing);
      var DeltaPhi = delta * Math.cos(theta);
      var phi2 = phi1 + DeltaPhi;
      // check for some daft bugger going past the pole, normalise latitude if so
      if (Math.abs(phi2) > Math.PI / 2)
          phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1); // E-W course becomes ill-conditioned with 0/0
      var DeltaLambda = delta * Math.sin(theta) / q;
      var lambda2 = lambda1 + DeltaLambda;
      origin.x = ((lambda2 * 180 / Math.PI) + 540) % 360 - 180;
      origin.y = phi2 * 180 / Math.PI;
      return origin; // normalise to −180..+180°
  }
  var wgs84 = {
      'measure': 'EPSG:4326',
      sphere: new Sphere(6378137),
      /**
       * 计算两个坐标之间的距离
       *
       * @english
       * Measure the length between 2 coordinates.
       * @param c1
       * @param c2
       */
      measureLenBetween: function (c1, c2) {
          return this.sphere.measureLenBetween(c1, c2);
      },
      /**
       * 计算给定闭合坐标的面积
       *
       * @english
       * Measure the area closed by the given coordinates.
       * @param coordinates
       */
      measureArea: function (coordinates) {
          return this.sphere.measureArea.call(this.sphere, coordinates);
      },
      _locate: function (c, xDist, yDist) {
          return this.sphere._locate.call(this.sphere, c, xDist, yDist);
      },
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c - source coordinate
       * @param xDist - x-axis distance
       * @param yDist - y-axis distance
       * @param out - out
       */
      locate: function (c, xDist, yDist, out) {
          return this.sphere.locate.call(this.sphere, c, xDist, yDist, out);
      },
      _rotate: function (c, pivot, angle) {
          return this.sphere._rotate.call(this.sphere, c, pivot, angle);
      },
      /**
       * 绕枢轴旋转给定角度的坐标
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       */
      rotate: function (c, pivot, angle) {
          return this.sphere.rotate.call(this.sphere, c, pivot, angle);
      }
  };
  /**
   * WGS84 椭球球体
   * @english
   * WGS84 Sphere measurer.
   * @category geo
   * @protected
   * @group measurer
   * @module WGS84Sphere
   * {@inheritDoc measurer.Common}
   */
  var WGS84Sphere = extend$2(wgs84, common);
  var baidu = {
      'measure': 'BAIDU',
      sphere: new Sphere(6370996.81),
      /**
       * 计算两个坐标之间的距离
       *
       * @english
       * Measure the length between 2 coordinates.
       * @param c1
       * @param c2
       */
      measureLenBetween: function (c1, c2) {
          return this.sphere.measureLenBetween.call(this.sphere, c1, c2);
      },
      /**
       * 计算给定闭合坐标的面积
       *
       * @english
       * Measure the area closed by the given coordinates.
       * @param coordinates
       */
      measureArea: function (coordinates) {
          return this.sphere.measureArea.call(this.sphere, coordinates);
      },
      _locate: function (c, xDist, yDist) {
          return this.sphere._locate.call(this.sphere, c, xDist, yDist);
      },
      /**
       * 使用 x 轴距离和 y 轴距离从给定源坐标定位坐标。
       * @english
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param c - source coordinate
       * @param xDist - x-axis distance
       * @param yDist - y-axis distance
       * @param out - out
       */
      locate: function (c, xDist, yDist, out) {
          return this.sphere.locate.call(this.sphere, c, xDist, yDist, out);
      },
      _rotate: function (c, pivot, angle) {
          return this.sphere._rotate.call(this.sphere, c, pivot, angle);
      },
      /**
       * 绕枢轴旋转给定角度的坐标
       * @english
       * Rotate a coordinate of given angle around pivot
       * @param c  - source coordinate
       * @param pivot - pivot
       * @param angle - angle in degree
       */
      rotate: function (c, pivot, angle) {
          return this.sphere.rotate.call(this.sphere, c, pivot, angle);
      }
  };
  /**
   * 百度地图所使用的椭球体
   *
   * @english
   * Baidu sphere measurer
   * @category geo
   * @protected
   * @group measurer
   * @module BaiduSphere
   * {@inheritDoc measurer.Common}
   */
  var BaiduSphere = extend$2(baidu, common);

  /** @namespace measurer */
  /**
   * 默认 measurer, [WGS84Sphere]{@link WGS84Sphere}
   * @english
   * Default measurer, [WGS84Sphere]{@link WGS84Sphere}
   *
   * @category geo
   * @protected
   * @group measurer
   * @module DEFAULT
   * {@inheritDoc measurer.WGS84Sphere}
   */
  var DEFAULT$1 = WGS84Sphere;
  var measurers = {};
  function registerMeasurer(m) {
      measurers[m.measure] = m;
  }
  registerMeasurer(extended);
  registerMeasurer(WGS84Sphere);
  registerMeasurer(BaiduSphere);
  /**
   * 带有测量功能的方法，不能直接初始化。
   * Measurer提供了地理计算的方法，例如长度和面积测量等。
   *
   * @english
   * Utilities with measurers. It is static and should not be initiated.<br>
   * Measurer provides methods for geographical computations such as length and area measuring, etc.
   * @module Measurer
   * @group measurer
   * @category geo
   */
  var Measurer = {
      /**
       * 获取量测计算的实例
       *
       * @english
       * Get a measurer instance.
       * @param name - code of the measurer: 'EPSG:4326', 'Identity', 'BAIDU'
       * @returns a measurer object
       * @function Measurer.getInstance
       */
      getInstance: function (name) {
          if (!name) {
              return DEFAULT$1;
          }
          for (var p in measurers) {
              if (hasOwn(measurers, p)) {
                  var mName = measurers[p]['measure'];
                  if (!mName) {
                      continue;
                  }
                  if (name.toLowerCase() === mName.toLowerCase()) {
                      return measurers[p];
                  }
              }
          }
          return null;
      }
  };

  var index$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BaiduSphere: BaiduSphere,
    DEFAULT: DEFAULT$1,
    Identity: extended,
    Measurer: Measurer,
    WGS84Sphere: WGS84Sphere
  });

  var delta = 1E-7;
  var EPSG3857Projection = {
      /**
       * "EPSG:3857", Code of the projection
       * @constant
       */
      code: 'EPSG:3857',
      rad: Math.PI / 180,
      metersPerDegree: 6378137 * Math.PI / 180,
      maxLatitude: 85.0511287798,
      project: function (lnglat, out) {
          var rad = this.rad, metersPerDegree = this.metersPerDegree, max = this.maxLatitude;
          var lng = lnglat.x, lat = Math.max(Math.min(max, lnglat.y), -max);
          var c;
          if (lat === 0) {
              c = 0;
          }
          else {
              c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;
          }
          var x = lng * metersPerDegree;
          var y = c * metersPerDegree;
          if (out) {
              out.x = x;
              out.y = y;
              return out;
          }
          return new Coordinate(x, y);
      },
      unproject: function (pLnglat, out) {
          var rad = this.rad;
          var metersPerDegree = this.metersPerDegree;
          var x = pLnglat.x / metersPerDegree;
          var y = pLnglat.y;
          var c;
          if (y === 0) {
              c = 0;
          }
          else {
              c = y / metersPerDegree;
              c = (2 * Math.atan(Math.exp(c * rad)) - Math.PI / 2) / rad;
          }
          if (Math.abs(Math.abs(x) - 180) < delta) {
              x = sign(x) * 180;
          }
          if (Math.abs(Math.abs(c) - this.maxLatitude) < delta) {
              c = sign(c) * this.maxLatitude;
          }
          // const rx = wrap(x, -180, 180);
          // const ry = wrap(c, -this.maxLatitude, this.maxLatitude);
          var rx = x;
          var ry = c;
          if (out) {
              out.x = rx;
              out.y = ry;
              return out;
          }
          return new Coordinate(rx, ry);
      }
  };
  /**
   * Google 地图或 OSM 地图使用的常规投影，又名墨卡托投影。<br>
   * 这是地图的默认投影。
   *
   * @english
   * Well-known projection used by Google maps or Open Street Maps, aka Mercator Projection.<br>
   * It is map's default projection.
   *
   * @category geo
   * @protected
   * @group projection
   * @name EPSG3857
   * {@inheritDoc projection.Common}
   * {@inheritDoc measurer.WGS84Sphere}
   */
  var EPSG3857 = extend$2({}, CommonProjection, EPSG3857Projection, WGS84Sphere);

  var EPSG4326Projection = {
      /**
       * "EPSG:4326", Code of the projection
       * @constant
       */
      code: 'EPSG:4326',
      aliases: ['EPSG:4490'],
      project: function (p, out) {
          if (out) {
              out.x = p.x;
              out.y = p.y;
              return out;
          }
          return new Coordinate(p);
      },
      unproject: function (p, out) {
          if (out) {
              out.x = p.x;
              out.y = p.y;
              return out;
          }
          return new Coordinate(p);
      }
  };
  /**
   * GIS 中常见的 CRS。 使用简单的等距矩形投影
   *
   * @english
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * @category geo
   * @protected
   * @group projection
   * @name EPSG4326
   * {@inheritDoc projection.Common}
   * {@inheritDoc measurer.WGS84Sphere}
   */
  var Projection_EPSG4326 = extend$2({}, CommonProjection, EPSG4326Projection, WGS84Sphere);

  /* eslint-disable */
  // https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js
  // add math.h functions to library scope
  // (to make porting projection functions simpler)
  var fabs = Math.abs, sin = Math.sin, cos = Math.cos, tan = Math.tan, atan = Math.atan, atan2 = Math.atan2, sqrt = Math.sqrt, log = Math.log, hypot$1 = Math.hypot, sinh = Math.sinh, cosh = Math.cosh;
  // constants from math.h
  var HUGE_VAL = Infinity;
  function pj_etmerc(P) {
      var cgb = [], cbg = [], utg = [], gtu = [], Qn, Zb, f, n, np, Z;
      if (P.es <= 0)
          ;
      /* flattening */
      f = P.es / (1 + sqrt(1 - P.es)); /* Replaces: f = 1 - sqrt(1-P.es); */
      /* third flattening */
      np = n = f / (2 - f);
      /* COEF. OF TRIG SERIES GEO <-> GAUSS */
      /* cgb := Gaussian -> Geodetic, KW p190 - 191 (61) - (62) */
      /* cbg := Geodetic -> Gaussian, KW p186 - 187 (51) - (52) */
      /* PROJ_ETMERC_ORDER = 6th degree : Engsager and Poder: ICC2007 */
      cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
      cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
      np *= n;
      cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
      cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
      np *= n;
      /* n^5 coeff corrected from 1262/105 -> -1262/105 */
      cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
      cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
      np *= n;
      /* n^5 coeff corrected from 322/35 -> 332/35 */
      cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
      cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
      np *= n;
      cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
      cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
      np *= n;
      cgb[5] = np * (601676 / 22275);
      cbg[5] = np * (444337 / 155925);
      /* Constants of the projections */
      /* Transverse Mercator (UTM, ITM, etc) */
      np = n * n;
      /* Norm. mer. quad, K&W p.50 (96), p.19 (38b), p.5 (2) */
      Qn = P.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
      /* coef of trig series */
      /* utg := ell. N, E -> sph. N, E,  KW p194 (65) */
      /* gtu := sph. N, E -> ell. N, E,  KW p196 (69) */
      utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
      gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
      utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
      gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
      np *= n;
      utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
      gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
      np *= n;
      utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
      gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
      np *= n;
      utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
      gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
      np *= n;
      utg[5] = np * (-20648693 / 638668800);
      gtu[5] = np * (212378941 / 319334400);
      /* Gaussian latitude value of the origin latitude */
      Z = gatg(cbg, P.phi0);
      /* Origin northing minus true northing at the origin latitude */
      /* i.e. true northing = N - P.Zb  */
      Zb = -Qn * (Z + clens(gtu, 2 * Z));
      P.fwd = e_fwd;
      P.inv = e_inv;
      function e_fwd(lp, xy) {
          var sin_Cn, cos_Cn, cos_Ce, sin_Ce, tmp;
          var Cn = lp.phi, Ce = lp.lam;
          /* ell. LAT, LNG -> Gaussian LAT, LNG */
          Cn = gatg(cbg, Cn);
          /* Gaussian LAT, LNG -> compl. sph. LAT */
          sin_Cn = sin(Cn);
          cos_Cn = cos(Cn);
          sin_Ce = sin(Ce);
          cos_Ce = cos(Ce);
          Cn = atan2(sin_Cn, cos_Ce * cos_Cn);
          Ce = atan2(sin_Ce * cos_Cn, hypot$1(sin_Cn, cos_Cn * cos_Ce));
          /* compl. sph. N, E -> ell. norm. N, E */
          Ce = asinhy(tan(Ce));
          tmp = clenS(gtu, 2 * Cn, 2 * Ce);
          Cn += tmp[0];
          Ce += tmp[1];
          if (fabs(Ce) <= 2.623395162778) {
              xy.y = Qn * Cn + Zb; /* Northing */
              xy.x = Qn * Ce; /* Easting  */
          }
          else {
              xy.x = xy.y = HUGE_VAL;
          }
      }
      function e_inv(xy, lp) {
          var sin_Cn, cos_Cn, cos_Ce, sin_Ce, tmp;
          var Cn = xy.y, Ce = xy.x;
          /* normalize N, E */
          Cn = (Cn - Zb) / Qn;
          Ce = Ce / Qn;
          if (fabs(Ce) <= 2.623395162778) { /* 150 degrees */
              /* norm. N, E -> compl. sph. LAT, LNG */
              tmp = clenS(utg, 2 * Cn, 2 * Ce);
              Cn += tmp[0];
              Ce += tmp[1];
              Ce = atan(sinh(Ce)); /* Replaces: Ce = 2*(atan(exp(Ce)) - M_FORTPI); */
              /* compl. sph. LAT -> Gaussian LAT, LNG */
              sin_Cn = sin(Cn);
              cos_Cn = cos(Cn);
              sin_Ce = sin(Ce);
              cos_Ce = cos(Ce);
              Ce = atan2(sin_Ce, cos_Ce * cos_Cn);
              Cn = atan2(sin_Cn * cos_Ce, hypot$1(sin_Ce, cos_Ce * cos_Cn));
              /* Gaussian LAT, LNG -> ell. LAT, LNG */
              lp.phi = gatg(cgb, Cn);
              lp.lam = Ce;
          }
          else {
              lp.phi = lp.lam = HUGE_VAL;
          }
      }
      function log1py(x) {
          var y = 1 + x, z = y - 1;
          return z === 0 ? x : x * log(y) / z;
      }
      function asinhy(x) {
          var y = fabs(x);
          y = log1py(y * (1 + y / (hypot$1(1, y) + 1)));
          return x < 0 ? -y : y;
      }
      function gatg(pp, B) {
          var cos_2B = 2 * cos(2 * B), i = pp.length - 1, h1 = pp[i], h2 = 0, h;
          while (--i >= 0) {
              h = -h2 + cos_2B * h1 + pp[i];
              h2 = h1;
              h1 = h;
          }
          return (B + h * sin(2 * B));
      }
      function clens(pp, arg_r) {
          var r = 2 * cos(arg_r), i = pp.length - 1, hr1 = pp[i], hr2 = 0, hr;
          while (--i >= 0) {
              hr = -hr2 + r * hr1 + pp[i];
              hr2 = hr1;
              hr1 = hr;
          }
          return sin(arg_r) * hr;
      }
      function clenS(pp, arg_r, arg_i) {
          var sin_arg_r = sin(arg_r), cos_arg_r = cos(arg_r), sinh_arg_i = sinh(arg_i), cosh_arg_i = cosh(arg_i), r = 2 * cos_arg_r * cosh_arg_i, i = -2 * sin_arg_r * sinh_arg_i, j = pp.length - 1, hr = pp[j], hi1 = 0, hr1 = 0, hi = 0, hr2, hi2;
          while (--j >= 0) {
              hr2 = hr1;
              hi2 = hi1;
              hr1 = hr;
              hi1 = hi;
              hr = -hr2 + r * hr1 - i * hi1 + pp[j];
              hi = -hi2 + i * hr1 + r * hi1;
          }
          r = sin_arg_r * cosh_arg_i;
          i = cos_arg_r * sinh_arg_i;
          return [r * hr - i * hi, r * hi + i * hr];
      }
  }
  /* eslint-enable */

  /* eslint-disable no-loss-of-precision */
  // from proj_api.h
  // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
  var RAD_TO_DEG = 57.295779513082321, DEG_TO_RAD = 0.017453292519943296;
  /* eslint-enable no-loss-of-precision */
  // from pj_transform.c
  var SRS_WGS84_SEMIMAJOR = 6378137;
  var SRS_WGS84_ESQUARED = 0.0066943799901413165;
  var aliases = ['Traverse_Mercator'];
  var EPSG9807Projection = {
      code: 'EPSG:9807',
      aliases: aliases,
      centralMeridian: 0,
      create: function (params) {
          var P = {
              a: SRS_WGS84_SEMIMAJOR,
              es: SRS_WGS84_ESQUARED,
              x0: isNil(params.falseEasting) ? 500000 : params.falseEasting,
              y0: isNil(params.falseNorthing) ? 0 : params.falseNorthing,
              k0: params.scaleFactor || 0.9996,
              lam0: (params.centralMeridian || 0) * DEG_TO_RAD,
              phi0: (params.latitudeOfOrigin || 0) * DEG_TO_RAD,
              originLam0: params.startLongtitude || 0,
              originPhi0: params.startLatitude || 0
          };
          pj_etmerc(P);
          var lp = { lam: 0, phi: 0 };
          var xy = {};
          var originX = 0;
          var originY = 0;
          if (P.originLam0 || P.originPhi0) {
              lp.lam = P.originLam0 * DEG_TO_RAD - P.lam0;
              lp.phi = P.originPhi0 * DEG_TO_RAD;
              P.fwd(lp, xy);
              originX = P.a * xy.x + P.x0;
              originY = P.a * xy.y + P.y0;
          }
          var methods = {
              /**
               * "EPSG:9807", Code of the projection
               * @type {String}
               * @constant
               */
              code: 'EPSG:9807',
              aliases: aliases,
              centralMeridian: params.centralMeridian,
              project: function (p, out) {
                  lp.lam = p.x * DEG_TO_RAD - P.lam0;
                  lp.phi = p.y * DEG_TO_RAD;
                  P.fwd(lp, xy);
                  var x = P.a * xy.x + P.x0 - originX;
                  var y = P.a * xy.y + P.y0 - originY;
                  if (out) {
                      out.x = x;
                      out.y = y;
                      return out;
                  }
                  return new Coordinate(x, y);
              },
              unproject: function (p, out) {
                  xy.x = (p.x - P.x0 + originX) / P.a;
                  xy.y = (p.y - P.y0 + originY) / P.a;
                  P.inv(xy, lp);
                  var x = (lp.lam + P.lam0) * RAD_TO_DEG;
                  var y = lp.phi * RAD_TO_DEG;
                  if (out) {
                      out.x = x;
                      out.y = y;
                      return out;
                  }
                  return new Coordinate(x, y);
              }
          };
          return extend$2({}, CommonProjection, methods, WGS84Sphere);
      }
  };
  /**
   * 横轴墨卡托投影
   *
   * @english
   * Traverse Mercator Projection
   *
   * @category geo
   * @protected
   * @group projection
   * @name EPSG9807
   * {@inheritDoc projection.Common}
   * {@inheritDoc measurer.WGS84Sphere}
   */
  var EPSG9807 = extend$2({}, CommonProjection, EPSG9807Projection);

  var UTMProjection = {
      /**
       * "EPSG:4490", Code of the projection
       * @constant
       */
      code: 'utm',
      aliases: [],
      create: function (params) {
          var P = {};
          var zone = parseInt(params.zone);
          P.falseNorthing = params.south ? 10000000 : 0;
          P.falseEasting = 500000;
          if (zone > 0 && zone <= 60) {
              zone--;
          }
          else {
              throw new Error('zone must be > 0 and <= 60.');
          }
          P.centralMeridian = (zone + 0.5) * 6 - 180;
          P.scaleFactor = 0.9996;
          return EPSG9807.create(P);
      }
  };
  /**
   * Universal Traverse Mercator projection
   *
   * @class
   * @category geo
   * @protected
   * @memberOf projection
   * @name EPSG4490
   * {@inheritDoc projection.EPSG9807}
   */
  var Projection_UTM = extend$2({}, EPSG9807, UTMProjection);

  var ProjectionMethods = {
      EARTHRADIUS: 6370996.81,
      MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
      LLBAND: [75, 60, 45, 30, 15, 0],
      MC2LL: [
          [1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2],
          [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86],
          [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37],
          [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06],
          [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4],
          [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]
      ],
      LL2MC: [
          [-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5],
          [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5],
          [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5],
          [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5],
          [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5],
          [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]
      ],
      convertMC2LL: function (cB, out) {
          var cE;
          for (var cD = 0, len = this.MCBAND.length; cD < len; cD++) {
              if (Math.abs(cB.y) >= this.MCBAND[cD]) {
                  cE = this.MC2LL[cD];
                  break;
              }
          }
          var T = this.convertor(cB, cE, out);
          return T;
      },
      convertLL2MC: function (T, out) {
          var cD, cC, len;
          T.x = this.getLoop(T.x, -180, 180);
          T.y = this.getRange(T.y, -74, 74);
          var cB = new Coordinate(T.x, T.y);
          for (cC = 0, len = this.LLBAND.length; cC < len; cC++) {
              if (cB.y >= this.LLBAND[cC]) {
                  cD = this.LL2MC[cC];
                  break;
              }
          }
          if (!cD) {
              for (cC = this.LLBAND.length - 1; cC >= 0; cC--) {
                  if (cB.y <= -this.LLBAND[cC]) {
                      cD = this.LL2MC[cC];
                      break;
                  }
              }
          }
          var cE = this.convertor(T, cD, out);
          return cE;
      },
      convertor: function (cC, cD, out) {
          if (!cC || !cD) {
              return null;
          }
          var T = cD[0] + cD[1] * Math.abs(cC.x);
          var cB = Math.abs(cC.y) / cD[9];
          var cE = cD[2] + cD[3] * cB + cD[4] * cB * cB +
              cD[5] * cB * cB * cB + cD[6] * cB * cB * cB * cB +
              cD[7] * cB * cB * cB * cB * cB +
              cD[8] * cB * cB * cB * cB * cB * cB;
          T *= (cC.x < 0 ? -1 : 1);
          cE *= (cC.y < 0 ? -1 : 1);
          if (out) {
              out.x = T;
              out.y = cE;
              return out;
          }
          return new Coordinate(T, cE);
      },
      toRadians: function (T) {
          return Math.PI * T / 180;
      },
      toDegrees: function (T) {
          return (180 * T) / Math.PI;
      },
      getRange: function (cC, cB, T) {
          if (cB != null) {
              cC = Math.max(cC, cB);
          }
          if (T != null) {
              cC = Math.min(cC, T);
          }
          return cC;
      },
      getLoop: function (cC, cB, T) {
          if (cC === Infinity) {
              return T;
          }
          else if (cC === -Infinity) {
              return cB;
          }
          while (cC > T) {
              cC -= T - cB;
          }
          while (cC < cB) {
              cC += T - cB;
          }
          return cC;
      }
  };
  var BAIDUProjection = {
      /**
       * "BAIDU", Code of the projection
       * @constant
       */
      code: 'BAIDU',
      project: function (p, out) {
          return this.convertLL2MC(p, out);
      },
      unproject: function (p, out) {
          return this.convertMC2LL(p, out);
      }
  };
  /**
   * 百度地图所使用的投影 [Baidu Map]{@link http://map.baidu.com}
   *
   * @english
   * Projection used by [Baidu Map]{@link http://map.baidu.com}
   *
   * @category geo
   * @protected
   * @group projection
   * @name BAIDU
   * {@inheritDoc projection.Common}
   * {@inheritDoc BaiduSphere}
   */
  var Projection_Baidu = extend$2({}, CommonProjection, BAIDUProjection, BaiduSphere, ProjectionMethods);

  var IdentityProjection = {
      /**
       * "IDENTITY", Code of the projection
       * @constant
       */
      code: 'IDENTITY',
      project: function (p, out) {
          if (out) {
              out.x = p.x;
              out.y = p.y;
              return out;
          }
          return p.copy();
      },
      unproject: function (p, out) {
          if (out) {
              out.x = p.x;
              out.y = p.y;
              return out;
          }
          return p.copy();
      }
  };
  /**
   * 基于笛卡尔坐标系的投影。<br>
   * 该投影直接映射 x、y，常用于平面地图（例如室内地图、游戏地图）。
   *
   * @english
   * A projection based on Cartesian coordinate system.<br>
   * This projection maps x, y directly, it is useful for maps of flat surfaces (e.g. indoor maps, game maps).
   *
   * @category geo
   * @protected
   * @group projection
   * @name IDENTITY
   * {@inheritDoc projection.Common}
   * {@inheritDoc measurer.Identity}
   */
  var Projection_IDENTITY = extend$2({}, CommonProjection, IdentityProjection, extended);

  /** @namespace projection */
  /**
   * 默认投影, [EPSG3857]{@link projection.EPSG3857}
   * @english
   * Default projection, [EPSG3857]{@link projection.EPSG3857}
   *
   * @category geo
   * @protected
   * @group projection
   * @module DEFAULT
   * {@inheritDoc projection.EPSG3857}
   */
  var DEFAULT = EPSG3857;

  var projections = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BAIDU: Projection_Baidu,
    Common: CommonProjection,
    DEFAULT: DEFAULT,
    EPSG3857: EPSG3857,
    EPSG4326: Projection_EPSG4326,
    EPSG9807: EPSG9807,
    IDENTITY: Projection_IDENTITY,
    UTM: Projection_UTM
  });

  /**
   * 一切可渲染的公共方法，例如：`Map`、'Layers'
   * @english
   * Common methods for classes can be rendered, e.g. Map, Layers
   * @mixin Renderable
   * @protected
   */
  function Renderable (Base) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          /**
           * 用给定的 name 注册一个 `renderer` 类
           * @english
           * Register a renderer class with the given name.
           * @param  name  - renderer's register key
           * @param  clazz - renderer's class{@link Class}).
           */
          class_1.registerRenderer = function (name, clazz) {
              var proto = this.prototype;
              var parentProto = Object.getPrototypeOf(proto);
              if (!proto._rendererClasses || proto._rendererClasses === parentProto._rendererClasses) {
                  proto._rendererClasses = proto._rendererClasses ? Object.create(proto._rendererClasses) : {};
              }
              proto._rendererClasses[name.toLowerCase()] = clazz;
              return this;
          };
          /**
           * 返回用name注册的 `renderer` 类
           * @english
           * Get the registered renderer class by the given name
           * @param  name  - renderer's register key
           */
          class_1.getRendererClass = function (name) {
              var proto = this.prototype;
              if (!proto._rendererClasses) {
                  return null;
              }
              return proto._rendererClasses[name.toLowerCase()];
          };
          return class_1;
      }(Base));
  }

  var CHECK_FPS_WORKER_KEY = 'check_browser_max_fps';
  var CHECK_FPS_WORKER_CODE = "function (exports) {\n    exports.initialize = function () {};\n    function now(){\n        return  new Date().getTime();\n    }\n    function checkFPS(cb) {\n        if (!requestAnimationFrame) {\n            cb(-1);\n            return;\n        }\n        const count = 100;\n        let idx = 0;\n        let id;\n        let startTime;\n        function loop() {\n            idx++;\n            if (idx === count) {\n                cancelAnimationFrame(id);\n                const endTime = now();\n                const timePerFPS = (endTime - startTime) / count;\n                const fps = Math.floor(1000 / timePerFPS);\n                cb(fps);\n            } else {\n                id = requestAnimationFrame(loop);\n            }\n        }\n        startTime = now();\n        id = requestAnimationFrame(loop);\n    }\n    //recive message\n    exports.onmessage = function (msg, postResponse) {\n        checkFPS((fps) => {\n            if (fps < -1) {\n                postResponse('check fps fail');\n            } else {\n                postResponse(null, { fps });\n            }\n        })\n    }\n}";
  registerWorkerAdapter(CHECK_FPS_WORKER_KEY, function () { return CHECK_FPS_WORKER_CODE; });

  var dedicatedWorker = 0;
  var EMPTY_BUFFERS = [];
  /**
   * An actor to exchange data from main-thread to workers
   * contains code from [mapbox-gl-js](https://github.com/mapbox/mapbox-gl-js)
   * @category core
   * @memberof worker
   * @example
   *  const workerKey = 'test_worker_key';
      maptalks.registerWorkerAdapter(workerKey, function (exports, global) {
        //will be called only for once when loaded in worker thread
        exports.initialize = function () {
          console.log('[worker] initialized');
        };
        //to receive message from main thread sent by maptalks.worker.Actor
        exports.onmessage = function (message, postResponse) {
          const data = message.data;
          console.log(`[worker] received data : ` + data);
          //send message back to main thread
          //the parameters:
          //error, data, buffers (arraybuffers in data)
          postResponse(null, 'message from worker thread', null);
        };
      });

      const MyActor = class extends maptalks.worker.Actor {
        test(info, cb) {
          //send data to worker thread
          this.send(info, null, cb);
        }
      }

      //must be same with workerKey for maptalks.registerWorkerAdapter
      const actor = new MyActor(workerKey);
      actor.test('hi', (err, data) => {
        //received data from worker thread
        console.log(data);
      });
   */
  var Actor = /** @class */ (function () {
      function Actor(workerKey) {
          var _this = this;
          startTasks();
          this._delayMessages = [];
          this.initializing = false;
          var hasCreated = adapterHasCreated(workerKey);
          //当同一个workerKey多例时初始化会有问题吗？不会，因为第一个Actor会将workerpool占满，后续的Actor worker通信处于排队状态
          //当第一个Actor初始化完成释放了worker pool里的每个worker资源,后续的Actor的消息通信才会被执行
          //当且仅当worker线程池启动且第一次创建改Actor时才走这个逻辑,后续改workerKey的Actor都是同步的
          if (workersHasCreated() && !hasCreated) {
              this.initializing = true;
              console.log("Injecting codes in worker with worker key: :".concat(workerKey));
              createAdapter(workerKey, function () {
                  _this.initializing = false;
                  _this.created();
              });
          }
          this.workerKey = workerKey;
          this.workerPool = getGlobalWorkerPool();
          this.currentActor = 0;
          this.actorId = UID();
          this.workers = this.workerPool.acquire(this.actorId);
          this.callbacks = {};
          this.callbackID = 0;
          this.receiveFn = this.receive.bind(this);
          this.workers.forEach(function (w) {
              w.addEventListener('message', _this.receiveFn, false);
          });
          pushAdapterCreated(workerKey);
      }
      Actor.prototype.created = function () {
          var _this = this;
          // handler delay messages
          this._delayMessages.forEach(function (message) {
              var command = message.command, data = message.data, buffers = message.buffers, cb = message.cb, workerId = message.workerId;
              _this[command](data, buffers, cb, workerId);
          });
          this._delayMessages = [];
      };
      /**
       * If the actor is active
       * @returns
       */
      Actor.prototype.isActive = function () {
          return !!this.workers;
      };
      /**
       * Broadcast a message to all Workers.
       * @param {Object} data - data to send to worker thread
       * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables
       * @param {Function} cb - callback function when received message from worker thread
       */
      Actor.prototype.broadcast = function (data, buffers, cb) {
          var _this = this;
          if (this.initializing) {
              this._delayMessages.push({ command: 'broadcast', data: data, buffers: buffers, cb: cb });
              return this;
          }
          cb = cb || function () { };
          asyncAll(this.workers, function (worker, done) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              _this.send(data, buffers, done, worker.id);
          }, cb);
          return this;
      };
      /**
       * Sends a message from a main-thread to a Worker and call callback when response received.
       *
       * @param {Object} data - data to send to worker thread
       * @param {ArrayBuffer[]} buffers - arraybuffers in data as transferables
       * @param {Function} cb - callback function when received message from worker thread
       * @param {Number} [workerId=undefined] - Optional, a particular worker id to which to send this message.
       */
      Actor.prototype.send = function (data, buffers, cb, workerId) {
          if (this.initializing) {
              this._delayMessages.push({ command: 'send', data: data, buffers: buffers, cb: cb, workerId: workerId });
              return this;
          }
          var id = cb ? "".concat(this.actorId, ":").concat(this.callbackID++) : null;
          if (cb)
              this.callbacks[id] = cb;
          this.post({
              data: data,
              callback: String(id)
          }, buffers, workerId);
          return this;
      };
      /**
       * A listener callback for incoming message from worker thread.
       * SHOULD NOT BE OVERRIDED only if you know what you are doing.
       * @param {Object} message - response message from worker thread
       */
      Actor.prototype.receive = function (message) {
          var _this = this;
          var data = message.data, id = data.callback;
          var callback = this.callbacks[id];
          delete this.callbacks[id];
          if (data.type === '<request>') {
              if (this.actorId === data.actorId) {
                  //request from worker to main thread
                  this[data.command](data.params, function (err, cbData, buffers) {
                      var message = {
                          type: '<response>',
                          callback: data.callback
                      };
                      if (err) {
                          message.error = err.message;
                      }
                      else {
                          message.data = cbData;
                      }
                      _this.post(message, buffers || EMPTY_BUFFERS, data.workerId);
                  });
              }
          }
          else if (callback && data.error) {
              callback(data.error);
          }
          else if (callback) {
              callback(null, data.data);
          }
      };
      /**
       * Remove the actor
       */
      Actor.prototype.remove = function () {
          var _this = this;
          this.workers.forEach(function (w) {
              w.removeEventListener('message', _this.receiveFn, false);
          });
          // this.workerPool.release(this.actorId);
          delete this.receiveFn;
          delete this.workers;
          delete this.callbacks;
          delete this.workerPool;
      };
      /**
       * Send a message to a Worker.
       * @param {Object} data - data to send
       * @param {ArrayBuffer[]} buffers   - arraybuffers in data
       * @param {Number} targetID The ID of the Worker to which to send this message. Omit to allow the dispatcher to choose.
       * @returns {Number} The ID of the worker to which the message was sent.
       */
      Actor.prototype.post = function (data, buffers, targetID) {
          if (typeof targetID !== 'number' || isNaN(targetID)) {
              // Use round robin to send requests to web workers.
              targetID = this.currentActor = (this.currentActor + 1) % this.workerPool.workerCount;
          }
          data.workerId = targetID;
          data.workerKey = this.workerKey;
          data.actorId = this.actorId;
          // this.workers[targetID].postMessage(data, buffers || EMPTY_BUFFERS);
          this.workerPool.addMessage(targetID, data, buffers || EMPTY_BUFFERS);
          return targetID;
      };
      /**
       * Get a dedicated worker in a round-robin fashion
       */
      Actor.prototype.getDedicatedWorker = function () {
          dedicatedWorker = (dedicatedWorker + 1) % this.workerPool.workerCount;
          return dedicatedWorker;
      };
      return Actor;
  }());
  function asyncAll(array, fn, callback) {
      if (!array.length) {
          callback(null, []);
      }
      var remaining = array.length;
      var results = new Array(array.length);
      var error = null;
      array.forEach(function (item, i) {
          fn(item, function (err, result) {
              if (err)
                  error = err;
              results[i] = result;
              if (--remaining === 0)
                  callback(error, results);
          });
      });
  }
  var actor;
  var FPSCheckActor = /** @class */ (function (_super) {
      __extends(FPSCheckActor, _super);
      function FPSCheckActor() {
          return _super.call(this, CHECK_FPS_WORKER_KEY) || this;
      }
      return FPSCheckActor;
  }(Actor));
  function checkFPS(cb) {
      if (!actor) {
          actor = new FPSCheckActor();
      }
      actor.send({}, [], function (err, data) {
          if (err) {
              console.error(err);
              cb();
          }
          else {
              cb(data.fps);
          }
      });
  }
  var checkFPSing = false;
  function checkBrowserMaxFPS() {
      if (checkFPSing) {
          return;
      }
      if (GlobalConfig.maxFPS <= 0) {
          checkFPSing = true;
          checkFPS(function (fps) {
              if (isNumber(fps) && fps > 0 && GlobalConfig.maxFPS <= 0) {
                  GlobalConfig.maxFPS = fps;
              }
              checkFPSing = false;
          });
      }
  }
  pushLoopHook(checkBrowserMaxFPS);

  /* eslint-disable @typescript-eslint/ban-types */
  var EMPTY_ARRAY$2 = [];
  var ResourceWorkerConnection = /** @class */ (function (_super) {
      __extends(ResourceWorkerConnection, _super);
      function ResourceWorkerConnection() {
          return _super.call(this, imageFetchWorkerKey) || this;
      }
      ResourceWorkerConnection.prototype.fetchImage = function (url, cb) {
          var data = {
              url: url
          };
          this.send(data, EMPTY_ARRAY$2, cb);
      };
      return ResourceWorkerConnection;
  }(Actor));
  /**
   * 在 HTMLCanvasElement 上渲染图层的基类
   * @english
   * Base Class to render layer on HTMLCanvasElement
   * @abstract
   * @protected
   * @memberOf renderer
   * @extends Class
   */
  var CanvasRenderer$1 = /** @class */ (function (_super) {
      __extends(CanvasRenderer, _super);
      /**
       * @param  {Layer} layer the layer to render
       */
      function CanvasRenderer(layer) {
          var _this = _super.call(this) || this;
          _this.layer = layer;
          _this._painted = false;
          _this._drawTime = 0;
          if (Browser$1.decodeImageInWorker && !Browser$1.safari && !Browser$1.iosWeixin) {
              _this._resWorkerConn = new ResourceWorkerConnection();
          }
          _this.setToRedraw();
          return _this;
      }
      /**
       * Render the layer.
       * Call checkResources
       */
      CanvasRenderer.prototype.render = function (framestamp) {
          this.prepareRender();
          if (!this.getMap() || !this.layer.isVisible()) {
              return;
          }
          if (!this.resources) {
              /* eslint-disable no-use-before-define */
              this.resources = new ResourceCache();
              /* eslint-enable no-use-before-define */
          }
          this.checkAndDraw(this._tryToDraw, framestamp);
          this._frameTime = framestamp;
      };
      CanvasRenderer.prototype.getFrameTimestamp = function () {
          return this._frameTime || 0;
      };
      CanvasRenderer.prototype.checkAndDraw = function (drawFn) {
          var _this = this;
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          this._toRedraw = false;
          if (this.checkResources) {
              var resources = this.checkResources();
              if (resources.length > 0) {
                  this._loadingResource = true;
                  this.loadResources(resources).then(function () {
                      _this._loadingResource = false;
                      if (_this.layer) {
                          /**
                           * resourceload event, fired when external resources of the layer complete loading.
                           *
                           * @event Layer#resourceload
                           * @type {Object}
                           * @property {String} type     - resourceload
                           * @property {Layer} target    - layer
                           */
                          _this.layer.fire('resourceload');
                          var map = _this.layer.getMap();
                          _this.setToRedraw();
                          map.getRenderer().callInNextFrame(function () {
                              // sometimes renderer still fails to fetch loaded images, an additional frame will solved it
                              _this.setToRedraw();
                          });
                      }
                  });
              }
              else {
                  drawFn.call.apply(drawFn, __spreadArray([this], __read(args), false));
              }
          }
          else {
              drawFn.call.apply(drawFn, __spreadArray([this], __read(args), false));
          }
      };
      /**
       * Check if has any external resources to load
       * If yes, load the resources before calling draw method
       * @abstract
       * @method checkResources
       * @instance
       * @returns {Array[]} an array of resource arrays [ [url1, width, height], [url2, width, height], [url3, width, height] .. ]
       * @memberOf renderer.CanvasRenderer
       */
      /**
       * a required abstract method to implement
       * draw the layer when map is not interacting
       * @abstract
       * @instance
       * @method draw
       * @memberOf renderer.CanvasRenderer
       */
      /**
       * an optional abstract method to implement
       * draw the layer when map is interacting (moving/zooming/dragrotating)
       * @abstract
       * @instance
       * @method drawOnInteracting
       * @param {Object} eventParam event parameters
       * @memberOf renderer.CanvasRenderer
       */
      /**
       * @private
       */
      CanvasRenderer.prototype.testIfNeedRedraw = function () {
          var map = this.getMap();
          if (this._loadingResource) {
              return false;
          }
          if (this._toRedraw) {
              return true;
          }
          if (map.isInteracting() && !this.drawOnInteracting) {
              return false;
          }
          if (this.needToRedraw()) {
              return true;
          }
          return false;
      };
      /**
       * Ask whether the layer renderer needs to redraw
       */
      CanvasRenderer.prototype.needToRedraw = function () {
          var map = this.getMap();
          if (map.isInteracting() || map.getRenderer().isViewChanged()) {
              // don't redraw when map is moving without any pitch
              return !(!map.getPitch() && map.isMoving() && !map.isZooming() && !map.isRotating() && !this.layer.options['forceRenderOnMoving']);
          }
          return false;
      };
      /**
       * A callback for overriding when drawOnInteracting is skipped due to low fps
       */
      CanvasRenderer.prototype.onSkipDrawOnInteracting = function () { };
      CanvasRenderer.prototype.isLoadingResource = function () {
          return this._loadingResource;
      };
      CanvasRenderer.prototype.isRenderComplete = function () {
          return !!this._renderComplete;
      };
      /**
       * Whether must call render instead of drawOnInteracting when map is interacting
       */
      CanvasRenderer.prototype.mustRenderOnInteracting = function () {
          return !this._painted;
      };
      /**
       * Set to redraw, ask map to call draw/drawOnInteracting to redraw the layer
       */
      CanvasRenderer.prototype.setToRedraw = function () {
          this._toRedraw = true;
          return this;
      };
      /**
       *  Mark layer's canvas updated
       */
      CanvasRenderer.prototype.setCanvasUpdated = function () {
          this._canvasUpdated = true;
          return this;
      };
      /**
       * Only called by map's renderer to check whether the layer's canvas is updated
       * @protected
       * @return {Boolean}
       */
      CanvasRenderer.prototype.isCanvasUpdated = function () {
          return !!this._canvasUpdated;
      };
      /**
       * Remove the renderer, will be called when layer is removed
       */
      CanvasRenderer.prototype.remove = function () {
          this.onRemove();
          delete this._loadingResource;
          delete this.middleWest;
          delete this.canvas;
          delete this.context;
          delete this.canvasExtent2D;
          delete this._extent2D;
          if (this.resources) {
              this.resources.remove();
          }
          delete this.resources;
          if (this._resWorkerConn) {
              this._resWorkerConn.remove();
              delete this._resWorkerConn;
          }
          delete this.layer;
      };
      CanvasRenderer.prototype.onRemove = function () { };
      CanvasRenderer.prototype.onAdd = function () { };
      /**
       * Get map
       */
      CanvasRenderer.prototype.getMap = function () {
          if (!this.layer) {
              return null;
          }
          return this.layer.getMap();
      };
      /**
       * Get renderer's Canvas image object
       */
      CanvasRenderer.prototype.getCanvasImage = function () {
          var map = this.getMap();
          this._canvasUpdated = false;
          if (this._renderZoom !== map.getZoom() || !this.canvas || !this._extent2D) {
              return null;
          }
          if (this.isBlank()) {
              return null;
          }
          if (this.layer.isEmpty && this.layer.isEmpty()) {
              return null;
          }
          // size = this._extent2D.getSize(),
          var containerPoint = map._pointToContainerPoint(this.middleWest)._add(0, -map.height / 2);
          return {
              'image': this.canvas,
              'layer': this.layer,
              'point': containerPoint /* ,
              'size': size */
          };
      };
      /**
       * Clear canvas
       */
      CanvasRenderer.prototype.clear = function () {
          this.clearCanvas();
      };
      /**
       * A method to help improve performance.
       * If you are sure that layer's canvas is blank, returns true to save unnecessary layer works of maps.
       */
      CanvasRenderer.prototype.isBlank = function () {
          return !this._painted;
      };
      /**
       * Show the layer
       */
      CanvasRenderer.prototype.show = function () {
          this.setToRedraw();
      };
      /**
       * Hide the layer
       */
      CanvasRenderer.prototype.hide = function () {
          this.clear();
          this.setToRedraw();
      };
      /**
       * Set z-index of layer
       */
      CanvasRenderer.prototype.setZIndex = function (_z) {
          this.setToRedraw();
      };
      /**
       * Detect if there is anything painted on the given point
       * @param point containerPoint
       */
      CanvasRenderer.prototype.hitDetect = function (point) {
          if (!this.context || (this.layer.isEmpty && this.layer.isEmpty()) || this.isBlank() || this._errorThrown || (this.layer.isVisible && !this.layer.isVisible())) {
              return false;
          }
          var map = this.getMap();
          var r = map.getDevicePixelRatio();
          var size = map.getSize();
          if (point.x < 0 || point.x > size['width'] * r || point.y < 0 || point.y > size['height'] * r) {
              return false;
          }
          var imageData = this.getImageData && this.getImageData();
          if (imageData) {
              var x = Math.round(r * point.x), y = Math.round(r * point.y);
              var idx = y * imageData.width * 4 + x * 4;
              //索引下标从0开始需要-1
              return imageData.data[idx + 3] > 0;
          }
          try {
              var imgData = this.context.getImageData(r * point.x, r * point.y, 1, 1).data;
              if (imgData[3] > 0) {
                  return true;
              }
          }
          catch (error) {
              if (!this._errorThrown) {
                  if (console) {
                      console.warn('hit detect failed with tainted canvas, some geometries have external resources in another domain:\n', error);
                  }
                  this._errorThrown = true;
              }
              //usually a CORS error will be thrown if the canvas uses resources from other domain.
              //this may happen when a geometry is filled with pattern file.
              return false;
          }
          return false;
      };
      /**
       * loadResource from resourceUrls
       * @param  {String[]} resourceUrls    - Array of urls to load
       * @returns {Promise[]}
       */
      CanvasRenderer.prototype.loadResources = function (resourceUrls) {
          if (!this.resources) {
              /* eslint-disable no-use-before-define */
              this.resources = new ResourceCache();
              /* eslint-enable no-use-before-define */
          }
          var resources = this.resources, promises = [];
          if (isArrayHasData(resourceUrls)) {
              var cache = {};
              for (var i = resourceUrls.length - 1; i >= 0; i--) {
                  var url = resourceUrls[i];
                  if (!url || !url.length || cache[url.join('-')]) {
                      continue;
                  }
                  cache[url.join('-')] = 1;
                  if (!resources.isResourceLoaded(url, true)) {
                      //closure it to preserve url's value
                      promises.push(new Promise(this._promiseResource(url)));
                  }
              }
          }
          return Promise.all(promises);
      };
      /**
       * Prepare rendering
       * Set necessary properties, like this._renderZoom/ this.canvasExtent2D, this.middleWest
       * @private
       */
      CanvasRenderer.prototype.prepareRender = function () {
          delete this._renderComplete;
          var map = this.getMap();
          this._renderZoom = map.getZoom();
          this.canvasExtent2D = this._extent2D = map.get2DExtent();
          //change from northWest to middleWest, because northwest's point <=> containerPoint changes when pitch >= 72
          this.middleWest = map._containerPointToPoint(new Point(0, map.height / 2));
      };
      /**
       * Create renderer's Canvas
       */
      CanvasRenderer.prototype.createCanvas = function () {
          if (this.canvas) {
              return;
          }
          var map = this.getMap();
          var size = map.getSize();
          var r = map.getDevicePixelRatio(), w = Math.round(r * size.width), h = Math.round(r * size.height);
          if (this.layer._canvas) {
              var canvas = this.layer._canvas;
              canvas.width = w;
              canvas.height = h;
              if (canvas.style) {
                  canvas.style.width = size.width + 'px';
                  canvas.style.height = size.height + 'px';
              }
              this.canvas = this.layer._canvas;
          }
          else {
              this.canvas = Canvas.createCanvas(w, h, map.CanvasClass);
          }
          this.onCanvasCreate();
      };
      CanvasRenderer.prototype.onCanvasCreate = function () {
      };
      //@internal
      CanvasRenderer.prototype._canvasContextScale = function (context, dpr) {
          context.scale(dpr, dpr);
          context.dpr = dpr;
          return this;
      };
      CanvasRenderer.prototype.createContext = function () {
          //Be compatible with layer renderers that overrides create canvas and create gl/context
          if (this.gl && this.gl.canvas === this.canvas || this.context) {
              return;
          }
          this.context = Canvas.getCanvas2DContext(this.canvas);
          if (!this.context) {
              return;
          }
          this.context.dpr = 1;
          if (this.layer.options['globalCompositeOperation']) {
              this.context.globalCompositeOperation = this.layer.options['globalCompositeOperation'];
          }
          var dpr = this.getMap().getDevicePixelRatio();
          if (dpr !== 1) {
              this._canvasContextScale(this.context, dpr);
          }
      };
      CanvasRenderer.prototype.resetCanvasTransform = function () {
          if (!this.context) {
              return;
          }
          var dpr = this.getMap().getDevicePixelRatio();
          this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
      };
      /**
       * Resize the canvas
       * @param canvasSize the size resizing to
       */
      CanvasRenderer.prototype.resizeCanvas = function (canvasSize) {
          var canvas = this.canvas;
          if (!canvas) {
              return;
          }
          var size = canvasSize || this.getMap().getSize();
          var r = this.getMap().getDevicePixelRatio();
          var _a = calCanvasSize(size, r), width = _a.width, height = _a.height, cssWidth = _a.cssWidth, cssHeight = _a.cssHeight;
          // width/height不变并不意味着 css width/height 不变
          if (this.layer._canvas && (canvas.style.width !== cssWidth || canvas.style.height !== cssHeight)) {
              canvas.style.width = cssWidth;
              canvas.style.height = cssHeight;
          }
          if (canvas.width === width && canvas.height === height) {
              return;
          }
          //retina support
          canvas.height = height;
          canvas.width = width;
          if (this.context) {
              this.context.dpr = 1;
          }
          if (r !== 1 && this.context) {
              this._canvasContextScale(this.context, r);
          }
      };
      /**
       * Clear the canvas to blank
       */
      CanvasRenderer.prototype.clearCanvas = function () {
          if (!this.context || !this.getMap()) {
              return;
          }
          //fix #1597
          var r = this.getMap().getDevicePixelRatio();
          var rScale = 1 / r;
          var w = this.canvas.width * rScale, h = this.canvas.height * rScale;
          Canvas.clearRect(this.context, 0, 0, Math.max(w, this.canvas.width), Math.max(h, this.canvas.height));
      };
      /**
       * @english
       * Prepare the canvas for rendering. <br>
       * 1. Clear the canvas to blank. <br>
       * 2. Clip the canvas by mask if there is any and return the mask's extent
       * @return {PointExtent} mask's extent of current zoom's 2d point.
       */
      CanvasRenderer.prototype.prepareCanvas = function () {
          if (!this.canvas) {
              this.createCanvas();
              this.createContext();
              this.layer.onCanvasCreate();
              /**
               * canvascreate event, fired when canvas created.
               *
               * @event Layer#canvascreate
               * @type {Object}
               * @property {String} type     - canvascreate
               * @property {Layer} target    - layer
               * @property {CanvasRenderingContext2D} context - canvas's context
               * @property {WebGLRenderingContext2D} gl  - canvas's webgl context
               */
              this.layer.fire('canvascreate', {
                  'context': this.context,
                  'gl': this.gl
              });
          }
          else {
              this.resetCanvasTransform();
              this.clearCanvas();
              this.resizeCanvas();
          }
          delete this._maskExtent;
          var mask = this.layer.getMask();
          // this.context may be not available
          if (!mask) {
              this.layer.fire('renderstart', {
                  'context': this.context,
                  'gl': this.gl
              });
              return null;
          }
          var maskExtent2D = this._maskExtent = mask._getMaskPainter().get2DExtent();
          //fix vt _extent2D is null
          if (maskExtent2D && this._extent2D && !maskExtent2D.intersects(this._extent2D)) {
              this.layer.fire('renderstart', {
                  'context': this.context,
                  'gl': this.gl
              });
              return maskExtent2D;
          }
          /**
           * renderstart event, fired when layer starts to render.
           *
           * @event Layer#renderstart
           * @type {Object}
           * @property {String} type              - renderstart
           * @property {Layer} target    - layer
           * @property {CanvasRenderingContext2D} context - canvas's context
           */
          this.layer.fire('renderstart', {
              'context': this.context,
              'gl': this.gl
          });
          return maskExtent2D;
      };
      CanvasRenderer.prototype.clipCanvas = function (context) {
          var mask = this.layer.getMask();
          if (!mask) {
              return false;
          }
          if (!this.layer.options.maskClip) {
              return false;
          }
          var old = this.middleWest;
          var map = this.getMap();
          //when clipping, layer's middleWest needs to be reset for mask's containerPoint conversion
          this.middleWest = map._containerPointToPoint(new Point(0, map.height / 2));
          context.save();
          var dpr = map.getDevicePixelRatio();
          if (dpr !== 1) {
              context.save();
              this._canvasContextScale(context, dpr);
          }
          // Handle MultiPolygon
          if (mask.getGeometries) {
              context.isMultiClip = true;
              var masks = mask.getGeometries() || [];
              context.beginPath();
              masks.forEach(function (_mask) {
                  var painter = _mask._getMaskPainter();
                  painter.paint(null, context);
              });
              context.stroke();
              context.isMultiClip = false;
          }
          else {
              context.isClip = true;
              context.beginPath();
              var painter = mask._getMaskPainter();
              painter.paint(null, context);
              context.isClip = false;
          }
          if (dpr !== 1) {
              context.restore();
          }
          try {
              context.clip('evenodd');
          }
          catch (error) {
              console.error(error);
          }
          this.middleWest = old;
          return true;
      };
      /**
       * Get renderer's current view extent in 2d point
       * @return {Object} view.extent, view.maskExtent, view.zoom, view.middleWest
       */
      CanvasRenderer.prototype.getViewExtent = function () {
          return {
              'extent': this._extent2D,
              'maskExtent': this._maskExtent,
              'zoom': this._renderZoom,
              'middleWest': this.middleWest
          };
      };
      /**
       * call when rendering completes, this will fire necessary events and call setCanvasUpdated
       */
      CanvasRenderer.prototype.completeRender = function () {
          if (this.getMap()) {
              this._renderComplete = true;
              /**
               * renderend event, fired when layer ends rendering.
               *
               * @event Layer#renderend
               * @type {Object}
               * @property {String} type              - renderend
               * @property {Layer} target    - layer
               * @property {CanvasRenderingContext2D} context - canvas's context
               */
              this.layer.fire('renderend', {
                  'context': this.context,
                  'gl': this.gl
              });
              this.setCanvasUpdated();
          }
      };
      /**
       * Get renderer's event map registered on the map
       * @return {Object} events
       */
      CanvasRenderer.prototype.getEvents = function () {
          return {
              '_zoomstart': this.onZoomStart,
              '_zooming': this.onZooming,
              '_zoomend': this.onZoomEnd,
              '_resize': this.onResize,
              '_movestart': this.onMoveStart,
              '_moving': this.onMoving,
              '_moveend': this.onMoveEnd,
              '_dragrotatestart': this.onDragRotateStart,
              '_dragrotating': this.onDragRotating,
              '_dragrotateend': this.onDragRotateEnd,
              '_spatialreferencechange': this.onSpatialReferenceChange
          };
      };
      /* eslint-disable @typescript-eslint/no-unused-vars */
      /**
       * onZoomStart
       * @param  {Object} param event parameters
       */
      CanvasRenderer.prototype.onZoomStart = function (param) {
      };
      /**
      * onZoomEnd
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onZoomEnd = function (param) {
          this.setToRedraw();
      };
      /**
      * onZooming
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onZooming = function (param) { };
      /**
      * onMoveStart
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onMoveStart = function (param) { };
      /**
      * onMoving
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onMoving = function (param) { };
      /**
      * onMoveEnd
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onMoveEnd = function (param) {
          this.setToRedraw();
      };
      /**
      * onResize
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onResize = function (param) {
          delete this._extent2D;
          this.resizeCanvas();
          this.setToRedraw();
      };
      /**
      * onDragRotateStart
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onDragRotateStart = function (param) { };
      /**
      * onDragRotating
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onDragRotating = function (param) { };
      /**
      * onDragRotateEnd
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onDragRotateEnd = function (param) {
          this.setToRedraw();
      };
      /**
      * onSpatialReferenceChange
      * @param  {Object} param event parameters
      */
      CanvasRenderer.prototype.onSpatialReferenceChange = function (param) {
      };
      /* eslint-disable @typescript-eslint/no-unused-vars */
      /**
       * Get ellapsed time of previous drawing
       * @return {Number}
       */
      CanvasRenderer.prototype.getDrawTime = function () {
          return this._drawTime;
      };
      //@internal
      CanvasRenderer.prototype._tryToDraw = function (framestamp) {
          this._toRedraw = false;
          if (!this.canvas && this.layer.isEmpty && this.layer.isEmpty()) {
              this._renderComplete = true;
              // not to create canvas when layer is empty
              return;
          }
          this._drawAndRecord(framestamp);
      };
      //@internal
      CanvasRenderer.prototype._drawAndRecord = function (framestamp) {
          if (!this.getMap()) {
              return;
          }
          var painted = this._painted;
          this._painted = true;
          var t = now();
          this.draw(framestamp);
          t = now() - t;
          //reduce some time in the first draw
          this._drawTime = painted ? t : t / 2;
          if (painted && this.layer && this.layer.options['logDrawTime']) {
              console.log(this.layer.getId(), 'frameTimeStamp:', framestamp, 'drawTime:', this._drawTime);
          }
      };
      //@internal
      CanvasRenderer.prototype._promiseResource = function (url) {
          var _this = this;
          var layer = this.layer;
          var resources = this.resources;
          var crossOrigin = layer.options['crossOrigin'];
          var renderer = layer.options['renderer'] || '';
          return function (resolve) {
              if (resources.isResourceLoaded(url, true)) {
                  resolve(url);
                  return;
              }
              var imageURL = formatResourceUrl(url[0]);
              if (isImageBitMap(imageURL)) {
                  createImageBitmap(imageURL).then(function (newbitmap) {
                      //新的数据为layer提供服务
                      _this._cacheResource(url, newbitmap);
                      resolve(url);
                  }).catch(function (err) {
                      console.error(err);
                      resolve(url);
                  });
                  return;
              }
              var fetchInWorker = !isSVG(url[0]) && _this._resWorkerConn && (layer.options['renderer'] !== 'canvas' || layer.options['decodeImageInWorker']);
              if (fetchInWorker) {
                  // const uri = getAbsoluteURL(url[0]);
                  _this._resWorkerConn.fetchImage(imageURL, function (err, data) {
                      if (err) {
                          if (err && typeof console !== 'undefined') {
                              console.warn(err);
                          }
                          resolve(url);
                          return;
                      }
                      getImageBitMap(data, function (bitmap) {
                          _this._cacheResource(url, bitmap);
                          resolve(url);
                      });
                  });
              }
              else {
                  var img_1 = new Image();
                  if (!isNil(crossOrigin)) {
                      img_1['crossOrigin'] = crossOrigin;
                  }
                  else if (renderer !== 'canvas') {
                      img_1['crossOrigin'] = '';
                  }
                  if (isSVG(url[0]) && !IS_NODE) {
                      //amplify the svg image to reduce loading.
                      if (url[1]) {
                          url[1] *= 2;
                      }
                      if (url[2]) {
                          url[2] *= 2;
                      }
                  }
                  img_1.onload = function () {
                      _this._cacheResource(url, img_1);
                      resolve(url);
                  };
                  img_1.onabort = function (err) {
                      if (console) {
                          console.warn('image loading aborted: ' + url[0]);
                      }
                      if (err) {
                          if (console) {
                              console.warn(err);
                          }
                      }
                      resolve(url);
                  };
                  img_1.onerror = function (err) {
                      // if (console) { console.warn('image loading failed: ' + url[0]); }
                      if (err && typeof console !== 'undefined') {
                          console.warn(err);
                      }
                      resources.markErrorResource(url);
                      resolve(url);
                  };
                  loadImage(img_1, [imageURL]);
              }
          };
      };
      //@internal
      CanvasRenderer.prototype._cacheResource = function (url, img) {
          if (!this.layer || !this.resources) {
              return;
          }
          var w = url[1], h = url[2];
          if (this.layer.options['cacheSvgOnCanvas'] && isSVG(url[0]) === 1 && (Browser$1.edge || Browser$1.ie)) {
              //opacity of svg img painted on canvas is always 1, so we paint svg on a canvas at first.
              if (isNil(w)) {
                  w = img.width || this.layer.options['defaultIconSize'][0];
              }
              if (isNil(h)) {
                  h = img.height || this.layer.options['defaultIconSize'][1];
              }
              var canvas = Canvas.createCanvas(w, h);
              Canvas.image(canvas.getContext('2d'), img, 0, 0, w, h);
              img = canvas;
          }
          this.resources.addResource(url, img);
      };
      return CanvasRenderer;
  }(Class));
  var ResourceCache = /** @class */ (function () {
      function ResourceCache() {
          this.resources = {};
          this._errors = {};
      }
      ResourceCache.prototype.addResource = function (url, img) {
          var _this = this;
          this.resources[url[0]] = {
              image: img,
              width: +url[1],
              height: +url[2],
              refCnt: 0
          };
          if (img && img.width && img.height && !img.close && Browser$1.imageBitMap && !Browser$1.safari && !Browser$1.iosWeixin) {
              if (img.src && isSVG(img.src)) {
                  return;
              }
              createImageBitmap(img).then(function (imageBitmap) {
                  if (!_this.resources[url[0]]) {
                      //removed
                      return;
                  }
                  _this.resources[url[0]].image = imageBitmap;
              });
          }
      };
      ResourceCache.prototype.isResourceLoaded = function (url, checkSVG) {
          if (!url) {
              return false;
          }
          var imgUrl = this._getImgUrl(url);
          if (this._errors[imgUrl]) {
              return true;
          }
          var img = this.resources[imgUrl];
          if (!img) {
              return false;
          }
          if (checkSVG && isSVG(url[0]) && (+url[1] > img.width || +url[2] > img.height)) {
              return false;
          }
          return true;
      };
      ResourceCache.prototype.login = function (url) {
          var res = this.resources[url];
          if (res) {
              res.refCnt++;
          }
      };
      ResourceCache.prototype.logout = function (url) {
          var res = this.resources[url];
          if (res && res.refCnt-- <= 0) {
              if (res.image && res.image.close) {
                  res.image.close();
              }
              delete this.resources[url];
          }
      };
      ResourceCache.prototype.getImage = function (url) {
          var imgUrl = this._getImgUrl(url);
          if (!this.isResourceLoaded(url) || this._errors[imgUrl]) {
              return null;
          }
          return this.resources[imgUrl].image;
      };
      ResourceCache.prototype.markErrorResource = function (url) {
          this._errors[this._getImgUrl(url)] = 1;
      };
      ResourceCache.prototype.merge = function (res) {
          if (!res) {
              return this;
          }
          for (var p in res.resources) {
              var img = res.resources[p];
              this.addResource([p, img.width, img.height], img.image);
          }
          return this;
      };
      ResourceCache.prototype.forEach = function (fn) {
          if (!this.resources) {
              return this;
          }
          for (var p in this.resources) {
              if (hasOwn(this.resources, p)) {
                  fn(p, this.resources[p]);
              }
          }
          return this;
      };
      //@internal
      ResourceCache.prototype._getImgUrl = function (url) {
          if (!Array.isArray(url)) {
              return url;
          }
          return url[0];
      };
      ResourceCache.prototype.remove = function () {
          for (var p in this.resources) {
              var res = this.resources[p];
              if (res && res.image && res.image.close) {
                  // close bitmap
                  res.image.close();
              }
          }
          this.resources = {};
      };
      return ResourceCache;
  }());
  var workerSource = "\nfunction (exports) {\n    exports.onmessage = function (msg, postResponse) {\n        var url = msg.data.url;\n        var fetchOptions = msg.data.fetchOptions;\n        requestImageOffscreen(url, function (err, data) {\n            var buffers = [];\n            if (data && data.data) {\n                buffers.push(data.data);\n            }\n            postResponse(err, data, buffers);\n        }, fetchOptions);\n    };\n\n    function requestImageOffscreen(url, cb, fetchOptions) {\n        fetch(url, fetchOptions ? fetchOptions : {})\n            .then(response => response.arrayBuffer())\n            .then(arrayBuffer => {\n                const blob=new Blob([arrayBuffer]);\n                return createImageBitmap(blob);\n            })\n            .then(bitmap => {\n                cb(null, {data:bitmap});\n            }).catch(err => {\n                console.warn('error when loading tile:', url);\n                console.warn(err);\n                cb(err);\n            });\n    }\n}";
  function registerWorkerSource() {
      if (!Browser$1.decodeImageInWorker) {
          return;
      }
      registerWorkerAdapter(imageFetchWorkerKey, function () { return workerSource; });
  }
  registerWorkerSource();

  var DEFAULT_MARKER_SYMBOLS = {
      markerWidth: 10,
      markerHeight: 10,
      markerLineWidth: 1
  };
  //-------------- methods for fixed extent of markers -------------
  var TEMP_DXDYPOINT = new Point(0, 0);
  /** p(0,0)
   *   \
   *    \
   *     \
   *      \
   *     dxdy
   */
  function getDxDyRad(dxdy) {
      if (!dxdy) {
          return 0;
      }
      var x = dxdy.x, y = dxdy.y;
      if (x === 0 && y === 0) {
          return 0;
      }
      if (x === 0 || !x) {
          if (y < 0) {
              return -Math.PI / 2;
          }
          if (y > 0) {
              return Math.PI / 2;
          }
      }
      var tan = y / x;
      if (y < 0 && x < 0) {
          return Math.atan(tan) - Math.PI;
      }
      else if (y > 0 && x < 0) {
          return Math.atan(tan) + Math.PI;
      }
      return Math.atan(tan);
  }
  function getImageRotateBBOX(width, height, rad) {
      /**
       * p1(0,0)
       * p2(0,height)
       * p3(width,height)
       * p4(width,0)
       *
       * p1 --------- p4
       * |            |
       * |            |
       * |            |
       * p2 --------- p3
       */
      var rad2 = Math.PI / 2 + rad;
      var rad3 = Math.PI / 4 + rad;
      var rad4 = rad;
      var r2 = height;
      var r3 = Math.sqrt(width * width + height * height);
      var r4 = width;
      var p1x = 0, p1y = 0;
      var p2x = Math.cos(rad2) * r2, p2y = Math.sin(rad2) * r2;
      var p3x = Math.cos(rad3) * r3, p3y = Math.sin(rad3) * r3;
      var p4x = Math.cos(rad4) * r4, p4y = Math.sin(rad4) * r4;
      var minx = Math.min(p2x, p3x, p4x, p1x);
      var miny = Math.min(p2y, p3y, p4y, p1y);
      var maxx = Math.max(p2x, p3x, p4x, p1x);
      var maxy = Math.max(p2y, p3y, p4y, p1y);
      return [minx, miny, maxx - minx, maxy - miny];
  }
  function getMarkerRotationExtent(out, rad, width, height, dxdy, alignPoint) {
      var x = dxdy.x + alignPoint.x, y = dxdy.y + alignPoint.y;
      TEMP_DXDYPOINT.x = x;
      TEMP_DXDYPOINT.y = y;
      //dxdy rad
      var dxdyRad = getDxDyRad(TEMP_DXDYPOINT);
      //dxdy的半径
      var radius = Math.sqrt(x * x + y * y);
      //dydy 在 markerRaotation下的像素点新的位置
      /**
       *     p
       *     /\
       *    /  \
       *   /    \
       *  /      \
       * /        \
       * dxdy    rxry
       */
      var rx = Math.cos(rad + dxdyRad) * radius, ry = Math.sin(rad + dxdyRad) * radius;
      //p像素点平移到 rxry所在的像素点
      var minx = 0, miny = 0;
      minx += rx;
      miny += ry;
      //计算旋转图形后新的图形的BBOX
      var _a = __read(getImageRotateBBOX(width, height, rad), 4), offsetX = _a[0], offsetY = _a[1], w = _a[2], h = _a[3];
      minx += offsetX;
      miny += offsetY;
      var maxx = minx + Math.max(width, w), maxy = miny + Math.max(height, h);
      out.set(minx, miny, maxx, maxy);
      return out;
  }
  function getVectorPadding( /*symbol*/) {
      return 0.5;
  }
  var DXDY = new Point(0, 0);
  function getFixedExtent(out, dx, dy, rotation, alignPoint, w, h) {
      var dxdy = DXDY.set(dx, dy);
      if (rotation) {
          return getMarkerRotationExtent(out, rotation, w, h, dxdy, alignPoint);
      }
      var result = out.set(dxdy.x, dxdy.y, dxdy.x + w, dxdy.y + h);
      result._add(alignPoint);
      if (rotation) {
          rotateExtent(result, rotation);
      }
      return result;
  }
  var SIZE = [];
  function getVectorMarkerFixedExtent(out, symbol, size) {
      // const padding = getVectorPadding(symbol) * 2;
      size = size || calVectorMarkerSize(SIZE, symbol);
      if (size && (size[0] === 0 || size[1] === 0)) {
          emptyExtent(out);
          return out;
      }
      // if (padding) {
      //     size = size.map(d => d - padding);
      // }
      var alignPoint = getVectorMarkerAnchor(symbol, size[0], size[1]);
      return getFixedExtent(out, symbol['markerDx'] || 0, symbol['markerDy'] || 0, getMarkerRotation(symbol), alignPoint, size[0], size[1]);
  }
  function getDefaultHAlign(markerType) {
      if (markerType === 'rectangle') {
          return 'right';
      }
      else {
          return 'middle';
      }
  }
  function getDefaultVAlign(markerType) {
      if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
          return 'top';
      }
      else if (markerType === 'rectangle') {
          return 'bottom';
      }
      else {
          return 'middle';
      }
  }
  var TEMP_SIZE$1 = new Size(0, 0);
  function getVectorMarkerAnchor(symbol, w, h) {
      var padding = getVectorPadding();
      var shadow = 2 * (symbol['shadowBlur'] || 0), margin = shadow + padding;
      TEMP_SIZE$1.width = w;
      TEMP_SIZE$1.height = h;
      var markerType = symbol['markerType'];
      var p = getAlignPoint(TEMP_SIZE$1, symbol['markerHorizontalAlignment'] || getDefaultHAlign(markerType), symbol['markerVerticalAlignment'] || getDefaultVAlign(markerType));
      if (p.x !== -w / 2) {
          p.x -= sign(p.x + w / 2) * margin;
      }
      if (p.y !== -h / 2) {
          p.y -= sign(p.y + h / 2) * margin;
      }
      return p;
  }
  function calVectorMarkerSize(out, symbol) {
      var padding = getVectorPadding();
      var width = getValueOrDefault(symbol['markerWidth'], DEFAULT_MARKER_SYMBOLS.markerWidth);
      var height = getValueOrDefault(symbol['markerHeight'], DEFAULT_MARKER_SYMBOLS.markerHeight);
      if (width === 0 || height === 0) {
          out[0] = 0;
          out[1] = 0;
          return out;
      }
      var lineWidth = getValueOrDefault(symbol['markerLineWidth'], DEFAULT_MARKER_SYMBOLS.markerLineWidth), shadow = 2 * ((symbol['shadowBlur'] || 0) + Math.max(Math.abs(symbol['shadowOffsetX'] || 0) + Math.abs(symbol['shadowOffsetY'] || 0))), // add some tolerance for shadowOffsetX/Y
      w = Math.round(width + lineWidth + shadow + padding * 2), h = Math.round(height + lineWidth + shadow + padding * 2);
      out[0] = w;
      out[1] = h;
      return out;
  }
  var ROTATE_EXTENT = new PointExtent();
  function rotateExtent(fixedExtent, angle) {
      var xmin = fixedExtent.xmin, ymin = fixedExtent.ymin, xmax = fixedExtent.xmax, ymax = fixedExtent.ymax;
      ROTATE_EXTENT.set(xmin, ymin, xmax, ymax);
      return ROTATE_EXTENT.convertTo(function (p) { return p._rotate(angle); }, fixedExtent);
  }
  function getMarkerRotation(symbol, prop) {
      if (prop === void 0) { prop = 'markerRotation'; }
      var r = symbol[prop];
      if (!isNumber(r)) {
          return 0;
      }
      //to radian
      return -r * Math.PI / 180;
  }
  function getImageMarkerFixedExtent(out, symbol, resources) {
      var url = symbol['markerFile'], img = resources ? resources.getImage(url) : null;
      var width = symbol['markerWidth'] || (img ? img.width : 0), height = symbol['markerHeight'] || (img ? img.height : 0);
      TEMP_SIZE$1.width = width;
      TEMP_SIZE$1.height = height;
      if (symbol['markerWidth'] === 0 || symbol['markerHeight'] === 0) {
          emptyExtent(out);
          return out;
      }
      var alignPoint = getAlignPoint(TEMP_SIZE$1, symbol['markerHorizontalAlignment'] || 'middle', symbol['markerVerticalAlignment'] || 'top');
      return getFixedExtent(out, symbol['markerDx'] || 0, symbol['markerDy'] || 0, getMarkerRotation(symbol), alignPoint, width, height);
  }
  function getTextMarkerFixedExtent(out, symbol, textDesc) {
      var size = textDesc['size'];
      if (size && (size.width === 0 || size.height === 0)) {
          emptyExtent(out);
          return out;
      }
      var alignPoint = getAlignPoint(size, symbol['textHorizontalAlignment'], symbol['textVerticalAlignment']);
      // if (symbol['textHaloRadius']) {
      //     const r = symbol['textHaloRadius'];
      //     size = size.add(r * 2, r * 2);
      // }
      var textHaloRadius = (symbol.textHaloRadius || 0);
      var extent = getFixedExtent(out, symbol['textDx'] || 0, symbol['textDy'] || 0, getMarkerRotation(symbol, 'textRotation'), alignPoint, size.width, size.height);
      extent.xmin -= textHaloRadius;
      extent.xmax += textHaloRadius;
      extent.ymin -= textHaloRadius;
      extent.ymax += textHaloRadius;
      return extent;
  }
  var FIXED_EXTENT = new PointExtent();
  function getMarkerFixedExtent(out, symbol, resources, textDesc) {
      var extent = out || new PointExtent();
      if (Array.isArray(symbol)) {
          var symbols = symbol;
          for (var i = 0; i < symbols.length; i++) {
              getMarkerFixedExtent(extent, symbols[i], resources, textDesc[i]);
          }
          return extent;
      }
      if (isTextSymbol(symbol)) {
          extent._combine(getTextMarkerFixedExtent(FIXED_EXTENT, symbol, textDesc));
      }
      if (isImageSymbol(symbol)) {
          extent._combine(getImageMarkerFixedExtent(FIXED_EXTENT, symbol, resources));
      }
      if (isVectorSymbol(symbol)) {
          extent._combine(getVectorMarkerFixedExtent(FIXED_EXTENT, symbol));
      }
      if (isPathSymbol(symbol)) {
          extent._combine(getImageMarkerFixedExtent(FIXED_EXTENT, symbol));
      }
      return extent;
  }
  function isTextSymbol(symbol) {
      if (!symbol) {
          return false;
      }
      if (!isNil(symbol['textName'])) {
          return true;
      }
      return false;
  }
  function isImageSymbol(symbol) {
      if (!symbol) {
          return false;
      }
      if (!isNil(symbol['markerFile'])) {
          return true;
      }
      return false;
  }
  function isVectorSymbol(symbol) {
      if (!symbol) {
          return false;
      }
      if (isNil(symbol['markerFile']) && !isNil(symbol['markerType']) && (symbol['markerType'] !== 'path')) {
          return true;
      }
      return false;
  }
  function isPathSymbol(symbol) {
      if (!symbol) {
          return false;
      }
      if (isNil(symbol['markerFile']) && symbol['markerType'] === 'path') {
          return true;
      }
      return false;
  }
  var DYNAMIC_SYMBOL_PROPS = [
      'markerWidth', 'markerHeight', 'markerHorizontalAlignment', 'markerVerticalAlignment', 'markerDx', 'markerDy', 'markerRotation',
      'textName',
      'textSize', 'textDx', 'textDy', 'textVerticalAlignment', 'textHorizontalAlignment', 'textRotation', 'textWrapWidth'
  ];
  var SIZE_SYMBOL_PROPS = [
      'textName', 'markerType', 'markerFile', 'textHaloRadius', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textWrapWidth'
  ];
  function emptyExtent(extent) {
      if (!extent) {
          return;
      }
      extent.xmin = Infinity;
      extent.ymin = Infinity;
      extent.xmax = -Infinity;
      extent.ymax = -Infinity;
  }

  function clipLine(points, bounds, round, noCut) {
      var parts = [];
      var k = 0, segment;
      for (var j = 0, l = points.length; j < l - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, round, noCut);
          if (!segment) {
              continue;
          }
          parts[k] = parts[k] || [];
          parts[k].push({
              'point': segment[0],
              'index': j
          });
          // if segment goes out of screen, or it's the last one, it's the end of the line part
          if ((segment[1] !== points[j + 1]) || (j === l - 2)) {
              // parts[k].push(segment[1]);
              parts[k].push({
                  'point': segment[1],
                  'index': j + 1
              });
              k++;
          }
      }
      return parts;
  }
  var _lastCode;
  // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.
  // @copyright Leaflet
  function clipSegment(a, b, bounds, useLastCode, round, noCut) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
      // save 2nd code to avoid calculating it on the next segment
      //@internal
      _lastCode = codeB;
      /* eslint-disable no-constant-condition */
      while (true) {
          // if a,b is inside the clip window (trivial accept)
          if (!(codeA | codeB)) {
              return [a, b];
          }
          // if a,b is outside the clip window (trivial reject)
          if (codeA & codeB) {
              return false;
          }
          if (noCut) {
              return [a, b];
          }
          // other cases
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
              a = p;
              codeA = newCode;
          }
          else {
              b = p;
              codeB = newCode;
          }
      }
      /* eslint-enable no-constant-condition */
  }
  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a seperate method for it.
   * @copyright Leaflet
   */
  function clipPolygon(points, bounds, round) {
      var edges = [1, 4, 2, 8];
      var clippedPoints, i, j, k, a, b, len, edge, p;
      for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
      }
      // for each edge (left, bottom, right, top)
      for (k = 0; k < 4; k++) {
          edge = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
              a = points[i];
              b = points[j];
              // if a is inside the clip window
              if (!(a._code & edge)) {
                  // if b is outside the clip window (a->b goes out of screen)
                  if (b._code & edge) {
                      p = _getEdgeIntersection(b, a, edge, bounds, round);
                      p._code = _getBitCode(p, bounds);
                      clippedPoints.push(p);
                  }
                  clippedPoints.push(a);
                  // else if b is inside the clip window (a->b enters the screen)
              }
              else if (!(b._code & edge)) {
                  p = _getEdgeIntersection(b, a, edge, bounds, round);
                  p._code = _getBitCode(p, bounds);
                  clippedPoints.push(p);
              }
          }
          points = clippedPoints;
      }
      return points;
  }
  function _getEdgeIntersection(a, b, code, bounds, round) {
      var dx = b.x - a.x, dy = b.y - a.y, min = bounds.getMin(), max = bounds.getMax();
      var x, y;
      if (code & 8) { // top
          x = a.x + dx * (max.y - a.y) / dy;
          y = max.y;
      }
      else if (code & 4) { // bottom
          x = a.x + dx * (min.y - a.y) / dy;
          y = min.y;
      }
      else if (code & 2) { // right
          x = max.x;
          y = a.y + dy * (max.x - a.x) / dx;
      }
      else if (code & 1) { // left
          x = min.x;
          y = a.y + dy * (min.x - a.x) / dx;
      }
      var p = new Point(x, y);
      if (round) {
          p._round();
      }
      return p;
  }
  function _getBitCode(p, bounds) {
      var code = 0;
      if (p.x < bounds.getMin().x) { // left
          code |= 1;
      }
      else if (p.x > bounds.getMax().x) { // right
          code |= 2;
      }
      if (p.y < bounds.getMin().y) { // bottom
          code |= 4;
      }
      else if (p.y > bounds.getMax().y) { // top
          code |= 8;
      }
      return code;
  }
  /**
   * Is the point within an ellipse
   * @param  point
   * @param  center ellipse's center
   * @param  southeast ellipse's southeast point
   * @param  tolerance
   * @returns
   * @private
   * @memberOf Util
   */
  function withInEllipse(point, center, southeast, tolerance) {
      point = new Point(point);
      var a = Math.abs(southeast.x - center.x), b = Math.abs(southeast.y - center.y), c = Math.sqrt(Math.abs(a * a - b * b)), xfocus = a >= b;
      var f1, f2, d;
      if (xfocus) {
          f1 = new Point(center.x - c, center.y);
          f2 = new Point(center.x + c, center.y);
          d = a * 2;
      }
      else {
          f1 = new Point(center.x, center.y - c);
          f2 = new Point(center.x, center.y + c);
          d = b * 2;
      }
      /*
      L1 + L2 = D
      L1 + t >= L1'
      L2 + t >= L2'
      D + 2t >= L1' + L2'
      */
      return (point.distanceTo(f1) + point.distanceTo(f2)) <= (d + 2 * tolerance);
  }
  function getMinMaxAltitude(altitude) {
      if (!altitude) {
          return [0, 0];
      }
      var min = Infinity, max = -Infinity;
      //number
      if (isNumber(altitude)) {
          min = max = altitude;
          return [min, max];
      }
      var pathMinMax = function (alts) {
          for (var i = 0, len = alts.length; i < len; i++) {
              var alt = alts[i];
              min = Math.min(min, alt);
              max = Math.max(max, alt);
          }
      };
      //number []
      if (!Array.isArray(altitude[0])) {
          pathMinMax(altitude);
          return [min, max];
      }
      //number [][]
      for (var i = 0, len = altitude.length; i < len; i++) {
          var alts = altitude[i];
          pathMinMax(alts);
      }
      return [min, max];
  }

  /**
   * symbolilzers的基础类,所有的symbolilzers都继承于此
   * 抽象类,不可实例化
   *
   * @english
   * @classdesc
   * Base class for all the symbolilzers
   * @class
   * @extends Class
   * @abstract
   * @private
   */
  var Symbolizer = /** @class */ (function () {
      function Symbolizer() {
          this.bbox = getDefaultBBOX();
      }
      //@internal
      Symbolizer.prototype._setBBOX = function (ctx, x1, y1, x2, y2) {
          if (!ctx.isHitTesting) {
              setBBOX(this.bbox, x1, y1, x2, y2);
          }
          return this;
      };
      //@internal
      Symbolizer.prototype._bufferBBOX = function (ctx, bufferSize) {
          if (!ctx.isHitTesting) {
              bufferBBOX(this.bbox, bufferSize);
          }
          return this;
      };
      Symbolizer.prototype.getMap = function () {
          return this.geometry.getMap();
      };
      Symbolizer.prototype.getPainter = function () {
          return this.painter;
      };
      Symbolizer.prototype.isDynamicSize = function () {
          return false;
      };
      Symbolizer.prototype.isVisible = function () {
          if (!this.style) {
              return true;
          }
          var visible = this.style.visible;
          if (visible === false || visible === 0) {
              return false;
          }
          var opacity = this.style.opacity;
          if (opacity <= 0) {
              return false;
          }
          return true;
      };
      /**
       * 测试该属性是否是与着色相关的属性
       *
       * @english
       * Test if the property is a property related with coloring
       * @param  prop - property name to test
       * @static
       * @function
       * @memberof symbolizer.Symbolizer
       */
      Symbolizer.testColor = function (prop) {
          if (!prop || !isString(prop)) {
              return false;
          }
          if (COLOR_PROPERTIES.indexOf(prop) >= 0) {
              return true;
          }
          return false;
      };
      return Symbolizer;
  }());

  /**
   *所有基于 HTML5 Canvas2D 的symbolizer类
   *
   * @english
   * @classdesc
   * Base symbolizer class for all the symbolizers base on HTML5 Canvas2D
   * @abstract
   * @class
   * @private
   * @memberOf symbolizer
   * @name CanvasSymbolizer
   * @extends {Symbolizer}
   */
  var CanvasSymbolizer = /** @class */ (function (_super) {
      __extends(CanvasSymbolizer, _super);
      function CanvasSymbolizer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      //@internal
      CanvasSymbolizer.prototype._prepareContext = function (ctx) {
          if (isFunctionDefinition(this.symbol['opacity'])) {
              if (!this._opacityFn) {
                  this._opacityFn = interpolated(this.symbol['opacity']);
              }
          }
          else {
              delete this._opacityFn;
          }
          if (isNumber(this.symbol['opacity'])) {
              if (ctx.globalAlpha !== this.symbol['opacity']) {
                  ctx.globalAlpha = this.symbol['opacity'];
              }
          }
          else if (this._opacityFn) {
              var map = this.getMap();
              ctx.globalAlpha = this._opacityFn(map.getZoom());
          }
          else if (ctx.globalAlpha !== 1) {
              ctx.globalAlpha = 1;
          }
      };
      CanvasSymbolizer.prototype.prepareCanvas = function (ctx, style, resources) {
          if (ctx.setLineDash && isArrayHasData(style['lineDasharray'])) {
              ctx.setLineDash(style['lineDasharray']);
          }
          var isHitTesting = this.getPainter().isHitTesting();
          Canvas.prepareCanvas(ctx, style, resources, isHitTesting);
      };
      CanvasSymbolizer.prototype.remove = function () { };
      CanvasSymbolizer.prototype.setZIndex = function () { };
      CanvasSymbolizer.prototype.show = function () { };
      CanvasSymbolizer.prototype.hide = function () { };
      //@internal
      CanvasSymbolizer.prototype._defineStyle = function (style) {
          if (this.symbol) {
              style.visible = this.symbol.visible;
              style.opacity = this.symbol.opacity;
          }
          return loadGeoSymbol(style, this.geometry);
      };
      return CanvasSymbolizer;
  }(Symbolizer));

  function getImage(resources, url) {
      var img = resources && resources.getImage(url);
      return img || null;
  }
  function drawVectorMarker(ctx, point, symbol, resources) {
      var strokeAndFill = translateMarkerLineAndFill(symbol);
      var style = symbol, markerType = style['markerType'].toLowerCase(), vectorArray = getVectorMarkerPoints(markerType, style['markerWidth'], style['markerHeight']), lineOpacity = strokeAndFill['lineOpacity'], fillOpacity = strokeAndFill['polygonOpacity'];
      var gradient = isGradient(strokeAndFill['polygonFill']);
      if (gradient) {
          var gradientExtent = void 0;
          if (isGradient(strokeAndFill['polygonFill'])) {
              if (!gradientExtent) {
                  gradientExtent = getGraidentExtent(point, style.markerWidth, style.markerHeight);
              }
              strokeAndFill['polygonGradientExtent'] = gradientExtent;
          }
      }
      Canvas.prepareCanvas(ctx, strokeAndFill, resources);
      var width = style['markerWidth'], height = style['markerHeight'], hLineWidth = style['markerLineWidth'] / 2;
      if (markerType === 'ellipse') {
          //ellipse default
          Canvas.ellipse(ctx, point, width / 2, height / 2, height / 2, lineOpacity, fillOpacity);
      }
      else if (markerType === 'cross' || markerType === 'x') {
          for (var j = vectorArray.length - 1; j >= 0; j--) {
              vectorArray[j]._add(point);
          }
          //线类型
          Canvas.path(ctx, vectorArray.slice(0, 2), lineOpacity);
          Canvas.path(ctx, vectorArray.slice(2, 4), lineOpacity);
      }
      else if (markerType === 'diamond' || markerType === 'bar' || markerType === 'square' || markerType === 'rectangle' || markerType === 'triangle') {
          if (markerType === 'bar') {
              point = point.add(0, -hLineWidth);
          }
          else if (markerType === 'rectangle') {
              point = point.add(hLineWidth, hLineWidth);
          }
          for (var j = vectorArray.length - 1; j >= 0; j--) {
              vectorArray[j]._add(point);
          }
          //面类型
          Canvas.polygon(ctx, vectorArray, lineOpacity, fillOpacity);
      }
      else if (markerType === 'pin') {
          point = point.add(0, -hLineWidth);
          for (var j = vectorArray.length - 1; j >= 0; j--) {
              vectorArray[j]._add(point);
          }
          var lineCap = ctx.lineCap;
          ctx.lineCap = 'round'; //set line cap to round to close the pin bottom
          Canvas.bezierCurveAndFill(ctx, vectorArray, lineOpacity, fillOpacity);
          ctx.lineCap = lineCap;
      }
      else if (markerType === 'pie') {
          point = point.add(0, -hLineWidth);
          var angle = Math.atan(width / 2 / height) * 180 / Math.PI;
          var lineCap = ctx.lineCap;
          ctx.lineCap = 'round';
          Canvas.sector(ctx, point, height, [90 - angle, 90 + angle], lineOpacity, fillOpacity);
          ctx.lineCap = lineCap;
      }
      else {
          throw new Error('unsupported markerType: ' + markerType);
      }
      return ctx.canvas;
  }
  function getGraidentExtent(point, w, h) {
      var e = new PointExtent();
      e._combine(point);
      e['xmin'] += -w / 2;
      e['ymin'] += -h / 2;
      e['xmax'] += w / 2;
      e['ymax'] += h / 2;
      return e;
  }
  function translateMarkerLineAndFill(s) {
      var result = {
          'lineColor': s['markerLineColor'],
          'linePatternFile': s['markerLinePatternFile'],
          'lineWidth': s['markerLineWidth'],
          'lineOpacity': s['markerLineOpacity'],
          'lineDasharray': s['markerLineDasharray'],
          'lineCap': 'butt',
          'lineJoin': 'round',
          'polygonFill': s['markerFill'],
          'polygonPatternFile': s['markerFillPatternFile'],
          'polygonOpacity': s['markerFillOpacity']
      };
      if (result['lineWidth'] === 0) {
          result['lineOpacity'] = 0;
      }
      return result;
  }
  function getVectorMarkerPoints(markerType, width, height) {
      //half height and half width
      var hh = height / 2, hw = width / 2;
      var left = 0, top = 0;
      var v0, v1, v2, v3;
      if (markerType === 'triangle') {
          v0 = new Point(left, top - hh);
          v1 = new Point(left - hw, top + hh);
          v2 = new Point(left + hw, top + hh);
          return [v0, v1, v2];
      }
      else if (markerType === 'cross') {
          v0 = new Point((left - hw), top);
          v1 = new Point((left + hw), top);
          v2 = new Point((left), (top - hh));
          v3 = new Point((left), (top + hh));
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'diamond') {
          v0 = new Point((left - hw), top);
          v1 = new Point(left, (top - hh));
          v2 = new Point((left + hw), top);
          v3 = new Point((left), (top + hh));
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'square') {
          v0 = new Point((left - hw), (top + hh));
          v1 = new Point((left + hw), (top + hh));
          v2 = new Point((left + hw), (top - hh));
          v3 = new Point((left - hw), (top - hh));
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'rectangle') {
          v0 = new Point(left, top);
          v1 = v0.add(width, 0);
          v2 = v0.add(width, height);
          v3 = v0.add(0, height);
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'x') {
          v0 = new Point(left - hw, top + hh);
          v1 = new Point(left + hw, top - hh);
          v2 = new Point(left + hw, top + hh);
          v3 = new Point(left - hw, top - hh);
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'bar') {
          v0 = new Point((left - hw), (top - height));
          v1 = new Point((left + hw), (top - height));
          v2 = new Point((left + hw), top);
          v3 = new Point((left - hw), top);
          return [v0, v1, v2, v3];
      }
      else if (markerType === 'pin' || markerType === 'pie') {
          var extWidth = height * Math.atan(hw / hh);
          v0 = new Point(left, top);
          v1 = new Point(left - extWidth, top - height);
          v2 = new Point(left + extWidth, top - height);
          v3 = new Point(left, top);
          return [v0, v1, v2, v3];
      }
      return [];
  }

  var TEMP_POINT0$3 = new Point(0, 0);
  var TEMP_POINT1$2 = new Point(0, 0);
  var TEMP_POINT2$2 = new Point(0, 0);
  var TEMP_POINT3$1 = new Point(0, 0);
  /**
   * 所有点类型符号样式的symbolizer基类
   *
   * @english
   * @classdesc
   * Base symbolizer class for all the point type symbol styles.
   * @abstract
   * @class
   * @private
   * @memberOf symbolizer
   * @name PointSymbolizer
   * @extends {symbolizer.CanvasSymbolizer}
   */
  var PointSymbolizer = /** @class */ (function (_super) {
      __extends(PointSymbolizer, _super);
      function PointSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this) || this;
          _this.symbol = symbol;
          _this.geometry = geometry;
          _this.painter = painter;
          return _this;
      }
      PointSymbolizer.prototype.get2DExtent = function () {
          var map = this.getMap();
          var glRes = map.getGLRes();
          var extent = new PointExtent();
          var renderPoints = this._getRenderPoints()[0];
          for (var i = renderPoints.length - 1; i >= 0; i--) {
              if (renderPoints[i]) {
                  extent._combine(map._pointAtResToPoint(renderPoints[i], glRes));
              }
          }
          return extent;
      };
      PointSymbolizer.prototype.isDynamicSize = function () {
          var symbol = this.symbol;
          return isFunctionDefinition(symbol['markerWidth']) || isFunctionDefinition(symbol['markerHeight']) ||
              isFunctionDefinition(symbol['textSize']);
      };
      //@internal
      PointSymbolizer.prototype._rotateExtent = function (fixedExtent, angle) {
          return fixedExtent.convertTo(function (p) { return p._rotate(angle); });
      };
      //@internal
      PointSymbolizer.prototype._getRenderPoints = function () {
          var painter = this.getPainter();
          var placement = painter.isSpriting() ? 'center' : this.getPlacement();
          return this.getPainter().getRenderPoints(placement);
      };
      /**
       * 获取容器内的点用于绘制
       *
       * @english
       * Get container points to draw on Canvas
       */
      //@internal
      PointSymbolizer.prototype._getRenderContainerPoints = function (ignoreAltitude) {
          var painter = this.getPainter();
          if (painter.isSpriting()) {
              return this._getRenderPoints()[0];
          }
          var geometry = this.geometry;
          var dxdy = this.getDxDy();
          var cpoints;
          if (geometry._cPoint && !ignoreAltitude) {
              //DANGEROUS
              //调用 _getRenderContainerPoints 获取坐标之后，都直接绘制了，所以这里可以用TEMP_POINT来减少对象创建
              //但如果 _getRenderContainerPoints 获取坐标后还有其他操作，会导致bug。
              var p = ignoreAltitude ? TEMP_POINT2$2 : TEMP_POINT3$1;
              p.set(geometry._cPoint.x, geometry._cPoint.y);
              // const p = geometry._cPoint;
              var containerOffset = painter.containerOffset;
              p._sub(containerOffset);
              var dx = dxdy.x, dy = dxdy.y;
              if (dx || dy) {
                  p._add(dx || 0, dy || 0);
              }
              cpoints = [p];
          }
          else {
              var points = this._getRenderPoints()[0];
              cpoints = this.painter._pointContainerPoints(points, dxdy.x, dxdy.y, ignoreAltitude, true, this.getPlacement());
          }
          if (!cpoints || !Array.isArray(cpoints[0])) {
              return cpoints;
          }
          var flat = [];
          for (var i = 0, l = cpoints.length; i < l; i++) {
              for (var ii = 0, ll = cpoints[i].length; ii < ll; ii++) {
                  flat.push(cpoints[i][ii]);
              }
          }
          return flat;
      };
      PointSymbolizer.prototype.getPlacement = function () {
          return this.symbol['markerPlacement'];
      };
      PointSymbolizer.prototype.getRotation = function () {
          return getMarkerRotation(this.style);
      };
      PointSymbolizer.prototype.getDxDy = function () {
          var s = this.style;
          var dx = s['markerDx'], dy = s['markerDy'];
          return new Point(dx, dy);
      };
      //@internal
      PointSymbolizer.prototype._getRotationAt = function (i) {
          var r = this.getRotation();
          if (!r) {
              r = 0;
          }
          var rotations = this._getRenderPoints()[1];
          if (!rotations || !rotations[i]) {
              return r;
          }
          var map = this.getMap();
          var p0 = rotations[i][0], p1 = rotations[i][1];
          if (map.isTransforming()) {
              var glRes = map.getGLRes();
              p0 = map._pointAtResToContainerPoint(rotations[i][0], glRes, 0, TEMP_POINT0$3);
              p1 = map._pointAtResToContainerPoint(rotations[i][1], glRes, 0, TEMP_POINT1$2);
              return r + computeDegree(p0.x, p0.y, p1.x, p1.y);
          }
          else {
              //point的y轴方向与containerPoint是相反的，所以角度取负值
              return r + -computeDegree(p0.x, p0.y, p1.x, p1.y);
          }
      };
      //@internal
      PointSymbolizer.prototype._rotate = function (ctx, origin, rotation) {
          if (rotation) {
              var dxdy = this.getDxDy();
              var p = origin.sub(dxdy);
              ctx.save();
              ctx.translate(p.x, p.y);
              ctx.rotate(rotation);
              return dxdy;
          }
          return null;
      };
      return PointSymbolizer;
  }(CanvasSymbolizer));

  var DebugSymbolizer = /** @class */ (function (_super) {
      __extends(DebugSymbolizer, _super);
      function DebugSymbolizer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      DebugSymbolizer.prototype.getPlacement = function () {
          return 'point';
      };
      DebugSymbolizer.prototype.getDxDy = function () {
          return new Point(0, 0);
      };
      DebugSymbolizer.prototype.symbolize = function (ctx) {
          var geometry = this.geometry, layer = geometry.getLayer();
          if (!geometry.options['debug'] && layer && !layer.options['debug']) {
              return;
          }
          var map = this.getMap();
          if (!map || map.isZooming()) {
              return;
          }
          var color = layer.options['debugOutline'], op = 1;
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          //set debug style
          ctx.lineWidth = 1;
          ctx.font = '18px  serif';
          //outline
          var outline = geometry.getContainerExtent().toArray();
          Canvas.polygon(ctx, [outline], op, 0);
          //center cross and id if have any.
          var points = this._getRenderContainerPoints(), id = this.geometry.getId(), cross = getVectorMarkerPoints('cross', 10, 10);
          for (var i = 0; i < points.length; i++) {
              var p = points[i];
              if (!isNil(id)) {
                  Canvas.fillText(ctx, id, p.add(8, -4), color);
              }
              var c = [];
              for (var ii = 0; ii < cross.length; ii++) {
                  c.push(cross[ii].add(p));
              }
              Canvas.path(ctx, c.slice(0, 2), op);
              Canvas.path(ctx, c.slice(2, 4), op);
          }
      };
      return DebugSymbolizer;
  }(PointSymbolizer));

  var TEMP_SIZE = new Size(1, 1);
  var TEMP_EXTENT$8 = new PointExtent();
  var ImageMarkerSymbolizer = /** @class */ (function (_super) {
      __extends(ImageMarkerSymbolizer, _super);
      function ImageMarkerSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this, symbol, geometry, painter) || this;
          _this.style = _this._defineStyle(_this.translate());
          return _this;
      }
      ImageMarkerSymbolizer.test = function (symbol) {
          return isImageSymbol(symbol);
      };
      ImageMarkerSymbolizer.prototype.symbolize = function (ctx, resources) {
          if (!this.isVisible()) {
              return;
          }
          var style = this.style;
          if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 || style['markerOpacity'] === 0)) {
              return;
          }
          var cookedPoints = this._getRenderContainerPoints();
          if (!isArrayHasData(cookedPoints)) {
              return;
          }
          var img = this._getImage(resources);
          if (!img) {
              if (typeof console !== 'undefined') {
                  console.warn('no img found for ' + (this.style['markerFile'] || this._url[0]));
              }
              return;
          }
          this._prepareContext(ctx);
          var width = style['markerWidth'];
          var height = style['markerHeight'];
          if (!isNumber(width) || !isNumber(height)) {
              width = img.width;
              height = img.height;
              style['markerWidth'] = width;
              style['markerHeight'] = height;
              var imgURL = style['markerFile'];
              if (!resources.isResourceLoaded(imgURL)) {
                  resources.addResource(imgURL, img);
              }
              var painter = this.getPainter();
              if (!painter.isSpriting()) {
                  painter.removeCache();
              }
          }
          var alpha;
          // for VectorPathMarkerSymbolizer, opacity is already set into SVG element.
          if (this.symbol['markerType'] !== 'path' &&
              isNumber(style['markerOpacity']) && style['markerOpacity'] < 1) {
              alpha = ctx.globalAlpha;
              ctx.globalAlpha *= style['markerOpacity'];
          }
          TEMP_SIZE.width = width;
          TEMP_SIZE.height = height;
          var alignPoint = getAlignPoint(TEMP_SIZE, style['markerHorizontalAlignment'], style['markerVerticalAlignment']);
          for (var i = 0, len = cookedPoints.length; i < len; i++) {
              var p = cookedPoints[i];
              // //for debug
              // ctx.fillStyle = 'red';
              // ctx.fillRect(p.x - 2, p.y - 160, 4, 4);
              // const origin = this._rotate(ctx, p, this._getRotationAt(i));
              var origin_1 = this.getRotation() ? this._rotate(ctx, p, this._getRotationAt(i)) : null;
              var extent = void 0;
              if (origin_1) {
                  //坐标对应的像素点
                  var pixel = p.sub(origin_1);
                  p = origin_1;
                  var rad = this._getRotationAt(i);
                  extent = getMarkerRotationExtent(TEMP_EXTENT$8, rad, width, height, p, alignPoint);
                  extent._add(pixel);
              }
              var x = p.x + alignPoint.x, y = p.y + alignPoint.y;
              Canvas.image(ctx, img, x, y, width, height);
              if (origin_1) {
                  ctx.restore();
              }
              if (origin_1) {
                  this._setBBOX(ctx, extent.xmin, extent.ymin, extent.xmax, extent.ymax);
              }
              else {
                  this._setBBOX(ctx, x, y, x + width, y + height);
              }
          }
          if (alpha !== undefined) {
              ctx.globalAlpha = alpha;
          }
      };
      //@internal
      ImageMarkerSymbolizer.prototype._getImage = function (resources) {
          return getImage(resources, this.style['markerFile']);
      };
      ImageMarkerSymbolizer.prototype.getFixedExtent = function (resources) {
          this._fixedExtent = this._fixedExtent || new PointExtent();
          return getImageMarkerFixedExtent(this._fixedExtent, this.style, resources);
      };
      ImageMarkerSymbolizer.prototype.translate = function () {
          var s = this.symbol;
          return {
              markerFile: s['markerFile'],
              markerOpacity: getValueOrDefault(s['markerOpacity'], 1),
              markerWidth: getValueOrDefault(s['markerWidth'], null),
              markerHeight: getValueOrDefault(s['markerHeight'], null),
              markerRotation: getValueOrDefault(s['markerRotation'], 0),
              markerDx: getValueOrDefault(s['markerDx'], 0),
              markerDy: getValueOrDefault(s['markerDy'], 0),
              markerHorizontalAlignment: getValueOrDefault(s['markerHorizontalAlignment'], 'middle'), //left | middle | right
              markerVerticalAlignment: getValueOrDefault(s['markerVerticalAlignment'], 'top'), // top | middle | bottom
          };
      };
      return ImageMarkerSymbolizer;
  }(PointSymbolizer));

  var TEMP_COORD0 = new Coordinate(0, 0);
  var TEMP_COORD1 = new Coordinate(0, 0);
  var StrokeAndFillSymbolizer = /** @class */ (function (_super) {
      __extends(StrokeAndFillSymbolizer, _super);
      function StrokeAndFillSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this) || this;
          _this.symbol = symbol;
          _this.geometry = geometry;
          _this.painter = painter;
          if (geometry.isPoint) {
              return _this;
          }
          _this.style = _this._defineStyle(_this.translate());
          return _this;
      }
      StrokeAndFillSymbolizer.test = function (symbol, geometry) {
          if (!symbol) {
              return false;
          }
          if (geometry && geometry.isPoint) {
              return false;
          }
          for (var p in symbol) {
              var f = p.slice(0, 4);
              if (f === 'line' || f === 'poly') {
                  return true;
              }
          }
          return false;
      };
      StrokeAndFillSymbolizer.prototype.symbolize = function (ctx, resources) {
          var _a, _b;
          if (!this.isVisible()) {
              return;
          }
          var style = this.style;
          if (style['polygonOpacity'] === 0 && style['lineOpacity'] === 0 && !this.painter.isHitTesting()) {
              return;
          }
          var paintParams = this._getPaintParams();
          if (!paintParams) {
              return;
          }
          this._prepareContext(ctx);
          var isGradient$1 = isGradient(style['lineColor']), isPath = this.geometry.getJSONType() === 'Polygon' || this.geometry.type === 'LineString';
          if (isGradient$1 && (style['lineColor']['places'] || !isPath)) {
              style['lineGradientExtent'] = this.geometry.getContainerExtent()._expand(style['lineWidth']);
          }
          if (isGradient(style['polygonFill'])) {
              style['polygonGradientExtent'] = this.geometry.getContainerExtent();
          }
          // const lineWidth = style['lineWidth'] || 1;
          var geometryEventTolerance = this.geometry.getLayer().options['geometryEventTolerance'] || 0;
          var tolerance = this.geometry._hitTestTolerance() + geometryEventTolerance;
          var points = paintParams[0], isSplitted = (this.geometry.getJSONType() === 'Polygon' && points.length > 0 && Array.isArray(points[0][0])) ||
              (this.geometry.type === 'LineString' && points.length > 0 && Array.isArray(points[0]));
          if (isSplitted) {
              for (var i = 0; i < points.length; i++) {
                  this.prepareCanvas(ctx, style, resources);
                  if (isGradient$1 && isPath && !style['lineColor']['places']) {
                      this._createGradient(ctx, points[i], style['lineColor']);
                  }
                  var params = [ctx, points[i]];
                  if (paintParams.length > 1) {
                      params.push.apply(params, __spreadArray([], __read(paintParams.slice(1)), false));
                  }
                  params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);
                  // @ts-expect-error todo 属性“_paintOn”在类型“Geometry”上不存在
                  var bbox = (_a = this.geometry)._paintOn.apply(_a, __spreadArray([], __read(params), false));
                  this._setBBOX(ctx, bbox);
                  this._bufferBBOX(ctx, tolerance);
              }
          }
          else {
              this.prepareCanvas(ctx, style, resources);
              if (isGradient$1 && isPath && !style['lineColor']['places']) {
                  this._createGradient(ctx, points, style['lineColor']);
              }
              var params = [ctx];
              params.push.apply(params, __spreadArray([], __read(paintParams), false));
              params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);
              // @ts-expect-error todo 属性“_paintOn”在类型“Geometry”上不存在
              var bbox = (_b = this.geometry)._paintOn.apply(_b, __spreadArray([], __read(params), false));
              this._setBBOX(ctx, bbox);
              this._bufferBBOX(ctx, tolerance);
          }
          if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
              ctx.setLineDash([]);
          }
      };
      StrokeAndFillSymbolizer.prototype.get2DExtent = function () {
          var map = this.getMap();
          var extent = this.geometry._getPrjExtent();
          if (!extent) {
              return null;
          }
          // this ugly implementation is to improve perf as we can
          // it tries to avoid creating instances to save cpu consumption.
          if (!this._extMin || !this._extMax) {
              this._extMin = new Coordinate(0, 0);
              this._extMax = new Coordinate(0, 0);
          }
          this._extMin.x = extent['xmin'];
          this._extMin.y = extent['ymin'];
          this._extMax.x = extent['xmax'];
          this._extMax.y = extent['ymax'];
          // @ts-expect-error todo fix coordinate not to point
          var min = map._prjToPoint(this._extMin, undefined, TEMP_COORD0), 
          // @ts-expect-error todo fix coordinate not to point
          max = map._prjToPoint(this._extMax, undefined, TEMP_COORD1);
          if (!this._pxExtent) {
              this._pxExtent = new PointExtent(min, max);
          }
          else {
              this._pxExtent.set(Math.min(min.x, max.x), Math.min(min.y, max.y), Math.max(min.x, max.x), Math.max(min.y, max.y));
          }
          return this._pxExtent;
      };
      StrokeAndFillSymbolizer.prototype.getFixedExtent = function () {
          var t = this.style['lineWidth'] / 2;
          return new PointExtent(-t, -t, t, t);
      };
      //@internal
      StrokeAndFillSymbolizer.prototype._getPaintParams = function () {
          // @ts-expect-error todo fix must has four params
          return this.getPainter().getPaintParams(this.style['lineDx'], this.style['lineDy']);
      };
      StrokeAndFillSymbolizer.prototype.translate = function () {
          var s = this.symbol;
          var result = {
              lineColor: getValueOrDefault(s['lineColor'], '#000'),
              lineWidth: getValueOrDefault(s['lineWidth'], 2),
              lineOpacity: getValueOrDefault(s['lineOpacity'], 1),
              lineDasharray: getValueOrDefault(s['lineDasharray'], []),
              lineCap: getValueOrDefault(s['lineCap'], 'butt'), //“butt”, “square”, “round”
              lineJoin: getValueOrDefault(s['lineJoin'], 'miter'), //“bevel”, “round”, “miter”
              linePatternFile: getValueOrDefault(s['linePatternFile'], null),
              lineDx: getValueOrDefault(s['lineDx'], 0),
              lineDy: getValueOrDefault(s['lineDy'], 0),
              polygonFill: getValueOrDefault(s['polygonFill'], null),
              polygonOpacity: getValueOrDefault(s['polygonOpacity'], 1),
              polygonPatternFile: getValueOrDefault(s['polygonPatternFile'], null),
              polygonPatternDx: getValueOrDefault(s['polygonPatternDx'], 0),
              polygonPatternDy: getValueOrDefault(s['polygonPatternDy'], 0),
              linePatternDx: getValueOrDefault(s['linePatternDx'], 0),
              linePatternDy: getValueOrDefault(s['linePatternDy'], 0),
          };
          if (result['lineWidth'] === 0) {
              result['lineOpacity'] = 0;
          }
          // fill of arrow
          if (this.geometry.type === 'LineString' && !result['polygonFill']) {
              result['polygonFill'] = result['lineColor'];
          }
          return result;
      };
      //@internal
      StrokeAndFillSymbolizer.prototype._createGradient = function (ctx, points, lineColor) {
          if (!Array.isArray(points) || !points.length) {
              return;
          }
          var _a = __read(getGradientPoints(points), 2), p1 = _a[0], p2 = _a[1];
          if (!p1 || !p2) {
              console.error('unable create canvas LinearGradient,error data:', points);
              return;
          }
          var grad = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
          lineColor['colorStops'].forEach(function (stop) {
              grad.addColorStop.apply(grad, __spreadArray([], __read(stop), false));
          });
          ctx.strokeStyle = grad;
      };
      return StrokeAndFillSymbolizer;
  }(CanvasSymbolizer));
  function getGradientPoints(points) {
      var pts;
      var isLine = true;
      //polygon rings
      if (Array.isArray(points[0])) {
          pts = points[0];
          isLine = false;
      }
      else {
          pts = points;
      }
      var len = pts.length;
      if (isLine) {
          return [pts[0], pts[len - 1]];
      }
      var p1 = pts[0];
      var distance = 0, p2;
      for (var i = 1; i < len; i++) {
          var p = pts[i];
          var dis = p1.distanceTo(p);
          if (dis > distance) {
              distance = dis;
              p2 = p;
          }
      }
      return [p1, p2];
  }

  var TEMP_EXTENT$7 = new PointExtent();
  var TextMarkerSymbolizer = /** @class */ (function (_super) {
      __extends(TextMarkerSymbolizer, _super);
      function TextMarkerSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this, symbol, geometry, painter) || this;
          var style = _this.translate();
          _this._dynamic = hasFunctionDefinition(style);
          _this.style = _this._defineStyle(style);
          if (_this.style['textWrapWidth'] === 0) {
              return _this;
          }
          _this.strokeAndFill = _this._defineStyle(_this.translateLineAndFill(_this.style));
          return _this;
      }
      TextMarkerSymbolizer.test = function (symbol) {
          return isTextSymbol(symbol);
      };
      TextMarkerSymbolizer.prototype.symbolize = function (ctx, resources) {
          if (!this.isVisible()) {
              return;
          }
          if (!this.painter.isHitTesting() && (this.style['textSize'] === 0 ||
              !this.style['textOpacity'] && (!this.style['textHaloRadius'] || !this.style['textHaloOpacity']) ||
              this.style['textWrapWidth'] === 0)) {
              return;
          }
          var cookedPoints = this._getRenderContainerPoints();
          if (!isArrayHasData(cookedPoints)) {
              return;
          }
          var style = this.style, strokeAndFill = this.strokeAndFill;
          var textContent = replaceVariable(this.style['textName'], this.geometry.getProperties());
          if (this._dynamic) {
              delete this._textDesc;
          }
          var textDesc = this._textDesc = this._textDesc || describeText(textContent, this.style);
          this._prepareContext(ctx);
          this.prepareCanvas(ctx, strokeAndFill, resources);
          Canvas.prepareCanvasFont(ctx, style);
          var textHaloRadius = style.textHaloRadius || 0;
          for (var i = 0, len = cookedPoints.length; i < len; i++) {
              var p = cookedPoints[i];
              // const origin = this._rotate(ctx, p, this._getRotationAt(i));
              var origin_1 = this.getRotation() ? this._rotate(ctx, p, this._getRotationAt(i)) : null;
              var extent = void 0;
              if (origin_1) {
                  //坐标对应的像素点
                  var pixel = p.sub(origin_1);
                  p = origin_1;
                  var rad = this._getRotationAt(i);
                  var _a = textDesc.size || { width: 0, height: 0 }, width = _a.width, height = _a.height;
                  var alignPoint = getAlignPoint(textDesc.size, style['textHorizontalAlignment'], style['textVerticalAlignment']);
                  extent = getMarkerRotationExtent(TEMP_EXTENT$7, rad, width, height, p, alignPoint);
                  extent._add(pixel);
              }
              var bbox = Canvas.text(ctx, textContent, p, style, textDesc);
              if (origin_1) {
                  this._setBBOX(ctx, extent.xmin, extent.ymin, extent.xmax, extent.ymax);
                  ctx.restore();
              }
              else {
                  this._setBBOX(ctx, bbox);
              }
              this._bufferBBOX(ctx, textHaloRadius);
          }
      };
      TextMarkerSymbolizer.prototype.getPlacement = function () {
          return this.symbol['textPlacement'];
      };
      TextMarkerSymbolizer.prototype.getRotation = function () {
          var r = this.style['textRotation'];
          if (!isNumber(r)) {
              return null;
          }
          //to radian
          return (-r * Math.PI) / 180;
      };
      TextMarkerSymbolizer.prototype.getDxDy = function () {
          var s = this.style;
          return new Point(s['textDx'], s['textDy']);
      };
      TextMarkerSymbolizer.prototype.getFixedExtent = function () {
          var textDesc = this.geometry.getTextDesc();
          if (Array.isArray(textDesc)) {
              textDesc = textDesc[this._index];
          }
          this._fixedExtent = this._fixedExtent || new PointExtent();
          if (!textDesc) {
              return this._fixedExtent;
          }
          return getTextMarkerFixedExtent(this._fixedExtent, this.style, textDesc);
      };
      TextMarkerSymbolizer.prototype.translate = function () {
          var s = this.symbol;
          var result = {
              textName: s['textName'],
              textFaceName: getValueOrDefault(s['textFaceName'], 'monospace'),
              textWeight: getValueOrDefault(s['textWeight'], 'normal'), //'bold', 'bolder'
              textStyle: getValueOrDefault(s['textStyle'], 'normal'), //'italic', 'oblique'
              textSize: getValueOrDefault(s['textSize'], DEFAULT_TEXT_SIZE),
              textFont: getValueOrDefault(s['textFont'], null),
              textFill: getValueOrDefault(s['textFill'], '#000'),
              textOpacity: getValueOrDefault(s['textOpacity'], 1),
              textHaloFill: getValueOrDefault(s['textHaloFill'], '#ffffff'),
              textHaloRadius: getValueOrDefault(s['textHaloRadius'], 0),
              textHaloOpacity: getValueOrDefault(s['textHaloOpacity'], 1),
              textWrapWidth: getValueOrDefault(s['textWrapWidth'], null),
              textWrapCharacter: getValueOrDefault(s['textWrapCharacter'], '\n'),
              textLineSpacing: getValueOrDefault(s['textLineSpacing'], 0),
              textDx: getValueOrDefault(s['textDx'], 0),
              textDy: getValueOrDefault(s['textDy'], 0),
              textHorizontalAlignment: getValueOrDefault(s['textHorizontalAlignment'], 'middle'), //left | middle | right | auto
              textVerticalAlignment: getValueOrDefault(s['textVerticalAlignment'], 'middle'), // top | middle | bottom | auto
              textAlign: getValueOrDefault(s['textAlign'], 'center'), //left | right | center | auto
              textRotation: getValueOrDefault(s['textRotation'], 0),
              textMaxWidth: getValueOrDefault(s['textMaxWidth'], 0),
              textMaxHeight: getValueOrDefault(s['textMaxHeight'], 0),
          };
          if (result['textMaxWidth'] > 0 && (!result['textWrapWidth'] || result['textWrapWidth'] > result['textMaxWidth'])) {
              if (!result['textWrapWidth']) {
                  result['textMaxHeight'] = 1;
              }
              result['textWrapWidth'] = result['textMaxWidth'];
          }
          return result;
      };
      TextMarkerSymbolizer.prototype.translateLineAndFill = function (s) {
          return {
              lineColor: s['textHaloRadius'] ? s['textHaloFill'] : s['textFill'],
              lineWidth: s['textHaloRadius'],
              lineOpacity: s['textOpacity'],
              lineDasharray: null,
              lineCap: 'butt',
              lineJoin: 'round',
              polygonFill: s['textFill'],
              polygonOpacity: s['textOpacity'],
          };
      };
      return TextMarkerSymbolizer;
  }(PointSymbolizer));

  var MARKER_SIZE = [0, 0];
  var TEMP_EXTENT$6 = new PointExtent();
  var DEFAULT_ANCHOR = new Point(0, 0);
  var VectorMarkerSymbolizer = /** @class */ (function (_super) {
      __extends(VectorMarkerSymbolizer, _super);
      function VectorMarkerSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this, symbol, geometry, painter) || this;
          var style = _this.translate();
          _this._dynamic = hasFunctionDefinition(style);
          _this.style = _this._defineStyle(style);
          _this.strokeAndFill = _this._defineStyle(translateMarkerLineAndFill(_this.style));
          // const lineWidth = this.strokeAndFill['lineWidth'];
          // if (lineWidth % 2 === 0) {
          //     this.padding = 2;
          // } else {
          //     this.padding = 1.5;
          // }
          _this.padding = 0;
          return _this;
      }
      VectorMarkerSymbolizer.test = function (symbol) {
          return isVectorSymbol(symbol);
      };
      VectorMarkerSymbolizer.prototype.symbolize = function (ctx, resources) {
          if (!this.isVisible()) {
              return;
          }
          var style = this.style;
          if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 ||
              (style['polygonOpacity'] === 0 && style['lineOpacity'] === 0))) {
              return;
          }
          var cookedPoints = this._getRenderContainerPoints();
          if (!isArrayHasData(cookedPoints)) {
              return;
          }
          this._prepareContext(ctx);
          if (this.getPainter().isSpriting() ||
              this.geometry.getLayer().getMask() === this.geometry ||
              this._dynamic ||
              this.geometry.getLayer().options['cacheVectorOnCanvas'] === false) {
              this._drawMarkers(ctx, cookedPoints, resources);
          }
          else {
              this._drawMarkersWithCache(ctx, cookedPoints, resources);
          }
      };
      //@internal
      VectorMarkerSymbolizer.prototype._drawMarkers = function (ctx, cookedPoints, resources) {
          for (var i = cookedPoints.length - 1; i >= 0; i--) {
              var point = cookedPoints[i];
              var size = calVectorMarkerSize(MARKER_SIZE, this.style);
              var _a = __read(size, 2), width = _a[0], height = _a[1];
              // const origin = this._rotate(ctx, point, this._getRotationAt(i));
              var extent = void 0;
              var origin_1 = this.getRotation() ? this._rotate(ctx, point, this._getRotationAt(i)) : null;
              if (origin_1) {
                  var pixel = point.sub(origin_1);
                  point = origin_1;
                  var rad = this._getRotationAt(i);
                  extent = getMarkerRotationExtent(TEMP_EXTENT$6, rad, width, height, point, DEFAULT_ANCHOR);
                  extent._add(pixel);
              }
              this._drawVectorMarker(ctx, point, resources);
              if (origin_1) {
                  ctx.restore();
                  this._setBBOX(ctx, extent.xmin, extent.ymin, extent.xmax, extent.ymax);
              }
              else {
                  var x = point.x, y = point.y;
                  this._setBBOX(ctx, x, y, x + width, y + height);
              }
          }
      };
      //@internal
      VectorMarkerSymbolizer.prototype._drawMarkersWithCache = function (ctx, cookedPoints, resources) {
          var stamp = this._stampSymbol();
          var image = resources.getImage(stamp);
          if (!image) {
              image = this._createMarkerImage(ctx, resources);
              resources.addResource([stamp, image.width, image.height], image);
          }
          var anchor = getVectorMarkerAnchor(this.style, image.width, image.height);
          for (var i = cookedPoints.length - 1; i >= 0; i--) {
              var point = cookedPoints[i];
              // const origin = this._rotate(ctx, point, this._getRotationAt(i));
              var origin_2 = this.getRotation() ? this._rotate(ctx, point, this._getRotationAt(i)) : null;
              var extent = void 0;
              if (origin_2) {
                  //坐标对应的像素点
                  var pixel = point.sub(origin_2);
                  point = origin_2;
                  var rad = this._getRotationAt(i);
                  extent = getMarkerRotationExtent(TEMP_EXTENT$6, rad, image.width, image.height, point, anchor);
                  extent._add(pixel);
              }
              var x = point.x + anchor.x, y = point.y + anchor.y;
              Canvas.image(ctx, image, x, y);
              if (origin_2) {
                  ctx.restore();
                  this._setBBOX(ctx, extent.xmin, extent.ymin, extent.xmax, extent.ymax);
              }
              else {
                  this._setBBOX(ctx, x, y, x + image.width, y + image.height);
              }
          }
      };
      //@internal
      VectorMarkerSymbolizer.prototype._createMarkerImage = function (ctx, resources) {
          var canvasClass = ctx.canvas.constructor, size = calVectorMarkerSize(MARKER_SIZE, this.style), canvas = Canvas.createCanvas(size[0], size[1], canvasClass), point = this._getCacheImageAnchor(size[0], size[1]);
          var context = canvas.getContext('2d');
          this._drawVectorMarker(context, point, resources);
          return canvas;
      };
      //@internal
      VectorMarkerSymbolizer.prototype._stampSymbol = function () {
          if (!this._stamp) {
              this._stamp = hashCode([
                  this.style['markerType'],
                  isGradient(this.style['markerFill']) ? getGradientStamp(this.style['markerFill']) : this.style['markerFill'],
                  this.style['markerFillOpacity'],
                  this.style['markerFillPatternFile'],
                  isGradient(this.style['markerLineColor']) ? getGradientStamp(this.style['markerLineColor']) : this.style['markerLineColor'],
                  this.style['markerLineWidth'],
                  this.style['markerLineOpacity'],
                  this.style['markerLineDasharray'] ? this.style['markerLineDasharray'].join(',') : '',
                  this.style['markerLinePatternFile'],
                  this.style['markerWidth'],
                  this.style['markerHeight'],
                  this.style['markerHorizontalAlignment'],
                  this.style['markerVerticalAlignment'],
              ].join('_'));
          }
          return this._stamp;
      };
      //@internal
      VectorMarkerSymbolizer.prototype._getCacheImageAnchor = function (w, h) {
          var shadow = 2 * (this.symbol['shadowBlur'] || 0), margin = shadow + this.padding;
          var markerType = this.style['markerType'];
          if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
              return new Point(w / 2, h - margin);
          }
          else if (markerType === 'rectangle') {
              return new Point(margin, margin);
          }
          else {
              return new Point(w / 2, h / 2);
          }
      };
      //@internal
      VectorMarkerSymbolizer.prototype._getGraidentExtent = function (points) {
          var e = new PointExtent(), dxdy = this.getDxDy(), m = this.getFixedExtent();
          if (Array.isArray(points)) {
              for (var i = points.length - 1; i >= 0; i--) {
                  e._combine(points[i]);
              }
          }
          else {
              e._combine(points);
          }
          e['xmin'] += m['xmin'] - dxdy.x;
          e['ymin'] += m['ymin'] - dxdy.y;
          e['xmax'] += m['xmax'] - dxdy.x;
          e['ymax'] += m['ymax'] - dxdy.y;
          return e;
      };
      //@internal
      VectorMarkerSymbolizer.prototype._drawVectorMarker = function (ctx, point, resources) {
          drawVectorMarker(ctx, point, this.style, resources);
      };
      VectorMarkerSymbolizer.prototype.getFixedExtent = function () {
          var isDynamic = this.isDynamicSize();
          var w = this.style.markerWidth;
          var h = this.style.markerHeight;
          this._fixedExtent = this._fixedExtent || new PointExtent();
          return getVectorMarkerFixedExtent(this._fixedExtent, this.style, isDynamic ? [128, 128 * (w === 0 ? 1 : h / w)] : null);
      };
      VectorMarkerSymbolizer.prototype.translate = function () {
          var s = this.symbol;
          var result = {
              markerType: getValueOrDefault(s['markerType'], 'ellipse'), //<----- ellipse | cross | x | triangle | diamond | square | bar | pin等,默认ellipse
              markerFill: getValueOrDefault(s['markerFill'], '#00f'), //blue as cartoCSS
              markerFillOpacity: getValueOrDefault(s['markerFillOpacity'], 1),
              markerFillPatternFile: getValueOrDefault(s['markerFillPatternFile'], null),
              markerLineColor: getValueOrDefault(s['markerLineColor'], '#000'), //black
              markerLineWidth: getValueOrDefault(s['markerLineWidth'], DEFAULT_MARKER_SYMBOLS.markerLineWidth),
              markerLineOpacity: getValueOrDefault(s['markerLineOpacity'], 1),
              markerLineDasharray: getValueOrDefault(s['markerLineDasharray'], []),
              markerLinePatternFile: getValueOrDefault(s['markerLinePatternFile'], null),
              markerDx: getValueOrDefault(s['markerDx'], 0),
              markerDy: getValueOrDefault(s['markerDy'], 0),
              markerWidth: getValueOrDefault(s['markerWidth'], DEFAULT_MARKER_SYMBOLS.markerWidth),
              markerHeight: getValueOrDefault(s['markerHeight'], DEFAULT_MARKER_SYMBOLS.markerHeight),
              markerRotation: getValueOrDefault(s['markerRotation'], 0),
              shadowBlur: getValueOrDefault(s['shadowBlur'], 0),
              shadowOffsetX: getValueOrDefault(s['shadowOffsetX'], 0),
              shadowOffsetY: getValueOrDefault(s['shadowOffsetY'], 0),
          };
          var markerType = result['markerType'];
          var ha = getDefaultHAlign(markerType);
          var va = getDefaultVAlign(markerType);
          result['markerHorizontalAlignment'] = getValueOrDefault(s['markerHorizontalAlignment'], ha); //left | middle | right
          result['markerVerticalAlignment'] = getValueOrDefault(s['markerVerticalAlignment'], va); // top | middle | bottom
          //markerOpacity覆盖fillOpacity和lineOpacity
          if (isNumber(s['markerOpacity'])) {
              if (isNumber(s['markerFillOpacity'])) {
                  result['markerFillOpacity'] *= s['markerOpacity'];
              }
              if (isNumber(s['markerLineOpacity'])) {
                  result['markerLineOpacity'] *= s['markerOpacity'];
              }
          }
          return result;
      };
      return VectorMarkerSymbolizer;
  }(PointSymbolizer));

  // import { ResourceProxy } from '../../../core/ResourceProxy';
  var VectorPathMarkerSymbolizer = /** @class */ (function (_super) {
      __extends(VectorPathMarkerSymbolizer, _super);
      function VectorPathMarkerSymbolizer(symbol, geometry, painter) {
          var _this = this;
          //IE must have a valid width and height to draw a svg image
          //otherwise, error will be thrown
          if (isNil(symbol['markerWidth'])) {
              symbol['markerWidth'] = 80;
          }
          if (isNil(symbol['markerHeight'])) {
              symbol['markerHeight'] = 80;
          }
          _this = _super.call(this, symbol, geometry, painter) || this;
          symbol = extend$2({}, symbol, _this.translate());
          var style = (_this.style = _this._defineStyle(symbol));
          if (Browser$1.gecko) {
              // Firefox requires valid width and height attributes in SVG's root element.
              _this._url = [
                  getMarkerPathBase64(style, style['markerWidth'], style['markerHeight']), style['markerWidth'], style['markerHeight']
              ];
          }
          else {
              _this._url = [getMarkerPathBase64(style), style['markerWidth'], style['markerHeight']];
          }
          return _this;
      }
      VectorPathMarkerSymbolizer.test = function (symbol) {
          return isPathSymbol(symbol);
      };
      //@internal
      VectorPathMarkerSymbolizer.prototype._prepareContext = function () {
          //for VectorPathMarkerSymbolizer, opacity is already added into SVG element.
      };
      //@internal
      VectorPathMarkerSymbolizer.prototype._getImage = function (resources) {
          var _this = this;
          if (resources && resources.isResourceLoaded(this._url)) {
              return resources.getImage(this._url);
          }
          var painter = this.painter;
          var image = new Image();
          image.onload = function () {
              var renderer = painter.getLayer() && painter.getLayer().getRenderer();
              if (renderer) {
                  renderer.setToRedraw();
              }
          };
          image.onerror = function (err) {
              if (err && typeof console !== 'undefined') {
                  console.warn(err);
              }
              resources.markErrorResource(_this._url);
          };
          image.src = this._url[0];
          if (resources) {
              resources.addResource(this._url, image);
          }
          return image;
          // return resources ? resources.getImage(this._url) : null;
      };
      return VectorPathMarkerSymbolizer;
  }(ImageMarkerSymbolizer));

  var defaultSymbol$1 = {
      lineWidth: 1,
      polygonFill: '#fff',
      polygonOpacity: 0.5,
  };
  var DrawAltitudeSymbolizer = /** @class */ (function (_super) {
      __extends(DrawAltitudeSymbolizer, _super);
      function DrawAltitudeSymbolizer(symbol, geometry, painter) {
          var _this = _super.call(this, symbol, geometry, painter) || this;
          _this.style = geometry.getLayer().options['drawAltitude'];
          if (!_this.style || !isObject$1(_this.style)) {
              _this.style = {
                  lineWidth: 2,
              };
          }
          if (!_this.style['lineWidth']) {
              // for get2DExtent
              _this.style['lineWidth'] = 0;
          }
          _this.dxdy = _this._defineStyle({
              dx: symbol['textDx'] || symbol['markerDx'],
              dy: symbol['textDy'] || symbol['markerDy'],
          });
          return _this;
      }
      DrawAltitudeSymbolizer.test = function (symbol, geometry) {
          var layer = geometry.getLayer();
          if (!layer) {
              return false;
          }
          var type = geometry.getJSONType();
          // shoule be a point or linestring
          return type === 'Marker' || type === 'LineString';
      };
      DrawAltitudeSymbolizer.prototype.symbolize = function (ctx) {
          var layer = this.geometry.getLayer();
          if (!layer.options['drawAltitude']) {
              return;
          }
          // const properties = this.geometry.getProperties();
          // if (!properties || !properties[layer.options['altitudeProperty']]) {
          //     return;
          // }
          if (!this.geometry.hasAltitude()) {
              return;
          }
          var style = this._getStyle();
          this._prepareContext(ctx);
          if (this.geometry.type === 'LineString') {
              var paintParams = this._getPaintParams(style['lineDx'], style['lineDy']);
              if (!paintParams) {
                  return;
              }
              //container points that ignore altitude
              var groundPoints = this.getPainter().getPaintParams(style['lineDx'], style['lineDy'], true, true, '_groundpt')[0];
              this._drawLineAltitude(ctx, paintParams[0], groundPoints);
          }
          else {
              var point = this._getRenderContainerPoints(), groundPoint = this._getRenderContainerPoints(true);
              if (!point || point.length === 0) {
                  return;
              }
              this._drawMarkerAltitude(ctx, point[0], groundPoint[0]);
          }
      };
      DrawAltitudeSymbolizer.prototype.getDxDy = function () {
          var s = this.dxdy;
          return new Point(s['dx'] || 0, s['dy'] || 0);
      };
      DrawAltitudeSymbolizer.prototype.get2DExtent = function () {
          if (this.geometry.type === 'LineString') {
              return StrokeAndFillSymbolizer.prototype.get2DExtent.apply(this);
          }
          else {
              return _super.prototype.get2DExtent.call(this);
          }
      };
      DrawAltitudeSymbolizer.prototype.getPlacement = function () {
          return 'point';
      };
      //@internal
      DrawAltitudeSymbolizer.prototype._getPaintParams = function (dx, dy) {
          return this.getPainter().getPaintParams(dx || 0, dy || 0, null, true, '_altpt');
      };
      //@internal
      DrawAltitudeSymbolizer.prototype._drawMarkerAltitude = function (ctx, point, groundPoint) {
          var style = this._getStyle();
          this.prepareCanvas(ctx, style);
          Canvas.path(ctx, [point, groundPoint], style['lineOpacity'], null, style['lineDasharray']);
      };
      //@internal
      DrawAltitudeSymbolizer.prototype._drawLineAltitude = function (ctx, points, groundPoints) {
          var style = this._getStyle();
          var isSplitted = points.length > 0 && Array.isArray(points[0]);
          if (isSplitted) {
              for (var i = 0; i < points.length; i++) {
                  this._drawLine(ctx, points[i], groundPoints[i]);
              }
          }
          else {
              this._drawLine(ctx, points, groundPoints);
          }
          if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
              ctx.setLineDash([]);
          }
      };
      //@internal
      DrawAltitudeSymbolizer.prototype._drawLine = function (ctx, points, groundPoints) {
          var style = this._getStyle();
          this.prepareCanvas(ctx, style);
          for (var i = 0, l = points.length - 1; i < l; i++) {
              Canvas.polygon(ctx, [points[i], points[i + 1], groundPoints[i + 1], groundPoints[i],], style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);
          }
      };
      //@internal
      DrawAltitudeSymbolizer.prototype._getStyle = function () {
          // read drawAltitude from layer every time
          var layer = this.geometry.getLayer();
          var style = layer.options['drawAltitude'];
          if (Array.isArray(style)) {
              var geos = layer.getGeometries() || [];
              var index = geos.indexOf(this.geometry);
              if (index >= 0) {
                  style = style[index] || defaultSymbol$1;
              }
          }
          if (!isObject$1(style)) {
              style = defaultSymbol$1;
          }
          if (!style['lineWidth']) {
              // for get2DExtent
              style['lineWidth'] = 0;
              style['lineOpacity'] = 0;
          }
          return style;
      };
      return DrawAltitudeSymbolizer;
  }(PointSymbolizer));

  var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CanvasSymbolizer: CanvasSymbolizer,
    DebugSymbolizer: DebugSymbolizer,
    DrawAltitudeSymbolizer: DrawAltitudeSymbolizer,
    ImageMarkerSymbolizer: ImageMarkerSymbolizer,
    PointSymbolizer: PointSymbolizer,
    StrokeAndFillSymbolizer: StrokeAndFillSymbolizer,
    Symbolizer: Symbolizer,
    TextMarkerSymbolizer: TextMarkerSymbolizer,
    VectorMarkerSymbolizer: VectorMarkerSymbolizer,
    VectorPathMarkerSymbolizer: VectorPathMarkerSymbolizer
  });

  //registered symbolizers
  //the latter will paint at the last
  var registerSymbolizers = [
      DrawAltitudeSymbolizer,
      StrokeAndFillSymbolizer,
      ImageMarkerSymbolizer,
      VectorPathMarkerSymbolizer,
      VectorMarkerSymbolizer,
      TextMarkerSymbolizer
  ];
  var testCanvas;
  var TEMP_POINT0$2 = new Point(0, 0);
  var TEMP_PAINT_EXTENT = new PointExtent();
  var TEMP_FIXED_EXTENT = new PointExtent();
  var TEMP_CLIP_EXTENT0 = new PointExtent();
  var TEMP_CLIP_EXTENT1 = new PointExtent();
  var TEMP_CLIP_EXTENT2 = new PointExtent();
  var PROJECTION = {
      code: undefined
  };
  // const TEMP_CONTAINER_EXTENT = new PointExtent();
  var TEMP_BBOX = {
      minx: Infinity,
      miny: Infinity,
      maxx: -Infinity,
      maxy: -Infinity
  };
  /**
   * @classdesc
   * Painter class for all geometry types except the collection types.
   * @class
   * @private
   */
  var Painter = /** @class */ (function (_super) {
      __extends(Painter, _super);
      /**
       *  @param geometry - geometry to paint
       */
      function Painter(geometry) {
          var _this = _super.call(this) || this;
          _this.geometry = geometry;
          _this.symbolizers = _this._createSymbolizers();
          _this._altAtGL = _this._getGeometryAltitude();
          _this.bbox = getDefaultBBOX();
          _this._drawTime = 0;
          return _this;
      }
      //@internal
      Painter.prototype._setDrawTime = function (time) {
          this._drawTime = time;
          return this;
      };
      Painter.prototype.getRenderBBOX = function () {
          var layer = this.getLayer();
          if (layer && layer._drawTime !== this._drawTime) {
              return null;
          }
          resetBBOX(this.bbox);
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              var symbolizer = this.symbolizers[i];
              var bbox = symbolizer.bbox;
              if (!validateBBOX(bbox)) {
                  continue;
              }
              setBBOX(this.bbox, bbox);
          }
          if (validateBBOX(this.bbox)) {
              return this.bbox;
          }
          return null;
      };
      Painter.prototype.getMap = function () {
          return this.geometry.getMap();
      };
      Painter.prototype.getLayer = function () {
          return this.geometry && this.geometry.getLayer();
      };
      /**
       * create symbolizers
       */
      //@internal
      Painter.prototype._createSymbolizers = function () {
          var geoSymbol = this.getSymbol(), symbolizers = [], regSymbolizers = registerSymbolizers;
          var symbols = geoSymbol;
          if (!Array.isArray(geoSymbol)) {
              symbols = [geoSymbol];
          }
          for (var ii = symbols.length - 1; ii >= 0; ii--) {
              var symbol = symbols[ii];
              for (var i = regSymbolizers.length - 1; i >= 0; i--) {
                  if (regSymbolizers[i].test(symbol, this.geometry)) {
                      var symbolizer = new regSymbolizers[i](symbol, this.geometry, this);
                      symbolizer._index = ii;
                      symbolizers.push(symbolizer);
                      if (symbolizer instanceof PointSymbolizer) {
                          this._hasPoint = true;
                      }
                  }
              }
          }
          if (!symbolizers.length) {
              if (console) {
                  var id = this.geometry.getId();
                  console.warn('invalid symbol for geometry(' + (this.geometry ? this.geometry.getType() + (id ? ':' + id : '') : '') + ') to draw : ' + JSON.stringify(geoSymbol));
              }
              // throw new Error('no symbolizers can be created to draw, check the validity of the symbol.');
          }
          this._debugSymbolizer = new DebugSymbolizer(geoSymbol, this.geometry, this);
          return symbolizers;
      };
      Painter.prototype.hasPoint = function () {
          return !!this._hasPoint;
      };
      /**
       * for point symbolizers
       * @return points to render
       */
      Painter.prototype.getRenderPoints = function (placement) {
          this._verifyProjection();
          if (!this._renderPoints) {
              this._renderPoints = {};
          }
          if (!placement) {
              placement = 'center';
          }
          if (!this._renderPoints[placement]) {
              this._renderPoints[placement] = this.geometry._getRenderPoints(placement);
          }
          return this._renderPoints[placement];
      };
      /**
       * for strokeAndFillSymbolizer
       * @return resources to render vector
       */
      Painter.prototype.getPaintParams = function (dx, dy, ignoreAltitude, disableClip, ptkey) {
          if (ptkey === void 0) { ptkey = '_pt'; }
          var renderer = this.getLayer()._getRenderer();
          var mapStateCache = renderer.mapStateCache;
          var resolution, pitch, bearing, glScale, containerExtent;
          var map = this.getMap();
          if (mapStateCache && (!this._hitPoint)) {
              resolution = mapStateCache.resolution;
              pitch = mapStateCache.pitch;
              bearing = mapStateCache.bearing;
              glScale = mapStateCache.glScale;
              containerExtent = mapStateCache.containerExtent;
          }
          else {
              resolution = map.getResolution();
              pitch = map.getPitch();
              bearing = map.getBearing();
              glScale = map.getGLScale();
              containerExtent = map.getContainerExtent();
          }
          var geometry = this.geometry, res = resolution, pitched = (pitch !== 0), rotated = (bearing !== 0);
          var params = this._cachedParams;
          var paintAsPath = geometry._paintAsPath && geometry._paintAsPath();
          if (paintAsPath && this._unsimpledParams && res <= this._unsimpledParams._res) {
              //if res is smaller, return unsimplified params directly
              params = this._unsimpledParams;
          }
          else if (!params ||
              // refresh paint params
              // simplified, but not same zoom
              params._res !== resolution ||
              // refresh if requested by geometry
              this._pitched !== pitched && geometry._redrawWhenPitch() ||
              this._rotated !== rotated && geometry._redrawWhenRotate()) {
              //render resources geometry returned are based on 2d points.
              params = geometry._getPaintParams();
              if (!params) {
                  return null;
              }
              params._res = res;
              if (!geometry._simplified && paintAsPath) {
                  if (!this._unsimpledParams) {
                      this._unsimpledParams = params;
                  }
                  if (res > this._unsimpledParams._res) {
                      this._unsimpledParams._res = res;
                  }
              }
              this._cachedParams = params;
          }
          if (!params) {
              return null;
          }
          this._pitched = pitched;
          this._rotated = rotated;
          var zoomScale = glScale, 
          // paintParams = this._paintParams,
          tr = [], // transformed params
          points = params[0];
          var mapExtent = containerExtent;
          var cPoints = this._pointContainerPoints(points, dx, dy, ignoreAltitude, disableClip || this._hitPoint && !mapExtent.contains(this._hitPoint), null, ptkey);
          if (!cPoints) {
              return null;
          }
          tr.push(cPoints);
          for (var i = 1, l = params.length; i < l; i++) {
              if (isNumber(params[i]) || (params[i] instanceof Size)) {
                  if (isNumber(params[i])) {
                      tr.push(params[i] / zoomScale);
                  }
                  else {
                      tr.push(params[i].multi(1 / zoomScale));
                  }
              }
              else {
                  tr.push(params[i]);
              }
          }
          return tr;
      };
      //@internal
      Painter.prototype._pointContainerPoints = function (points, dx, dy, ignoreAltitude, disableClip, pointPlacement, ptkey) {
          if (ptkey === void 0) { ptkey = '_pt'; }
          if (this._aboveCamera()) {
              return null;
          }
          var renderer = this.getLayer()._getRenderer();
          var mapStateCache = renderer.mapStateCache;
          var map = this.getMap(), geometry = this.geometry, containerOffset = this.containerOffset;
          var glRes, containerExtent;
          if (mapStateCache) {
              glRes = mapStateCache.glRes;
              containerExtent = mapStateCache.containerExtent;
          }
          else {
              glRes = map.getGLRes();
              containerExtent = map.getContainerExtent();
          }
          var cPoints;
          var roundPoint = this.getLayer().options['roundPoint'];
          var minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
          var needClip = !disableClip;
          var clipBBoxBufferSize = renderer.layer.options['clipBBoxBufferSize'] || 3;
          var symbolizers = this.symbolizers;
          var enableClip = geometry.options.enableClip;
          function pointsContainerPoints(viewPoints, alts) {
              if (viewPoints === void 0) { viewPoints = []; }
              if (alts === void 0) { alts = []; }
              var pts = getPointsResultPts(viewPoints, ptkey);
              pts = map._pointsAtResToContainerPoints(viewPoints, glRes, alts, pts);
              for (var i = 0, len = pts.length; i < len; i++) {
                  var p = pts[i];
                  p._sub(containerOffset);
                  if (dx || dy) {
                      p._add(dx || 0, dy || 0);
                  }
                  if (roundPoint) {
                      //使用 round 会导致左右波动，用floor,ceil 要好点
                      p.x = Math.ceil(p.x);
                      p.y = Math.ceil(p.y);
                  }
                  minx = Math.min(p.x, minx);
                  miny = Math.min(p.y, miny);
                  maxx = Math.max(p.x, maxx);
                  maxy = Math.max(p.y, maxy);
              }
              if (enableClip && needClip && isDashLine(symbolizers)) {
                  TEMP_CLIP_EXTENT2.ymin = containerExtent.ymin;
                  if (TEMP_CLIP_EXTENT2.ymin < clipBBoxBufferSize) {
                      TEMP_CLIP_EXTENT2.ymin = containerExtent.ymin - clipBBoxBufferSize;
                  }
                  TEMP_CLIP_EXTENT2.xmin = containerExtent.xmin - clipBBoxBufferSize;
                  TEMP_CLIP_EXTENT2.xmax = containerExtent.xmax + clipBBoxBufferSize;
                  TEMP_CLIP_EXTENT2.ymax = containerExtent.ymax + clipBBoxBufferSize;
                  if (geometry.getShell && geometry.getHoles) {
                      return clipPolygon(pts, TEMP_CLIP_EXTENT2);
                  }
                  var clipPts = clipLine(pts, TEMP_CLIP_EXTENT2, false);
                  if (clipPts.length) {
                      var points_1 = [];
                      clipPts.forEach(function (clipPt) {
                          for (var i = 0, len = clipPt.length; i < len; i++) {
                              points_1.push(clipPt[i].point);
                          }
                      });
                      return points_1;
                  }
              }
              return pts;
          }
          var altitude = this.getAltitude();
          //convert 2d points to container points needed by canvas
          if (Array.isArray(points)) {
              var geometry_1 = this.geometry;
              var clipped = void 0;
              if (!disableClip && geometry_1.options['enableClip']) {
                  clipped = this._clip(points, altitude);
                  if (clipped.inView) {
                      needClip = false;
                  }
              }
              else {
                  clipped = {
                      points: points,
                      altitude: altitude
                  };
              }
              var clipPoints = clipped.points;
              altitude = clipped.altitude;
              if (ignoreAltitude) {
                  altitude = 0;
              }
              var alt = altitude;
              cPoints = [];
              var alts = [];
              var altitudeIsNumber = isNumber(altitude);
              for (var i = 0, l = clipPoints.length; i < l; i++) {
                  var c = clipPoints[i];
                  if (Array.isArray(c)) {
                      // const cring = [];
                      //polygon rings or clipped line string
                      if (altitudeIsNumber) {
                          var cring_1 = pointsContainerPoints(c, altitude);
                          cPoints.push(cring_1);
                          continue;
                      }
                      var altArray = [];
                      for (var ii = 0, ll = c.length; ii < ll; ii++) {
                          // const cc = c[ii];
                          if (Array.isArray(altitude)) {
                              if (altitude[i]) {
                                  alt = altitude[i][ii];
                              }
                              else {
                                  alt = 0;
                              }
                          }
                          altArray.push(alt);
                      }
                      var cring = pointsContainerPoints(c, altArray);
                      cPoints.push(cring);
                  }
                  else {
                      //line string
                      if (Array.isArray(altitude)) {
                          // altitude of different placement for point symbolizers
                          if (pointPlacement === 'vertex-last') {
                              alt = altitude[altitude.length - 1 - i];
                          }
                          else if (pointPlacement === 'line') {
                              alt = (altitude[i] + altitude[i + 1]) / 2;
                          }
                          else {
                              //vertex, vertex-first
                              alt = altitude[i];
                          }
                      }
                      alts.push(alt);
                  }
              }
              if (alts.length) {
                  cPoints = pointsContainerPoints(clipPoints, alts);
              }
          }
          else if (points instanceof Point) {
              if (ignoreAltitude) {
                  altitude = 0;
              }
              cPoints = map._pointAtResToContainerPoint(points, glRes, altitude)._sub(containerOffset);
              if (dx || dy) {
                  cPoints._add(dx, dy);
              }
          }
          //cache geometry bbox
          TEMP_BBOX.minx = minx;
          TEMP_BBOX.miny = miny;
          TEMP_BBOX.maxx = maxx;
          TEMP_BBOX.maxy = maxy;
          this._containerBbox = TEMP_BBOX;
          return cPoints;
      };
      //@internal
      Painter.prototype._clip = function (points, altitude) {
          // linestring polygon clip
          if (isNumber(altitude) && altitude !== 0) {
              return {
                  points: points,
                  altitude: altitude
              };
          }
          if (Array.isArray(altitude)) {
              var hasAltitude = false;
              for (var i = 0, len = altitude.length; i < len; i++) {
                  if (altitude[i] !== 0) {
                      hasAltitude = true;
                      break;
                  }
              }
              if (hasAltitude) {
                  return {
                      points: points,
                      altitude: altitude
                  };
              }
          }
          var map = this.getMap(), geometry = this.geometry;
          var lineWidth = this.getSymbol()['lineWidth'];
          if (!isNumber(lineWidth)) {
              lineWidth = 4;
          }
          var renderer = this.getLayer()._getRenderer();
          var mapStateCache = renderer.mapStateCache;
          var _2DExtent, glExtent, pitch;
          if (mapStateCache) {
              //@internal
              _2DExtent = mapStateCache._2DExtent;
              glExtent = mapStateCache.glExtent;
              pitch = mapStateCache.pitch;
          }
          else {
              //@internal
              _2DExtent = map.get2DExtent();
              glExtent = map.get2DExtentAtRes(map.getGLRes());
              pitch = map.getPitch();
          }
          var extent2D = _2DExtent._expand(lineWidth);
          if (pitch > 0 && altitude) {
              var c = map.cameraLookAt;
              var pos = map.cameraPosition;
              //add [1px, 1px] towards camera's lookAt
              TEMP_POINT0$2.set(pos[0], pos[1]);
              extent2D = extent2D._combine(TEMP_POINT0$2._add(sign(c[0] - pos[0]), sign(c[1] - pos[1])));
          }
          var e = this.get2DExtent(null, TEMP_CLIP_EXTENT1);
          var clipPoints = points;
          if (e.within(extent2D)) {
              // if (this.geometry.getJSONType() === 'LineString') {
              //     // clip line with altitude
              //     return this._clipLineByAlt(clipPoints, altitude);
              // }
              return {
                  points: clipPoints,
                  altitude: altitude,
                  inView: true
              };
          }
          var glExtent2D = glExtent._expand(lineWidth * map.getGLScale());
          TEMP_CLIP_EXTENT0.xmin = glExtent2D.xmin;
          TEMP_CLIP_EXTENT0.xmax = glExtent2D.xmax;
          TEMP_CLIP_EXTENT0.ymin = glExtent2D.ymin;
          TEMP_CLIP_EXTENT0.ymax = glExtent2D.ymax;
          var smoothness = geometry.options['smoothness'];
          // if (this.geometry instanceof Polygon) {
          if (geometry.getShell && this.geometry.getHoles && !smoothness) {
              //polygon buffer clip bbox
              var xmin = glExtent2D.xmin, ymin = glExtent2D.ymin, xmax = glExtent2D.xmax, ymax = glExtent2D.ymax;
              var dx = Math.abs(xmax - xmin), dy = Math.abs(ymax - ymin);
              var r = Math.sqrt(dx * dx + dy * dy);
              var rx = (r - dx) / 2, ry = (r - dy) / 2;
              TEMP_CLIP_EXTENT0.xmin = glExtent2D.xmin - rx;
              TEMP_CLIP_EXTENT0.xmax = glExtent2D.xmax + rx;
              TEMP_CLIP_EXTENT0.ymin = glExtent2D.ymin - ry;
              TEMP_CLIP_EXTENT0.ymax = glExtent2D.ymax + ry;
              // clip the polygon to draw less and improve performance
              if (!Array.isArray(points[0])) {
                  clipPoints = clipPolygon(points, TEMP_CLIP_EXTENT0);
              }
              else {
                  clipPoints = [];
                  for (var i = 0; i < points.length; i++) {
                      var part = clipPolygon(points[i], TEMP_CLIP_EXTENT0);
                      if (part.length) {
                          clipPoints.push(part);
                      }
                  }
              }
          }
          else if (geometry.getJSONType() === 'LineString' && !smoothness) {
              // clip the line string to draw less and improve performance
              if (!Array.isArray(points[0])) {
                  clipPoints = clipLine(points, TEMP_CLIP_EXTENT0, false, !!smoothness);
              }
              else {
                  clipPoints = [];
                  for (var i = 0; i < points.length; i++) {
                      pushIn(clipPoints, clipLine(points[i], TEMP_CLIP_EXTENT0, false, !!smoothness));
                  }
              }
              //interpolate line's segment's altitude if altitude is an array
              return this._interpolateSegAlt(clipPoints, points, altitude);
              // const segs = this._interpolateSegAlt(clipPoints, points, altitude);
              // return this._clipLineByAlt(segs.points, segs.altitude);
          }
          return {
              points: clipPoints,
              altitude: altitude
          };
      };
      // _clipLineByAlt(clipSegs, altitude) {
      //     const frustumAlt = this.getMap().getFrustumAltitude();
      //     if (!Array.isArray(altitude) || this.maxAltitude <= frustumAlt) {
      //         return {
      //             points : clipSegs,
      //             altitude : altitude
      //         };
      //     }
      //     return clipByALt(clipSegs, altitude, frustumAlt);
      // }
      /**
       * interpolate clipped line segs's altitude
       * @param {Point[]|Point[][]} clipSegs
       * @param {Point[]|Point[][]} orig
       * @param {Number|Number[]} altitude
       * @private
       */
      //@internal
      Painter.prototype._interpolateSegAlt = function (clipSegs, orig, altitude) {
          if (!Array.isArray(altitude)) {
              var fn_1 = function (cc) { return cc.point; };
              return {
                  points: clipSegs.map(function (c) {
                      if (Array.isArray(c)) {
                          return c.map(fn_1);
                      }
                      return c.point;
                  }),
                  altitude: altitude
              };
          }
          var segsWithAlt = interpolateAlt(clipSegs, orig, altitude);
          altitude = [];
          var points = segsWithAlt.map(function (p) {
              if (Array.isArray(p)) {
                  var alt_1 = [];
                  var cp = p.map(function (pp) {
                      alt_1.push(pp.altitude);
                      return pp.point;
                  });
                  altitude.push(alt_1);
                  return cp;
              }
              altitude.push(p.altitude);
              return p.point;
          });
          return {
              points: points,
              altitude: altitude
          };
      };
      Painter.prototype.getSymbol = function () {
          return this.geometry._getInternalSymbol();
      };
      //@internal
      Painter.prototype._resetSymbolizersBBOX = function () {
          //reset all symbolizers render bbox
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              var symbolizer = this.symbolizers[i];
              var bbox = symbolizer.bbox;
              resetBBOX(bbox);
          }
          return this;
      };
      Painter.prototype.paint = function (extent, context, offset) {
          var _a;
          if (!this.symbolizers) {
              return;
          }
          var layer = this.getLayer();
          var renderer = layer._getRenderer();
          if (!renderer || !renderer.context && !context) {
              return;
          }
          var mapStateCache = renderer.mapStateCache || { offset: undefined };
          //reduce geos to paint when drawOnInteracting
          if (!this.geometry._isCheck) {
              if (extent && !extent.intersects(this.get2DExtent(renderer.resources, TEMP_PAINT_EXTENT))) {
                  return;
              }
          }
          var map = this.getMap();
          if (this._aboveCamera()) {
              return;
          }
          //Multiplexing offset
          this.containerOffset = offset || mapStateCache.offset || map._pointToContainerPoint(renderer.middleWest)._add(0, -map.height / 2);
          this._beforePaint();
          var ctx = context || renderer.context;
          if (!ctx.isHitTesting) {
              this._resetSymbolizersBBOX();
          }
          var contexts = [ctx, renderer.resources];
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              // reduce function call
              if (ctx.shadowBlur || this.symbolizers[i].symbol['shadowBlur']) {
                  this._prepareShadow(ctx, this.symbolizers[i].symbol);
              }
              (_a = this.symbolizers[i]).symbolize.apply(_a, __spreadArray([], __read(contexts), false));
          }
          this._afterPaint();
          this._painted = true;
          // reduce function call
          if (this.geometry.options['debug'] || layer.options['debug']) {
              this._debugSymbolizer.symbolize(ctx);
          }
      };
      Painter.prototype.getSprite = function (resources, canvasClass) {
          var _a;
          if (!this.geometry.isPoint) {
              return null;
          }
          this._spriting = true;
          if (!this._sprite && this.symbolizers.length > 0) {
              var extent_1 = new PointExtent();
              this.symbolizers.forEach(function (s) {
                  var markerExtent = s.getFixedExtent(resources);
                  extent_1._combine(markerExtent);
              });
              var origin_1 = extent_1.getMin().multi(-1);
              var clazz = canvasClass || (this.getMap() ? this.getMap().CanvasClass : null);
              var canvas = Canvas.createCanvas(extent_1.getWidth(), extent_1.getHeight(), clazz);
              var bak = void 0;
              if (this._renderPoints) {
                  bak = this._renderPoints;
              }
              var ctx = canvas.getContext('2d');
              var contexts = [ctx, resources];
              for (var i = this.symbolizers.length - 1; i >= 0; i--) {
                  var dxdy = this.symbolizers[i].getDxDy();
                  this._renderPoints = {
                      'center': [
                          [origin_1.add(dxdy)]
                      ]
                  };
                  this._prepareShadow(ctx, this.symbolizers[i].symbol);
                  (_a = this.symbolizers[i]).symbolize.apply(_a, __spreadArray([], __read(contexts), false));
              }
              if (bak) {
                  this._renderPoints = bak;
              }
              this._sprite = {
                  'canvas': canvas,
                  'offset': extent_1.getCenter()
              };
          }
          this._spriting = false;
          return this._sprite;
      };
      Painter.prototype.isSpriting = function () {
          return !!this._spriting;
      };
      Painter.prototype.hitTest = function (cp, tolerance) {
          if (!tolerance || tolerance < 0.5) {
              tolerance = 0.5;
          }
          this._hitPoint = cp.sub(tolerance, tolerance);
          if (!testCanvas) {
              var canvasClass = this.getMap() ? this.getMap().CanvasClass : null;
              testCanvas = Canvas.createCanvas(1, 1, canvasClass);
          }
          Canvas.setHitTesting(true);
          testCanvas.width = testCanvas.height = 2 * tolerance;
          var ctx = Canvas.getCanvas2DContext(testCanvas);
          ctx.isHitTesting = true;
          try {
              this.paint(null, ctx, this._hitPoint);
          }
          finally {
              Canvas.setHitTesting(false);
          }
          delete this._hitPoint;
          var imgData = ctx.getImageData(0, 0, testCanvas.width, testCanvas.height).data;
          for (var i = 3, l = imgData.length; i < l; i += 4) {
              if (imgData[i] > 0) {
                  return true;
              }
          }
          return false;
      };
      Painter.prototype.isHitTesting = function () {
          return !!this._hitPoint;
      };
      //@internal
      Painter.prototype._prepareShadow = function (ctx, symbol) {
          if (symbol['shadowBlur']) {
              //Ignore shadows when hit detection
              ctx.shadowBlur = (this.isHitTesting() ? 0 : symbol['shadowBlur']);
              ctx.shadowColor = symbol['shadowColor'] || '#000';
              ctx.shadowOffsetX = symbol['shadowOffsetX'] || 0;
              ctx.shadowOffsetY = symbol['shadowOffsetY'] || 0;
          }
          else if (ctx.shadowBlur) {
              ctx.shadowBlur = null;
              ctx.shadowColor = null;
              ctx.shadowOffsetX = null;
              ctx.shadowOffsetY = null;
          }
      };
      //@internal
      Painter.prototype._eachSymbolizer = function (fn, context) {
          if (!this.symbolizers) {
              return;
          }
          if (!context) {
              context = this;
          }
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              fn.apply(context, [this.symbolizers[i]]);
          }
      };
      Painter.prototype.get2DExtent = function (resources, out) {
          this._verifyProjection();
          var map = this.getMap();
          resources = resources || this.getLayer()._getRenderer().resources;
          var zoom = map.getZoom();
          var isDynamicSize = this._isDynamicSize();
          if (!this._extent2D || this._extent2D._zoom !== zoom || !this._fixedExtent) {
              if (this._extent2D && this._extent2D._zoom !== zoom) {
                  delete this._extent2D;
              }
              if (this.symbolizers) {
                  if (!this._extent2D) {
                      this._extent2D = this._computeExtent2D(new PointExtent());
                      this._extent2D._zoom = zoom;
                  }
                  if (!this._fixedExtent) {
                      this._fixedExtent = this._computeFixedExtent(resources, new PointExtent());
                  }
              }
          }
          if (!this._extent2D) {
              if (isDynamicSize) {
                  delete this._fixedExtent;
              }
              return null;
          }
          var _a = this._fixedExtent, xmin = _a.xmin, ymin = _a.ymin, xmax = _a.xmax, ymax = _a.ymax;
          if (isDynamicSize) {
              delete this._fixedExtent;
          }
          //2d 坐标系是opengl规则，y轴方向与containerPoint是反向的
          TEMP_FIXED_EXTENT.set(xmin, -ymax, xmax, -ymin);
          if (out) {
              out.set(this._extent2D['xmin'], this._extent2D['ymin'], this._extent2D['xmax'], this._extent2D['ymax']);
              out._add(TEMP_FIXED_EXTENT);
              return out;
          }
          return this._extent2D.add(TEMP_FIXED_EXTENT);
      };
      //@internal
      Painter.prototype._computeExtent2D = function (extent) {
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              var symbolizer = this.symbolizers[i];
              extent._combine(symbolizer.get2DExtent());
          }
          return extent;
      };
      //@internal
      Painter.prototype._computeFixedExtent = function (resources, extent) {
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              var symbolizer = this.symbolizers[i];
              if (symbolizer.getFixedExtent) {
                  extent._combine(symbolizer.getFixedExtent(resources));
              }
          }
          return extent;
      };
      //@internal
      Painter.prototype._isDynamicSize = function () {
          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
              var symbolizer = this.symbolizers[i];
              if (symbolizer.isDynamicSize()) {
                  return true;
              }
          }
          return false;
      };
      //@internal
      Painter.prototype._aboveCamera = function () {
          var altitude = this.getMinAltitude();
          var map = this.getMap();
          var glRes = map.getGLRes();
          altitude = map.altitudeToPoint(altitude, glRes) * sign(altitude);
          var frustumAlt = map.getFrustumAltitude();
          return altitude && frustumAlt && frustumAlt < altitude;
      };
      Painter.prototype.getFixedExtent = function () {
          var map = this.getMap();
          var zoom = map.getZoom();
          if (this._isDynamicSize()) {
              return this._computeFixedExtent(null, new PointExtent());
          }
          if (!this._extent2D || this._extent2D._zoom !== zoom) {
              this.get2DExtent(null, TEMP_FIXED_EXTENT);
          }
          return this._fixedExtent;
      };
      Painter.prototype.setZIndex = function (change) {
          this._eachSymbolizer(function (symbolizer) {
              symbolizer.setZIndex(change);
          });
      };
      Painter.prototype.show = function () {
          if (!this._painted) {
              var layer = this.getLayer();
              if (!layer.isCanvasRender()) {
                  this.paint();
              }
          }
          else {
              this.removeCache();
              this._eachSymbolizer(function (symbolizer) {
                  symbolizer.show();
              });
          }
      };
      Painter.prototype.hide = function () {
          this._eachSymbolizer(function (symbolizer) {
              symbolizer.hide();
          });
      };
      Painter.prototype.repaint = function () {
          this._altAtGL = this._getGeometryAltitude();
          this.removeCache();
          var layer = this.getLayer();
          if (!layer) {
              return;
          }
          var renderer = layer.getRenderer();
          if (!renderer || !renderer.setToRedraw()) {
              return;
          }
          renderer.setToRedraw();
      };
      /**
       * refresh symbolizers when symbol changed
       */
      Painter.prototype.refreshSymbol = function () {
          this.removeCache();
          this._removeSymbolizers();
          this.symbolizers = this._createSymbolizers();
      };
      Painter.prototype.remove = function () {
          this.removeCache();
          this._removeSymbolizers();
      };
      //@internal
      Painter.prototype._removeSymbolizers = function () {
          this._eachSymbolizer(function (symbolizer) {
              delete symbolizer.painter;
              symbolizer.remove();
          });
          delete this.symbolizers;
      };
      /**
       * delete painter's caches
       */
      Painter.prototype.removeCache = function () {
          delete this._renderPoints;
          delete this._paintParams;
          delete this._sprite;
          delete this._extent2D;
          delete this._fixedExtent;
          delete this._cachedParams;
          delete this._unsimpledParams;
      };
      Painter.prototype.getAltitude = function () {
          var propAlt = this.geometry._getAltitude();
          if (propAlt !== this._propAlt) {
              this._altAtGL = this._getGeometryAltitude();
          }
          if (!this._altAtGL) {
              return 0;
          }
          return this._altAtGL;
      };
      Painter.prototype.getMinAltitude = function () {
          if (!this.minAltitude) {
              return 0;
          }
          return this.minAltitude;
      };
      Painter.prototype.getMaxAltitude = function () {
          if (!this.maxAltitude) {
              return 0;
          }
          return this.maxAltitude;
      };
      //@internal
      Painter.prototype._getGeometryAltitude = function () {
          var map = this.getMap();
          if (!map) {
              return 0;
          }
          var altitude = this.geometry._getAltitude();
          this._propAlt = altitude;
          var _a = __read(getMinMaxAltitude(altitude), 2), min = _a[0], max = _a[1];
          this.minAltitude = min;
          this.maxAltitude = max;
          if (!altitude) {
              return 0;
          }
          var center = this.geometry.getCenter();
          if (!center) {
              return 0;
          }
          return altitude;
      };
      //@internal
      Painter.prototype._verifyProjection = function () {
          var projection = this.geometry._getProjection() || PROJECTION;
          if (this._projCode && this._projCode !== projection.code) {
              this.removeCache();
          }
          this._projCode = projection.code;
      };
      //@internal
      Painter.prototype._beforePaint = function () {
      };
      //@internal
      Painter.prototype._afterPaint = function () {
      };
      return Painter;
  }(Class));
  function interpolateAlt(points, orig, altitude) {
      if (!Array.isArray(altitude)) {
          return points;
      }
      var parts = [];
      for (var i = 0, l = points.length; i < l; i++) {
          if (Array.isArray(points[i])) {
              parts.push(interpolateAlt(points[i], orig, altitude));
          }
          else {
              var p = points[i];
              if (!p.point.equals(orig[p.index])) {
                  var w0 = void 0, w1 = void 0;
                  if (p.index === 0) {
                      w0 = p.index;
                      w1 = p.index + 1;
                  }
                  else {
                      w0 = p.index - 1;
                      w1 = p.index;
                  }
                  var t0 = p.point.distanceTo(orig[w1]);
                  var t = t0 / (t0 + orig[w0].distanceTo(p.point));
                  var alt = interpolate$3(altitude[w0], altitude[w1], 1 - t);
                  p.altitude = alt;
                  parts.push(p);
              }
              else {
                  p.altitude = altitude[p.index];
                  parts.push(p);
              }
          }
      }
      return parts;
  }

  var TEMP_EXTENT$5 = new PointExtent();
  /**
   * @classdesc
   * Painter for collection type geometries
   * @class
   * @private
   */
  var CollectionPainter = /** @class */ (function (_super) {
      __extends(CollectionPainter, _super);
      /**
       * @param geometry - geometry to paint
       * @param isMask
       */
      function CollectionPainter(geometry, isMask) {
          var _this = _super.call(this) || this;
          _this.geometry = geometry;
          _this.isMask = isMask;
          _this.bbox = getDefaultBBOX();
          _this._drawTime = 0;
          return _this;
      }
      //@internal
      CollectionPainter.prototype._setDrawTime = function (time) {
          this._drawTime = time;
          this._eachPainter(function (painter) {
              painter._setDrawTime(time);
          });
          return this;
      };
      CollectionPainter.prototype.getRenderBBOX = function () {
          var _this = this;
          var layer = this.getLayer();
          if (layer && layer._drawTime !== this._drawTime) {
              return null;
          }
          resetBBOX(this.bbox);
          this._eachPainter(function (painter) {
              var bbox = painter.getRenderBBOX();
              if (!validateBBOX(bbox)) {
                  return;
              }
              setBBOX(_this.bbox, bbox);
          });
          if (validateBBOX(this.bbox)) {
              return this.bbox;
          }
          return null;
      };
      //@internal
      CollectionPainter.prototype._eachPainter = function (fn) {
          var geometries = this.geometry.getGeometries();
          var painter;
          for (var i = 0, len = geometries.length; i < len; i++) {
              painter = this.isMask ? geometries[i]._getMaskPainter() : geometries[i]._getPainter();
              if (!painter) {
                  continue;
              }
              if (painter) {
                  if (fn.call(this, painter) === false) {
                      break;
                  }
              }
          }
      };
      CollectionPainter.prototype.getLayer = function () {
          return this.geometry && this.geometry.getLayer();
      };
      CollectionPainter.prototype.paint = function (extent) {
          if (!this.geometry) {
              return;
          }
          this._eachPainter(function (painter) {
              painter.paint(extent);
          });
      };
      CollectionPainter.prototype.get2DExtent = function (resources, out) {
          if (out) {
              out.set(null, null, null, null);
          }
          // const extent = out || new PointExtent();
          // const geometries = this.geometry.getGeometries();
          // for (let i = 0, len = geometries.length; i < len; i++) {
          //     extent._combine(geometries[i].get2DExtent());
          // }
          // return extent;
          var extent = out || new PointExtent();
          this._eachPainter(function (painter) {
              extent = extent._combine(painter.get2DExtent(resources, TEMP_EXTENT$5));
          });
          return extent;
      };
      CollectionPainter.prototype.remove = function () {
          this._eachPainter(function (painter) {
              painter.remove();
          });
      };
      CollectionPainter.prototype.setZIndex = function (index) {
          this._eachPainter(function (painter) {
              painter.setZIndex(index);
          });
      };
      CollectionPainter.prototype.show = function () {
          this._eachPainter(function (painter) {
              painter.show();
          });
      };
      CollectionPainter.prototype.hide = function () {
          this._eachPainter(function (painter) {
              painter.hide();
          });
      };
      CollectionPainter.prototype.repaint = function () {
          this._eachPainter(function (painter) {
              painter.repaint();
          });
      };
      CollectionPainter.prototype.refreshSymbol = function () {
          this._eachPainter(function (painter) {
              painter.refreshSymbol();
          });
      };
      CollectionPainter.prototype.hasPoint = function () {
          var result = false;
          this._eachPainter(function (painter) {
              if (painter.hasPoint()) {
                  result = true;
                  return false;
              }
              return true;
          });
          return result;
      };
      CollectionPainter.prototype.getMinAltitude = function () {
          var first = true;
          var result = 0;
          this._eachPainter(function (painter) {
              var alt = painter.getMinAltitude();
              if (first || alt < result) {
                  first = false;
                  result = alt;
              }
          });
          return result;
      };
      CollectionPainter.prototype.getMaxAltitude = function () {
          var result = 0;
          this._eachPainter(function (painter) {
              var alt = painter.getMaxAltitude();
              if (alt > result) {
                  result = alt;
              }
          });
          return result;
      };
      return CollectionPainter;
  }(Class));

  function getProjectionCode(code) {
      var newcode = '';
      var codeArray = code.split('');
      for (var len = codeArray.length, i = len - 1; i >= 0; i--) {
          if (!isNaN(codeArray[i])) {
              newcode = codeArray[i] + newcode;
          }
          else {
              break;
          }
      }
      return newcode;
  }
  function getProjection(projection) {
      var prj = (projection.indexOf('EPSG') > -1 ? projection : 'EPSG:' + projection);
      prj = strReplace(prj, [
          ['4490', '4326'],
          ['102100', '3857'],
          ['900913', '3857']
      ]);
      return prj;
  }
  function strReplace(str, repArray) {
      if (repArray === void 0) { repArray = []; }
      repArray.forEach(function (rep) {
          var _a = __read(rep, 2), template = _a[0], value = _a[1];
          str = str.replace(template, value);
      });
      return str;
  }
  function getTransformValue(options) {
      var projection = options.projection, isArcgis = options.isArcgis, isGeoServer = options.isGeoServer, isSuperMap = options.isSuperMap;
      //transform value, ArcGIS is different from others
      var transformValue = 0.0002645833333333333;
      if (isArcgis || isGeoServer || isSuperMap) {
          transformValue = 0.00028;
      }
      if (projection && projection.indexOf('4326') > -1) {
          transformValue = 2.3767925226029154e-9;
          if (isArcgis || isSuperMap) {
              transformValue = 2.518101729011901e-9;
          }
          if (isGeoServer) {
              transformValue = 2.51528279553466e-9;
          }
      }
      return transformValue;
  }
  var ns = 'wmts';
  // try get by localName, ns:localName
  function getElementsByTagName(element, localName) {
      var result = element.getElementsByTagName(localName);
      if (result && result.length) {
          return result;
      }
      var name = ns + ':' + localName;
      return element.getElementsByTagName(name);
  }
  function getTileMatrixSet(TileMatrixSets, TileMatrixSetLink) {
      for (var i = 0; i < TileMatrixSets.length; i++) {
          var TileMatrixSet = TileMatrixSets[i];
          TileMatrixSet = TileMatrixSet.getElementsByTagName('ows:Identifier')[0];
          if (TileMatrixSet) {
              if (TileMatrixSet.textContent === TileMatrixSetLink) {
                  return TileMatrixSets[i];
              }
          }
      }
      return null;
  }
  function parseWMTSXML(str, requestUrl, options) {
      var serviceType = ["isArcgis", "isSuperMap", "isGeoServer"];
      if (serviceType.every(function (key) { return options[key] == null; })) {
          console.warn("Please specify the server type, such as isArcgis, isSuperMap, isGeoServer, Otherwise, the system will determine by itself");
      }
      //IE test success
      if (options.isArcgis == null) {
          options.isArcgis = ["arcgis", "geoscene"].some(function (key) { return str.indexOf(key) > -1; });
      }
      if (options.isSuperMap == null) {
          options.isSuperMap = str.indexOf('supermap') > -1;
      }
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(str, 'text/xml');
      var content = xmlDoc.querySelectorAll('Contents')[0];
      if (!content) {
          return [];
      }
      var layers = getElementsByTagName(content, 'Layer');
      if (!layers.length) {
          return [];
      }
      var TileMatrixSets = [];
      for (var i = 0, len = content.childNodes.length; i < len; i++) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          if (content.childNodes[i].localName === 'TileMatrixSet') {
              TileMatrixSets.push(content.childNodes[i]);
          }
      }
      if (!TileMatrixSets.length) {
          return [];
      }
      var result = [];
      for (var i = 0, len = layers.length; i < len; i++) {
          var layer = layers[i];
          var style = layer.querySelectorAll('Style')[0];
          if (style) {
              style = style.getElementsByTagName('ows:Identifier')[0];
              if (style) {
                  style = style.textContent;
              }
          }
          var layerName = layer.getElementsByTagName('ows:Identifier')[0];
          if (layerName) {
              layerName = layerName.textContent;
          }
          var tileMatrixSetLinks = getElementsByTagName(layer, 'TileMatrixSetLink');
          if (tileMatrixSetLinks.length === 0) {
              continue;
          }
          for (var j = 0, len1 = tileMatrixSetLinks.length; j < len1; j++) {
              var tileMatrixSetLink = tileMatrixSetLinks[j];
              tileMatrixSetLink = getElementsByTagName(tileMatrixSetLink, 'TileMatrixSet')[0];
              if (tileMatrixSetLink) {
                  tileMatrixSetLink = tileMatrixSetLink.textContent;
              }
              var tileMatrixSet = getTileMatrixSet(TileMatrixSets, tileMatrixSetLink);
              if (!tileMatrixSet) {
                  continue;
              }
              var resourceURL = layer.querySelectorAll('ResourceURL')[0];
              var url = '';
              if (resourceURL) {
                  url = resourceURL.attributes.template.value;
              }
              var _a = parseTileMatrixSet(tileMatrixSet, options), resolutions = _a.resolutions, tileSize = _a.tileSize, tileSystem = _a.tileSystem, projection = _a.projection, TileMatrixSet = _a.TileMatrixSet, isGeoServer = _a.isGeoServer, levelStr = _a.levelStr;
              //not find ServerURL
              if (!url.length) {
                  url = requestUrl.substr(0, requestUrl.lastIndexOf('?'));
                  url += '?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT={tiles}&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}';
              }
              var urlTemplate = strReplace(url, [
                  ['{LAYER}', layerName],
                  ['{Layer}', layerName],
                  ['{layer}', layerName],
                  ['{STYLE}', style],
                  ['{Style}', style],
                  ['{style}', style],
                  ['{TileMatrixSet}', TileMatrixSet],
                  ['{TileMatrix}', isGeoServer ? "".concat(levelStr, ":{z}") : '{z}'],
                  ['{TileRow}', '{y}'],
                  ['{TileCol}', '{x}'],
                  ['{tiles}', isGeoServer ? 'image/png' : 'tiles'],
              ]);
              result.push({
                  tileSize: tileSize,
                  tileSystem: tileSystem,
                  spatialReference: {
                      resolutions: resolutions,
                      projection: projection
                  },
                  urlTemplate: urlTemplate,
                  info: {
                      layerName: layerName,
                      TileMatrixSet: TileMatrixSet,
                      style: style,
                      tileSize: tileSize,
                      tileSystem: tileSystem,
                      resolutions: resolutions,
                      projection: projection,
                      urlTemplate: urlTemplate
                  }
              });
          }
      }
      return result;
  }
  function parseTileMatrixSet(TileMatrixSet, options) {
      if (options === void 0) { options = {}; }
      var TileMatrixs = getElementsByTagName(TileMatrixSet, 'TileMatrix');
      var resolutions = [], tileSystem = [], tileSize = [];
      var projection, tset, isGeoServer = false, levelStr;
      if (!projection) {
          var supportedCRS = TileMatrixSet.getElementsByTagName('ows:SupportedCRS')[0];
          if (supportedCRS) {
              projection = supportedCRS.textContent;
              projection = projection.split('EPSG')[1];
              projection = getProjectionCode(projection);
              projection = getProjection(projection);
          }
      }
      if (!tset) {
          tset = TileMatrixSet.getElementsByTagName('ows:Identifier')[0];
          if (tset) {
              tset = tset.textContent;
          }
      }
      options.projection = projection;
      var minLevel = Infinity;
      for (var index = 0; index < TileMatrixs.length; index++) {
          var TileMatrix = TileMatrixs[index];
          var level = TileMatrix.getElementsByTagName('ows:Identifier')[0].textContent;
          if (isNaN(parseInt(level))) {
              levelStr = level.substr(0, level.lastIndexOf(':'));
              level = level.split(':');
              level = level[level.length - 1];
              level = parseInt(level);
              isGeoServer = true;
              options.isGeoServer = true;
          }
          else {
              level = parseInt(level);
          }
          minLevel = Math.min(minLevel, level);
          var ScaleDenominator = getElementsByTagName(TileMatrix, 'ScaleDenominator')[0].textContent;
          var TopLeftCorner = getElementsByTagName(TileMatrix, 'TopLeftCorner')[0].textContent;
          var TileWidth = getElementsByTagName(TileMatrix, 'TileWidth')[0].textContent;
          var TileHeight = getElementsByTagName(TileMatrix, 'TileHeight')[0].textContent;
          if (tileSize.length === 0) {
              tileSize.push(parseInt(TileWidth), parseInt(TileHeight));
          }
          if (tileSystem.length === 0) {
              var _a = __read(TopLeftCorner.split(' ').filter(function (s) {
                  return s !== '';
              }).map(function (v) {
                  return parseFloat(v);
              }), 2), x = _a[0], y = _a[1];
              if (x > 0) {
                  tileSystem.push(1, -1, y, x);
              }
              else {
                  tileSystem.push(1, -1, x, y);
              }
          }
          var transformValue = getTransformValue(options);
          var res = parseFloat(ScaleDenominator) * transformValue;
          resolutions.push(res);
      }
      //Missing LOD completion
      // such as http://t0.tianditu.gov.cn/img_w/wmts?request=GetCapabilities&service=wmts&tk=de0dc270a51aaca3dd4e64d4f8c81ff6
      if (minLevel > 0) {
          var res = resolutions[0];
          for (var i = minLevel - 1; i >= 0; i--) {
              res = res * 2;
              resolutions.splice(0, 0, res);
          }
      }
      return {
          resolutions: resolutions,
          tileSize: tileSize,
          tileSystem: tileSystem,
          projection: projection,
          TileMatrixSet: tset,
          isGeoServer: isGeoServer,
          levelStr: levelStr
      };
  }
  var loadWMTS = function (url, cb, options) {
      if (options === void 0) { options = { 'jsonp': true }; }
      if (isString(url)) {
          Ajax.get(url, function (err, xml) {
              if (err) {
                  cb(err);
                  return;
              }
              var layers = parseWMTSXML(xml, url, options);
              cb(null, layers);
          }, options);
      }
      // return this;
  };

  /**
   * 解析Arcgis空间参考配置
   * @param arcConf
   * @returns
   */
  function parse(arcConf) {
      var tileInfo = arcConf['tileInfo'], tileSize = [tileInfo['cols'], tileInfo['rows']], resolutions = [], lods = tileInfo['lods'];
      for (var i = 0, len = lods.length; i < len; i++) {
          resolutions.push(lods[i]['resolution']);
      }
      var fullExtent = arcConf['fullExtent'], origin = tileInfo['origin'], tileSystem = [1, -1, origin['x'], origin['y']];
      delete fullExtent['spatialReference'];
      return {
          'spatialReference': {
              'resolutions': resolutions,
              'fullExtent': fullExtent
          },
          'tileSystem': tileSystem,
          'tileSize': tileSize
      };
  }
  /**
   * 加载Arcgis空间参考配置文件
   * @param url arcgis spatialreference json file url
   * @param cb
   * @param options
   * @returns
   */
  var loadArcgis = function (url, cb, options) {
      if (options === void 0) { options = { 'jsonp': true }; }
      if (isString(url) && url.substring(0, 1) !== '{') {
          Ajax.getJSON(url, function (err, json) {
              if (err) {
                  cb(err);
                  return;
              }
              var spatialRef = parse(json);
              cb(null, spatialRef);
          }, options);
      }
      else {
          if (isString(url)) {
              url = parseJSON(url);
          }
          var spatialRef = parse(url);
          cb(null, spatialRef);
      }
      // return this;
  };

  var MAX_ZOOM = 23;
  var DefaultSpatialReference = {
      'EPSG:3857': {
          'projection': 'EPSG:3857',
          'resolutions': (function () {
              var resolutions = [];
              var d = 2 * 6378137 * Math.PI;
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = d / (256 * Math.pow(2, i));
              }
              return resolutions;
          })(),
          'fullExtent': {
              'top': 6378137 * Math.PI,
              'left': -6378137 * Math.PI,
              'bottom': -6378137 * Math.PI,
              'right': 6378137 * Math.PI
          }
      },
      'EPSG:4326': {
          'projection': 'EPSG:4326',
          'fullExtent': {
              'top': 90,
              'left': -180,
              'bottom': -90,
              'right': 180
          },
          'resolutions': (function () {
              var resolutions = [];
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = 180 / (Math.pow(2, i) * 128);
              }
              return resolutions;
          })()
      },
      'BAIDU': {
          'projection': 'baidu',
          'resolutions': (function () {
              var res = Math.pow(2, 18);
              var resolutions = [];
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = res;
                  res *= 0.5;
              }
              return resolutions;
          })(),
          'fullExtent': {
              'top': 33554432,
              'left': -33554432,
              'bottom': -33554432,
              'right': 33554432
          }
      },
      'IDENTITY': {
          'projection': 'identity',
          'resolutions': (function () {
              var res = Math.pow(2, 8);
              var resolutions = [];
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = res;
                  res *= 0.5;
              }
              return resolutions;
          })(),
          'fullExtent': {
              'top': 200000,
              'left': -200000,
              'bottom': -200000,
              'right': 200000
          }
      },
      // TileSystem: [1, -1, -6378137 * Math.PI, 6378137 * Math.PI]
      'PRESET-VT-3857': {
          'projection': 'EPSG:3857',
          'resolutions': (function () {
              var resolutions = [];
              var d = 6378137 * Math.PI;
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = d / (256 * Math.pow(2, i));
              }
              return resolutions;
          })(),
          'fullExtent': {
              'top': 6378137 * Math.PI,
              'left': -6378137 * Math.PI,
              'bottom': -6378137 * Math.PI,
              'right': 6378137 * Math.PI
          }
      },
      'PRESET-VT-4326': {
          'projection': 'EPSG:4326',
          'fullExtent': {
              'top': 90,
              'left': -180,
              'bottom': -90,
              'right': 180
          },
          'resolutions': (function () {
              var resolutions = [];
              for (var i = 0; i < MAX_ZOOM; i++) {
                  resolutions[i] = 180 / 4 / (Math.pow(2, i) * 128);
              }
              return resolutions;
          })()
      }
  };
  DefaultSpatialReference['EPSG:4490'] = DefaultSpatialReference['EPSG:4326'];
  DefaultSpatialReference['PRESET-3857-512'] = DefaultSpatialReference['PRESET-VT-3857'];
  DefaultSpatialReference['PRESET-4326-512'] = DefaultSpatialReference['PRESET-VT-4326'];
  DefaultSpatialReference['PRESET-4490-512'] = DefaultSpatialReference['PRESET-VT-4326'];
  /**
   * 空间参考类
   *
   * @english
   * SpatialReference Class
   */
  var SpatialReference = /** @class */ (function () {
      function SpatialReference(options) {
          if (options === void 0) { options = {}; }
          this.options = options;
          this._initSpatialRef();
      }
      SpatialReference.registerPreset = function (name, value) {
          name = name && name.toUpperCase();
          if (DefaultSpatialReference[name]) {
              console.warn("Spatial reference ".concat(name, " already registered."));
          }
          DefaultSpatialReference[name] = value;
      };
      SpatialReference.getPreset = function (preset) {
          return DefaultSpatialReference[preset.toUpperCase()];
      };
      SpatialReference.getAllPresets = function () {
          return Object.keys(DefaultSpatialReference);
      };
      SpatialReference.loadArcgis = function (url, cb, options) {
          loadArcgis(url, cb, options);
          return this;
      };
      SpatialReference.loadWMTS = function (url, cb, options) {
          loadWMTS(url, cb, options);
          return this;
      };
      /**
       * 获取投影类实例对象
       *
       * @english
       * get Projection Class instance
       * @param projection
       * @returns
       */
      SpatialReference.getProjectionInstance = function (projection) {
          var proj;
          if (!projection) {
              return null;
          }
          if (isString(projection)) {
              proj = {
                  code: projection
              };
          }
          else {
              proj = projection;
          }
          // a custom one
          if (proj.project) {
              if (!proj.locate) {
                  proj = extend$2({}, proj);
                  if (proj.measure === 'identity') {
                      extend$2(proj, Measurer.getInstance('IDENTITY'));
                  }
                  else {
                      extend$2(proj, Measurer.getInstance('EPSG:4326'));
                  }
              }
              return proj;
          }
          var prjName = (proj.code + '').toLowerCase();
          for (var p in projections) {
              if (hasOwn(projections, p)) {
                  var names = projections[p].aliases || [];
                  var code = projections[p]['code'];
                  if (code) {
                      names.push(code);
                  }
                  for (var i = 0; i < names.length; i++) {
                      if (names[i].toLowerCase() === prjName) {
                          if (projections[p].create) {
                              var instance = projections[p].create(projection);
                              instance.code = names[i];
                              return instance;
                          }
                          else {
                              if (projections[p].code === names[i]) {
                                  return projections[p];
                              }
                              var instance = extend$2({}, projections[p]);
                              instance.code = names[i];
                              return instance;
                          }
                      }
                  }
              }
          }
          return null;
      };
      SpatialReference.equals = function (sp1, sp2) {
          if (isString(sp1) || isString(sp2)) {
              return sp1 === sp2;
          }
          if (!sp1 && !sp2) {
              return true;
          }
          else if (!sp1 || !sp2) {
              return false;
          }
          if (sp1.projection !== sp2.projection) {
              return false;
          }
          // 这里强制类型为 FullExtent，因为在创建时内部会主动赋值 top/left 等
          var f1 = sp1.fullExtent, f2 = sp2.fullExtent;
          if (f1 && !f2 || !f1 && f2) {
              return false;
          }
          if (f1 && f2) {
              if (f1.top !== f2.top || f1.bottom !== f2.bottom || f1.left !== f2.left || f1.right !== f2.right) {
                  return false;
              }
          }
          var r1 = sp1.resolutions, r2 = sp2.resolutions;
          if (r1 && r2) {
              if (r1.length !== r2.length) {
                  return false;
              }
              for (var i = 0; i < r1.length; i++) {
                  if (r1[i] !== r2[i]) {
                      return false;
                  }
              }
          }
          else if (r1 || r2) {
              return false;
          }
          return true;
      };
      //@internal
      SpatialReference.prototype._initSpatialRef = function () {
          var projection;
          if (this.options['projection']) {
              projection = SpatialReference.getProjectionInstance(this.options['projection']);
          }
          else {
              projection = DEFAULT;
          }
          if (!projection) {
              throw new Error('must provide a valid projection in map\'s spatial reference.');
          }
          projection = extend$2({}, CommonProjection, projection);
          if (!projection.measureLength) {
              extend$2(projection, DEFAULT$1);
          }
          this._projection = projection;
          var defaultSpatialRef, resolutions = this.options['resolutions'];
          if (!resolutions) {
              if (projection['code']) {
                  defaultSpatialRef = DefaultSpatialReference[projection['code'].toUpperCase()];
                  if (defaultSpatialRef) {
                      resolutions = defaultSpatialRef['resolutions'];
                      this.isEPSG = projection['code'] !== 'IDENTITY';
                  }
              }
              if (!resolutions) {
                  throw new Error('must provide valid resolutions in map\'s spatial reference.');
              }
          }
          this._resolutions = resolutions;
          this._pyramid = true;
          if (this._pyramid) {
              var delta = 1E4;
              for (var i = 0; i < resolutions.length; i++) {
                  if (resolutions[i] && resolutions[i - 1]) {
                      if (Math.round(resolutions[i - 1] / resolutions[i] * delta) / delta !== 2) {
                          this._pyramid = false;
                          break;
                      }
                  }
              }
          }
          var fullExtent = this.options['fullExtent'];
          if (!fullExtent) {
              if (projection['code']) {
                  defaultSpatialRef = DefaultSpatialReference[projection['code'].toUpperCase()];
                  if (defaultSpatialRef) {
                      fullExtent = defaultSpatialRef['fullExtent'];
                  }
              }
              if (!fullExtent) {
                  throw new Error('must provide a valid fullExtent in map\'s spatial reference.');
              }
          }
          if (!isNil(fullExtent['left'])) {
              this._fullExtent = new Extent(new Coordinate(fullExtent['left'], fullExtent['top']), new Coordinate(fullExtent['right'], fullExtent['bottom']));
          }
          else {
              this._fullExtent = new Extent(fullExtent);
              fullExtent['left'] = fullExtent['xmin'];
              fullExtent['right'] = fullExtent['xmax'];
              fullExtent['top'] = fullExtent['ymax'];
              fullExtent['bottom'] = fullExtent['ymin'];
          }
          if (isNil(fullExtent['top']) || isNil(fullExtent['bottom']) || isNil(fullExtent['left']) || isNil(fullExtent['right'])) {
              throw new Error('must provide valid top/bottom/left/right in fullExtent.');
          }
          //set left, right, top, bottom value
          extend$2(this._fullExtent, fullExtent);
          this._projection.fullExtent = fullExtent;
          var a = fullExtent['right'] >= fullExtent['left'] ? 1 : -1, b = fullExtent['top'] >= fullExtent['bottom'] ? -1 : 1;
          this._transformation = new Transformation([a, b, 0, 0]);
      };
      SpatialReference.prototype.getResolutions = function () {
          return this._resolutions || [];
      };
      SpatialReference.prototype.getResolution = function (zoom) {
          var z = (zoom | 0);
          if (z < 0) {
              z = 0;
          }
          else if (z > this._resolutions.length - 1) {
              z = this._resolutions.length - 1;
          }
          var res = this._resolutions[z];
          if (z !== zoom && zoom > 0 && z < this._resolutions.length - 1) {
              var next = this._resolutions[z + 1];
              return res + (next - res) * (zoom - z);
          }
          return res;
      };
      SpatialReference.prototype.getProjection = function () {
          return this._projection;
      };
      SpatialReference.prototype.getFullExtent = function () {
          return this._fullExtent;
      };
      SpatialReference.prototype.getTransformation = function () {
          return this._transformation;
      };
      SpatialReference.prototype.getMinZoom = function () {
          for (var i = 0; i < this._resolutions.length; i++) {
              if (!isNil(this._resolutions[i])) {
                  return i;
              }
          }
          return 0;
      };
      SpatialReference.prototype.getMaxZoom = function () {
          for (var i = this._resolutions.length - 1; i >= 0; i--) {
              if (!isNil(this._resolutions[i])) {
                  return i;
              }
          }
          return this._resolutions.length - 1;
      };
      SpatialReference.prototype.getZoomDirection = function () {
          return sign(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()]);
      };
      SpatialReference.prototype.toJSON = function () {
          if (!this.json) {
              this.json = {
                  'resolutions': this._resolutions,
                  'fullExtent': {
                      'top': this._fullExtent.top,
                      'left': this._fullExtent.left,
                      'bottom': this._fullExtent.bottom,
                      'right': this._fullExtent.right
                  },
                  'projection': this._projection.code
              };
          }
          return this.json;
      };
      SpatialReference.prototype.isPyramid = function () {
          return this._pyramid;
      };
      return SpatialReference;
  }());

  var TEMP_POINT0$1 = new Point(0, 0);
  var TEMP_EXTENT$4 = new PointExtent();
  var TEMP_PROPERTIES = {};
  function validateExtent(extent) {
      if (!extent) {
          return false;
      }
      var xmin = extent.xmin, ymin = extent.ymin, xmax = extent.xmax, ymax = extent.ymax;
      return (xmax - xmin > 0 && ymax - ymin > 0);
  }
  /**
   * @property {Object} options                       - geometry options
   * @property {Boolean} [options.id=null]            - id of the geometry
   * @property {Boolean} [options.visible=true]       - whether the geometry is visible.
   * @property {Boolean} [options.editable=true]      - whether the geometry can be edited.
   * @property {Boolean} [options.interactive=true]   - whether the geometry can be interactived.
   * @property {String} [options.cursor=null]         - cursor style when mouseover the geometry, same as the definition in CSS.
   * @property {String} [options.measure=EPSG:4326]   - the measure code for the geometry, defines {@tutorial measureGeometry how it can be measured}.
   * @property {Boolean} [options.draggable=false]    - whether the geometry can be dragged.
   * @property {Boolean} [options.dragShadow=true]    - if true, during geometry dragging, a shadow will be dragged before geometry was moved.
   * @property {Boolean} [options.dragOnAxis=null]    - if set, geometry can only be dragged along the specified axis, possible values: x, y
   * @property {Number}  [options.zIndex=undefined]   - geometry's initial zIndex
   * @property {Boolean}  [options.antiMeridian=false]   - geometry's antiMeridian
   * @memberOf Geometry
   * @instance
   */
  var options$C = {
      'id': null,
      'visible': true,
      'interactive': true,
      'editable': true,
      'cursor': null,
      'antiMeridian': false,
      'defaultProjection': 'EPSG:4326' // BAIDU, IDENTITY
  };
  /**
   * 所有几何图形的基类。
   * 它定义了所有几何图形类共享的通用方法。
   * 它是抽象的，不打算被实例化而是被扩展。
   * @english
   * Base class for all the geometries. <br/>
   * It defines common methods that all the geometry classes share. <br>
   * It is abstract and not intended to be instantiated but extended.
   *
   * @category geometry
   * @abstract
   * @extends Class
   * @mixes Eventable
   * @mixes Handlerable
   * @mixes JSONAble
   * @mixes ui.Menuable
   */
  var Geometry = /** @class */ (function (_super) {
      __extends(Geometry, _super);
      function Geometry(options) {
          var _this = this;
          var opts = extend$2({}, options);
          var symbol = opts['symbol'];
          var properties = opts['properties'];
          var id = opts['id'];
          delete opts['symbol'];
          delete opts['id'];
          delete opts['properties'];
          _this = _super.call(this, opts) || this;
          if (symbol) {
              _this.setSymbol(symbol);
          }
          else {
              _this._genSizeSymbol();
          }
          if (properties) {
              _this.setProperties(properties);
          }
          if (!isNil(id)) {
              _this.setId(id);
          }
          //record rotate
          if (options && isNumber(options.rotateAngle)) {
              _this._dirtyRotate = true;
          }
          return _this;
      }
      Geometry.fromJSON = function (json) {
          return json;
      };
      /**
       * 获取几何图形第一个坐标点
       * @english
       * Returns the first coordinate of the geometry.
       *
       * @return {Coordinate} First Coordinate
       */
      Geometry.prototype.getFirstCoordinate = function () {
          if (this.type === 'GeometryCollection') {
              var geometries = this.getGeometries();
              if (!geometries.length) {
                  return null;
              }
              return geometries[0].getFirstCoordinate();
          }
          var coordinates = this.getCoordinates();
          if (!Array.isArray(coordinates)) {
              return coordinates;
          }
          do {
              coordinates = coordinates[0];
          } while (Array.isArray(coordinates) && coordinates.length > 0);
          return coordinates;
      };
      /**
       * 获取几何图形最后一个坐标点
       * @english
       * Returns the last coordinate of the geometry.
       *
       * @return {Coordinate} Last Coordinate
       */
      Geometry.prototype.getLastCoordinate = function () {
          if (this.type === 'GeometryCollection') {
              var geometries = this.getGeometries();
              if (!geometries.length) {
                  return null;
              }
              return geometries[geometries.length - 1].getLastCoordinate();
          }
          var coordinates = this.getCoordinates();
          if (!Array.isArray(coordinates)) {
              return coordinates;
          }
          do {
              coordinates = coordinates[coordinates.length - 1];
          } while (Array.isArray(coordinates) && coordinates.length > 0);
          return coordinates;
      };
      /**
       * 将几何图形添加到指定图层上
       * @english
       * Adds the geometry to a layer
       * @param {Layer} layer    - layer add to
       * @param {Boolean} [fitview=false] - automatically set the map to a fit center and zoom for the geometry
       * @return {Geometry} this
       * @fires Geometry#add
       */
      Geometry.prototype.addTo = function (layer, fitview) {
          layer.addGeometry(this, fitview);
          return this;
      };
      /**
       * 获取几何图形所在的图层
       * @english
       * Get the layer which this geometry added to.
       * @returns {Layer} - layer added to
       */
      Geometry.prototype.getLayer = function () {
          if (!this._layer) {
              return null;
          }
          return this._layer;
      };
      /**
       * 获取几何图形所在的地图对象
       * @english
       * Get the map which this geometry added to
       * @returns {Map} - map added to
       */
      Geometry.prototype.getMap = function () {
          if (!this._layer) {
              return null;
          }
          return this._layer.getMap();
      };
      /**
       * 获取几何图形的id
       * @english
       * Gets geometry's id. Id is set by setId or constructor options.
       * @returns {String|Number} geometry的id
       */
      Geometry.prototype.getId = function () {
          return this._id;
      };
      /**
       * 给几何图形设置id
       * @english
       * Set geometry's id.
       * @param {String} id - new id
       * @returns {Geometry} this
       * @fires Geometry#idchange
       */
      Geometry.prototype.setId = function (id) {
          var oldId = this.getId();
          this._id = id;
          /**
           * idchange event.
           *
           * @event Geometry#idchange
           * @type {Object}
           * @property {String} type - idchange
           * @property {Geometry} target - the geometry fires the event
           * @property {String|Number} old        - value of the old id
           * @property {String|Number} new        - value of the new id
           */
          this._fireEvent('idchange', {
              'old': oldId,
              'new': id
          });
          return this;
      };
      /**
       * 获取几何图形的属性
       * @english
       * Get geometry's properties. Defined by GeoJSON as [feature's properties]{@link http://geojson.org/geojson-spec.html#feature-objects}.
       *
       * @returns {Object} properties
       */
      Geometry.prototype.getProperties = function () {
          if (!this.properties) {
              if (this._getParent()) {
                  return this._getParent().getProperties();
              }
              return null;
          }
          return this.properties;
      };
      /**
       * 给几何图形设置新的属性
       * Set a new properties to geometry.
       * @param {Object} properties - new properties
       * @returns {Geometry} this
       * @fires Geometry#propertieschange
       */
      Geometry.prototype.setProperties = function (properties) {
          var old = this.properties;
          this.properties = isObject$1(properties) ? extend$2({}, properties) : properties;
          //such as altitude update
          this._clearAltitudeCache();
          this._repaint();
          /**
           * propertieschange event, thrown when geometry's properties is changed.
           *
           * @event Geometry#propertieschange
           * @type {Object}
           * @property {String} type - propertieschange
           * @property {Geometry} target - the geometry fires the event
           * @property {String|Number} old        - value of the old properties
           * @property {String|Number} new        - value of the new properties
           */
          this._fireEvent('propertieschange', {
              'old': old,
              'new': properties
          });
          return this;
      };
      /**
       * 获取几何图形的类型,例如“点”,"线"
       * @english
       * Get type of the geometry, e.g. "Point", "LineString"
       * @returns {String} type of the geometry
       */
      Geometry.prototype.getType = function () {
          return this.type;
      };
      /**
       * 获取几何图形的样式
       * @english
       * Get symbol of the geometry
       * @returns {Object} geometry's symbol
       */
      Geometry.prototype.getSymbol = function () {
          var s = this._symbol;
          if (s) {
              if (!Array.isArray(s)) {
                  return extend$2({}, s);
              }
              else {
                  return extendSymbol(s);
              }
          }
          return null;
      };
      /**
       * 给几何图形设置样式
       * @english
       * Set a new symbol to style the geometry.
       * @param {Object} symbol - new symbol
       * @see {@tutorial symbol Style a geometry with symbols}
       * @return {Geometry} this
       * @fires Geometry#symbolchange
       */
      Geometry.prototype.setSymbol = function (symbol) {
          this._symbolUpdated = symbol;
          this._symbol = this._prepareSymbol(symbol);
          this.onSymbolChanged();
          delete this._compiledSymbol;
          delete this._symbolHash;
          return this;
      };
      /**
       * 获取样式的哈希值
       * @english
       * Get symbol's hash code
       * @return {String}
       */
      Geometry.prototype.getSymbolHash = function () {
          if (!this._symbolHash) {
              this._symbolHash = getSymbolHash(this._symbolUpdated);
          }
          return this._symbolHash;
      };
      /**
       * 更新几何图形当前的样式
       * @english
       * Update geometry's current symbol.
       *
       * @param  {Object | Array} props - symbol properties to update
       * @return {Geometry} this
       * @fires Geometry#symbolchange
       * @example
       * var marker = new Marker([0, 0], {
       *  // if has markerFile , the priority of the picture is greater than the vector and the path of svg
       *  // svg image type:'path';vector type:'cross','x','diamond','bar','square','rectangle','triangle','ellipse','pin','pie'
       *    symbol : {
       *       markerType : 'ellipse',
       *       markerWidth : 20,
       *       markerHeight : 30
       *    }
       * });
       * // update symbol's markerWidth to 40
       * marker.updateSymbol({
       *     markerWidth : 40
       * });
       */
      Geometry.prototype.updateSymbol = function (props) {
          if (!props) {
              return this;
          }
          var s = this._getSymbol();
          if (Array.isArray(s)) {
              if (!Array.isArray(props)) {
                  throw new Error('Parameter of updateSymbol is not an array.');
              }
              for (var i = 0; i < props.length; i++) {
                  if (isTextSymbol(props[i])) {
                      delete this._textDesc;
                  }
                  if (s[i] && props[i]) {
                      s[i] = extendSymbol(s[i], props[i]);
                  }
              }
          }
          else if (Array.isArray(props)) {
              throw new Error('Geometry\'s symbol is not an array to update.');
          }
          else {
              if (isTextSymbol(s)) {
                  delete this._textDesc;
              }
              if (s) {
                  s = extendSymbol(s, props);
              }
              else {
                  s = extendSymbol(this._getInternalSymbol(), props);
              }
          }
          this._eventSymbolProperties = props;
          delete this._compiledSymbol;
          return this.setSymbol(s);
      };
      /**
       * 如果几何图形有文本内容，就获取它
       * @english
       * Get geometry's text content if it has
       * @returns {String}
       */
      Geometry.prototype.getTextContent = function () {
          var symbol = this._getInternalSymbol();
          if (Array.isArray(symbol)) {
              var contents = [];
              var has = false;
              for (var i = 0; i < symbol.length; i++) {
                  contents[i] = replaceVariable(symbol[i] && symbol[i]['textName'], this.getProperties());
                  if (!isNil(contents[i])) {
                      has = true;
                  }
              }
              return has ? contents : null;
          }
          return replaceVariable(symbol && symbol['textName'], this.getProperties());
      };
      Geometry.prototype.getTextDesc = function () {
          if (!this._textDesc) {
              var textContent_1 = this.getTextContent();
              // if textName='',this is error
              // if (!textContent) {
              //     return null;
              // }
              var symbol = this._sizeSymbol;
              var isArray_1 = Array.isArray(textContent_1);
              if (Array.isArray(symbol)) {
                  this._textDesc = symbol.map(function (s, i) {
                      return describeText(isArray_1 ? textContent_1[i] : '', s);
                  });
              }
              else {
                  this._textDesc = describeText(textContent_1, symbol);
              }
          }
          return this._textDesc;
      };
      /**
       * 获取几何图形中心点
       * @english
       * Get the geographical center of the geometry.
       *
       * @returns {Coordinate}
       */
      Geometry.prototype.getCenter = function () {
          return this._computeCenter(this._getMeasurer());
      };
      /**
       * 获取几何图形的包围盒范围
       * @english
       * Get the geometry's geographical extent
       *
       * @returns {Extent} geometry's extent
       */
      Geometry.prototype.getExtent = function () {
          var prjExt = this._getPrjExtent();
          var projection = this._getProjection();
          if (prjExt && projection) {
              var min = projection.unproject(new Coordinate(prjExt['xmin'], prjExt['ymin'])), max = projection.unproject(new Coordinate(prjExt['xmax'], prjExt['ymax']));
              return new Extent(min, max, projection);
          }
          else {
              return this._computeExtent(this._getMeasurer());
          }
      };
      /**
       * 获取几何图形的屏幕像素范围
       * @english
       * Get geometry's screen extent in pixel
       *
       * @returns {PointExtent}
       */
      Geometry.prototype.getContainerExtent = function (out) {
          var extent2d = this.get2DExtent();
          if (!extent2d || !extent2d.isValid()) {
              return null;
          }
          var map = this.getMap();
          // const center = this.getCenter();
          var glRes = map.getGLRes();
          var minAltitude = this.getMinAltitude();
          var extent = extent2d.convertTo(function (c) { return map._pointAtResToContainerPoint(c, glRes, minAltitude, TEMP_POINT0$1); }, out);
          var maxAltitude = this.getMaxAltitude();
          if (maxAltitude !== minAltitude) {
              var extent2 = extent2d.convertTo(function (c) { return map._pointAtResToContainerPoint(c, glRes, maxAltitude, TEMP_POINT0$1); }, TEMP_EXTENT$4);
              extent._combine(extent2);
          }
          var layer = this.getLayer();
          if (layer && this.type === 'LineString' && maxAltitude && layer.options['drawAltitude']) {
              var groundExtent = extent2d.convertTo(function (c) { return map._pointAtResToContainerPoint(c, glRes, 0, TEMP_POINT0$1); }, TEMP_EXTENT$4);
              extent._combine(groundExtent);
          }
          if (extent) {
              var fixedExtent = this._getFixedExtent();
              if (validateExtent(fixedExtent)) {
                  extent._add(fixedExtent);
              }
          }
          var smoothness = this.options['smoothness'];
          if (smoothness) {
              extent._expand(extent.getWidth() * 0.15);
          }
          return extent;
      };
      //@internal
      Geometry.prototype._getFixedExtent = function () {
          // only for LineString and Polygon, Marker's will be overrided
          if (!this._fixedExtent) {
              this._fixedExtent = new PointExtent();
          }
          var symbol = this._sizeSymbol;
          var t = (symbol && symbol['lineWidth'] || 1) / 2;
          this._fixedExtent.set(-t, -t, t, t);
          var dx = (symbol && symbol['lineDx']) || 0;
          this._fixedExtent._add([dx, 0]);
          var dy = (symbol && symbol['lineDy']) || 0;
          this._fixedExtent._add([0, dy]);
          return this._fixedExtent;
      };
      Geometry.prototype.get2DExtent = function () {
          var map = this.getMap();
          if (!map) {
              return null;
          }
          if (this._extent2d) {
              return this._extent2d;
          }
          var extent = this._getPrjExtent();
          if (!extent || !extent.isValid()) {
              return null;
          }
          var min = extent.getMin();
          var max = extent.getMax();
          var glRes = map.getGLRes();
          map._prjToPointAtRes(min, glRes, min);
          map._prjToPointAtRes(max, glRes, max);
          this._extent2d = new PointExtent(min, max);
          this._extent2d.z = map.getZoom();
          return this._extent2d;
      };
      /**
       * 获取几何体的像素大小，不同缩放级别的像素大小可能会有所不同。
       * @english
       * Get pixel size of the geometry, which may vary in different zoom levels.
       *
       * @returns {Size}
       */
      Geometry.prototype.getSize = function () {
          var extent = this.getContainerExtent();
          return extent ? extent.getSize() : null;
      };
      /**
       * 几何体是否包含输入容器点
       * @english
       * Whehter the geometry contains the input container point.
       *
       * @param  {Point|Coordinate} point - input container point or coordinate
       * @param  {Number} [t=undefined] - tolerance in pixel
       * @return {Boolean}
       * @example
       * var circle = new Circle([0, 0], 1000)
       *     .addTo(layer);
       * var contains = circle.containsPoint(new maptalks.Point(400, 300));
       */
      Geometry.prototype.containsPoint = function (containerPoint, t) {
          if (!this.getMap()) {
              throw new Error('The geometry is required to be added on a map to perform "containsPoint".');
          }
          if (containerPoint instanceof Coordinate) {
              containerPoint = this.getMap().coordToContainerPoint(containerPoint);
          }
          return this._containsPoint(containerPoint, t);
          // return this._containsPoint(this.getMap()._containerPointToPoint(new Point(containerPoint)), t);
      };
      //@internal
      Geometry.prototype._containsPoint = function (containerPoint, t) {
          var painter = this._getPainter();
          if (!painter) {
              return false;
          }
          t = t || 0;
          if (this._hitTestTolerance) {
              t += this._hitTestTolerance();
          }
          return painter.hitTest(containerPoint, t);
      };
      /**
       * 显示几何图形
       * @english
       * Show the geometry.
       *
       * @return {Geometry} this
       * @fires Geometry#show
       */
      Geometry.prototype.show = function () {
          this.options['visible'] = true;
          if (this.getMap()) {
              var painter = this._getPainter();
              if (painter) {
                  painter.show();
              }
              /**
               * show event
               *
               * @event Geometry#show
               * @type {Object}
               * @property {String} type - show
               * @property {Geometry} target - the geometry fires the event
               */
              this._fireEvent('show');
          }
          return this;
      };
      /**
       * 隐藏几何图形
       * @english
       * Hide the geometry
       *
       * @return {Geometry} this
       * @fires Geometry#hide
       */
      Geometry.prototype.hide = function () {
          this.options['visible'] = false;
          if (this.getMap()) {
              this.onHide();
              var painter = this._getPainter();
              if (painter) {
                  painter.hide();
              }
              /**
               * hide event
               *
               * @event Geometry#hide
               * @type {Object}
               * @property {String} type - hide
               * @property {Geometry} target - the geometry fires the event
               */
              this._fireEvent('hide');
          }
          return this;
      };
      /**
       * 几何图形是否可见
       * @english
       * Whether the geometry is visible
       *
       * @returns {Boolean}
       */
      Geometry.prototype.isVisible = function () {
          if (!this.options['visible']) {
              return false;
          }
          var symbol = this._getInternalSymbol();
          if (!symbol) {
              return true;
          }
          if (!this.symbolIsVisible()) {
              return false;
          }
          if (Array.isArray(symbol)) {
              if (!symbol.length) {
                  return true;
              }
              for (var i = 0, l = symbol.length; i < l; i++) {
                  if (isNil(symbol[i]['opacity']) || symbol[i]['opacity'] > 0) {
                      return true;
                  }
              }
              return false;
          }
          else {
              return (isNil(symbol['opacity']) || isObject$1(symbol['opacity']) || (isNumber(symbol['opacity']) && symbol['opacity'] > 0));
          }
      };
      /**
       * symbol是否可见
       * @english
       * Whether the geometry symbol is visible
       *
       * @returns {Boolean}
       */
      Geometry.prototype.symbolIsVisible = function () {
          //function-type
          var symbols = this._getCompiledSymbol();
          if (!symbols) {
              return true;
          }
          if (!Array.isArray(symbols)) {
              symbols = [symbols];
          }
          for (var i = 0, len = symbols.length; i < len; i++) {
              var symbol = symbols[i];
              if (!symbol) {
                  continue;
              }
              var isVisible = symbol.visible;
              if (isVisible !== false && isVisible !== 0) {
                  return true;
              }
          }
          return false;
      };
      /**
       * 获取几何图形所在层级，默认是0
       * @english
       * Get zIndex of the geometry, default is 0
       * @return {Number} zIndex
       */
      Geometry.prototype.getZIndex = function () {
          return this.options['zIndex'] || 0;
      };
      /**
       * 给几何图形设置新的层级并触发zindexchange事件（将导致层对几何体进行排序并进行渲染）
       * @english
       * Set a new zIndex to Geometry and fire zindexchange event (will cause layer to sort geometries and render)
       * @param {Number} zIndex - new zIndex
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      Geometry.prototype.setZIndex = function (zIndex) {
          var old = this.options['zIndex'];
          this.options['zIndex'] = zIndex;
          /**
           * 层级改变事件，当几何图形层级发生改变将会触发
           * @english
           * zindexchange event, fired when geometry's zIndex is changed.
           *
           * @event Geometry#zindexchange
           * @type {Object}
           * @property {String} type - zindexchange
           * @property {Geometry} target - the geometry fires the event
           * @property {Number} old        - old zIndex
           * @property {Number} new        - new zIndex
           */
          this._fireEvent('zindexchange', {
              'old': old,
              'new': zIndex
          });
          return this;
      };
      /**
       * 仅将新的zIndex设置为Geometry，而不触发zindexchange事件
       * 当需要更新许多几何图形的zIndex时，可以用来提高性能
       * 当更新了N个几何体时，可以将setZIndexSilently与（N-1）个几何体一起使用，并将setZIendex与要排序和渲染的层的最后一个几何体一同使用。
       * @english
       * Only set a new zIndex to Geometry without firing zindexchange event. <br>
       * Can be useful to improve perf when a lot of geometries' zIndex need to be updated. <br>
       * When updated N geometries, You can use setZIndexSilently with (N-1) geometries and use setZIndex with the last geometry for layer to sort and render.
       * @param {Number} zIndex - new zIndex
       * @return {Geometry} this
       */
      Geometry.prototype.setZIndexSilently = function (zIndex) {
          this.options['zIndex'] = zIndex;
          return this;
      };
      /**
       * 将几何图形至于顶层
       * @english
       * Bring the geometry on the top
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      Geometry.prototype.bringToFront = function () {
          var layer = this.getLayer();
          if (!layer || !layer.getGeoMaxZIndex) {
              return this;
          }
          var topZ = layer.getGeoMaxZIndex();
          this.setZIndex(topZ + 1);
          return this;
      };
      /**
       * 将几何图形置于底层
       * @english
       * Bring the geometry to the back
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      Geometry.prototype.bringToBack = function () {
          var layer = this.getLayer();
          if (!layer || !layer.getGeoMinZIndex) {
              return this;
          }
          var bottomZ = layer.getGeoMinZIndex();
          this.setZIndex(bottomZ - 1);
          return this;
      };
      /**
       * 按给定偏移平移或移动几何体
       * @english
       * Translate or move the geometry by the given offset.
       *
       * @param  {Coordinate} offset - translate offset
       * @return {Geometry} this
       * @fires Geometry#positionchange
       * @fires Geometry#shapechange
       */
      /**
       * Translate or move the geometry by the given offset.
       *
       * @param  {Number} x - x offset
       * @param  {Number} y - y offset
       * @return {Geometry} this
       * @fires Geometry#positionchange
       * @fires Geometry#shapechange
       */
      Geometry.prototype.translate = function (x, y) {
          if (isNil(x)) {
              return this;
          }
          var offset = new Coordinate(x, y);
          if (offset.x === 0 && offset.y === 0) {
              return this;
          }
          var coordinates = this.getCoordinates();
          this._silence = true;
          if (coordinates) {
              if (Array.isArray(coordinates)) {
                  var translated = forEachCoord(coordinates, function (coord) {
                      return coord.add(offset);
                  });
                  this.setCoordinates(translated);
              }
              else {
                  this.setCoordinates(coordinates.add(offset));
              }
          }
          this._silence = false;
          this._fireEvent('positionchange');
          return this;
      };
      //translate rotate Pivot when coordinates change
      //@interlal
      Geometry.prototype._translateRotatePivot = function (newCoordinate) {
          if (!this._pivot || !newCoordinate) {
              return this;
          }
          if (this.options.rotatePivot) {
              var oldCoordinate = this.getCoordinates();
              if (!oldCoordinate) {
                  return this;
              }
              if (!(newCoordinate instanceof Coordinate)) {
                  newCoordinate = new Coordinate(newCoordinate);
              }
              var offset = newCoordinate.sub(oldCoordinate);
              if (offset.x === 0 && offset.y === 0) {
                  return this;
              }
              this._pivot._add(offset);
              this.options.rotatePivot = this._pivot.toArray();
          }
          return this;
      };
      /**
       * 闪烁几何图形，按一定的内部显示和隐藏计数次数。
       * @english
       * Flash the geometry, show and hide by certain internal for times of count.
       *
       * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)
       * @param {Number} [count=4]          - flash times
       * @param {Function} [cb=null]        - callback function when flash ended
       * @param {*} [context=null]          - callback context
       * @return {Geometry} this
       */
      Geometry.prototype.flash = function (interval, count, cb, context) {
          return flash.call(this, interval, count, cb, context);
      };
      /**
       * 返回不包含事件侦听器的几何体的副本。
       * @english
       * Returns a copy of the geometry without the event listeners.
       * @returns {Geometry} copy
       */
      Geometry.prototype.copy = function () {
          var json = this.toJSON();
          var ret = Geometry.fromJSON(json);
          //restore visibility
          ret.options['visible'] = true;
          return ret;
      };
      /**
       * 将其自身从图层中移除（如果有的话）。
       * @english
       * remove itself from the layer if any.
       * @returns {Geometry} this
       * @fires Geometry#removestart
       * @fires Geometry#remove
       */
      Geometry.prototype.remove = function () {
          var layer = this.getLayer();
          if (!layer) {
              return this;
          }
          /**
           * removestart event.
           *
           * @event Geometry#removestart
           * @type {Object}
           * @property {String} type - removestart
           * @property {Geometry} target - the geometry fires the event
           */
          this._fireEvent('removestart');
          this._unbind();
          /**
           * removeend event.
           *
           * @event Geometry#removeend
           * @type {Object}
           * @property {String} type - removeend
           * @property {Geometry} target - the geometry fires the event
           */
          this._fireEvent('removeend');
          /**
           * remove event.
           *
           * @event Geometry#remove
           * @type {Object}
           * @property {String} type - remove
           * @property {Geometry} target - the geometry fires the event
           */
          this._fireEvent('remove');
          return this;
      };
      /**
       * 将几何对象导出成geojson对象
       * @english
       * Exports [geometry]{@link http://geojson.org/geojson-spec.html#feature-objects} out of a GeoJSON feature.
       * @return {Object} GeoJSON Geometry
       */
      Geometry.prototype.toGeoJSONGeometry = function () {
          var gJson = this._exportGeoJSONGeometry();
          return gJson;
      };
      /**
       * 导出geojson对象中的一个feature
       * @english
       * Exports a GeoJSON feature.
       * @param {Object} [opts=null]              - export options
       * @param {Boolean} [opts.geometry=true]    - whether export geometry
       * @param {Boolean} [opts.properties=true]  - whether export properties
       * @returns {Object} GeoJSON Feature
       */
      Geometry.prototype.toGeoJSON = function (opts) {
          if (!opts) {
              opts = {};
          }
          var feature = {
              'type': 'Feature',
              'geometry': null
          };
          if (isNil(opts['geometry']) || opts['geometry']) {
              var geoJSON = this._exportGeoJSONGeometry();
              feature['geometry'] = geoJSON;
          }
          var id = this.getId();
          if (!isNil(id)) {
              feature['id'] = id;
          }
          var properties;
          if (isNil(opts['properties']) || opts['properties']) {
              properties = this._exportProperties();
          }
          feature['properties'] = properties;
          return feature;
      };
      /**
       * 从几何体中导出一个配置文件json。
       * 除了导出特性对象，概要文件json还包含符号、构造选项和信息窗口信息。
       * 配置文件json可以存储在其他地方，稍后用于重现几何图形
       * 由于函数的序列化问题，概要文件json中不包括事件侦听器和上下文菜单
       * @english
       * Export a profile json out of the geometry. <br>
       * Besides exporting the feature object, a profile json also contains symbol, construct options and infowindow info.<br>
       * The profile json can be stored somewhere else and be used to reproduce the geometry later.<br>
       * Due to the problem of serialization for functions, event listeners and contextmenu are not included in profile json.
       * @example
       *     // an example of a profile json.
       * var profile = {
              "feature": {
                    "type": "Feature",
                    "id" : "point1",
                    "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                    "properties": {"prop0": "value0"}
              },
              //construct options.
              "options":{
                  "draggable" : true
              },
              //symbol
              "symbol":{
                  "markerFile"  : "http://foo.com/icon.png",
                  "markerWidth" : 20,
                  "markerHeight": 20
              },
              //infowindow info
              "infowindow" : {
                  "options" : {
                      "style" : "black"
                  },
                  "title" : "this is a infowindow title",
                  "content" : "this is a infowindow content"
              }
          };
       * @param {Object}  [options=null]          - export options
       * @param {Boolean} [opts.geometry=true]    - whether export feature's geometry
       * @param {Boolean} [opts.properties=true]  - whether export feature's properties
       * @param {Boolean} [opts.options=true]     - whether export construct options
       * @param {Boolean} [opts.symbol=true]      - whether export symbol
       * @param {Boolean} [opts.infoWindow=true]  - whether export infowindow
       * @return {Object} profile json object
       */
      Geometry.prototype.toJSON = function (options) {
          //一个Graphic的profile
          /*
              //因为响应函数无法被序列化, 所以menu, 事件listener等无法被包含在graphic中
          }*/
          if (!options) {
              options = {};
          }
          var json = this._toJSON(options);
          var other = this._exportGraphicOptions(options);
          extend$2(json, other);
          return json;
      };
      /**
       * 获取几何图形的地理长度
       * @english
       * Get the geographic length of the geometry.
       * @returns {Number} geographic length, unit is meter
       */
      Geometry.prototype.getLength = function () {
          return this._computeGeodesicLength(this._getMeasurer());
      };
      /**
       * 获取几何图形的面积
       * @english
       * Get the geographic area of the geometry.
       * @returns {Number} geographic area, unit is sq.meter
       */
      Geometry.prototype.getArea = function () {
          return this._computeGeodesicArea(this._getMeasurer());
      };
      /**
       * 按给定角度围绕轴心点旋转几何体
       * @english
       * Rotate the geometry of given angle around a pivot point
       * @param {Number} angle - angle to rotate in degree
       * @param {Coordinate} [pivot=null]  - optional, will be the geometry's center by default
       * @returns {Geometry} this
       */
      Geometry.prototype.rotate = function (angle, pivot) {
          if (!isNumber(angle)) {
              console.error("angle:".concat(angle, " is not number"));
              return this;
          }
          if (!this._painter) {
              this._dirtyRotate = true;
          }
          if (this.type === 'GeometryCollection') {
              var geometries = this.getGeometries();
              geometries.forEach(function (g) { return g.rotate(angle, pivot); });
              return this;
          }
          if (!pivot) {
              pivot = this.getCenter();
          }
          else {
              pivot = new Coordinate(pivot);
          }
          this._angle = angle;
          this._pivot = pivot;
          var measurer = this._getMeasurer();
          var coordinates = this.getCoordinates();
          if (!Array.isArray(coordinates)) {
              //exclude Rectangle ,Ellipse,Sector by shell judge
              if ((pivot.x !== coordinates.x || pivot.y !== coordinates.y) && !this.getShell) {
                  var c = measurer._rotate(coordinates, pivot, angle);
                  this.setCoordinates(c);
              }
              else {
                  //only redraw ,not to change coordinate
                  this.onPositionChanged();
              }
              if (this.getShell) {
                  this.options.rotateAngle = angle;
                  this.options.rotatePivot = pivot.toArray();
              }
              return this;
          }
          forEachCoord(coordinates, function (c) {
              return measurer._rotate(c, pivot, angle);
          });
          this.setCoordinates(coordinates);
          return this;
      };
      //@internal
      Geometry.prototype._rotatePrjCoordinates = function (coordinates) {
          if (!coordinates || this._angle === 0 || !this._pivot) {
              return coordinates;
          }
          var projection = this._getProjection();
          if (!projection) {
              return coordinates;
          }
          var offsetAngle = 0;
          var isArray = Array.isArray(coordinates);
          var coord = isArray ? coordinates : [coordinates];
          var rotatePrjCoordinates = [];
          var cx, cy;
          //sector is special
          if (this.getRotateOffsetAngle) {
              offsetAngle = this.getRotateOffsetAngle();
              var center = coord[coord.length - 1];
              cx = center.x;
              cy = center.y;
          }
          else {
              var bbox = getDefaultBBOX();
              //cal all points center
              pointsBBOX(coord, bbox);
              var _a = __read(bbox, 4), minx = _a[0], miny = _a[1], maxx = _a[2], maxy = _a[3];
              cx = (minx + maxx) / 2;
              cy = (miny + maxy) / 2;
          }
          //图形按照自身的几何中心旋转
          for (var i = 0, len = coord.length; i < len; i++) {
              var c = coord[i];
              var x = c.x, y = c.y;
              var dx = x - cx, dy = y - cy;
              var r = Math.sqrt(dx * dx + dy * dy);
              var sAngle = getSegmentAngle(cx, cy, x, y);
              var rad = (sAngle - this._angle + offsetAngle) / 180 * Math.PI;
              var rx_1 = Math.cos(rad) * r, ry_1 = Math.sin(rad) * r;
              var rc = new Coordinate(cx + rx_1, cy + ry_1);
              rotatePrjCoordinates.push(rc);
          }
          var prjCenter = projection.project(this._pivot);
          var rx = prjCenter.x, ry = prjCenter.y;
          //translate rotate center
          var translateX = cx - rx, translateY = cy - ry;
          //平移到指定的选中中心点
          for (var i = 0, len = rotatePrjCoordinates.length; i < len; i++) {
              var c = rotatePrjCoordinates[i];
              c.x -= translateX;
              c.y -= translateY;
          }
          if (isArray) {
              return rotatePrjCoordinates;
          }
          return rotatePrjCoordinates[0];
      };
      Geometry.prototype.isRotated = function () {
          return !!(isNumber(this._angle) && this._pivot);
      };
      /**
       * 获取连线的连接点
       * @english
       * Get the connect points for [ConnectorLine]{@link ConnectorLine}
       * @return {Coordinate[]} connect points
       * @private
       */
      //@internal
      Geometry.prototype._getConnectPoints = function () {
          return [this.getCenter()];
      };
      //options initializing
      //@internal
      Geometry.prototype._initOptions = function (options) {
          var opts = extend$2({}, options);
          var symbol = opts['symbol'];
          var properties = opts['properties'];
          var id = opts['id'];
          delete opts['symbol'];
          delete opts['id'];
          delete opts['properties'];
          this.setOptions(opts);
          if (symbol) {
              this.setSymbol(symbol);
          }
          if (properties) {
              this.setProperties(properties);
          }
          if (!isNil(id)) {
              this.setId(id);
          }
      };
      //bind the geometry to a layer
      //@internal
      Geometry.prototype._bindLayer = function (layer) {
          if (layer === this.getLayer()) {
              return;
          }
          //check dupliaction
          if (this.getLayer()) {
              throw new Error('Geometry cannot be added to two or more layers at the same time.');
          }
          this._layer = layer;
          this._clearCache();
          this._bindInfoWindow();
          this._bindMenu();
          // this._clearProjection();
          // this.callInitHooks();
      };
      //@internal
      Geometry.prototype._prepareSymbol = function (symbol) {
          if (Array.isArray(symbol)) {
              var cookedSymbols = [];
              for (var i = 0; i < symbol.length; i++) {
                  cookedSymbols.push(convertResourceUrl(this._checkAndCopySymbol(symbol[i])));
              }
              return cookedSymbols;
          }
          else if (symbol) {
              symbol = this._checkAndCopySymbol(symbol);
              return convertResourceUrl(symbol);
          }
          return null;
      };
      //@internal
      Geometry.prototype._checkAndCopySymbol = function (symbol) {
          var s = {};
          for (var i in symbol) {
              if (NUMERICAL_PROPERTIES[i] && isString(symbol[i])) {
                  s[i] = +symbol[i];
              }
              else {
                  s[i] = symbol[i];
              }
          }
          return s;
      };
      //@internal
      Geometry.prototype._getSymbol = function () {
          return this._symbol;
      };
      /**
       * 将外部符号设置为几何体，例如VectorLayer的setStyle中的样式
       * @english
       * Sets a external symbol to the geometry, e.g. style from VectorLayer's setStyle
       * @private
       * @param {Object} symbol - external symbol
       */
      //@internal
      Geometry.prototype._setExternSymbol = function (symbol) {
          this._eventSymbolProperties = symbol;
          if (!this._symbol) {
              delete this._textDesc;
          }
          this._externSymbol = this._prepareSymbol(symbol);
          this.onSymbolChanged();
          return this;
      };
      //@internal
      Geometry.prototype._getInternalSymbol = function () {
          if (this._symbol) {
              return this._symbol;
          }
          else if (this._externSymbol) {
              return this._externSymbol;
          }
          else if (this.options['symbol']) {
              return this.options['symbol'];
          }
          return null;
      };
      //@internal
      Geometry.prototype._getPrjExtent = function () {
          var p = this._getProjection();
          this._verifyProjection();
          if (!this._extent && p) {
              this._extent = this._computePrjExtent(p);
          }
          return this._extent;
      };
      //@internal
      Geometry.prototype._unbind = function () {
          var layer = this.getLayer();
          if (!layer) {
              return;
          }
          if (this._animPlayer) {
              this._animPlayer.finish();
          }
          // this._clearHandlers();
          //contextmenu
          this._unbindMenu();
          //infowindow
          this._unbindInfoWindow();
          if (this.isEditing()) {
              this.endEdit();
          }
          this._removePainter();
          if (this.onRemove) {
              this.onRemove();
          }
          if (layer.onRemoveGeometry) {
              layer.onRemoveGeometry(this);
          }
          delete this._layer;
          delete this._internalId;
          delete this._extent;
      };
      //@internal
      Geometry.prototype._getInternalId = function () {
          return this._internalId;
      };
      //只能被图层调用
      //@internal
      Geometry.prototype._setInternalId = function (id) {
          this._internalId = id;
      };
      //@internal
      Geometry.prototype._getMeasurer = function () {
          if (this._getProjection()) {
              return this._getProjection();
          }
          return SpatialReference.getProjectionInstance(this.options['defaultProjection']);
      };
      //@internal
      Geometry.prototype._getProjection = function () {
          var map = this.getMap();
          if (map) {
              return map.getProjection();
          }
          return null;
      };
      //@internal
      Geometry.prototype._verifyProjection = function () {
          var projection = this._getProjection();
          if (this._projCode && projection && this._projCode !== projection.code) {
              this._clearProjection();
          }
          this._projCode = projection ? projection.code : this._projCode;
      };
      //获取geometry样式中依赖的外部图片资源
      //@internal
      Geometry.prototype._getExternalResources = function () {
          var symbol = this._getInternalSymbol();
          return getExternalResources(symbol);
      };
      //@internal
      Geometry.prototype._getPainter = function () {
          //for performance
          if (this._painter) {
              return this._painter;
          }
          var layer = this.getLayer();
          if (!this._painter && layer) {
              if (GEOMETRY_COLLECTION_TYPES.indexOf(this.type) !== -1) {
                  //@ts-expect-error todo 待vectorlayer ts完善
                  if (layer.constructor.getCollectionPainterClass) {
                      //@ts-expect-error todo 待vectorlayer ts完善
                      var clazz = layer.constructor.getCollectionPainterClass();
                      if (clazz) {
                          this._painter = new clazz(this);
                      }
                  }
                  //@ts-expect-error todo 待vectorlayer ts完善
              }
              else if (layer.constructor.getPainterClass) {
                  //@ts-expect-error todo 待vectorlayer ts完善
                  var clazz = layer.constructor.getPainterClass();
                  if (clazz) {
                      this._painter = new clazz(this);
                  }
              }
          }
          return this._painter;
      };
      //@internal
      Geometry.prototype._getMaskPainter = function () {
          if (this._maskPainter) {
              return this._maskPainter;
          }
          this._maskPainter = this.getGeometries && this.getGeometries() ? new CollectionPainter(this, true) : new Painter(this);
          return this._maskPainter;
      };
      //@internal
      Geometry.prototype._removePainter = function () {
          if (this._painter) {
              this._painter.remove();
          }
          delete this._painter;
      };
      //@internal
      Geometry.prototype._paint = function (extent) {
          if (!this.symbolIsVisible()) {
              return;
          }
          if (this._painter) {
              if (this._dirtyCoords) {
                  delete this._dirtyCoords;
                  var projection = this._getProjection();
                  if (projection) {
                      this._pcenter = projection.project(this._coordinates);
                      this._clearCache();
                  }
              }
              if (this._dirtyRotate && isNumber(this.options.rotateAngle)) {
                  this.rotate(this.options.rotateAngle, this.options.rotatePivot);
              }
              this._dirtyRotate = false;
              this._painter.paint(extent);
          }
      };
      //@internal
      Geometry.prototype._clearCache = function () {
          delete this._extent;
          delete this._extent2d;
          this._clearAltitudeCache();
      };
      //@internal
      Geometry.prototype._clearProjection = function () {
          delete this._extent;
          delete this._extent2d;
      };
      //@internal
      Geometry.prototype._repaint = function () {
          if (this._painter) {
              this._painter.repaint();
          }
      };
      Geometry.prototype.onHide = function () {
          this.closeMenu();
          this.closeInfoWindow();
      };
      Geometry.prototype.onShapeChanged = function () {
          this._clearCache();
          this._repaint();
          /**
           * shapechange event.
           *
           * @event Geometry#shapechange
           * @type {Object}
           * @property {String} type - shapechange
           * @property {Geometry} target - the geometry fires the event
           */
          this._fireEvent('shapechange');
      };
      Geometry.prototype.onPositionChanged = function () {
          this._clearCache();
          this._repaint();
          /**
           * positionchange event.
           *
           * @event Geometry#positionchange
           * @type {Object}
           * @property {String} type - positionchange
           * @property {Geometry} target - the geometry fires the event
           */
          this._fireEvent('positionchange');
      };
      Geometry.prototype.onSymbolChanged = function () {
          if (this._painter) {
              this._painter.refreshSymbol();
          }
          var e = {};
          if (this._eventSymbolProperties) {
              e.properties = JSON.parse(JSON.stringify(this._eventSymbolProperties));
              delete this._eventSymbolProperties;
          }
          else {
              delete this._textDesc;
          }
          this._genSizeSymbol();
          /**
           * symbolchange event.
           *
           * @event Geometry#symbolchange
           * @type {Object}
           * @property {String} type - symbolchange
           * @property {Geometry} target - the geometry fires the event
           * @property {Object} properties - symbol properties to update if has
           */
          this._fireEvent('symbolchange', e);
      };
      //@internal
      Geometry.prototype._genSizeSymbol = function () {
          var symbol = this._getInternalSymbol();
          if (!symbol) {
              delete this._sizeSymbol;
              return;
          }
          if (Array.isArray(symbol)) {
              this._sizeSymbol = [];
              var dynamicSize = false;
              for (var i = 0; i < symbol.length; i++) {
                  var s = this._sizeSymbol[i] = this._getSizeSymbol(symbol[i]);
                  if (!dynamicSize && s && s._dynamic) {
                      dynamicSize = true;
                  }
              }
              this._sizeSymbol._dynamic = dynamicSize;
          }
          else {
              this._sizeSymbol = this._getSizeSymbol(symbol);
          }
      };
      //@internal
      Geometry.prototype._getSizeSymbol = function (symbol) {
          var symbolSize = loadGeoSymbol({
              lineWidth: symbol['lineWidth'],
              lineDx: symbol['lineDx'],
              lineDy: symbol['lineDy']
          }, this);
          if (isFunctionDefinition(symbol['lineWidth']) || isFunctionDefinition(symbol['lineDx']) || isFunctionDefinition(symbol['lineDy'])) {
              symbolSize._dynamic = true;
          }
          return symbolSize;
      };
      //@internal
      Geometry.prototype._getCompiledSymbol = function () {
          if (this._compiledSymbol) {
              return this._compiledSymbol;
          }
          this._compiledSymbol = loadGeoSymbol(this._getInternalSymbol(), this);
          return this._compiledSymbol;
      };
      Geometry.prototype.onConfig = function (conf) {
          var properties;
          if (conf['properties']) {
              properties = conf['properties'];
              delete conf['properties'];
          }
          var needRepaint = false;
          for (var p in conf) {
              if (conf.hasOwnProperty(p)) {
                  var prefix = p.slice(0, 5);
                  if (prefix === 'arrow' || prefix === 'smoot') {
                      needRepaint = true;
                      break;
                  }
              }
          }
          if (properties) {
              this.setProperties(properties);
              this._repaint();
          }
          else if (needRepaint) {
              this._repaint();
          }
      };
      /**
       * 将父对象设置为几何体，通常是“多重多边形”、“几何集合”等
       * @english
       * Set a parent to the geometry, which is usually a MultiPolygon, GeometryCollection, etc
       * @param {GeometryCollection} geometry - parent geometry
       * @private
       */
      //@internal
      Geometry.prototype._setParent = function (geometry) {
          if (geometry) {
              this._parent = geometry;
          }
      };
      //@internal
      Geometry.prototype._getParent = function () {
          return this._parent;
      };
      //@internal
      Geometry.prototype._fireEvent = function (eventName, param) {
          if (this._silence) {
              return;
          }
          if (this.getLayer() && this.getLayer()._onGeometryEvent) {
              if (!param) {
                  param = {};
              }
              param['type'] = eventName;
              param['target'] = this;
              this.getLayer()._onGeometryEvent(param);
          }
          this.fire(eventName, param);
      };
      //@internal
      Geometry.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options)
          };
      };
      //@internal
      Geometry.prototype._recordVisible = function () {
          var visible = this.options.visible;
          if (isNil(visible)) {
              visible = true;
          }
          this._savedVisible = visible;
      };
      //@internal
      Geometry.prototype._recoveryVisible = function () {
          delete this._savedVisible;
      };
      //@internal
      Geometry.prototype._exportGraphicOptions = function (options) {
          var json = {};
          if (isNil(options['options']) || options['options']) {
              json['options'] = this.config();
          }
          if (json['options'] && this.isEditing && this.isEditing()) {
              json['options'].visible = this._savedVisible;
          }
          if (isNil(options['symbol']) || options['symbol']) {
              json['symbol'] = this.getSymbol();
          }
          if (isNil(options['infoWindow']) || options['infoWindow']) {
              if (this._infoWinOptions) {
                  json['infoWindow'] = this._infoWinOptions;
              }
          }
          return json;
      };
      //@internal
      Geometry.prototype._exportGeoJSONGeometry = function () {
          var points = this.getCoordinates();
          var coordinates = Coordinate.toNumberArrays(points);
          return {
              'type': this.getType(),
              'coordinates': coordinates
          };
      };
      //@internal
      Geometry.prototype._exportProperties = function () {
          var properties = null;
          var geoProperties = this.getProperties();
          if (!isNil(geoProperties)) {
              if (isObject$1(geoProperties)) {
                  properties = extend$2({}, geoProperties);
              }
              else {
                  properties = geoProperties;
              }
          }
          return properties;
      };
      //@internal
      Geometry.prototype._hitTestTolerance = function () {
          return 0;
      };
      //------------- altitude + layer.altitude -------------
      //this is for vectorlayer
      //内部方法 for render,返回的值受layer和layer.options.enableAltitude,layer.options.altitude影响
      //@internal
      Geometry.prototype._getAltitude = function () {
          var layer = this.getLayer();
          if (!layer) {
              return 0;
          }
          var layerOpts = layer.options;
          var layerAltitude = layer.getAltitude ? layer.getAltitude() : 0;
          var enableAltitude = layerOpts['enableAltitude'];
          if (!enableAltitude && layer.isVectorLayer) {
              return layerAltitude;
          }
          var altitudeProperty = getAltitudeProperty(layer);
          var properties = this.properties || TEMP_PROPERTIES;
          var altitude = properties[altitudeProperty];
          //if properties.altitude is null
          //for new Geometry([x,y,z])
          if (isNil(altitude)) {
              var alts = getGeometryCoordinatesAlts(this, layerAltitude, enableAltitude);
              if (!isNil(alts)) {
                  return alts;
              }
              return layerAltitude;
          }
          //old,the altitude is bind properties
          if (Array.isArray(altitude)) {
              return altitude.map(function (alt) {
                  return alt + layerAltitude;
              });
          }
          return altitude + layerAltitude;
      };
      //this for user
      Geometry.prototype.getAltitude = function () {
          var layer = this.getLayer();
          var altitudeProperty = getAltitudeProperty(layer);
          var properties = this.properties || TEMP_PROPERTIES;
          var altitude = properties[altitudeProperty];
          if (!isNil(altitude)) {
              return altitude;
          }
          var alts = getGeometryCoordinatesAlts(this, 0, false);
          if (!isNil(alts)) {
              return alts;
          }
          return 0;
      };
      Geometry.prototype.hasAltitude = function () {
          this._genMinMaxAlt();
          return !!this._minAlt || !!this._maxAlt;
      };
      Geometry.prototype.setAltitude = function (alt) {
          if (!isNumber(alt)) {
              return this;
          }
          var layer = this.getLayer();
          var altitudeProperty = getAltitudeProperty(layer);
          var properties = this.properties || TEMP_PROPERTIES;
          var altitude = properties[altitudeProperty];
          //update properties altitude
          if (!isNil(altitude)) {
              if (Array.isArray(altitude)) {
                  for (var i = 0, len = altitude.length; i < len; i++) {
                      altitude[i] = alt;
                  }
              }
              else {
                  properties[altitudeProperty] = alt;
              }
          }
          var coordinates = this.getCoordinates ? this.getCoordinates() : null;
          if (!coordinates) {
              return this;
          }
          //update coordinates.z
          setCoordinatesAlt(coordinates, alt);
          if (layer) {
              var render = layer.getRenderer();
              //for webgllayer,pointlayer/linestringlayer/polygonlayer
              if (render && render.gl) {
                  this.setCoordinates(coordinates);
              }
              else if (render) {
                  this._repaint();
              }
          }
          this._clearAltitudeCache();
          this.onPositionChanged();
          return this;
      };
      //@internal
      Geometry.prototype._genMinMaxAlt = function () {
          if (this._minAlt === undefined || this._maxAlt === undefined) {
              var altitude = this._getAltitude();
              var _a = __read(getMinMaxAltitude(altitude), 2), min = _a[0], max = _a[1];
              this._minAlt = min;
              this._maxAlt = max;
          }
      };
      Geometry.prototype.getMinAltitude = function () {
          this._genMinMaxAlt();
          return this._minAlt;
      };
      Geometry.prototype.getMaxAltitude = function () {
          this._genMinMaxAlt();
          return this._maxAlt;
      };
      //clear alt cache
      //@internal
      Geometry.prototype._clearAltitudeCache = function () {
          this._minAlt = undefined;
          this._maxAlt = undefined;
          return this;
      };
      return Geometry;
  }(JSONAble(Eventable(Handlerable(Class)))));
  Geometry.mergeOptions(options$C);
  function getAltitudeProperty(layer) {
      var altitudeProperty = 'altitude';
      if (layer) {
          //only VectorLayer support properties.altitude
          if (!layer.isVectorLayer) {
              return null;
          }
          var layerOpts = layer.options;
          altitudeProperty = layerOpts['altitudeProperty'];
      }
      return altitudeProperty;
  }
  function getGeometryCoordinatesAlts(geometry, layerAlt, enableAltitude) {
      var coordinates = geometry.getCoordinates ? geometry.getCoordinates() : null;
      if (coordinates) {
          var tempAlts = [];
          coordinatesHasAlt(coordinates, tempAlts);
          if (tempAlts.length) {
              var alts = getCoordinatesAlts(coordinates, layerAlt, enableAltitude);
              // if (geometry.getShell && Array.isArray(alts[0])) {
              //     return alts;
              // }
              return alts;
          }
      }
      return null;
  }
  function setCoordinatesAlt(coordinates, alt) {
      if (Array.isArray(coordinates)) {
          for (var i = 0, len = coordinates.length; i < len; i++) {
              setCoordinatesAlt(coordinates[i], alt);
          }
      }
      else {
          coordinates.z = alt;
      }
  }
  function coordinatesHasAlt(coordinates, tempAlts) {
      if (tempAlts.length) {
          return;
      }
      if (Array.isArray(coordinates)) {
          for (var i = 0, len = coordinates.length; i < len; i++) {
              coordinatesHasAlt(coordinates[i], tempAlts);
          }
      }
      else if (isNumber(coordinates.z)) {
          tempAlts.push(coordinates.z);
      }
  }
  function getCoordinatesAlts(coordinates, layerAlt, enableAltitude) {
      if (Array.isArray(coordinates)) {
          var alts = [];
          for (var i = 0, len = coordinates.length; i < len; i++) {
              alts.push(getCoordinatesAlts(coordinates[i], layerAlt, enableAltitude));
          }
          return alts;
      }
      if (isNumber(coordinates.z)) {
          return enableAltitude ? layerAlt + coordinates.z : coordinates.z;
      }
      else if (enableAltitude) {
          return layerAlt;
      }
      else {
          return 0;
      }
  }
  function getSegmentAngle(cx, cy, x, y) {
      if (cx === x) {
          if (y > cy) {
              return -90;
          }
          return 90;
      }
      x -= cx;
      y -= cy;
      //经纬坐标系和屏幕坐标正好相反,经纬度向上递增,而屏幕坐标递减
      y = -y;
      var rad = Math.atan2(y, x);
      return rad / Math.PI * 180;
  }

  /**
   * 配置项
   *
   * @english
   * @property options=null                           - base options of layer.
   * @property options.attribution=null               - the attribution of this layer, you can specify company or other information of this layer.
   * @property options.minZoom=null                   - the minimum zoom to display the layer, set to -1 to unlimit it.
   * @property options.maxZoom=null                   - the maximum zoom to display the layer, set to -1 to unlimit it.
   * @property options.visible=true                   - whether to display the layer.
   * @property options.opacity=1                      - opacity of the layer, from 0 to 1.
   * @property options.zIndex=undefined               - z index of the layer
   * @property options.hitDetect=true                 - Whether to enable hit detection for layers for cursor styles on this map, disable it to improve performance.
   * @property options.renderer=canvas                - renderer type, "canvas" in default.
   * @property options.globalCompositeOperation=null  - (Only for layer rendered with [CanvasRenderer]{@link renderer.CanvasRenderer}) globalCompositeOperation of layer's canvas 2d context.context.globalCompositeOperation, 'source-over' in default
   * @property options.debugOutline='#0f0'            - debug outline's color.
   * @property options.cssFilter=null                 - css filter apply to canvas context's filter
   * @property options.forceRenderOnMoving=false      - force to render layer when map is moving
   * @property options.forceRenderOnZooming=false     - force to render layer when map is zooming
   * @property options.forceRenderOnRotating=false    - force to render layer when map is Rotating
   * @property options.collisionScope=layer           - layer's collision scope: layer or map
   * @property options.maskClip=true           - clip layer by mask(Polygon/MultiPolygon)
   * @memberOf Layer
   * @instance
   */
  var options$B = {
      'attribution': null,
      'minZoom': null,
      'maxZoom': null,
      'visible': true,
      'opacity': 1,
      // context.globalCompositeOperation, 'source-over' in default
      'globalCompositeOperation': null,
      'renderer': 'canvas',
      'debugOutline': '#0f0',
      'cssFilter': null,
      'forceRenderOnMoving': false,
      'forceRenderOnZooming': false,
      'forceRenderOnRotating': false,
      'collision': false,
      'collisionScope': 'layer',
      'hitDetect': (function () {
          return !Browser$1.mobile;
      })(),
      'maskClip': true
  };
  /**
   * layers的基础类，定义了所有layers公共方法。
   * 抽象类，不做实例化打算
   *
   * @english
   * @classdesc
   * Base class for all the layers, defines common methods that all the layer classes share. <br>
   * It is abstract and not intended to be instantiated.
   *
   * @category layer
   * @abstract
   * @extends Class
   * @mixes Eventable
   * @mixes JSONAble
   * @mixes Renderable
   */
  var Layer = /** @class */ (function (_super) {
      __extends(Layer, _super);
      function Layer(id, options) {
          var _this = this;
          var canvas;
          if (options) {
              canvas = options.canvas;
              delete options.canvas;
          }
          _this = _super.call(this, options) || this;
          _this._canvas = canvas;
          _this.setId(id);
          if (options) {
              _this.setZIndex(options.zIndex);
              if (options.mask) {
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore 未找到fromJSON属性
                  _this.setMask(Geometry.fromJSON(options.mask));
              }
          }
          _this.proxyOptions();
          return _this;
      }
      /**
       * 加载tile layer,不能被子类重写
       *
       * @english
       * load the tile layer, can't be overrided by sub-classes
       */
      Layer.prototype.load = function () {
          if (!this.getMap()) {
              return this;
          }
          if (this.onLoad()) {
              this._initRenderer();
              var zIndex = this.getZIndex();
              if (!isNil(zIndex)) {
                  this._renderer.setZIndex(zIndex);
                  if (!this.isCanvasRender()) {
                      this._renderer.render();
                  }
              }
              this.onLoadEnd();
          }
          return this;
      };
      /**
       * 获取layer Id
       *
       * @english
       * Get the layer id
       * @returns id
       */
      Layer.prototype.getId = function () {
          return this._id;
      };
      /**
       * 为layer新设一个 Id
       *
       * @english
       * Set a new id to the layer
       * @param id - new layer id
       * @return this
       * @fires Layer#idchange
       */
      Layer.prototype.setId = function (id) {
          var old = this._id;
          if (!isNil(id)) {
              id = id + '';
          }
          this._id = id;
          /**
           * idchange 事件
           *
           * @english
           * idchange event.
           *
           * @event Layer#idchange
           * @type {Object}
           * @property {String} type      - idchange
           * @property {Layer} target     - the layer fires the event
           * @property {String} old       - value of the old id
           * @property {String} new       - value of the new id
           */
          this.fire('idchange', {
              'type': 'idchange',
              'target': this,
              'old': old,
              'new': id
          });
          return this;
      };
      /**
       * 将图层添加至 map
       *
       * @english
       * Adds itself to a map.
       * @param map - map added to
       * @return this
       */
      Layer.prototype.addTo = function (map) {
          map.addLayer(this);
          return this;
      };
      /**
       * 为layer 设置zIndex
       *
       * @engilsh
       * Set a z-index to the layer
       * @param zIndex - layer's z-index
       * @return this
       */
      Layer.prototype.setZIndex = function (zIndex) {
          this._zIndex = zIndex;
          if (isNil(zIndex)) {
              delete this.options['zIndex'];
          }
          else {
              this.options.zIndex = zIndex;
          }
          if (this.map) {
              this.map._sortLayersByZIndex();
          }
          if (this._renderer) {
              this._renderer.setZIndex(zIndex);
          }
          /**
           * setzindex 事件
           *
           * @english
           * setzindex event.
           *
           * @event Layer#setzindex
           * @type {Object}
           * @property {String} type      - setzindex
           * @property {Layer} target     - the layer fires the event
           * @property {Number} zIndex    - value of the zIndex
           */
          this.fire('setzindex', {
              'type': 'setzindex',
              'target': this,
              zIndex: zIndex
          });
          return this;
      };
      /**
       * 获取layer 的 zIndex
       *
       * @english
       * Get the layer's z-index
       * @return
       */
      Layer.prototype.getZIndex = function () {
          return this._zIndex || 0;
      };
      /**
       * 获取 layer 的 minZoom
       *
       * @english
       * Get Layer's minZoom to display
       * @return
       */
      Layer.prototype.getMinZoom = function () {
          var map = this.getMap();
          var minZoom = this.options['minZoom'];
          return map ? Math.max(map.getMinZoom(), minZoom || 0) : minZoom;
      };
      /**
       * 获取layer 的 maxZoom
       *
       * @english
       * Get Layer's maxZoom to display
       * @return
       */
      Layer.prototype.getMaxZoom = function () {
          var map = this.getMap();
          var maxZoom = this.options['maxZoom'];
          return map ? Math.min(map.getMaxZoom(), isNil(maxZoom) ? Infinity : maxZoom) : maxZoom;
      };
      /**
       * 获取 layer 的 opacity
       *
       * @english
       * Get layer's opacity
       * @returns {Number}
       */
      Layer.prototype.getOpacity = function () {
          return this.options['opacity'];
      };
      /**
       * 设置 layer 的 opacity
       *
       * @english
       * Set opacity to the layer
       * @param opacity - layer's opacity
       * @return this
       */
      Layer.prototype.setOpacity = function (op) {
          this.config('opacity', op);
          /**
          * setopacity 事件
          *
          * @english
          * setopacity event.
          *
          * @event Layer#setopacity
          * @type {Object}
          * @property {String} type - setopacity
          * @property {Layer} target    - the layer fires the event
          * @property {Number} opacity        - value of the opacity
          */
          this.fire('setopacity', { type: 'setopacity', target: this, opacity: op });
          return this;
      };
      /**
       * layer 是否为 HTML5 Canvas 渲染
       *
       * @english
       * If the layer is rendered by HTML5 Canvas.
       * @return
       * @protected
       */
      Layer.prototype.isCanvasRender = function () {
          var renderer = this._getRenderer();
          return (renderer && (renderer instanceof CanvasRenderer$1));
      };
      /**
       * 获取图层所在 map
       *
       * @english
       * Get the map that the layer added to
       * @returns {Map}
       */
      Layer.prototype.getMap = function () {
          if (this.map) {
              return this.map;
          }
          return null;
      };
      /**
       * 获取 layer 所在map 的 projection
       *
       * @english
       * Get projection of layer's map
       * @returns
       */
      Layer.prototype.getProjection = function () {
          var map = this.getMap();
          return map ? map.getProjection() : null;
      };
      /**
       * 将图层置顶
       *
       * @english
       * Brings the layer to the top of all the layers
       * @returns this
       */
      Layer.prototype.bringToFront = function () {
          var layers = this._getLayerList();
          if (!layers.length) {
              return this;
          }
          var topLayer = layers[layers.length - 1];
          if (layers.length === 1 || topLayer === this) {
              return this;
          }
          var max = topLayer.getZIndex();
          this.setZIndex(max + 1);
          return this;
      };
      /**
       * 将图层置底
       *
       * @english
       * Brings the layer under the bottom of all the layers
       * @returns {Layer} this
       */
      Layer.prototype.bringToBack = function () {
          var layers = this._getLayerList();
          if (!layers.length) {
              return this;
          }
          var bottomLayer = layers[0];
          if (layers.length === 1 || bottomLayer === this) {
              return this;
          }
          var min = bottomLayer.getZIndex();
          this.setZIndex(min - 1);
          return this;
      };
      /**
       * 显示图层
       *
       * @english
       * Show the layer
       * @returns this
       */
      Layer.prototype.show = function () {
          var _this = this;
          if (!this.options['visible']) {
              this.options['visible'] = true;
              var renderer = this.getRenderer();
              if (renderer) {
                  renderer.show();
              }
              var map = this.getMap();
              if (renderer && map) {
                  //fire show at renderend to make sure layer is shown
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore Map 缺少once方法
                  map.once('renderend', function () {
                      _this.fire('show');
                  });
              }
              else {
                  /**
                  * show event.
                  *
                  * @event Layer#show
                  * @type {Object}
                  * @property {String} type - show
                  * @property {Layer} target    - the layer fires the event
                  */
                  this.fire('show');
              }
          }
          return this;
      };
      /**
       * 隐藏图层
       *
       * @english
       * Hide the layer
       * @returns this
       */
      Layer.prototype.hide = function () {
          var _this = this;
          if (this.options['visible']) {
              this.options['visible'] = false;
              var renderer = this.getRenderer();
              if (renderer) {
                  renderer.hide();
              }
              var map = this.getMap();
              if (renderer && map) {
                  //fire hide at renderend to make sure layer is hidden
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore Map 缺少once方法
                  map.once('renderend', function () {
                      _this.fire('hide');
                  });
              }
              else {
                  /**
                   * hide事件
                   *
                   * @english
                   * hide event.
                   *
                   * @event Layer#hide
                   * @type {Object}
                   * @property {String} type - hide
                   * @property {Layer} target    - the layer fires the event
                   */
                  this.fire('hide');
              }
          }
          // this.fire('hide');
          return this;
      };
      /**
       * layer 的当前 visible 状态
       *
       * @english
       * Whether the layer is visible now.
       * @return
       */
      Layer.prototype.isVisible = function () {
          if (isNumber(this.options['opacity']) && this.options['opacity'] <= 0) {
              return false;
          }
          var map = this.getMap();
          if (map) {
              var zoom = map.getZoom();
              if ((!isNil(this.options['maxZoom']) && this.options['maxZoom'] < zoom) ||
                  (!isNil(this.options['minZoom']) && this.options['minZoom'] > zoom)) {
                  return false;
              }
          }
          if (isNil(this.options['visible'])) {
              this.options['visible'] = true;
          }
          return this.options['visible'];
      };
      /**
       * 移除图层
       *
       * @english
       * Remove itself from the map added to.
       * @returns this
       */
      Layer.prototype.remove = function () {
          if (this.map) {
              var renderer = this.map.getRenderer();
              this.map.removeLayer(this);
              if (renderer) {
                  renderer.setToRedraw();
              }
          }
          else {
              this.fire('remove');
          }
          return this;
      };
      /**
       * 获取 mask geometry
       *
       * @english
       * Get the mask geometry of the layer
       * @return {Geometry}
       */
      Layer.prototype.getMask = function () {
          return this._mask;
      };
      /**
       * 设置mask geometry, 只显示掩码的区域
       *
       * @english
       * Set a mask geometry on the layer, only the area in the mask will be displayed.
       * @param {Geometry} mask - mask geometry, can only be a Marker with vector symbol, a Polygon or a MultiPolygon
       * @returns {Layer} this
       */
      Layer.prototype.setMask = function (mask) {
          if (!((mask.type === 'Point' && mask._isVectorMarker()) || mask.type === 'Polygon' || mask.type === 'MultiPolygon')) {
              throw new Error('Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).');
          }
          //@ts-expect-error Argument of type 'this' is not assignable to parameter of type 'OverlayLayer'.
          mask._bindLayer(this);
          if (mask.type === 'Point') {
              mask.updateSymbol({
                  'markerLineColor': 'rgba(0, 0, 0, 0)',
                  'markerFillOpacity': 0
              });
          }
          else {
              mask.setSymbol({
                  'lineColor': 'rgba(0, 0, 0, 0)',
                  'polygonOpacity': 0
              });
          }
          this._mask = mask;
          if (mask && mask.toGeoJSON) {
              try {
                  this._maskGeoJSON = mask.toGeoJSON();
              }
              catch (error) {
                  delete this._maskGeoJSON;
                  console.error(error);
              }
          }
          this.options.mask = mask.toJSON();
          if (!this.getMap() || this.getMap().isZooming()) {
              return this;
          }
          var renderer = this._getRenderer();
          if (renderer && renderer.setToRedraw) {
              this._getRenderer().setToRedraw();
          }
          return this;
      };
      /**
       * 移除mask
       *
       * @engilsh
       * Remove the mask
       * @returns {Layer} this
       */
      Layer.prototype.removeMask = function () {
          delete this._mask;
          delete this._maskGeoJSON;
          delete this.options.mask;
          if (!this.getMap() || this.getMap().isZooming()) {
              return this;
          }
          var renderer = this._getRenderer();
          if (renderer && renderer.setToRedraw) {
              this._getRenderer().setToRedraw();
          }
          return this;
      };
      /**
       * 准备层的加载，是一个由子类重写的方法。
       *
       * @english
       * Prepare Layer's loading, this is a method intended to be overrided by subclasses.
       * @return true to continue loading, false to cease.
       * @protected
       */
      Layer.prototype.onLoad = function () {
          return true;
      };
      Layer.prototype.onLoadEnd = function () {
      };
      /**
       * 是否加载layer
       *
       * @english
       * Whether the layer is loaded
       * @return
       */
      Layer.prototype.isLoaded = function () {
          return !!this._loaded;
      };
      /**
       * 获取collision index
       *
       * @english
       * Get layer's collision index
       * @returns {CollisionIndex}
       */
      Layer.prototype.getCollisionIndex = function () {
          if (this.options['collisionScope'] === 'layer') {
              if (!this._collisionIndex) {
                  this._collisionIndex = new CollisionIndex();
              }
              return this._collisionIndex;
          }
          var map = this.getMap();
          if (!map) {
              return null;
          }
          return map.getCollisionIndex();
      };
      /**
       * 清除 layer 的 collision index。
       * 如果 collisionScope !== 'layer' 将忽略
       *
       * @english
       * Clear layer's collision index.
       * Will ignore if collisionScope is not layer
       */
      Layer.prototype.clearCollisionIndex = function () {
          if (this.options['collisionScope'] === 'layer' &&
              this._collisionIndex) {
              this._collisionIndex.clear();
          }
          return this;
      };
      Layer.prototype.getRenderer = function () {
          return this._getRenderer();
      };
      Layer.prototype.onConfig = function (conf) {
          var needUpdate = conf && Object.keys && Object.keys(conf).length > 0;
          if (needUpdate && isNil(conf['animation'])) {
              // options change Hook,subLayers Can realize its own logic,such as tileSize/tileSystem etc change
              if (this._optionsHook && isFunction(this._optionsHook)) {
                  this._optionsHook(conf);
              }
              if (this._silentConfig) {
                  return;
              }
              var renderer = this.getRenderer();
              if (renderer && renderer.setToRedraw) {
                  renderer.setToRedraw();
              }
          }
      };
      Layer.prototype.onAdd = function () { };
      Layer.prototype.onRendererCreate = function () { };
      Layer.prototype.onCanvasCreate = function () { };
      Layer.prototype.onRemove = function () { };
      //@internal
      Layer.prototype._bindMap = function (map, zIndex) {
          if (!map) {
              return;
          }
          this.map = map;
          if (!isNil(zIndex)) {
              this.setZIndex(zIndex);
          }
          this._switchEvents('on', this);
          this.onAdd();
          this.fire('add');
      };
      //@internal
      Layer.prototype._initRenderer = function () {
          var renderer = this.options['renderer'];
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          if (!this.constructor.getRendererClass) {
              return;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          var clazz = this.constructor.getRendererClass(renderer);
          if (!clazz) {
              throw new Error('Invalid renderer for Layer(' + this.getId() + '):' + renderer);
          }
          this._renderer = new clazz(this);
          this._renderer.layer = this;
          this._renderer.setZIndex(this.getZIndex());
          this._switchEvents('on', this._renderer);
          // some plugin of dom renderer doesn't implement onAdd
          if (this._renderer.onAdd) {
              this._renderer.onAdd();
          }
          this.onRendererCreate();
          /**
           * renderercreate 事件, 当 renderer 创建完成后触发
           *
           * @english
           * renderercreate event, fired when renderer is created.
           *
           * @event Layer#renderercreate
           * @type {Object}
           * @property {String} type - renderercreate
           * @property {Layer} target    - the layer fires the event
           * @property {Any} renderer    - renderer of the layer
           */
          this.fire('renderercreate', {
              'type': 'renderercreate',
              'target': this,
              'renderer': this._renderer
          });
      };
      //@internal
      Layer.prototype._doRemove = function () {
          this._loaded = false;
          this._switchEvents('off', this);
          this.onRemove();
          if (this._renderer) {
              this._switchEvents('off', this._renderer);
              this._renderer.remove();
              delete this._renderer;
          }
          delete this.map;
          delete this._collisionIndex;
      };
      //@internal
      Layer.prototype._switchEvents = function (to, emitter) {
          if (emitter && emitter.getEvents && this.getMap()) {
              this.getMap()[to](emitter.getEvents(), emitter);
          }
      };
      //@internal
      Layer.prototype._getRenderer = function () {
          return this._renderer;
      };
      //@internal
      Layer.prototype._getLayerList = function () {
          if (!this.map) {
              return [];
          }
          var beginIndex = +!!this.map.getBaseLayer();
          return this.map.getLayers().slice(beginIndex);
      };
      //@internal
      Layer.prototype._getMask2DExtent = function () {
          if (!this._mask || !this.getMap()) {
              return null;
          }
          var painter = this._mask._getMaskPainter();
          if (!painter) {
              return null;
          }
          return painter.get2DExtent();
      };
      Layer.prototype.toJSON = function (options) {
          return {
              type: 'Layer',
              id: this.getId(),
              options: options || this.config()
          };
      };
      /**
       * Reproduce a Layer from layer's JSON.
       * @param  {Object} layerJSON - layer's JSON
       * @return {Layer}
       */
      Layer.fromJSON = function (layerJSON) {
          if (!layerJSON) {
              return null;
          }
          var layerType = layerJSON['type'];
          var clazz = Layer.getJSONClass(layerType);
          if (!clazz || !clazz.fromJSON) {
              throw new Error('unsupported layer type:' + layerType);
          }
          return clazz.fromJSON(layerJSON);
      };
      return Layer;
  }(JSONAble(Eventable(Renderable(Class)))));
  Layer.mergeOptions(options$B);
  var fire = Layer.prototype.fire;
  Layer.prototype.fire = function (eventType, param) {
      if (eventType === 'layerload') {
          this._loaded = true;
      }
      if (this.map) {
          if (!param) {
              param = {
                  'type': null,
                  'target': null
              };
          }
          param['type'] = eventType;
          param['target'] = this;
          this.map._onLayerEvent(param);
      }
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      // eslint-disable-next-line prefer-rest-params
      fire.apply(this, arguments);
      if (['show', 'hide'].indexOf(eventType) > -1) {
          /**
          * visiblechange 事件
          * @english
          * visiblechange event.
          *
          * @event Layer#visiblechange
          * @type {Object}
          * @property {String} type - visiblechange
          * @property {Layer} target    - the layer fires the event
          * @property {Boolean} visible        - value of visible
         */
          this.fire('visiblechange', Object.assign({}, param, { visible: this.options.visible }));
      }
      return this;
  };

  var TEMP_COORD$2 = new Coordinate(0, 0);
  var TEMP_POINT$5 = new Point(0, 0);
  var REDRAW_OPTIONS_PROPERTIES = ['centerCross', 'fog', 'fogColor', 'debugSky'];
  /**
   * @property {Object} options                                   - map's options, options must be updated by config method:<br> map.config('zoomAnimation', false);
   * @property {Boolean} [options.centerCross=false]              - Display a red cross in the center of map
   * @property {Boolean} [options.seamlessZoom=true]             - whether to use seamless zooming mode
   * @property {Boolean} [options.zoomInCenter=false]             - whether to fix in the center when zooming
   * @property {Number}  [options.zoomOrigin=null]                - zoom origin in container point, e.g. [400, 300]
   * @property {Boolean} [options.zoomAnimation=true]             - enable zooming animation
   * @property {Number}  [options.zoomAnimationDuration=330]      - zoom animation duration.
   * @property {Boolean} [options.panAnimation=true]              - continue to animate panning when dragging or touching ended.
   * @property {Boolean} [options.panAnimationDuration=600]       - duration of pan animation.
   * @property {Boolean} [options.rotateAnimation=true]           - continue to animate rotating when dragging or touching rotation ended.
   * @property {Boolean} [options.rotateAnimationDuration=800]    - duration of rotate animation.
   * @property {Boolean} [options.zoomable=true]                  - whether to enable map zooming.
   * @property {Boolean} [options.enableInfoWindow=true]          - whether to enable infowindow on this map.
   * @property {Boolean} [options.hitDetect=true]                 - whether to enable hit detecting of layers for cursor style on this map, disable it to improve performance.
   * @property {Boolean} [options.hitDetectLimit=5]               - the maximum number of layers to perform hit detect.
   * @property {Boolean} [options.fpsOnInteracting=25]            - fps when map is interacting, some slow layers will not be drawn on interacting when fps is low. Set to 0 to disable it.
   * @property {Boolean} [options.layerCanvasLimitOnInteracting=-1]    - limit of layer canvas to draw on map when interacting, set it to improve perf.
   * @property {Number}  [options.maxZoom=null]                   - the maximum zoom the map can be zooming to.
   * @property {Number}  [options.minZoom=null]                   - the minimum zoom the map can be zooming to.
   * @property {Extent}  [options.maxExtent=null]         - when maxExtent is set, map will be restricted to the give max extent and bouncing back when user trying to pan ouside the extent.
   * @property {Boolean} [options.fixCenterOnResize=true]        - whether to fix map center when map is resized
   *
   * @property {Number}  [options.maxPitch=80]                    - max pitch
   * @property {Number}  [options.maxVisualPitch=70]              - the max pitch to be visual
   *
   * @property {Extent}  [options.viewHistory=true]               -  whether to record view history
   * @property {Extent}  [options.viewHistoryCount=10]            -  the count of view history record.
   *
   * @property {Boolean} [options.draggable=true]                         - disable the map dragging if set to false.
   * @property {Boolean} [options.dragPan=true]                           - if true, map can be dragged to pan.
   * @property {Boolean} [options.dragRotate=true]                        - default true. If true, map can be dragged to rotate by right click or ctrl + left click.
   * @property {Boolean} [options.dragPitch=true]                         - default true. If true, map can be dragged to pitch by right click or ctrl + left click.
   * @property {Boolean} [options.dragRotatePitch=true]                   - if true, map is dragged to pitch and rotate at the same time.
   * @property {Number}  [options.switchDragButton=false]                 - switch to use left click (or touch on mobile) to rotate map and right click to move map.
   * @property {Boolean} [options.touchGesture=true]                      - whether to allow map to zoom/rotate/tilt by two finger touch gestures.
   * @property {Boolean} [options.touchZoom=true]                         - whether to allow map to zoom by touch pinch.
   * @property {Boolean} [options.touchRotate=true]                       - whether to allow map to rotate by touch pinch.
   * @property {Boolean} [options.touchPitch=true]                        - whether to allow map to pitch by touch pinch.
   * @property {Boolean} [options.touchZoomRotate=false]                  - if true, map is to zoom and rotate at the same time by touch pinch.
   * @property {Boolean} [options.doubleClickZoom=true]                    - whether to allow map to zoom by double click events.
   * @property {Boolean} [options.scrollWheelZoom=true]                   - whether to allow map to zoom by scroll wheel events.
   * @property {Boolean} [options.geometryEvents=true]                    - enable/disable firing geometry events
   * @property {Number}  [options.clickTimeThreshold=280]                 - time threshold between mousedown(touchstart) and mouseup(touchend) to determine if it's a click event
   *
   * @property {Boolean}        [options.control=true]                    - whether allow map to add controls.
   * @property {Boolean|Object} [options.attribution=true]                - whether to display the attribution control on the map. if true, attribution display maptalks info; if object, you can specify positon or your base content, and both;
   * @property {Boolean|Object} [options.zoomControl=false]               - display the zoom control on the map if set to true or a object as the control construct option.
   * @property {Boolean|Object} [options.scaleControl=false]              - display the scale control on the map if set to true or a object as the control construct option.
   * @property {Boolean|Object} [options.overviewControl=false]           - display the overview control on the map if set to true or a object as the control construct option.
   *
   * @property {Boolean}        [options.fog=true]                        - whether to draw fog in far distance.
   * @property {Number[]}       [options.fogColor=[233, 233, 233]]        - color of fog: [r, g, b]
   *
   * @property {String} [options.renderer=canvas]                 - renderer type. Don't change it if you are not sure about it. About renderer, see [TODO]{@link tutorial.renderer}.
   * @property {Number} [options.devicePixelRatio=null]           - device pixel ratio to override device's default one
   * @property {Number} [options.heightFactor=1]           - the factor for height/altitude calculation,This affects the height calculation of all layers(vectortilelayer/gllayer/threelayer/3dtilelayer)
   * @property {Boolean} [options.stopRenderOnOffscreen=true]           - whether to stop map rendering when container is offscreen
   * @property {Boolean} [options.originLatitudeForAltitude=40]         - default latitude for map.altitudeToPoint method
   * @property {Number} [options.mousemoveThrottleTime=48]         - mousemove event interval time(ms)
   * @property {Number} [options.maxFPS=0]         - 0 means no frame is locked, otherwise the frame is locked
   * @property {Number} [options.cameraFarUndergroundInMeter=2000]      - camera far distance from underground in meter
   * @memberOf Map
   * @instance
   */
  var options$A = {
      'maxVisualPitch': 70,
      'maxPitch': 80,
      'centerCross': false,
      'zoomInCenter': false,
      'zoomOrigin': null,
      'zoomAnimation': (function () {
          return !IS_NODE;
      })(),
      'zoomAnimationDuration': 330,
      'panAnimation': (function () {
          return !IS_NODE;
      })(),
      //default pan animation duration
      'panAnimationDuration': 600,
      'rotateAnimation': (function () {
          return !IS_NODE;
      })(),
      'zoomable': true,
      'enableInfoWindow': true,
      'hitDetect': (function () {
          return !Browser$1.mobile;
      })(),
      'hitDetectLimit': 5,
      'fpsOnInteracting': 25,
      'layerCanvasLimitOnInteracting': -1,
      'maxZoom': null,
      'minZoom': null,
      'maxExtent': null,
      'limitExtentOnMaxExtent': false,
      'fixCenterOnResize': true,
      'checkSize': true,
      'checkSizeInterval': 1000,
      'renderer': 'canvas',
      'cascadePitches': [10, 60],
      'renderable': true,
      'clickTimeThreshold': 280,
      'stopRenderOnOffscreen': true,
      'preventWheelScroll': true,
      'preventTouch': true,
      //for plugin layer,such as threelayer
      'supportPluginEvent': true,
      'switchDragButton': false,
      'mousemoveThrottleTime': MOUSEMOVE_THROTTLE_TIME,
      'maxFPS': 0,
      'debug': false,
      'cameraFarUndergroundInMeter': 2000
  };
  /**
   * The central class of the library, to create a map on a container.
   *
   * @category map
   *
   * @mixes Eventable
   * @mixes Handlerable
   * @mixes ui.Menuable
   * @mixes Renderable
   *
   * @example
   * var map = new maptalks.Map("map",{
   *      center:     [180,0],
   *      zoom:  4,
   *      baseLayer : new maptalks.TileLayer("base",{
   *          urlTemplate:'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
   *          subdomains:['a','b','c']
   *      }),
   *      layers : [
   *          new maptalks.VectorLayer('v', [new maptalks.Marker([180, 0])])
   *      ]
   * });
   */
  var Map$1 = /** @class */ (function (_super) {
      __extends(Map, _super);
      /**
       * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>
       *                                          1. A HTMLElement container.<br/>
       *                                          2. ID of a HTMLElement container.<br/>
       *                                          3. Any canvas compatible container
       * @param {Object} options - construct options
       * @param {(Number[]|Coordinate)} options.center - initial center of the map.
       * @param {Number} options.zoom - initial zoom of the map.
       * @param {Object} [options.spatialReference=null] - map's spatial reference, default is using projection EPSG:3857 with resolutions used by google map/osm.
       * @param {Layer} [options.baseLayer=null] - base layer that will be set to map initially.
       * @param {Layer[]} [options.layers=null] - layers that will be added to map initially.
       * @param {*} options.* - any other option defined in [Map.options]{@link Map#options}      [description]
       */
      function Map(container, options) {
          var _this = this;
          if (!options) {
              throw new Error('Invalid options when creating map.');
          }
          if (!options['center']) {
              throw new Error('Invalid center when creating map.');
          }
          // prepare options
          var opts = extend$2({}, options);
          var zoom = opts['zoom'];
          delete opts['zoom'];
          var center = new Coordinate(opts['center']);
          delete opts['center'];
          var baseLayer = opts['baseLayer'];
          delete opts['baseLayer'];
          var layers = opts['layers'];
          delete opts['layers'];
          _this = _super.call(this, opts) || this;
          /**
           * @property {String}  - Version of library
           * @constant
           * @static
           */
          _this.VERSION = Map.VERSION;
          Object.defineProperty(_this, 'id', {
              value: UID(),
              writable: false
          });
          _this._loaded = false;
          _this._initContainer(container);
          _this._panels = {};
          //Layers
          _this._baseLayer = null;
          _this._layers = [];
          _this._zoomLevel = zoom;
          _this._center = center;
          _this._centerZ = center.z;
          _this.setSpatialReference(opts['spatialReference'] || opts['view']);
          _this._mapViewPoint = new Point(0, 0);
          _this._initRenderer();
          _this._updateMapSize(_this._getContainerDomSize());
          if (baseLayer) {
              _this.setBaseLayer(baseLayer);
          }
          if (layers) {
              _this.addLayer(layers);
          }
          _this.setMaxExtent(opts['maxExtent']);
          _this._Load();
          _this.proxyOptions();
          _this.isMap = true;
          return _this;
      }
      /**
       * Add hooks for additional codes when map's loading complete, useful for plugin developping.
       * Note that it can only be called before the map is created.
       * @param {Function | any} fn
       * @returns {Map}
       */
      Map.addOnLoadHook = function (fn) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          // const args = Array.prototype.slice.call(arguments, 1);
          var onload = typeof fn === 'function' ? fn : function () {
              var _a;
              (_a = this[fn]).call.apply(_a, __spreadArray([this], __read(args), false));
          };
          this.prototype._onLoadHooks = this.prototype._onLoadHooks || [];
          this.prototype._onLoadHooks.push(onload);
          return this;
      };
      /**
       * Whether the map is loaded or not.
       * @return {Boolean}
       */
      Map.prototype.isLoaded = function () {
          return !!this._loaded;
      };
      /**
       * Get map's container
       * @returns {HTMLElement}
       */
      Map.prototype.getContainer = function () {
          return this._containerDOM;
      };
      /**
       * Get the spatial reference of the Map.
       * @return {SpatialReference} map's spatial reference
       */
      Map.prototype.getSpatialReference = function () {
          return this._spatialReference;
      };
      /**
       * Change the spatial reference of the map. <br>
       * A SpatialReference is a series of settings to decide the map presentation:<br>
       * 1. the projection.<br>
       * 2. zoom levels and resolutions. <br>
       * 3. full extent.<br>
       * There are some [predefined spatial references]{@link http://www.foo.com}, and surely you can [define a custom one.]{@link http://www.foo.com}.<br>
       * SpatialReference can also be updated by map.config('spatialReference', spatialReference);
       * @param {SpatialReference} spatialReference - spatial reference
       * @returns {Map} this
       * @fires Map#spatialreferencechange
       * @example
       *  map.setSpatialReference({
              projection:'EPSG:4326',
              resolutions: (function() {
                  const resolutions = [];
                  for (let i=0; i < 19; i++) {
                      resolutions[i] = 180/(Math.pow(2, i)*128);
                  }
                  return resolutions;
              })()
       *  });
         @example
       *  map.config('spatialReference', {
              projection:'EPSG:4326',
              resolutions: (function() {
                  const resolutions = [];
                  for (let i=0; i < 19; i++) {
                      resolutions[i] = 180/(Math.pow(2, i)*128);
                  }
                  return resolutions;
              })()
          });
       */
      Map.prototype.setSpatialReference = function (ref) {
          var oldRef = this.options['spatialReference'];
          if (this._loaded && SpatialReference.equals(oldRef, ref)) {
              return this;
          }
          this._updateSpatialReference(ref, oldRef);
          return this;
      };
      //@internal
      Map.prototype._updateSpatialReference = function (ref, oldRef) {
          if (isString(ref)) {
              ref = SpatialReference.getPreset(ref);
          }
          ref = extend$2({}, ref);
          this._center = this.getCenter();
          this.options['spatialReference'] = ref;
          this._spatialReference = new SpatialReference(ref);
          var projection = this._spatialReference.getProjection();
          if (this.options['spatialReference'] && isFunction(this.options['spatialReference']['projection'])) {
              //save projection code for map profiling (toJSON/fromJSON)
              this.options['spatialReference']['projection'] = projection['code'];
          }
          this._resetMapStatus();
          if (EPSG9807.is(projection.code)) {
              this._originLng = projection.centralMeridian;
              this._altitudeOriginDirty = true;
          }
          /**
           * spatialreferencechange event, fired when map's spatial reference is updated.
           *
           * @event Map#spatialreferencechange
           * @type {Object}
           * @property {String} type - spatialreferencechange
           * @property {Map} target - map
           * @property {Map} old - the old spatial reference
           * @property {Map} new - the new spatial reference changed to
           */
          this._fireEvent('spatialreferencechange', {
              'old': oldRef,
              'new': extend$2({}, this.options['spatialReference'])
          });
          return this;
      };
      // _syncWorld() {
      //     const projection = this.getProjection();
      //     if (!projection) {
      //         return false;
      //     }
      //     const pcenter = this._getPrjCenter();
      //     if (projection.isOutSphere(pcenter)) {
      //         const wrapped = projection.wrapCoord(pcenter);
      //         this._setPrjCenter(wrapped);
      //         this._fireEvent('syncworld', { 'old' : pcenter.toArray(), 'new' : wrapped.toArray() });
      //         return true;
      //     }
      //     return false;
      // }
      /**
       * Callback when any option is updated
       * @param  {Object} conf - options to update
       * @return {Map}   this
       */
      Map.prototype.onConfig = function (conf) {
          var ref = conf['spatialReference'] || conf['view'];
          if (!isNil(ref)) {
              this._updateSpatialReference(ref, null);
          }
          var needUpdate = false;
          for (var i = 0, len = REDRAW_OPTIONS_PROPERTIES.length; i < len; i++) {
              var key = REDRAW_OPTIONS_PROPERTIES[i];
              if (!isNil(conf[key])) {
                  needUpdate = true;
                  break;
              }
          }
          if (!needUpdate) {
              return this;
          }
          var renderer = this.getRenderer();
          if (renderer) {
              renderer.setToRedraw();
          }
          return this;
      };
      /**
       * Get the projection of the map. <br>
       * Projection is an algorithm for map projection, e.g. well-known [Mercator Projection]{@link https://en.wikipedia.org/wiki/Mercator_projection} <br>
       * A projection must have 2 methods: <br>
       * 1. project(coordinate) - project the input coordinate <br>
       * 2. unproject(coordinate) - unproject the input coordinate <br>
       * Projection also contains measuring method usually extended from a measurer: <br>
       * 1. measureLength(coord1, coord2) - compute length between 2 coordinates.  <br>
       * 2. measureArea(coords[]) - compute area of the input coordinates. <br>
       * 3. locate(coord, distx, disty) - compute the coordinate from the coord with xdist on axis x and ydist on axis y.
       * @return {Object}
       */
      Map.prototype.getProjection = function () {
          if (!this._spatialReference) {
              return null;
          }
          return this._spatialReference.getProjection();
      };
      /**
       * Get map's full extent, which is defined in map's spatial reference. <br>
       * eg: {'left': -180, 'right' : 180, 'top' : 90, 'bottom' : -90}
       * @return {Extent}
       */
      Map.prototype.getFullExtent = function () {
          if (!this._spatialReference) {
              return null;
          }
          return this._spatialReference.getFullExtent();
      };
      /**
       * Set map's cursor style, cursor style is same with CSS.
       * @param {String} cursor - cursor style
       * @returns {Map} this
       * @example
       * map.setCursor('url(cursor.png) 4 12, auto');
       */
      Map.prototype.setCursor = function (cursor) {
          delete this._cursor;
          this._trySetCursor(cursor);
          this._cursor = cursor;
          return this;
      };
      /**
       * Reset map's cursor style.
       * @return {Map} this
       * @example
       * map.resetCursor();
       */
      Map.prototype.resetCursor = function () {
          return this.setCursor(null);
      };
      /**
       * Get center of the map.
       * @return {Coordinate}
       */
      Map.prototype.getCenter = function () {
          if (!this._loaded || !this._prjCenter) {
              return this._center;
          }
          var projection = this.getProjection();
          var center = projection.unproject(this._prjCenter);
          center.x = Math.round(center.x * 1E8) / 1E8;
          center.y = Math.round(center.y * 1E8) / 1E8;
          center.z = this._centerZ;
          if (this.centerAltitude) {
              center.z = this.centerAltitude;
          }
          return center;
      };
      /**
       * Set a new center to the map.
       * @param {Coordinate} center
       * @param  {Object} [padding]
       * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container
       * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container
       * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container
       * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container
       * @return {Map} this
       */
      Map.prototype.setCenter = function (center, padding) {
          if (!center) {
              return this;
          }
          center = new Coordinate(center);
          if (padding) {
              center = this._getCenterByPadding(center, this.getZoom(), padding);
          }
          var projection = this.getProjection();
          var pcenter = projection.project(center);
          if (!this._verifyExtent(pcenter) && !this.options.limitExtentOnMaxExtent) {
              return this;
          }
          if (!this._loaded) {
              this._center = center;
              return this;
          }
          this._centerZ = center.z;
          this.onMoveStart();
          this._setPrjCenter(pcenter);
          this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
          return this;
      };
      /**
       * Get map's size (width and height) in pixel.
       * @return {Size}
       */
      Map.prototype.getSize = function () {
          if (isNil(this.width) || isNil(this.height)) {
              return this._getContainerDomSize();
          }
          return new Size(this.width, this.height);
      };
      /**
       * Get container extent of the map
       * @return {PointExtent}
       */
      Map.prototype.getContainerExtent = function () {
          var visualHeight = this.height;
          var pitch = this.getPitch(), maxVisualPitch = this.options['maxVisualPitch'];
          if (maxVisualPitch && pitch > maxVisualPitch) {
              visualHeight = this._getVisualHeight(maxVisualPitch);
          }
          return new PointExtent(0, this.height - visualHeight, this.width, this.height);
      };
      //@internal
      Map.prototype._getVisualHeight = function (visualPitch) {
          // const pitch = this.getPitch();
          // const visualDistance = this.height / 2 * Math.tan(visualPitch * Math.PI / 180);
          // return this.height / 2 + visualDistance *  Math.tan((90 - pitch) * Math.PI / 180);
          visualPitch = visualPitch || 1E-2;
          var pitch = (90 - this.getPitch()) * Math.PI / 180;
          var fov = this.getFov() * Math.PI / 180;
          visualPitch *= Math.PI / 180;
          var cameraToCenter = this.cameraCenterDistance / this.getGLScale();
          var tanB = Math.tan(fov / 2);
          var tanP = Math.tan(visualPitch);
          var visualDistance = (cameraToCenter * tanB) / (1 / tanP - tanB) / Math.sin(visualPitch);
          var x = cameraToCenter * (Math.sin(pitch) * visualDistance / (cameraToCenter + Math.cos(pitch) * visualDistance));
          return this.height / 2 + x;
      };
      /**
       * Get the geographical extent of map's current view extent.
       *
       * @return {Extent}
       */
      Map.prototype.getExtent = function () {
          return this.pointToExtent(this.get2DExtent());
      };
      /**
       * Get the projected geographical extent of map's current view extent.
       *
       * @return {Extent}
       */
      Map.prototype.getProjExtent = function () {
          var extent2D = this.get2DExtent();
          return new Extent(this._pointToPrj(extent2D.getMin()), this._pointToPrj(extent2D.getMax()));
      };
      /**
       * Alias for getProjExtent
       *
       * @return {Extent}
       */
      Map.prototype.getPrjExtent = function () {
          return this.getProjExtent();
      };
      /**
       * Get the max extent that the map is restricted to.
       * @return {Extent}
       */
      Map.prototype.getMaxExtent = function () {
          if (!this.options['maxExtent']) {
              return null;
          }
          return new Extent(this.options['maxExtent'], this.getProjection());
      };
      /**
       * Sets the max extent that the map is restricted to.
       * @param {Extent}
       * @return {Map} this
       * @example
       * map.setMaxExtent(map.getExtent());
       */
      Map.prototype.setMaxExtent = function (extent) {
          if (extent) {
              var maxExt = new Extent(extent, this.getProjection());
              this.options['maxExtent'] = maxExt;
              var projection_1 = this.getProjection();
              this._prjMaxExtent = maxExt.convertTo(function (c) { return projection_1.project(c); });
              if (!this._verifyExtent(this._getPrjCenter())) {
                  if (this._loaded) {
                      this._panTo(this._prjMaxExtent.getCenter());
                  }
                  else {
                      this._center = projection_1.unproject(this._prjMaxExtent.getCenter());
                  }
              }
          }
          else {
              delete this.options['maxExtent'];
              delete this._prjMaxExtent;
          }
          return this;
      };
      /**
       * Get map's current zoom.
       * @return {Number}
       */
      Map.prototype.getZoom = function () {
          return this._zoomLevel;
      };
      /**
       * Caculate the target zoom if scaling from "fromZoom" by "scale"
       * @param  {Number} scale
       * @param  {Number} fromZoom
       * @param  {Boolean} isFraction - can return fractional zoom
       * @return {Number} zoom fit for scale starting from fromZoom
       */
      Map.prototype.getZoomForScale = function (scale, fromZoom, isFraction) {
          var zoom = this.getZoom();
          if (isNil(fromZoom)) {
              fromZoom = zoom;
          }
          if (scale === 1 && fromZoom === zoom) {
              return zoom;
          }
          var res = this._getResolution(fromZoom), targetRes = res / scale;
          var scaleZoom = this.getZoomFromRes(targetRes);
          if (isFraction) {
              return scaleZoom;
          }
          else {
              var delta = 1E-6; //avoid precision
              return this.getSpatialReference().getZoomDirection() < 0 ?
                  Math.ceil(scaleZoom - delta) : Math.floor(scaleZoom + delta);
          }
      };
      Map.prototype.getZoomFromRes = function (res) {
          var resolutions = this._getResolutions(), minRes = this._getResolution(this.getMinZoom()), maxRes = this._getResolution(this.getMaxZoom());
          if (minRes <= maxRes) {
              if (res <= minRes) {
                  return this.getMinZoom();
              }
              else if (res >= maxRes) {
                  return this.getMaxZoom();
              }
          }
          else if (res >= minRes) {
              return this.getMinZoom();
          }
          else if (res <= maxRes) {
              return this.getMaxZoom();
          }
          var l = resolutions.length;
          for (var i = 0; i < l - 1; i++) {
              if (!resolutions[i]) {
                  continue;
              }
              var gap = resolutions[i + 1] - resolutions[i];
              var test = res - resolutions[i];
              if (sign(gap) === sign(test) && Math.abs(gap) >= Math.abs(test)) {
                  return i + test / gap;
              }
          }
          return l - 1;
      };
      /**
       * Sets zoom of the map
       * @param {Number} zoom
       * @param {Object} [options=null] options
       * @param {Boolean} [options.animation=true] whether zoom is animation, true by default
       * @returns {Map} this
       */
      Map.prototype.setZoom = function (zoom, options) {
          if (options === void 0) { options = { 'animation': true }; }
          if (isNaN(zoom) || isNil(zoom)) {
              return this;
          }
          zoom = +zoom;
          if (this._loaded && this.options['zoomAnimation'] && options['animation']) {
              this._zoomAnimation(zoom);
          }
          else {
              this._zoom(zoom);
          }
          return this;
      };
      /**
       * Get the max zoom that the map can be zoom to.
       * @return {Number}
       */
      Map.prototype.getMaxZoom = function () {
          if (!isNil(this.options['maxZoom'])) {
              return this.options['maxZoom'];
          }
          return this.getMaxNativeZoom();
      };
      /**
       * Sets the max zoom that the map can be zoom to.
       * @param {Number} maxZoom
       * @returns {Map} this
       */
      Map.prototype.setMaxZoom = function (maxZoom) {
          var viewMaxZoom = this.getMaxNativeZoom();
          if (maxZoom > viewMaxZoom) {
              maxZoom = viewMaxZoom;
          }
          if (maxZoom !== null && maxZoom < this._zoomLevel) {
              this.setZoom(maxZoom);
              maxZoom = +maxZoom;
          }
          this.options['maxZoom'] = maxZoom;
          return this;
      };
      /**
       * Get the min zoom that the map can be zoom to.
       * @return {Number}
       */
      Map.prototype.getMinZoom = function () {
          if (!isNil(this.options['minZoom'])) {
              return this.options['minZoom'];
          }
          return this._spatialReference.getMinZoom();
      };
      /**
       * Sets the min zoom that the map can be zoom to.
       * @param {Number} minZoom
       * @return {Map} this
       */
      Map.prototype.setMinZoom = function (minZoom) {
          if (minZoom !== null) {
              minZoom = +minZoom;
              var viewMinZoom = this._spatialReference.getMinZoom();
              if (minZoom < viewMinZoom) {
                  minZoom = viewMinZoom;
              }
              if (minZoom > this._zoomLevel) {
                  this.setZoom(minZoom);
              }
          }
          this.options['minZoom'] = minZoom;
          return this;
      };
      /**
       * Maximum zoom the map has
       * @return {Number}
       */
      Map.prototype.getMaxNativeZoom = function () {
          var ref = this.getSpatialReference();
          if (!ref) {
              return null;
          }
          return ref.getMaxZoom();
      };
      /**
       * Resolution for world point in WebGL context
       * @returns {Number}
       */
      Map.prototype.getGLRes = function () {
          if (this._glRes) {
              return this._glRes;
          }
          var fullExtent = this.getSpatialReference().getFullExtent();
          this._glRes = (fullExtent.right - fullExtent.left) / Math.pow(2, 19);
          return this._glRes;
          // return this._getResolution(14);
          // return this._getResolution(this.getMaxNativeZoom() / 2);
      };
      /**
       * Caculate scale from gl zoom to given zoom (default by current zoom)
       * @param {Number} [zoom=undefined] target zoom, current zoom by default
       * @returns {Number}
       * @examples
       * const point = map.coordToPoint(map.getCenter());
       * // convert to point in gl zoom
       * const glPoint = point.multi(this.getGLScale());
       */
      Map.prototype.getGLScale = function (zoom) {
          if (isNil(zoom)) {
              zoom = this.getZoom();
          }
          return this._getResolution(zoom) / this.getGLRes();
      };
      /**
       * zoom in
       * @return {Map} this
       */
      Map.prototype.zoomIn = function () {
          return this.setZoom(this.getZoom() + 1);
      };
      /**
       * zoom out
       * @return {Map} this
       */
      Map.prototype.zoomOut = function () {
          return this.setZoom(this.getZoom() - 1);
      };
      /**
       * Whether the map is zooming
       * @return {Boolean}
       */
      Map.prototype.isZooming = function () {
          return !!this._zooming;
      };
      /**
       * Whether the map is being interacted
       * @return {Boolean}
       */
      Map.prototype.isInteracting = function () {
          return this.isZooming() || this.isMoving() || this.isRotating();
      };
      /**
       * Sets the center and zoom at the same time.
       * @param {Coordinate} center
       * @param {Number} zoom
       * @return {Map} this
       */
      Map.prototype.setCenterAndZoom = function (center, zoom) {
          if (!isNil(zoom) && this._zoomLevel !== zoom) {
              this.setCenter(center);
              this.setZoom(zoom, { animation: false });
          }
          else {
              this.setCenter(center);
          }
          return this;
      };
      /**
       * Get the padding Size
       * @param  {Object} options
       * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container
       * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container
       * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container
       * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container
       * @returns {Object|null}
       */
      //@internal
      Map.prototype._getPaddingSize = function (options) {
          if (options === void 0) { options = {}; }
          if (options['paddingLeft'] || options['paddingTop'] || options['paddingRight'] || options['paddingBottom']) {
              return {
                  width: (options['paddingLeft'] || 0) + (options['paddingRight'] || 0),
                  height: (options['paddingTop'] || 0) + (options['paddingBottom'] || 0)
              };
          }
          return null;
      };
      /**
       * Caculate the zoom level that contains the given extent with the maximum zoom level possible.
       * @param {Extent} extent
       * @param  {Boolean} [isFraction] - can return fractional zoom
       * @param  {Object} [padding] [padding] - padding
       * @param  {Object} [padding.paddingLeft] - Sets the amount of padding in the left of a map container
       * @param  {Object} [padding.paddingTop] - Sets the amount of padding in the top of a map container
       * @param  {Object} [padding.paddingRight] - Sets the amount of padding in the right of a map container
       * @param  {Object} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container
       * @return {Number} zoom fit for scale starting from fromZoom
       */
      Map.prototype.getFitZoom = function (extent, isFraction, padding) {
          var _this = this;
          if (!extent || !(extent instanceof Extent)) {
              return this._zoomLevel;
          }
          //It's a point
          if (extent['xmin'] === extent['xmax'] && extent['ymin'] === extent['ymax']) {
              return this.getMaxZoom();
          }
          var size = this.getSize();
          var paddingSize = this._getPaddingSize(padding);
          if (paddingSize) {
              var rect = {
                  width: size.width - (paddingSize.width || 0),
                  height: size.height - (paddingSize.height || 0)
              };
              size = new Size(rect.width, rect.height);
          }
          var containerExtent = extent.convertTo(function (p) { return _this.coordToPoint(p); });
          var w = containerExtent.getWidth(), h = containerExtent.getHeight();
          var scaleX = size['width'] / w, scaleY = size['height'] / h;
          var scale = this.getSpatialReference().getZoomDirection() < 0 ?
              Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
          var zoom = this.getZoomForScale(scale, null, isFraction);
          return zoom;
      };
      /**
       * Get map's current view (center/zoom/pitch/bearing)
       * @return {Object} { center : *, zoom : *, pitch : *, bearing : * }
       */
      Map.prototype.getView = function () {
          return {
              'center': this.getCenter().toArray(),
              'zoom': this.getZoom(),
              'pitch': this.getPitch(),
              'bearing': this.getBearing()
          };
      };
      //@internal
      Map.prototype._validateView = function (view) {
          if (!view || !isObject$1(view)) {
              return;
          }
          if (isNumber(view.bearing)) {
              view.bearing = Math.max(-180, view.bearing);
              view.bearing = Math.min(180, view.bearing);
          }
          if (isNumber(view.pitch)) {
              view.pitch = Math.max(0, view.pitch);
              view.pitch = Math.min(this.options.maxPitch, view.pitch);
          }
          var maxZoom = this.getMaxZoom();
          if (isNumber(view.zoom)) {
              view.zoom = Math.max(0, view.zoom);
              view.zoom = Math.min(maxZoom, view.zoom);
          }
          return;
      };
      /**
       * Set map's center/zoom/pitch/bearing at one time
       * @param {Object} view - a object containing center/zoom/pitch/bearing
       * return {Map} this
       */
      Map.prototype.setView = function (view) {
          if (!view) {
              return this;
          }
          this._validateView(view);
          if (view['center']) {
              this.setCenter(view['center']);
          }
          if (view['zoom'] !== null && !isNaN(+view['zoom'])) {
              this.setZoom(+view['zoom'], { 'animation': false });
          }
          if (view['pitch'] !== null && !isNaN(+view['pitch'])) {
              this.setPitch(+view['pitch']);
          }
          if (view['bearing'] !== null && !isNaN(+view['bearing'])) {
              this.setBearing(+view['bearing']);
          }
          return this;
      };
      /**
       * Get map's resolution
       * @param {Number} zoom - zoom or current zoom if not given
       * @return {Number} resolution
       */
      Map.prototype.getResolution = function (zoom) {
          return this._getResolution(zoom);
      };
      /**
       * Get scale of resolutions from zoom to max zoom
       * @param {Number} zoom - zoom or current zoom if not given
       * @return {Number} scale
       */
      Map.prototype.getScale = function (zoom) {
          var z = (isNil(zoom) ? this.getZoom() : zoom);
          var max = this._getResolution(this.getMaxNativeZoom()), res = this._getResolution(z);
          return res / max;
      };
      /**
       * Get center by the padding.
       * @private
       * @param  {Coordinate} center
       * @param  {Number} zoom
       * @param  {Object} padding
       * @param  {Number} [padding.paddingLeft] - Sets the amount of padding in the left of a map container
       * @param  {Number} [padding.paddingTop] - Sets the amount of padding in the top of a map container
       * @param  {Number} [padding.paddingRight] - Sets the amount of padding in the right of a map container
       * @param  {Number} [padding.paddingBottom] - Sets the amount of padding in the bottom of a map container
       * @return {Coordinate}
       */
      //@internal
      Map.prototype._getCenterByPadding = function (center, zoom, padding) {
          var point = this.coordinateToPoint(center, zoom);
          var _a = padding || {}, _b = _a.paddingLeft, paddingLeft = _b === void 0 ? 0 : _b, _c = _a.paddingRight, paddingRight = _c === void 0 ? 0 : _c, _d = _a.paddingTop, paddingTop = _d === void 0 ? 0 : _d, _e = _a.paddingBottom, paddingBottom = _e === void 0 ? 0 : _e;
          var pX = 0;
          var pY = 0;
          if (paddingLeft || paddingRight) {
              pX = (paddingRight - paddingLeft) / 2;
          }
          if (paddingTop || paddingBottom) {
              pY = (paddingTop - paddingBottom) / 2;
          }
          var newPoint = new Point({
              x: point.x + pX,
              y: point.y + pY
          });
          return this.pointToCoordinate(newPoint, zoom);
      };
      /**
       * Set the map to be fit for the given extent with the max zoom level possible.
       * @param  {Extent} extent - extent
       * @param  {Number} zoomOffset - zoom offset
       * @param  {Object} [options={}] - options
       * @param  {Object} [options.animation]
       * @param  {Object} [options.duration]
       * @param  {Object} [options.zoomAnimationDuration]
       * @param  {Object} [options.easing='out']
       * @param  {Number} [options.paddingLeft] - Sets the amount of padding in the left of a map container
       * @param  {Number} [options.paddingTop] - Sets the amount of padding in the top of a map container
       * @param  {Number} [options.paddingRight] - Sets the amount of padding in the right of a map container
       * @param  {Number} [options.paddingBottom] - Sets the amount of padding in the bottom of a map container
       * @param  {Boolean} [options.isFraction=false] - can locate to fractional zoom
       * @param  {Function} step - step function for animation
       * @return {Map | player} - this
       */
      Map.prototype.fitExtent = function (extent, zoomOffset, options, step) {
          options = (options || {});
          if (!extent) {
              return this;
          }
          extent = new Extent(extent, this.getProjection());
          var zoom = this.getFitZoom(extent, options.isFraction || false, options) + (zoomOffset || 0);
          var center = extent.getCenter();
          if (this._getPaddingSize(options)) {
              center = this._getCenterByPadding(center, zoom, options);
          }
          if (typeof (options['animation']) === 'undefined' || options['animation'])
              return this._animateTo({
                  center: center,
                  zoom: zoom
              }, {
                  'duration': options['duration'] || this.options['zoomAnimationDuration'],
                  'easing': options['easing'] || 'out',
              }, step);
          else
              return this.setCenterAndZoom(center, zoom);
      };
      /**
       * Get the base layer of the map.
       * @return {Layer}
       */
      Map.prototype.getBaseLayer = function () {
          return this._baseLayer;
      };
      /**
       * Sets a new base layer to the map.<br>
       * Some events will be thrown such as baselayerchangestart, baselayerload, baselayerchangeend.
       * @param  {Layer} baseLayer - new base layer
       * @return {Map} this
       * @fires Map#setbaselayer
       * @fires Map#baselayerchangestart
       * @fires Map#baselayerchangeend
       */
      Map.prototype.setBaseLayer = function (baseLayer) {
          var isChange = false;
          if (this._baseLayer) {
              isChange = true;
              /**
               * baselayerchangestart event, fired when base layer is changed.
               *
               * @event Map#baselayerchangestart
               * @type {Object}
               * @property {String} type - baselayerchangestart
               * @property {Map} target - map
               */
              this._fireEvent('baselayerchangestart');
              this._baseLayer.remove();
          }
          if (!baseLayer) {
              delete this._baseLayer;
              /**
               * baselayerchangeend event, fired when base layer is changed.
               *
               * @event Map#baselayerchangeend
               * @type {Object}
               * @property {String} type - baselayerchangeend
               * @property {Map} target - map
               */
              this._fireEvent('baselayerchangeend');
              /**
               * setbaselayer event, fired when base layer is set.
               *
               * @event Map#setbaselayer
               * @type {Object}
               * @property {String} type - setbaselayer
               * @property {Map} target - map
               */
              this._fireEvent('setbaselayer');
              return this;
          }
          this._baseLayer = baseLayer;
          baseLayer._bindMap(this, -1);
          function onbaseLayerload() {
              /**
               * baselayerload event, fired when base layer is loaded.
               *
               * @event Map#baselayerload
               * @type {Object}
               * @property {String} type - baselayerload
               * @property {Map} target - map
               */
              this._fireEvent('baselayerload');
              if (isChange) {
                  isChange = false;
                  this._fireEvent('baselayerchangeend');
              }
          }
          this._baseLayer.on('layerload', onbaseLayerload, this);
          if (this._loaded) {
              this._baseLayer.load();
          }
          this._fireEvent('setbaselayer');
          return this;
      };
      /**
       * Remove the base layer from the map
       * @return {Map} this
       * @fires Map#baselayerremove
       */
      Map.prototype.removeBaseLayer = function () {
          if (this._baseLayer) {
              this._baseLayer.remove();
              delete this._baseLayer;
              /**
               * baselayerremove event, fired when base layer is removed.
               *
               * @event Map#baselayerremove
               * @type {Object}
               * @property {String} type - baselayerremove
               * @property {Map} target - map
               */
              this._fireEvent('baselayerremove');
          }
          return this;
      };
      /**
       * Get the layers of the map, except base layer (which should be by getBaseLayer). <br>
       * A filter function can be given to filter layers, e.g. exclude all the VectorLayers.
       * @param {Function} [filter=undefined] - a filter function of layers, return false to exclude the given layer.
       * @return {Layer[]}
       * @example
       * var vectorLayers = map.getLayers(function (layer) {
       *     return (layer instanceof VectorLayer);
       * });
       */
      Map.prototype.getLayers = function (filter) {
          return this._getLayers(function (layer) {
              if (layer === this._baseLayer || layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0) {
                  return false;
              }
              if (filter) {
                  return filter(layer);
              }
              return true;
          });
      };
      /**
       * Get the layer with the given id.
       * @param  {String} id - layer id
       * @return {Layer}
       */
      Map.prototype.getLayer = function (id) {
          if (!id) {
              return null;
          }
          var layer = this._layerCache ? this._layerCache[id] : null;
          if (layer) {
              return layer;
          }
          var baseLayer = this.getBaseLayer();
          if (baseLayer && baseLayer.getId() === id) {
              return baseLayer;
          }
          return null;
      };
      /**
       * Add a new layer on the top of the map.
       * @param  {Layer|Layer[]} layer - one or more layers to add
       * @return {Map} this
       * @fires Map#addlayer
       */
      Map.prototype.addLayer = function (layers) {
          var otherLayers = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              otherLayers[_i - 1] = arguments[_i];
          }
          if (!layers) {
              return this;
          }
          if (!Array.isArray(layers)) {
              layers = [layers];
              // layers = Array.prototype.slice.call(arguments, 0);
              // return this.addLayer(layers);
          }
          if (otherLayers && otherLayers.length) {
              layers = layers.concat(otherLayers);
          }
          if (!this._layerCache) {
              this._layerCache = {};
          }
          var mapLayers = this._layers;
          for (var i = 0, len = layers.length; i < len; i++) {
              var layer = layers[i];
              var id = layer.getId();
              if (isNil(id)) {
                  throw new Error('Invalid id for the layer: ' + id);
              }
              if (layer.getMap() === this) {
                  continue;
              }
              if (this._layerCache[id]) {
                  throw new Error('Duplicate layer id in the map: ' + id);
              }
              this._layerCache[id] = layer;
              layer._bindMap(this);
              mapLayers.push(layer);
              if (this._loaded) {
                  layer.load();
              }
          }
          this._sortLayersByZIndex();
          /**
           * addlayer event, fired when adding layers.
           *
           * @event Map#addlayer
           * @type {Object}
           * @property {String} type - addlayer
           * @property {Map} target - map
           * @property {Layer[]} layers - layers to add
           */
          this._fireEvent('addlayer', {
              'layers': layers
          });
          return this;
      };
      /**
       * Remove a layer from the map
       * @param  {String|String[]|Layer|Layer[]} layer - one or more layers or layer ids
       * @return {Map} this
       * @fires Map#removelayer
       */
      Map.prototype.removeLayer = function (layers) {
          if (!layers) {
              return this;
          }
          if (!Array.isArray(layers)) {
              return this.removeLayer([layers]);
          }
          var removed = [];
          for (var i = 0, len = layers.length; i < len; i++) {
              var layer = layers[i];
              if (!(layer instanceof Layer)) {
                  layer = this.getLayer(layer);
              }
              if (!layer) {
                  continue;
              }
              var map = layer.getMap();
              if (!map || map !== this) {
                  continue;
              }
              removed.push(layer);
              this._removeLayer(layer, this._layers);
              if (this._loaded) {
                  layer._doRemove();
              }
              var id = layer.getId();
              if (this._layerCache) {
                  delete this._layerCache[id];
              }
          }
          if (removed.length > 0) {
              var renderer = this.getRenderer();
              if (renderer) {
                  renderer.setLayerCanvasUpdated();
              }
              this.once('frameend', function () {
                  removed.forEach(function (layer) {
                      layer.fire('remove');
                  });
              });
          }
          /**
           * removelayer event, fired when removing layers.
           *
           * @event Map#removelayer
           * @type {Object}
           * @property {String} type - removelayer
           * @property {Map} target - map
           * @property {Layer[]} layers - layers to remove
           */
          this._fireEvent('removelayer', {
              'layers': layers
          });
          return this;
      };
      /**
       * Sort layers according to the order provided, the last will be on the top.
       * @param  {string[]|Layer[]} layers - layers or layer ids to sort
       * @return {Map} this
       * @example
       * map.addLayer([layer1, layer2, layer3]);
       * map.sortLayers([layer2, layer3, layer1]);
       * map.sortLayers(['3', '2', '1']); // sort by layer ids.
       */
      Map.prototype.sortLayers = function (layers) {
          if (!layers || !Array.isArray(layers)) {
              return this;
          }
          var layersToOrder = [];
          var minZ = Number.MAX_VALUE;
          for (var i = 0, l = layers.length; i < l; i++) {
              var layer = layers[i];
              if (isString(layers[i])) {
                  layer = this.getLayer(layer);
              }
              if (!(layer instanceof Layer) || !layer.getMap() || layer.getMap() !== this) {
                  throw new Error('It must be a layer added to this map to order.');
              }
              if (layer.getZIndex() < minZ) {
                  minZ = layer.getZIndex();
              }
              layersToOrder.push(layer);
          }
          for (var i = 0, l = layersToOrder.length; i < l; i++) {
              layersToOrder[i].setZIndex(minZ + i);
          }
          return this;
      };
      /**
       * Exports image from the map's canvas.
       * @param {Object} [options=undefined] - options
       * @param {String} [options.mimeType=image/png] - mime type of the image: image/png, image/jpeg, image/webp
       * @param {String} [options.quality=0.92] - A Number between 0 and 1 indicating the image quality to use for image formats that use lossy compression such as image/jpeg and image/webp.
       * @param {Boolean} [options.save=false] - whether pop a file save dialog to save the export image.
       * @param {String} [options.fileName=export] - specify the file name, if options.save is true.
       * @return {String} image of base64 format.
       */
      Map.prototype.toDataURL = function (options) {
          if (!options) {
              options = {};
          }
          var mimeType = options['mimeType'];
          if (!mimeType) {
              mimeType = 'image/png';
          }
          var save = options['save'];
          var renderer = this._getRenderer();
          if (renderer && renderer.toDataURL) {
              var file = options['fileName'];
              if (!file) {
                  file = 'export';
              }
              var dataURL = renderer.toDataURL(mimeType, options.quality || 0.92);
              if (save && dataURL) {
                  var imgURL = void 0;
                  if (typeof Blob !== 'undefined' && typeof atob !== 'undefined') {
                      var blob = b64toBlob(dataURL.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, ''), mimeType);
                      imgURL = URL.createObjectURL(blob);
                  }
                  else {
                      imgURL = dataURL;
                  }
                  var dlLink = document.createElement('a');
                  dlLink.download = file;
                  dlLink.href = imgURL;
                  document.body.appendChild(dlLink);
                  dlLink.click();
                  document.body.removeChild(dlLink);
              }
              return dataURL;
          }
          return null;
      };
      /**
       * shorter alias for coordinateToPoint
       */
      Map.prototype.coordToPoint = function (coordinate, zoom, out) {
          return this.coordinateToPoint(coordinate, zoom, out);
      };
      /**
       * shorter alias for coordinateToPointAtRes
       */
      Map.prototype.coordToPointAtRes = function (coordinate, res, out) {
          return this.coordinateToPointAtRes(coordinate, res, out);
      };
      /**
       * shorter alias for pointToCoordinate
       */
      Map.prototype.pointToCoord = function (point, zoom, out) {
          return this.pointToCoordinate(point, zoom, out);
      };
      /**
       * shorter alias for pointAtResToCoordinate
       */
      Map.prototype.pointAtResToCoord = function (point, res, out) {
          return this.pointAtResToCoordinate(point, res, out);
      };
      /**
       * shorter alias for coordinateToViewPoint
       */
      Map.prototype.coordToViewPoint = function (coordinate, out, altitude) {
          return this.coordinateToViewPoint(coordinate, out, altitude);
      };
      /**
       * shorter alias for viewPointToCoordinate
       */
      Map.prototype.viewPointToCoord = function (viewPoint, out) {
          return this.viewPointToCoordinate(viewPoint, out);
      };
      /**
       * shorter alias for coordinateToContainerPoint
       */
      Map.prototype.coordToContainerPoint = function (coordinate, zoom, out) {
          return this.coordinateToContainerPoint(coordinate, zoom, out);
      };
      /**
       * shorter alias for containerPointToCoordinate
       */
      Map.prototype.containerPointToCoord = function (containerPoint, out) {
          return this.containerPointToCoordinate(containerPoint, out);
      };
      /**
       * Converts a container point to the view point.
       * Usually used in plugin development.
       * @param {Point}
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @returns {Point}
       */
      Map.prototype.containerPointToViewPoint = function (containerPoint, out) {
          if (out) {
              out.set(containerPoint.x, containerPoint.y);
          }
          else {
              out = containerPoint.copy();
          }
          return out._sub(this.getViewPoint());
      };
      /**
       * Converts a view point to the container point.
       * Usually used in plugin development.
       * @param {Point}
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @returns {Point}
       */
      Map.prototype.viewPointToContainerPoint = function (viewPoint, out) {
          if (out) {
              out.set(viewPoint.x, viewPoint.y);
          }
          else {
              out = viewPoint.copy();
          }
          return out._add(this.getViewPoint());
      };
      /**
       * Checks if the map container size changed and updates the map if so.
       * @return {Map} this
       * @fires Map#resize
       */
      Map.prototype.checkSize = function (force) {
          var justStart = ((now() - this._initTime) < 1500) && this.width === 0 || this.height === 0;
          var watched = this._getContainerDomSize(), oldHeight = this.height, oldWidth = this.width;
          if (!force && watched['width'] === oldWidth && watched['height'] === oldHeight) {
              return this;
          }
          // refresh map's dom position
          computeDomPosition(this._containerDOM);
          var center = this.getCenter();
          if (!this.options['fixCenterOnResize']) {
              // fix northwest's geo coordinate
              var vh = this._getVisualHeight(this.getPitch());
              var nwCP = new Point(0, this.height - vh);
              var nwCoord = this._containerPointToPrj(nwCP);
              this._updateMapSize(watched);
              var vhAfter = this._getVisualHeight(this.getPitch());
              var nwCPAfter = new Point(0, this.height - vhAfter);
              this._setPrjCoordAtContainerPoint(nwCoord, nwCPAfter);
              // when size changed, center is updated but panel's offset remains.
              this._mapViewCoord = this._getPrjCenter();
          }
          else {
              this._updateMapSize(watched);
          }
          var hided = (watched['width'] === 0 || watched['height'] === 0 || oldWidth === 0 || oldHeight === 0);
          if (justStart || hided) {
              this._eventSilence = true;
              this.setCenter(center);
              delete this._eventSilence;
          }
          /**
           * resize event when map container's size changes
           * @event Map#resize
           * @type {Object}
           * @property {String} type - resize
           * @property {Map} target - map fires the event
           */
          this._fireEvent('resize');
          return this;
      };
      /**
       * Computes the coordinate from the given meter distance.
       * @param  {Coordinate} coordinate - source coordinate
       * @param  {Number} dx           - meter distance on X axis
       * @param  {Number} dy           - meter distance on Y axis
       * @return {Coordinate} Result coordinate
       */
      Map.prototype.locate = function (coordinate, dx, dy) {
          return this.getProjection()._locate(new Coordinate(coordinate), dx, dy);
      };
      /**
       * Return map's main panel
       * @returns {HTMLElement}
       */
      Map.prototype.getMainPanel = function () {
          var renderer = this._getRenderer();
          if (!renderer) {
              return null;
          }
          return renderer.getMainPanel();
      };
      /**
       * Returns map panels.
       * @return {Object}
       */
      Map.prototype.getPanels = function () {
          return this._panels;
      };
      /**
       * Remove the map
       * @return {Map} this
       */
      Map.prototype.remove = function () {
          var _this = this;
          if (this.isRemoved()) {
              return this;
          }
          this._fireEvent('removestart');
          this._removeDomEvents();
          this._clearHandlers();
          this.removeBaseLayer();
          var layers = this.getLayers();
          for (var i = 0; i < layers.length; i++) {
              layers[i].remove();
          }
          if (this._getRenderer()) {
              this._getRenderer().remove();
          }
          if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0) {
              Array.prototype.slice.call(this._containerDOM.childNodes, 0)
                  .filter(function (node) { return node.className === 'maptalks-wrapper'; })
                  .forEach(function (node) { return _this._containerDOM.removeChild(node); });
          }
          delete this._panels;
          delete this._containerDOM;
          delete this._renderer;
          this._fireEvent('removeend');
          this._clearAllListeners();
          return this;
      };
      /**
       * whether the map is removed
       * @return {Boolean}
       */
      Map.prototype.isRemoved = function () {
          return !this._containerDOM;
      };
      /**
       * Whether the map is moving
       * @return {Boolean}
       */
      Map.prototype.isMoving = function () {
          return !!this._moving;
      };
      /**
       * The callback function when move started
       * @private
       * @fires Map#movestart
       */
      Map.prototype.onMoveStart = function (param) {
          if (this._mapAnimPlayer) {
              this._stopAnim(this._mapAnimPlayer);
          }
          var prjCenter = this._getPrjCenter();
          if (!this._originCenter || this._verifyExtent(prjCenter)) {
              this._originCenter = prjCenter;
          }
          this._moving = true;
          this._trySetCursor('move');
          /**
           * movestart event
           * @event Map#movestart
           * @type {Object}
           * @property {String} type - movestart
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('movestart', this._parseEvent(param ? param['domEvent'] : null, 'movestart'));
      };
      Map.prototype.onMoving = function (param) {
          /**
           * moving event
           * @event Map#moving
           * @type {Object}
           * @property {String} type - moving
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('moving', this._parseEvent(param ? param['domEvent'] : null, 'moving'));
          this._limitMaxExtent();
      };
      Map.prototype.onMoveEnd = function (param) {
          this._moving = false;
          if (!this._suppressRecenter) {
              this._recenterOnTerrain();
          }
          this._trySetCursor('default');
          /**
           * moveend event
           * @event Map#moveend
           * @type {Object}
           * @property {String} type - moveend
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('moveend', (param && param['domEvent']) ? this._parseEvent(param['domEvent'], 'moveend') : param);
          if (!this._verifyExtent(this._getPrjCenter()) && this._originCenter && !this.options.limitExtentOnMaxExtent) {
              var moveTo_1 = this._originCenter;
              this._panTo(moveTo_1);
          }
          this._limitMaxExtent();
      };
      Map.prototype.onDragRotateStart = function (param) {
          this._dragRotating = true;
          /**
           * dragrotatestart event
           * @event Map#dragrotatestart
           * @type {Object}
           * @property {String} type - dragrotatestart
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('dragrotatestart', this._parseEvent(param ? param['domEvent'] : null, 'dragrotatestart'));
      };
      Map.prototype.onDragRotating = function (param) {
          /**
           * dragrotating event
           * @event Map#dragrotating
           * @type {Object}
           * @property {String} type - dragrotating
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('dragrotating', this._parseEvent(param ? param['domEvent'] : null, 'dragrotating'));
      };
      Map.prototype.onDragRotateEnd = function (param) {
          this._dragRotating = false;
          /**
           * dragrotateend event
           * @event Map#dragrotateend
           * @type {Object}
           * @property {String} type - dragrotateend
           * @property {Map} target - map fires the event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('dragrotateend', this._parseEvent(param ? param['domEvent'] : null, 'dragrotateend'));
      };
      Map.prototype.isDragRotating = function () {
          return !!this._dragRotating;
      };
      /**
       * Test if given box is out of current screen
       * @param {Number[] | PointExtent} box - [minx, miny, maxx, maxy]
       * @param {Number} padding - test padding
       * @returns {Boolean}
       */
      Map.prototype.isOffscreen = function (box, viewportPadding) {
          var _a;
          if (viewportPadding === void 0) { viewportPadding = 0; }
          var _b = this, width = _b.width, height = _b.height;
          var screenRightBoundary = width + viewportPadding;
          var screenBottomBoundary = height + viewportPadding;
          var _c = box, xmin = _c.xmin, ymin = _c.ymin, xmax = _c.xmax, ymax = _c.ymax;
          if (Array.isArray(box)) {
              _a = __read(box, 4), xmin = _a[0], ymin = _a[1], xmax = _a[2], ymax = _a[3];
          }
          return xmax < viewportPadding || xmin >= screenRightBoundary || ymax < viewportPadding || ymin > screenBottomBoundary;
      };
      Map.prototype.getRenderer = function () {
          return this._getRenderer();
      };
      /**
       * Get map's devicePixelRatio, you can override it by setting devicePixelRatio in options.
       * @returns {Number}
       */
      Map.prototype.getDevicePixelRatio = function () {
          return this.options['devicePixelRatio'] || Browser$1.devicePixelRatio || 1;
      };
      /**
       * Set map's devicePixelRatio
       * @param {Number} dpr
       * @returns {Map} this
       */
      Map.prototype.setDevicePixelRatio = function (dpr) {
          if (isNumber(dpr) && dpr > 0 && dpr !== this.options['devicePixelRatio']) {
              this.options['devicePixelRatio'] = dpr;
              this.checkSize(true);
          }
          return this;
      };
      //-----------------------------------------------------------
      //@internal
      Map.prototype._initContainer = function (container) {
          if (isString(container)) {
              this._containerDOM = document.getElementById(container);
              if (!this._containerDOM) {
                  throw new Error('Invalid container when creating map: \'' + container + '\'');
              }
          }
          else {
              this._containerDOM = container;
              if (IS_NODE) {
                  //Reserve container's constructor in node for canvas creating.
                  this.CanvasClass = this._containerDOM.constructor;
              }
          }
          if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0) {
              //@ts-expect-error I don't know either
              if (this._containerDOM.childNodes[0].className === 'maptalks-wrapper') {
                  throw new Error('Container is already loaded with another map instance, use map.remove() to clear it.');
              }
          }
      };
      /**
       * try to change cursor when map is not setCursored
       * @private
       * @param  {String} cursor css cursor
       */
      //@internal
      Map.prototype._trySetCursor = function (cursor) {
          if (!this._cursor && !this._priorityCursor) {
              if (!cursor) {
                  cursor = 'default';
              }
              this._setCursorToPanel(cursor);
          }
          return this;
      };
      //@internal
      Map.prototype._setPriorityCursor = function (cursor) {
          if (!cursor) {
              var hasCursor = false;
              if (this._priorityCursor) {
                  hasCursor = true;
              }
              delete this._priorityCursor;
              if (hasCursor) {
                  this.setCursor(this._cursor);
              }
          }
          else {
              this._priorityCursor = cursor;
              this._setCursorToPanel(cursor);
          }
          return this;
      };
      //@internal
      Map.prototype._setCursorToPanel = function (cursor) {
          var panel = this.getMainPanel();
          if (panel && panel.style && panel.style.cursor !== cursor) {
              panel.style.cursor = cursor;
          }
      };
      //remove a layer from the layerList
      //@internal
      Map.prototype._removeLayer = function (layer, layerList) {
          if (!layer || !layerList) {
              return;
          }
          var index = layerList.indexOf(layer);
          if (index > -1) {
              layerList.splice(index, 1);
          }
      };
      //@internal
      Map.prototype._sortLayersByZIndex = function () {
          if (!this._layers) {
              return;
          }
          for (var i = 0, l = this._layers.length; i < l; i++) {
              // this._layers[i]._order = i;
              var layer = this._layers[i];
              layer._order = i;
              if (layer.sortLayersByZIndex) {
                  layer.sortLayersByZIndex();
              }
          }
          this._layers.sort(function (a, b) {
              var c = a.getZIndex() - b.getZIndex();
              if (c === 0) {
                  return a._order - b._order;
              }
              return c;
          });
      };
      //@internal
      Map.prototype._fireEvent = function (eventName, param) {
          if (this._eventSilence) {
              return;
          }
          //fire internal events at first
          var underline = '_';
          if (eventName[0] !== underline) {
              this.fire(underline + eventName, param);
          }
          this.fire(eventName, param);
      };
      //@internal
      Map.prototype._Load = function () {
          this._resetMapStatus();
          if (this.options['pitch']) {
              this.setPitch(this.options['pitch']);
              delete this.options['pitch'];
          }
          if (this.options['bearing']) {
              this.setBearing(this.options['bearing']);
              delete this.options['bearing'];
          }
          delete this._glRes;
          this._loadAllLayers();
          this._getRenderer().onLoad();
          this._loaded = true;
          this._callOnLoadHooks();
          this._initTime = now();
      };
      //@internal
      Map.prototype._initRenderer = function () {
          var renderer = this.options['renderer'];
          var clazz = Map.getRendererClass(renderer);
          this._renderer = new clazz(this);
          this._renderer.load();
      };
      //@internal
      Map.prototype._getRenderer = function () {
          return this._renderer;
      };
      //@internal
      Map.prototype._loadAllLayers = function () {
          function loadLayer(layer) {
              if (layer) {
                  layer.load();
              }
          }
          if (this._baseLayer) {
              this._baseLayer.load();
          }
          this._eachLayer(loadLayer, this.getLayers());
      };
      /**
       * Gets layers that fits for the filter
       * @param  {fn} filter - filter function
       * @return {Layer[]}
       * @private
       */
      //@internal
      Map.prototype._getLayers = function (filter) {
          var layers = this._baseLayer ? [this._baseLayer].concat(this._layers) : this._layers;
          var result = [];
          for (var i = 0; i < layers.length; i++) {
              if (!filter || filter.call(this, layers[i])) {
                  result.push(layers[i]);
              }
          }
          return result;
      };
      //@internal
      Map.prototype._eachLayer = function (fn) {
          var layerLists = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              layerLists[_i - 1] = arguments[_i];
          }
          if (arguments.length < 2) {
              return;
          }
          // let layerLists = Array.prototype.slice.call(arguments, 1);
          if (layerLists && !Array.isArray(layerLists)) {
              layerLists = [layerLists];
          }
          var layers = [];
          for (var i = 0, len = layerLists.length; i < len; i++) {
              layers = layers.concat(layerLists[i]);
          }
          for (var j = 0, jlen = layers.length; j < jlen; j++) {
              fn.call(fn, layers[j]);
          }
      };
      //@internal
      Map.prototype._onLayerEvent = function (param) {
          if (!param) {
              return;
          }
          if (param['type'] === 'idchange') {
              delete this._layerCache[param['old']];
              this._layerCache[param['new']] = param['target'];
          }
      };
      //Check and reset map's status when map's spatial reference is changed.
      //@internal
      Map.prototype._resetMapStatus = function () {
          var maxZoom = this.getMaxZoom(), minZoom = this.getMinZoom();
          var viewMaxZoom = this._spatialReference.getMaxZoom(), viewMinZoom = this._spatialReference.getMinZoom();
          if (isNil(maxZoom) || maxZoom === -1 || maxZoom > viewMaxZoom) {
              this.setMaxZoom(viewMaxZoom);
          }
          if (isNil(minZoom) || minZoom === -1 || minZoom < viewMinZoom) {
              this.setMinZoom(viewMinZoom);
          }
          maxZoom = this.getMaxZoom();
          minZoom = this.getMinZoom();
          if (maxZoom < minZoom) {
              this.setMaxZoom(minZoom);
          }
          if (isNil(this._zoomLevel) || this._zoomLevel > maxZoom) {
              this._zoomLevel = maxZoom;
          }
          if (this._zoomLevel < minZoom) {
              this._zoomLevel = minZoom;
          }
          delete this._prjCenter;
          delete this._glRes;
          var projection = this.getProjection();
          this._prjCenter = projection.project(this._center);
          this._prjCenter.z = this._center.z;
          this._calcMatrices();
          var renderer = this._getRenderer();
          if (renderer) {
              renderer.resetContainer();
          }
      };
      Map.prototype.setContainerDomRect = function (domRect) {
          this._containerDomContentRect = domRect;
      };
      //@internal
      Map.prototype._getContainerDomSize = function () {
          if (!this._containerDOM) {
              return null;
          }
          var containerDOM = this._containerDOM;
          var width, height;
          if (this._containerDomContentRect) {
              width = this._containerDomContentRect.width;
              height = this._containerDomContentRect.height;
              return new Size(width, height);
          }
          //is Canvas
          var canvasDom = containerDOM;
          if (!isNil(canvasDom.width) && !isNil(canvasDom.height)) {
              width = canvasDom.width;
              height = canvasDom.height;
              var dpr = this.getDevicePixelRatio();
              if (dpr !== 1 && containerDOM['layer']) {
                  //is a canvas tile of CanvasTileLayer
                  width /= dpr;
                  height /= dpr;
              }
          }
          else if (!isNil(containerDOM.clientWidth) && !isNil(containerDOM.clientHeight)) {
              width = parseInt(containerDOM.clientWidth + '', 0);
              height = parseInt(containerDOM.clientHeight + '', 0);
          }
          else {
              throw new Error('can not get size of container');
          }
          return new Size(width, height);
      };
      //@internal
      Map.prototype._updateMapSize = function (mSize) {
          this.width = mSize['width'];
          this.height = mSize['height'];
          this._getRenderer().updateMapSize(mSize);
          this._calcMatrices();
          return this;
      };
      /**
       * Gets projected center of the map
       * @return {Coordinate}
       * @private
       */
      //@internal
      Map.prototype._getPrjCenter = function () {
          return this._prjCenter;
      };
      //@internal
      Map.prototype._setPrjCenter = function (pcenter) {
          this._prjCenter = pcenter;
          if (this.isInteracting() && !this.isMoving()) {
              // when map is not moving, map's center is updated but map platform won't
              // mapViewCoord needs to be synced
              this._mapViewCoord = pcenter;
          }
          this._calcMatrices();
      };
      //@internal
      Map.prototype._setPrjCoordAtContainerPoint = function (coordinate, point) {
          if (!this.centerAltitude && point.x === this.width / 2 && point.y === this.height / 2) {
              return this;
          }
          var p = this._containerPointToPoint(point);
          var t = p._sub(this._prjToPoint(this._getPrjCenter()));
          var pcenter = this._pointToPrj(this._prjToPoint(coordinate)._sub(t));
          this._setPrjCenter(pcenter);
          return this;
      };
      //@internal
      Map.prototype._setPrjCoordAtOffsetToCenter = function (prjCoord, offset) {
          var pcenter = this._pointToPrj(this._prjToPoint(prjCoord)._sub(offset));
          this._setPrjCenter(pcenter);
          return this;
      };
      //@internal
      Map.prototype._verifyExtent = function (prjCenter) {
          if (!prjCenter) {
              return false;
          }
          var maxExt = this._prjMaxExtent;
          if (!maxExt) {
              return true;
          }
          return maxExt.contains(prjCenter);
      };
      //@internal
      Map.prototype._limitMaxExtent = function () {
          var _this = this;
          if (this._limitMaxExtenting || !this.options.limitExtentOnMaxExtent) {
              return this;
          }
          var maxPrjExtent = this._prjMaxExtent;
          var maxExtent = this.getMaxExtent();
          if (!maxPrjExtent || !maxExtent) {
              return this;
          }
          var prjCoords = maxPrjExtent.toArray();
          var points = prjCoords.map(function (prjCoord) {
              return _this.prjToContainerPoint(prjCoord);
          });
          //屏幕坐标包围盒
          var maxExtentBBOX = getDefaultBBOX();
          pointsBBOX(points, maxExtentBBOX);
          var _a = this.getSize(), width = _a.width, height = _a.height;
          var mapBBOX = [0, 0, width, height];
          if (bboxInBBOX(mapBBOX, maxExtentBBOX)) {
              return this;
          }
          //maxExtent完全在当前视野内
          if (bboxInBBOX(maxExtentBBOX, mapBBOX)) {
              return this;
          }
          var translateX = 0, translateY = 0;
          var offsetleft = 0, offsetright = 0, offsettop = 0, offsetbottom = 0;
          var abs = Math.abs;
          var _b = __read(maxExtentBBOX, 4), left = _b[0], top = _b[1], right = _b[2], bottom = _b[3];
          //left overflow
          if (left > 0 && right > width) {
              translateX = offsetleft = abs(left);
          }
          if (left < 0 && right < width) {
              translateX = offsetleft = -abs(left);
          }
          //right overflow
          if (left < 0 && right < width) {
              translateX = offsetright = -abs(width - right);
          }
          if (left > 0 && right > width) {
              translateX = offsetright = abs(width - right);
          }
          //top overflow
          if (top > 0 && bottom > height) {
              translateY = offsettop = abs(top);
          }
          if (top < 0 && bottom < height) {
              translateY = offsettop = -abs(top);
          }
          //bottom overflow
          if (top < 0 && bottom < height) {
              translateY = offsetbottom = -abs(height - bottom);
          }
          if (top > 0 && bottom > height) {
              translateY = offsetbottom = abs(height - bottom);
          }
          //同时溢出取最小的值,四周最近距离吸附
          if (offsetleft !== 0 && offsetright !== 0) {
              translateX = offsetleft;
              if (abs(offsetright) < abs(offsetleft)) {
                  translateX = offsetright;
              }
          }
          if (offsettop !== 0 && offsetbottom !== 0) {
              translateY = offsettop;
              if (abs(offsetbottom) < abs(offsettop)) {
                  translateY = offsetbottom;
              }
          }
          if (translateX !== 0 || translateY !== 0) {
              var point = new Point(width / 2 + translateX, height / 2 + translateY);
              var center = this.containerPointToCoord(point);
              this._limitMaxExtenting = true;
              this.setCenter(center);
              this._limitMaxExtenting = false;
          }
          return this;
      };
      /**
       * Move map's center by pixels.
       * @param  {Point} pixel - pixels to move, the relation between value and direction is as:
       * -1,1 | 1,1
       * ------------
       *-1,-1 | 1,-1
       * @
       * @returns {Coordinate} the new projected center.
       */
      //@internal
      Map.prototype._offsetCenterByPixel = function (pixel) {
          var pos = TEMP_POINT$5.set(this.width / 2 - pixel.x, this.height / 2 - pixel.y);
          var coord = this._containerPointToPrj(pos, TEMP_COORD$2);
          var containerCenter = TEMP_POINT$5.set(this.width / 2, this.height / 2);
          this._setPrjCoordAtContainerPoint(coord, containerCenter);
      };
      /**
       * offset map panels.
       *
       * @param  {Point} offset - offset in pixel to move
       * @return {Map} this
       */
      /**
       * Gets map panel's current view point.
       * @return {Point}
       */
      Map.prototype.offsetPlatform = function (offset) {
          if (!offset) {
              return this._mapViewPoint;
          }
          else {
              this._getRenderer().offsetPlatform(offset);
              this._mapViewCoord = this._getPrjCenter();
              this._mapViewPoint = this._mapViewPoint.add(offset);
              return this._mapViewPoint;
          }
      };
      /**
       * Get map's view point, adding in frame offset
       * @return {Point} map view point
       */
      Map.prototype.getViewPoint = function () {
          var offset = this.getViewPointFrameOffset();
          var panelOffset = this.offsetPlatform();
          if (offset) {
              panelOffset = panelOffset.add(offset);
          }
          return panelOffset;
      };
      //@internal
      Map.prototype._resetMapViewPoint = function () {
          this._mapViewPoint = new Point(0, 0);
          // mapViewCoord is the proj coordinate of current view point
          this._mapViewCoord = this._getPrjCenter();
      };
      /**
       * Get map's current resolution
       * @return {Number} resolution
       * @private
       */
      //@internal
      Map.prototype._getResolution = function (zoom) {
          if ((zoom === undefined || zoom === this._zoomLevel) && this._mapRes !== undefined) {
              return this._mapRes;
          }
          if (isNil(zoom)) {
              zoom = this._zoomLevel;
          }
          return this._spatialReference.getResolution(zoom);
      };
      //@internal
      Map.prototype._getResolutions = function () {
          return this._spatialReference.getResolutions();
      };
      /**
       * Converts the projected coordinate to a 2D point in the specific zoom
       * @param  {Coordinate} pCoord - projected Coordinate
       * @param  {Number} zoom   - point's zoom level
       * @return {Point} 2D point
       * @private
       */
      //@internal
      Map.prototype._prjToPoint = function (pCoord, zoom, out) {
          zoom = (isNil(zoom) ? this.getZoom() : zoom);
          var res = this._getResolution(zoom);
          return this._prjToPointAtRes(pCoord, res, out);
      };
      //@internal
      Map.prototype._prjToPointAtRes = function (pCoord, res, out) {
          return this._spatialReference.getTransformation().transform(pCoord, res, out);
      };
      /**
       * Converts the projected coordinate to a 2D point in the specific resolution
       * @param  {Coordinate} pCoord - projected Coordinate
       * @param  {Number} res   - point's resolution
       * @return {Point} 2D point
       * @private
       * @internal
       */
      Map.prototype._prjsToPointsAtRes = function (pCoords, res, resultPoints) {
          if (resultPoints === void 0) { resultPoints = []; }
          var transformation = this._spatialReference.getTransformation();
          var pts = [];
          for (var i = 0, len = pCoords.length; i < len; i++) {
              var pt = transformation.transform(pCoords[i], res, resultPoints[i]);
              pts.push(pt);
          }
          return pts;
      };
      /**
       * Converts the 2D point to projected coordinate
       * @param  {Point} point - 2D point
       * @param  {Number} zoom   - point's zoom level
       * @return {Coordinate} projected coordinate
       * @private
       */
      //@internal
      Map.prototype._pointToPrj = function (point, zoom, out) {
          zoom = (isNil(zoom) ? this.getZoom() : zoom);
          var res = this._getResolution(zoom);
          return this._pointToPrjAtRes(point, res, out);
      };
      //@internal
      Map.prototype._pointToPrjAtRes = function (point, res, out) {
          return this._spatialReference.getTransformation().untransform(point, res, out);
      };
      /**
       * Convert point at zoom to point at current zoom
       * @param  {Point} point point
       * @param  {Number} zoom point's zoom
       * @return {Point} point at current zoom
       * @private
       */
      //@internal
      Map.prototype._pointToPoint = function (point, zoom, out) {
          if (!isNil(zoom)) {
              return this._pointAtResToPoint(point, this._getResolution(zoom), out);
          }
          if (out) {
              out.x = point.x;
              out.y = point.y;
          }
          else {
              out = point.copy();
          }
          return out;
      };
      //@internal
      Map.prototype._pointAtResToPoint = function (point, res, out) {
          if (out) {
              out.x = point.x;
              out.y = point.y;
          }
          else {
              out = point.copy();
          }
          return out._multi(res / this._getResolution());
      };
      /**
       * Convert point at current zoom to point at target res
       * @param  {Point} point point
       * @param  {Number} res target res
       * @return {Point} point at target res
       * @private
       */
      //@internal
      Map.prototype._pointToPointAtRes = function (point, res, out) {
          if (out) {
              out.x = point.x;
              out.y = point.y;
          }
          else {
              out = point.copy();
          }
          return out._multi(this._getResolution() / res);
      };
      /**
       * transform container point to geographical projected coordinate
       *
       * @param  {Point} containerPoint
       * @return {Coordinate}
       * @private
       */
      //@internal
      Map.prototype._containerPointToPrj = function (containerPoint, out) {
          return this._pointToPrj(this._containerPointToPoint(containerPoint, undefined, out), undefined, out);
      };
      /* eslint no-extend-native: 0 */
      //@internal
      Map.prototype._callOnLoadHooks = function () {
          var proto = Map.prototype;
          if (!proto._onLoadHooks) {
              return;
          }
          for (var i = 0, l = proto._onLoadHooks.length; i < l; i++) {
              proto._onLoadHooks[i].call(this);
          }
      };
      //fix prj value when current view is world wide
      //@internal
      Map.prototype._fixPrjOnWorldWide = function (prjCoord) {
          var projection = this.getProjection();
          if (projection && projection.fullExtent && prjCoord) {
              var _a = projection.fullExtent || {}, left = _a.left, bottom = _a.bottom, top_1 = _a.top, right = _a.right;
              if (isNumber(left)) {
                  prjCoord.x = Math.max(left, prjCoord.x);
              }
              if (isNumber(right)) {
                  prjCoord.x = Math.min(right, prjCoord.x);
              }
              if (isNumber(bottom)) {
                  prjCoord.y = Math.max(bottom, prjCoord.y);
              }
              if (isNumber(top_1)) {
                  prjCoord.y = Math.min(top_1, prjCoord.y);
              }
          }
          return this;
      };
      /**
       * Export the map's json, a snapshot of the map in JSON format.<br>
       * It can be used to reproduce the instance by [fromJSON]{@link Map#fromJSON} method
       * @param  {Object} [options=null] - export options
       * @param  {Boolean|Object} [options.baseLayer=null] - whether to export base layer's JSON, if yes, it will be used as layer's toJSON options.
       * @param  {Boolean|Extent} [options.clipExtent=null] - if set with an extent instance, only the geometries intersectes with the extent will be exported.
       *                                                             If set to true, map's current extent will be used.
       * @param  {Boolean|Object|Object[]} [options.layers=null] - whether to export other layers' JSON, if yes, it will be used as layer's toJSON options.
       *                                                        It can also be an array of layer export options with a "id" attribute to filter the layers to export.
       * @return {Object} layer's JSON
       */
      Map.prototype.toJSON = function (options) {
          if (!options) {
              options = {};
          }
          var json = {
              'jsonVersion': this['JSON_VERSION'],
              'version': this.VERSION,
              'extent': this.getExtent().toJSON()
          };
          json['options'] = this.config();
          json['options']['center'] = this.getCenter();
          json['options']['zoom'] = this.getZoom();
          json['options']['bearing'] = this.getBearing();
          json['options']['pitch'] = this.getPitch();
          var baseLayer = this.getBaseLayer();
          if ((isNil(options['baseLayer']) || options['baseLayer']) && baseLayer) {
              json['baseLayer'] = baseLayer.toJSON(options['baseLayer']);
          }
          var extraLayerOptions = {};
          if (options['clipExtent']) {
              //if clipExtent is set, only geometries intersecting with extent will be exported.
              //clipExtent's value can be an extent or true (map's current extent)
              if (options['clipExtent'] === true) {
                  extraLayerOptions['clipExtent'] = this.getExtent();
              }
              else {
                  extraLayerOptions['clipExtent'] = options['clipExtent'];
              }
          }
          var layersJSON = [];
          if (isNil(options['layers']) || (options['layers'] && !Array.isArray(options['layers']))) {
              var layers = this.getLayers();
              for (var i = 0, len = layers.length; i < len; i++) {
                  if (!layers[i].toJSON) {
                      continue;
                  }
                  var opts = extend$2({}, isObject$1(options['layers']) ? options['layers'] : {}, extraLayerOptions);
                  layersJSON.push(layers[i].toJSON(opts));
              }
              json['layers'] = layersJSON;
          }
          else if (isArrayHasData(options['layers'])) {
              var layers = options['layers'];
              for (var i = 0; i < layers.length; i++) {
                  var exportOption = layers[i];
                  var layer = this.getLayer(exportOption['id']);
                  if (!layer.toJSON) {
                      continue;
                  }
                  var opts = extend$2({}, exportOption['options'], extraLayerOptions);
                  layersJSON.push(layer.toJSON(opts));
              }
              json['layers'] = layersJSON;
          }
          else {
              json['layers'] = [];
          }
          return json;
      };
      /**
       * Reproduce a map from map's profile JSON.
       * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>
       *                                          1. A HTMLElement container.<br/>
       *                                          2. ID of a HTMLElement container.<br/>
       *                                          3. A canvas compatible container in node,
       *                                          e.g. [node-canvas]{@link https://github.com/Automattic/node-canvas},
       *                                              [canvas2svg]{@link https://github.com/gliffy/canvas2svg}
       * @param  {Object} mapJSON - map's profile JSON
       * @param  {Object} [options=null] - options
       * @param  {Object} [options.baseLayer=null] - whether to import the baseLayer
       * @param  {Object} [options.layers=null]    - whether to import the layers
       * @return {Map}
       * @static
       * @function
       * @example
       * var map = Map.fromJSON('map', mapProfile);
       */
      Map.fromJSON = function (container, profile, options) {
          if (!container || !profile) {
              return null;
          }
          if (!options) {
              options = {};
          }
          var map = new Map(container, profile['options']);
          if (isNil(options['baseLayer']) || options['baseLayer']) {
              var baseLayer = Layer.fromJSON(profile['baseLayer']);
              if (baseLayer) {
                  map.setBaseLayer(baseLayer);
              }
          }
          if (isNil(options['layers']) || options['layers']) {
              var layers = [];
              var layerJSONs = profile['layers'];
              for (var i = 0; i < layerJSONs.length; i++) {
                  var layer = Layer.fromJSON(layerJSONs[i]);
                  layers.push(layer);
              }
              map.addLayer(layers);
          }
          return map;
      };
      return Map;
  }(Handlerable(Eventable(Renderable(Class)))));
  Map$1.mergeOptions(options$A);

  var MapDoubleClickZoomHandler = /** @class */ (function (_super) {
      __extends(MapDoubleClickZoomHandler, _super);
      function MapDoubleClickZoomHandler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MapDoubleClickZoomHandler.prototype.addHooks = function () {
          if (!this.target) {
              return;
          }
          this.target.on('_dblclick', this._onDoubleClick, this);
      };
      MapDoubleClickZoomHandler.prototype.removeHooks = function () {
          if (!this.target) {
              return;
          }
          this.target.off('_dblclick', this._onDoubleClick, this);
      };
      //@internal
      MapDoubleClickZoomHandler.prototype._onDoubleClick = function (param) {
          var map = this.target;
          if (map.options['doubleClickZoom']) {
              var oldZoom = map.getZoom(), zoom = param['domEvent']['shiftKey'] ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;
              map._zoomAnimation(zoom, param['containerPoint']);
          }
      };
      return MapDoubleClickZoomHandler;
  }(Handler));
  Map$1.mergeOptions({
      'doubleClickZoom': true
  });
  Map$1.addOnLoadHook('addHandler', 'doubleClickZoom', MapDoubleClickZoomHandler);

  var MapDragHandler = /** @class */ (function (_super) {
      __extends(MapDragHandler, _super);
      function MapDragHandler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      // TODO:等待补充Map类型定义
      // target: Map
      MapDragHandler.prototype.addHooks = function () {
          var map = this.target;
          if (!map) {
              return;
          }
          var dom = map.getPanels().mapWrapper || map.getContainer();
          this._dragHandler = new DragHandler(dom, {
              'cancelOn': this._cancelOn.bind(this),
              'rightclick': true
          });
          this._dragHandler.on('mousedown', this._onMouseDown, this)
              .on('dragstart', this._onDragStart, this)
              .on('dragging', this._onDragging, this)
              .on('dragend', this._onDragEnd, this)
              .enable();
      };
      MapDragHandler.prototype.removeHooks = function () {
          this._dragHandler.off('mousedown', this._onMouseDown, this)
              .off('dragstart', this._onDragStart, this)
              .off('dragging', this._onDragging, this)
              .off('dragend', this._onDragEnd, this);
          this._dragHandler.remove();
          delete this._dragHandler;
      };
      //@internal
      MapDragHandler.prototype._cancelOn = function (domEvent) {
          if (this.target.isZooming() || this._ignore(domEvent)) {
              return true;
          }
          return false;
      };
      //@internal
      MapDragHandler.prototype._ignore = function (param) {
          if (!param) {
              return false;
          }
          if (param.domEvent) {
              param = param.domEvent;
          }
          return this.target._ignoreEvent(param) || this.target._isEventOutMap(param);
      };
      //@internal
      MapDragHandler.prototype._onMouseDown = function (param) {
          delete this.startDragTime;
          delete this._mode;
          var switchDragButton = this.target.options['switchDragButton'];
          var rotateModeButton = switchDragButton ? 0 : 2;
          var isTouch = param.domEvent.type === 'touchstart';
          var isRotatonMode = switchDragButton && isTouch || param.domEvent.button === rotateModeButton || param.domEvent.ctrlKey;
          if (isRotatonMode) {
              if (this.target.options['dragRotate'] || this.target.options['dragPitch']) {
                  this._mode = 'rotatePitch';
              }
          }
          else if (this.target.options['dragPan']) {
              this._mode = 'move';
          }
          this.target._stopAnim(this.target._mapAnimPlayer);
          preventDefault(param['domEvent']);
      };
      //@internal
      MapDragHandler.prototype._onDragStart = function (param) {
          this.startDragTime = now();
          if (this._mode === 'move') {
              this._moveStart(param);
          }
          else if (this._mode === 'rotatePitch') {
              this._rotateStart(param);
          }
      };
      //@internal
      MapDragHandler.prototype._onDragging = function (param) {
          var map = this.target;
          if (map._isEventOutMap(param['domEvent'])) {
              return;
          }
          if (this._mode === 'move') {
              this._moving(param);
          }
          else if (this._mode === 'rotatePitch') {
              this._rotating(param);
          }
      };
      //@internal
      MapDragHandler.prototype._onDragEnd = function (param) {
          if (this._mode === 'move') {
              this._moveEnd(param);
          }
          else if (this._mode === 'rotatePitch') {
              this._rotateEnd(param);
          }
          delete this.startDragTime;
          delete this.startBearing;
      };
      //@internal
      MapDragHandler.prototype._start = function (param) {
          this.preX = param['mousePos'].x;
          this.preY = param['mousePos'].y;
          this.startX = this.preX;
          this.startY = this.preY;
          this._startPrjCenter = this.target._getPrjCenter().copy();
      };
      //@internal
      MapDragHandler.prototype._moveStart = function (param) {
          this._start(param);
          var map = this.target;
          map.onMoveStart(param);
          var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());
          this.startPrjCoord = this._containerPointToPrj(p);
      };
      //@internal
      MapDragHandler.prototype._moving = function (param) {
          if (!this.startDragTime) {
              return;
          }
          var map = this.target;
          var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());
          var movingPoint = map._containerPointToPoint(p, undefined, undefined, this.startPrjCoord.z);
          var point = map._prjToPoint(map._pointToPrj(movingPoint));
          var offset = point._sub(map._prjToPoint(map._getPrjCenter()));
          map._setPrjCoordAtOffsetToCenter(this.startPrjCoord, offset);
          map.onMoving(param);
      };
      //@internal
      MapDragHandler.prototype._containerPointToPrj = function (p) {
          var map = this.target;
          var queryCoord = map._queryTerrainInfo(p);
          if (queryCoord) {
              var prjCoord = map.getProjection().project(queryCoord.coordinate);
              prjCoord.z = queryCoord.altitude;
              return prjCoord;
          }
          return map._containerPointToPrj(p);
      };
      //@internal
      MapDragHandler.prototype._moveEnd = function (param) {
          if (!this.startDragTime) {
              return;
          }
          var isTouch = param.domEvent.type === 'touchend';
          var map = this.target;
          var t = now() - this.startDragTime;
          var mx = param['mousePos'].x, my = param['mousePos'].y;
          var dx = mx - this.startX;
          var dy = my - this.startY;
          var currentCenter = map._getPrjCenter();
          var dxy = currentCenter.sub(this._startPrjCenter);
          this._clear();
          if (map.options['panAnimation'] && !param.interupted && map._verifyExtent(map._getPrjCenter()) && t < 280 && Math.abs(dy) + Math.abs(dx) > 5) {
              t = 5 * t;
              var dscale = isTouch ? 5 : 2.8;
              var targetPrjCoord = currentCenter.add(dxy._multi(dscale));
              // map._fixPrjOnWorldWide(targetPrjCoord);
              map._panTo(targetPrjCoord, { 'duration': isTouch ? t * 3 : t * 2, 'easing': 'outExpo' });
          }
          else {
              map.onMoveEnd(param);
          }
      };
      //@internal
      MapDragHandler.prototype._rotateStart = function (param) {
          this._start(param);
          delete this._rotateMode;
          this.startBearing = this.target.getBearing();
          this.target.onDragRotateStart(param);
          this._db = 0;
      };
      //@internal
      MapDragHandler.prototype._rotating = function (param) {
          var map = this.target;
          var mx = param['mousePos'].x, my = param['mousePos'].y;
          var prePitch = map.getPitch(), preBearing = map.getBearing();
          var dx = Math.abs(mx - this.preX), dy = Math.abs(my - this.preY);
          if (!this._rotateMode) {
              if (map.options['dragRotatePitch']) {
                  this._rotateMode = 'rotate_pitch';
              }
              else if (dx > dy) {
                  this._rotateMode = 'rotate';
              }
              else if (dx < dy) {
                  this._rotateMode = 'pitch';
              }
              else {
                  this._rotateMode = 'rotate';
              }
          }
          if (this._rotateMode === 'pitch' && prePitch === 0 && dy < 10) {
              return;
          }
          if (this._rotateMode.indexOf('rotate') >= 0 && map.options['dragRotate']) {
              var factor = 0.15;
              var db = 0;
              if (map.options['dragPitch'] || dx > dy) {
                  db = -factor * (this.preX - mx);
              }
              else if (mx > map.width / 2) {
                  db = factor * (this.preY - my);
              }
              else {
                  db = -factor * (this.preY - my);
              }
              var bearing = map.getBearing() + db;
              this._db = this._db || 0;
              this._db += db;
              map._setBearing(bearing);
          }
          if (this._rotateMode.indexOf('pitch') >= 0 && map.options['dragPitch']) {
              map._setPitch(map.getPitch() + (this.preY - my) * 0.15);
          }
          this.preX = mx;
          this.preY = my;
          if (map.getBearing() !== preBearing || map.getPitch() !== prePitch) {
              map.onDragRotating(param);
          }
      };
      //@internal
      MapDragHandler.prototype._rotateEnd = function (param) {
          var map = this.target;
          var bearing = map.getBearing();
          this._clear();
          var t = now() - this.startDragTime;
          map.onDragRotateEnd(param);
          if (map.options['rotateAnimation'] && Math.abs(bearing - this.startBearing) > 20 && (this._rotateMode === 'rotate' || this._rotateMode === 'rotate_pitch') && !param.interupted && t < 400) {
              var bearing_1 = map.getBearing();
              map._animateTo({
                  'bearing': bearing_1 + this._db / 1.5
              }, {
                  'easing': 'outQuint',
                  'duration': 1600
              });
          }
      };
      //@internal
      MapDragHandler.prototype._clear = function () {
          delete this.startPrjCoord;
          delete this.preX;
          delete this.preY;
          delete this.startX;
          delete this.startY;
      };
      return MapDragHandler;
  }(Handler));
  Map$1.mergeOptions({
      'draggable': true,
      'dragPan': true,
      'dragRotatePitch': true,
      'dragRotate': true,
      'dragPitch': true
  });
  Map$1.addOnLoadHook('addHandler', 'draggable', MapDragHandler);

  var EVENTS$3 = 
  /**
   * mousedown event
   * @event Geometry#mousedown
   * @type {Object}
   * @property {String} type                    - mousedown
   * @property {Geometry} target            - the Geometry fires event
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  'mousedown ' +
      /**
       * mouseup event
       * @event Geometry#mouseup
       * @type {Object}
       * @property {String} type                    - mouseup
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseup ' +
      /**
       * mousemove event
       * @event Geometry#mousemove
       * @type {Object}
       * @property {String} type                    - mousemove
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mousemove ' +
      /**
       * click event
       * @event Geometry#click
       * @type {Object}
       * @property {String} type                    - click
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'click ' +
      /**
       * dblclick event
       * @event Geometry#dblclick
       * @type {Object}
       * @property {String} type                    - dblclick
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'dblclick ' +
      /**
       * contextmenu event
       * @event Geometry#contextmenu
       * @type {Object}
       * @property {String} type                    - contextmenu
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'contextmenu ' +
      /**
       * touchstart event
       * @event Geometry#touchstart
       * @type {Object}
       * @property {String} type                    - touchstart
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchstart ' +
      /**
       * touchmove event
       * @event Geometry#touchmove
       * @type {Object}
       * @property {String} type                    - touchmove
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchmove ' +
      /**
       * touchend event
       * @event Geometry#touchend
       * @type {Object}
       * @property {String} type                    - touchend
       * @property {Geometry} target            - the Geometry fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchend ' +
      'mouseout';
  /**
   * mouseenter event for geometry
   * @event Geometry#mouseenter
   * @type {Object}
   * @property {String} type                    - mouseenter
   * @property {Geometry} target       - the geometry fires mouseenter
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  /**
   * mouseover event for geometry
   * @event Geometry#mouseover
   * @type {Object}
   * @property {String} type                    - mouseover
   * @property {Geometry} target       - the geometry fires mouseover
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  /**
   * mouseout event for geometry
   * @event Geometry#mouseout
   * @type {Object}
   * @property {String} type                    - mouseout
   * @property {Geometry} target       - the geometry fires mouseout
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  var MOUSEEVENT_ASSOCIATION_TABLE = {
      'mousemove': ['mousemove', 'mouseover', 'mouseout', 'mouseenter'],
      'touchend': ['touchend', 'click']
  };
  /**
   * geo validate
   * @ignore
   *
   */
  var isGeo = function (geometry) {
      return geometry && geometry.getLayer && geometry.on && geometry.fire;
  };
  var getGeoId = function (geometry) {
      if (geometry._getInternalId) {
          return geometry._getInternalId();
      }
      else if (geometry.getId) {
          return geometry.getId();
      }
      return null;
  };
  var fireGeoEvent = function (geometry, domEvent, type) {
      if (geometry._onEvent) {
          return geometry._onEvent(domEvent, type);
      }
      //plugin layer,such as threelayer
      var layer = geometry.getLayer();
      if (layer && layer.fireGeoEvent) {
          return layer.fireGeoEvent(geometry, domEvent, type);
      }
      return null;
  };
  var MapGeometryEventsHandler = /** @class */ (function (_super) {
      __extends(MapGeometryEventsHandler, _super);
      function MapGeometryEventsHandler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      // target: Map;
      MapGeometryEventsHandler.prototype.addHooks = function () {
          var map = this.target;
          var dom = map.getPanels().allLayers || map.getContainer();
          on(dom, EVENTS$3, this._identifyGeometryEvents, this);
      };
      MapGeometryEventsHandler.prototype.removeHooks = function () {
          var map = this.target;
          var dom = map.getPanels().allLayers || map.getContainer();
          off(dom, EVENTS$3, this._identifyGeometryEvents);
      };
      //@internal
      MapGeometryEventsHandler.prototype._identifyGeometryEvents = function (domEvent, type) {
          var map = this.target;
          if (map.isInteracting() || map._ignoreEvent(domEvent)) {
              return;
          }
          var oneMoreEvent = null;
          var eventType = type || domEvent.type;
          if (isMoveEvent(eventType) && !GlobalConfig.isTest && isMousemoveEventBlocked(this, map.options['mousemoveThrottleTime'])) {
              stopPropagation(domEvent);
              return;
          }
          // ignore click lasted for more than 300ms.
          var isMousedown = eventType === 'mousedown' || (eventType === 'touchstart' && domEvent.touches && domEvent.touches.length === 1);
          if (isMousedown) {
              this._mouseDownTime = now();
          }
          else if ((eventType === 'click' || eventType === 'touchend') && this._mouseDownTime) {
              var downTime = this._mouseDownTime;
              delete this._mouseDownTime;
              var time = now();
              if (time - downTime > 300) {
                  if (eventType === 'click') {
                      return;
                  }
              }
              else if (eventType === 'touchend') {
                  oneMoreEvent = 'click';
              }
          }
          var actual = domEvent.touches && domEvent.touches.length > 0 ?
              domEvent.touches[0] : domEvent.changedTouches && domEvent.changedTouches.length > 0 ?
              domEvent.changedTouches[0] : domEvent;
          if (!actual) {
              return;
          }
          var containerPoint = getEventContainerPoint(actual, map.getContainer());
          if (eventType === 'touchstart') {
              if (map.options['preventTouch']) {
                  preventDefault(domEvent);
              }
          }
          var geometryCursorStyle = null;
          var tops = this.target.getRenderer().getTopElements();
          var topOnlyEvent = isMousedown && domEvent.button !== 2;
          for (var i = 0; i < tops.length; i++) {
              if (tops[i].hitTest(containerPoint)) {
                  var cursor = tops[i].options['cursor'];
                  if (cursor) {
                      geometryCursorStyle = cursor;
                  }
                  if (topOnlyEvent || tops[i].events && tops[i].events.indexOf(eventType) >= 0) {
                      var e = { target: map, type: eventType, domEvent: domEvent, containerPoint: containerPoint };
                      if (topOnlyEvent) {
                          map._setPriorityCursor(geometryCursorStyle);
                          tops[i].mousedown(e);
                          return;
                      }
                      else {
                          tops[i].onEvent(e);
                      }
                  }
              }
          }
          var layers = map._getLayers(function (layer) {
              if (layer.identify && layer.options['geometryEvents']) {
                  return true;
              }
              return false;
          });
          // map._setPriorityCursor(geometryCursorStyle);
          if (!layers.length) {
              return;
          }
          var eventTypes = MOUSEEVENT_ASSOCIATION_TABLE[eventType] || [eventType];
          var identifyOptions = {
              'includeInternals': true,
              //return only one geometry on top,
              'filter': function (geometry) {
                  if (geometry instanceof Geometry) {
                      // 等待Geometry补充类型
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      var eventToFire = geometry._getEventTypeToFire(domEvent);
                      if (eventType === 'mousemove') {
                          if (!geometryCursorStyle && geometry.options['cursor']) {
                              geometryCursorStyle = geometry.options['cursor'];
                          }
                          //always return true for mouseout mouseleave
                          return true;
                          // if (!geometry.listens('mousemove') && !geometry.listens('mouseover') && !geometry.listens('mouseenter')) {
                          //     return false;
                          // }
                      }
                      else if (!geometry.listens(eventToFire) && !geometry.listens(oneMoreEvent)) {
                          return false;
                      }
                      return true;
                  }
                  else if (isGeo(geometry)) {
                      return true;
                  }
                  return false;
              },
              'count': 1,
              'onlyVisible': map.options['onlyVisibleGeometryEvents'],
              containerPoint: containerPoint,
              layers: layers,
              eventTypes: eventTypes,
              domEvent: domEvent
          };
          var callback = fireGeometryEvent.bind(this);
          if (isMoveEvent(eventType)) {
              this._queryIdentifyTimeout = map.getRenderer().callInNextFrame(function () {
                  if (map.isInteracting()) {
                      return;
                  }
                  map.identifyAtPoint(identifyOptions, callback);
              });
          }
          else {
              map.identifyAtPoint(identifyOptions, callback);
          }
          function fireGeometryEvent(geometries) {
              var _this = this;
              var propagation = true;
              var getOldGeos = function () {
                  var geos = _this._prevOverGeos && _this._prevOverGeos.geos;
                  return geos || [];
              };
              var oldGeosMouseout = function (oldTargets, geoMap) {
                  if (oldTargets === void 0) { oldTargets = []; }
                  if (geoMap === void 0) { geoMap = {}; }
                  if (oldTargets && oldTargets.length > 0) {
                      for (var i = oldTargets.length - 1; i >= 0; i--) {
                          var oldTarget = oldTargets[i];
                          if (!isGeo(oldTarget)) {
                              continue;
                          }
                          // const oldTargetId = oldTargets[i]._getInternalId();
                          var oldTargetId = getGeoId(oldTargets[i]);
                          /**
                           * 鼠标经过的新位置中不包含老的目标geometry
                           */
                          if (!geoMap[oldTargetId]) {
                              // propagation = oldTarget._onEvent(domEvent, 'mouseout');
                              propagation = fireGeoEvent(oldTarget, domEvent, 'mouseout');
                          }
                      }
                  }
              };
              //鼠标移出地图容器，所有的老的geos触发mouseout,这个属于原来没有做好的地方,现在加上
              if (eventType === 'mouseout') {
                  var oldTargets = getOldGeos();
                  this._prevOverGeos = {
                      'geos': [],
                      'geomap': {}
                  };
                  oldGeosMouseout(oldTargets, {});
              }
              else if (eventType === 'mousemove') {
                  var geoMap = {};
                  if (geometries.length > 0) {
                      for (var i = geometries.length - 1; i >= 0; i--) {
                          var geo = geometries[i];
                          if (!isGeo(geo)) {
                              continue;
                          }
                          var iid = getGeoId(geo);
                          geoMap[iid] = geo;
                          // geo._onEvent(domEvent);
                          fireGeoEvent(geo, domEvent);
                          if (!this._prevOverGeos || !this._prevOverGeos.geomap[iid]) {
                              // geo._onEvent(domEvent, 'mouseenter');
                              fireGeoEvent(geo, domEvent, 'mouseenter');
                          }
                          // propagation = geo._onEvent(domEvent, 'mouseover');
                          propagation = fireGeoEvent(geo, domEvent, 'mouseover');
                      }
                  }
                  map._setPriorityCursor(geometryCursorStyle);
                  var oldTargets = getOldGeos();
                  this._prevOverGeos = {
                      'geos': geometries,
                      'geomap': geoMap
                  };
                  oldGeosMouseout(oldTargets, geoMap);
              }
              else {
                  if (!geometries || !geometries.length) {
                      return;
                  }
                  for (var i = geometries.length - 1; i >= 0; i--) {
                      if (!isGeo(geometries[i])) {
                          continue;
                      }
                      // propagation = geometries[i]._onEvent(domEvent);
                      propagation = fireGeoEvent(geometries[i], domEvent);
                      if (oneMoreEvent) {
                          // geometries[i]._onEvent(domEvent, oneMoreEvent);
                          fireGeoEvent(geometries[i], domEvent, oneMoreEvent);
                      }
                      break;
                  }
              }
              if (propagation === false) {
                  stopPropagation(domEvent);
              }
          }
      };
      return MapGeometryEventsHandler;
  }(Handler));
  Map$1.mergeOptions({
      'geometryEvents': true,
      'onlyVisibleGeometryEvents': true
  });
  Map$1.addOnLoadHook('addHandler', 'geometryEvents', MapGeometryEventsHandler);

  /*!
   * Contains code from mapbox-gl-js
   * http://github.com/mapbox/mapbox-gl-js
   * License BSD-3-Clause
   */
  var wheelZoomDelta = 4.000244140625;
  var defaultZoomRate = 1 / 100;
  var wheelZoomRate = 1 / 450;
  var maxScalePerFrame = 2;
  var MapScrollWheelZoomHandler = /** @class */ (function (_super) {
      __extends(MapScrollWheelZoomHandler, _super);
      function MapScrollWheelZoomHandler(target) {
          var _this = _super.call(this, target) || this;
          _this._thisScrollZoom = _this._scrollZoom.bind(_this);
          _this._thisCheckIfEndZoom = _this._checkIfEndZoom.bind(_this);
          _this._wheelZoomRate = wheelZoomRate;
          _this._defaultZoomRate = defaultZoomRate;
          _this._delta = 0;
          return _this;
      }
      MapScrollWheelZoomHandler.prototype.addHooks = function () {
          addDomEvent(this.target._containerDOM, 'wheel', this._onWheelScroll, this);
      };
      MapScrollWheelZoomHandler.prototype.removeHooks = function () {
          removeDomEvent(this.target._containerDOM, 'wheel', this._onWheelScroll);
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._onWheelScroll = function (evt) {
          var map = this.target;
          if (map.options['preventWheelScroll']) {
              preventDefault(evt);
              stopPropagation(evt);
          }
          if (map._ignoreEvent(evt) || map._isEventOutMap(evt) || !map.options['zoomable']) {
              return false;
          }
          var container = map.getContainer();
          var origin = map._checkZoomOrigin(getEventContainerPoint(evt, container));
          if (map.options['seamlessZoom']) {
              if (!this._zooming) {
                  this._trackPadSuspect = 0;
                  this._ensureTrackpad = false;
              }
              return this._seamless(evt, origin);
          }
          else {
              return this._interval(evt, origin);
          }
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._seamless = function (evt, origin) {
          var value = evt.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? evt.deltaY * 60 : evt.deltaY;
          if (value % wheelZoomDelta !== 0) {
              //according to https://archive.fo/ZV8gz
              //value % wheelDelta === 0 means it must be  mouse on Mac OS X
              if (!this._ensureTrackpad) {
                  if (Math.abs(value) < 60) {
                      this._trackPadSuspect++;
                  }
                  else {
                      this._trackPadSuspect = 0;
                  }
                  //repeated very small delta value ensure it's a trackpad
                  if (this._trackPadSuspect >= 2) {
                      this._ensureTrackpad = true;
                  }
              }
              if (this._ensureTrackpad) {
                  value *= 14;
              }
          }
          if (evt.shiftKey && value)
              value = value / 4;
          this._lastWheelEvent = evt;
          //is undefined ,the _interval will delete it
          if (isNil(this._delta)) {
              this._delta = 0;
          }
          this._delta -= value;
          if (!this._zooming && this._delta) {
              var map = this.target;
              this._zoomOrigin = origin;
              map.onZoomStart(null, origin);
          }
          this._start();
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._start = function () {
          if (!this._delta)
              return;
          this._zooming = true;
          var map = this.target;
          if (!this._active) {
              map.getRenderer().callInNextFrame(this._thisScrollZoom);
              this._active = true;
          }
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._scrollZoom = function () {
          this._active = false;
          if (!this._delta) {
              return;
          }
          var zoomRate = (Math.abs(this._delta) > wheelZoomDelta) ? this._wheelZoomRate : this._defaultZoomRate;
          var scale = maxScalePerFrame / (1 + Math.exp(-Math.abs(this._delta * zoomRate)));
          if (this._delta < 0 && scale !== 0) {
              scale = 1 / scale;
          }
          var map = this.target;
          var zoom = map.getZoom();
          var targetZoom = map.getZoomForScale(scale, zoom, true);
          this._delta = 0;
          map.onZooming(targetZoom, this._zoomOrigin);
          this._scrollTime = performance.now();
          map.getRenderer().callInNextFrame(this._thisCheckIfEndZoom);
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._checkIfEndZoom = function () {
          if (!this._zooming) {
              return;
          }
          var map = this.target;
          var currentTime = performance.now();
          if (currentTime - this._scrollTime > 210) {
              this._zooming = false;
              map.onZoomEnd(map.getZoom(), this._zoomOrigin);
          }
          else {
              map.getRenderer().callInNextFrame(this._thisCheckIfEndZoom);
          }
      };
      //@internal
      MapScrollWheelZoomHandler.prototype._interval = function (evt, origin) {
          var _this = this;
          var map = this.target;
          if (this._zooming) {
              this._requesting++;
              return false;
          }
          this._requesting = 0;
          var levelValue = (evt.deltaY ? evt.deltaY * -1 : evt.wheelDelta ? evt.wheelDelta : evt.detail) > 0 ? 1 : -1;
          if (evt.detail) {
              levelValue *= -1;
          }
          var zoom = map.getZoom();
          var nextZoom = zoom + levelValue;
          nextZoom = map._checkZoom(levelValue > 0 ? Math.ceil(nextZoom) : Math.floor(nextZoom));
          if (nextZoom === zoom) {
              return false;
          }
          this._zooming = true;
          if (!this._delta) {
              map.onZoomStart(null, origin);
              this._origin = origin;
              this._delta = levelValue;
              this._startZoom = map.getZoom();
          }
          var duration = 90;
          map._animateTo({
              'zoom': nextZoom - this._delta * 1 / 2,
              'around': this._origin
          }, {
              'continueOnViewChanged': true,
              'easing': 'linear',
              'duration': duration,
              'wheelZoom': true
          }, function (frame) {
              if (frame.state.playState !== 'finished') {
                  if (frame.state.playState !== 'running') {
                      delete _this._zooming;
                      delete _this._requesting;
                  }
                  return;
              }
              if (_this._requesting < 1 || Math.abs(nextZoom - _this._startZoom) > 2 ||
                  //finish zooming if target zoom hits min/max
                  nextZoom === map.getMaxZoom() || nextZoom === map.getMinZoom()) {
                  map._animateTo({
                      'zoom': nextZoom,
                      'around': _this._origin
                  }, {
                      'continueOnViewChanged': true,
                      'duration': 100
                  }, function (frame) {
                      if (frame.state.playState !== 'running') {
                          // setTimeout(() => {
                          //     delete this._zooming;
                          //     delete this._requesting;
                          // }, 100);
                          delete _this._zooming;
                          delete _this._requesting;
                      }
                  });
                  delete _this._startZoom;
                  delete _this._origin;
                  delete _this._delta;
                  _this._requesting = 0;
              }
              else if (!isNil(_this._requesting)) {
                  delete _this._zooming;
                  _this._onWheelScroll(evt);
              }
          });
          return false;
      };
      return MapScrollWheelZoomHandler;
  }(Handler));
  Map$1.mergeOptions({
      'scrollWheelZoom': true,
      'seamlessZoom': true
  });
  Map$1.addOnLoadHook('addHandler', 'scrollWheelZoom', MapScrollWheelZoomHandler);

  //handler to zoom map by pinching
  var MapTouchZoomHandler = /** @class */ (function (_super) {
      __extends(MapTouchZoomHandler, _super);
      function MapTouchZoomHandler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MapTouchZoomHandler.prototype.addHooks = function () {
          addDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart, this);
      };
      MapTouchZoomHandler.prototype.removeHooks = function () {
          removeDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart);
      };
      //@internal
      MapTouchZoomHandler.prototype._onTouchStart = function (event) {
          var map = this.target;
          if (!event.touches || event.touches.length < 2) {
              return;
          }
          var container = map.getContainer();
          var p1 = getEventContainerPoint(event.touches[0], container), p2 = getEventContainerPoint(event.touches[1], container);
          this.preY = p1.y;
          this._startP1 = p1;
          this._startP2 = p2;
          this._startDist = p1.distanceTo(p2);
          this._startVector = p1.sub(p2);
          this._startZoom = map.getZoom();
          this._startBearing = map.getBearing();
          off(document, 'touchmove', this._onTouchMove);
          off(document, 'touchend', this._onTouchEnd);
          addDomEvent(document, 'touchmove', this._onTouchMove, this);
          addDomEvent(document, 'touchend', this._onTouchEnd, this);
          if (map.options['preventTouch']) {
              preventDefault(event);
          }
          /**
            * touchactstart event
            * @event Map#touchactstart
            * @type {Object}
            * @property {String} type                    - touchactstart
            * @property {Map} target                     - the map fires event
            */
          map._fireEvent('touchactstart');
      };
      //@internal
      MapTouchZoomHandler.prototype._onTouchMove = function (event) {
          var map = this.target;
          if (!event.touches || event.touches.length < 2) {
              return;
          }
          var container = map.getContainer(), p1 = getEventContainerPoint(event.touches[0], container), p2 = getEventContainerPoint(event.touches[1], container), d1 = p1.sub(this._startP1), d2 = p2.sub(this._startP2), vector = p1.sub(p2), scale = p1.distanceTo(p2) / this._startDist, bearing = vector.angleWith(this._startVector) * 180 / Math.PI, preY = this.preY || p1.y, pitch = (preY - p1.y) * 0.4;
          // console.log(preY, p1.y);
          this.preY = p1.y;
          var param = {
              'domEvent': event,
              'mousePos': [p1, p2]
          };
          if (!this.mode) {
              if (map.options['touchRotate'] && Math.abs(bearing) > 8) {
                  this.mode = map.options['touchZoomRotate'] ? 'rotate_zoom' : 'rotate';
              }
              else if (map.options['touchPitch'] && d1.y * d2.y > 0 && Math.abs(d1.y) > 10 && Math.abs(d2.y) > 10) {
                  this.mode = 'pitch';
              }
              else if (map.options['zoomable'] && map.options['touchZoom'] && Math.abs(1 - scale) > 0.15) {
                  this.mode = map.options['touchZoomRotate'] && map.options['touchRotate'] ? 'rotate_zoom' : 'zoom';
              }
              this._startTouching(param);
          }
          if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
              this._scale = scale;
              var res = map._getResolution(this._startZoom) / scale;
              var zoom = map.getZoomFromRes(res);
              map.onZooming(zoom, this._Origin);
          }
          if (this.mode === 'rotate' || this.mode === 'rotate_zoom') {
              map._setBearing(this._startBearing + bearing);
              map.onDragRotating(param);
          }
          else if (this.mode === 'pitch') {
              map._setPitch(map.getPitch() + pitch);
              map.onDragRotating(param);
          }
          /**
            * touchacting event
            * @event Map#touchacting
            * @type {Object}
            * @property {String} type                    - touchacting
            * @property {Map} target                     - the map fires event
            */
          map._fireEvent('touchactinging');
      };
      //@internal
      MapTouchZoomHandler.prototype._startTouching = function (param) {
          var map = this.target;
          if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
              var size = map.getSize();
              this._Origin = new Point(size['width'] / 2, size['height'] / 2);
              map.onZoomStart(null, this._Origin);
          }
          if (this.mode === 'rotate' || this.mode === 'pitch' || this.mode === 'rotate_zoom') {
              map.onDragRotateStart(param);
          }
      };
      //@internal
      MapTouchZoomHandler.prototype._onTouchEnd = function (event) {
          delete this.preY;
          var map = this.target;
          off(document, 'touchmove', this._onTouchMove);
          off(document, 'touchend', this._onTouchEnd);
          if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
              var scale = this._scale;
              var res = map._getResolution(this._startZoom) / scale;
              var zoom = map.getZoomFromRes(res);
              map.onZoomEnd(zoom, this._Origin);
          }
          if (this.mode === 'pitch' || this.mode === 'rotate' || this.mode === 'rotate_zoom') {
              map.onDragRotateEnd({
                  'domEvent': event
              });
          }
          delete this.mode;
          /**
            * touchactend event
            * @event Map#touchactend
            * @type {Object}
            * @property {String} type                    - touchactend
            * @property {Map} target                     - the map fires event
            */
          map._fireEvent('touchactend');
      };
      return MapTouchZoomHandler;
  }(Handler));
  Map$1.mergeOptions({
      'touchGesture': true,
      'touchZoom': true,
      'touchPitch': true,
      'touchRotate': true,
      'touchZoomRotate': false
  });
  Map$1.addOnLoadHook('addHandler', 'touchGesture', MapTouchZoomHandler);

  var KEY = '__anim_player';
  /**
   * @classdesc
   * Easing functions for anmation, from openlayers 3
   * @class
   * @category animation
   * @memberof animation
   * @protected
   */
  var Easing = {
      outExpo: function (x) {
          return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
      },
      outQuint: function (x) {
          return 1 - Math.pow(1 - x, 5);
      },
      /**
       * Start slow and speed up.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      in: function (t) {
          return Math.pow(t, 2);
      },
      /**
       * Start fast and slow down.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      out: function (t) {
          return 1 - Easing.in(1 - t);
      },
      /**
       * Start slow, speed up, and then slow down again.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      inAndOut: function (t) {
          return 3 * t * t - 2 * t * t * t;
      },
      /**
       * Maintain a constant speed over time.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      linear: function (t) {
          return t;
      },
      /**
       * Start slow, speed up, and at the very end slow down again.  This has the
       * same general behavior as {@link inAndOut}, but the final slowdown
       * is delayed.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      upAndDown: function (t) {
          if (t < 0.5) {
              return Easing.inAndOut(2 * t);
          }
          else {
              return 1 - Easing.inAndOut(2 * (t - 0.5));
          }
      }
  };
  /**
   * Animation Frame used internally in animation player.
   * @category animation
   * @memberof animation
   * @protected
   */
  var Frame = /** @class */ (function () {
      /**
       * Create an animation frame.
       * @param {Object} state  - animation state
       * @param {Object} styles - styles to animate
       */
      function Frame(state, styles) {
          this.state = state;
          this.styles = styles;
      }
      Object.defineProperty(Frame.prototype, "playState", {
          get: function () {
              return this.state.playState;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Frame.prototype, "symbol", {
          get: function () {
              return this.styles.symbol;
          },
          enumerable: false,
          configurable: true
      });
      return Frame;
  }());
  /**
   * An [Web Animation API]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Animation} style animation player
   * @category animation
   * @memberof animation
   */
  var Player = /** @class */ (function () {
      /**
       * Create an animation player
       * @param {Function} animation - animation [framing]{@link framing} function
       * @param {Object} options     - animation options
       * @param {Function} onFrame  - callback function for animation steps
       */
      function Player(animation, options, onFrame, target) {
          this._animation = animation;
          this.options = options;
          this._onFrame = onFrame;
          this.playState = 'idle';
          this.ready = true;
          this.finished = false;
          this.target = target;
      }
      //@internal
      Player.prototype._prepare = function () {
          var options = this.options;
          var duration = options['speed'] || options['duration'];
          if (isString(duration)) {
              duration = Animation.speed[duration];
              if (!duration) {
                  duration = +duration;
              }
          }
          if (!duration) {
              duration = Animation.speed['normal'];
          }
          this.duration = duration;
          this._framer = options['framer'] || Animation._requestAnimFrame.bind(Animation);
      };
      /**
       * Start or resume the animation
       * @return {Player} this
       */
      Player.prototype.play = function () {
          if (this.playState !== 'idle' && this.playState !== 'paused' || this.target && this.target[KEY]) {
              return this;
          }
          if (this.target) {
              this.target[KEY] = 1;
          }
          if (this.playState === 'idle') {
              this.currentTime = 0;
              this._prepare();
          }
          var t = now();
          if (!this.startTime) {
              var options = this.options;
              this.startTime = options['startTime'] ? options['startTime'] : t;
          }
          this._playStartTime = Math.max(t, this.startTime);
          if (this.playState === 'paused') {
              this._playStartTime -= this.currentTime;
          }
          this.playState = 'running';
          this._run();
          return this;
      };
      /**
       * Pause the animation
       * @return {Player} this
       */
      Player.prototype.pause = function () {
          if (this.playState === 'paused') {
              return this;
          }
          this.playState = 'paused';
          this._run();
          //this.duration = this.duration - this.currentTime;
          return this;
      };
      /**
       * Cancel the animation play and ready to play again
       * @return {Player} this
       */
      Player.prototype.cancel = function () {
          if (this.playState === 'idle') {
              return this;
          }
          this.playState = 'idle';
          this.finished = false;
          this._run();
          return this;
      };
      /**
       * Finish the animation play, and can't be played any more.
       * @return {Player} this
       */
      Player.prototype.finish = function () {
          if (this.playState === 'finished') {
              return this;
          }
          this.playState = 'finished';
          this.finished = true;
          this._run();
          return this;
      };
      Player.prototype.reverse = function () {
      };
      //@internal
      Player.prototype._run = function () {
          var _this = this;
          var onFrame = this._onFrame;
          var t = now();
          var elapsed = t - this._playStartTime;
          if (this.options['repeat'] && elapsed >= this.duration) {
              this._playStartTime = t;
              elapsed = 0;
          }
          if (this.playState !== 'running') {
              if (this.target) {
                  delete this.target[KEY];
              }
              if (onFrame) {
                  if (this.playState === 'finished') {
                      elapsed = this.duration;
                  }
                  else if (this.playState === 'idle') {
                      elapsed = 0;
                  }
                  var frame_1 = this._animation(elapsed, this.duration);
                  frame_1.state.playState = this.playState;
                  onFrame(frame_1);
              }
              return;
          }
          //elapsed, duration
          var frame = this._animation(elapsed, this.duration);
          this.playState = frame.state['playState'];
          if (this.playState !== 'running' && this.target) {
              delete this.target[KEY];
          }
          if (this.playState === 'idle') {
              if (this.startTime > t) {
                  setTimeout(this._run.bind(this), this.startTime - t);
              }
          }
          else if (this.playState === 'running') {
              this._framer(function () {
                  if (_this.playState !== 'running') {
                      // this._run();
                      return;
                  }
                  _this.currentTime = elapsed;
                  if (onFrame) {
                      onFrame(frame);
                  }
                  _this._run();
              });
          }
          else if (this.playState === 'finished') {
              this.finished = true;
              //finished
              if (onFrame) {
                  onFrame(frame);
              }
          }
      };
      return Player;
  }());
  /**
   * @classdesc
   * Utilities for animation
   * @class
   * @category animation
   * @memberof animation
   */
  var Animation = {
      /**
       * @property {Object} speed         - predefined animation speed
       * @property {Number} speed.slow    - 2000ms
       * @property {Number} speed.normal  - 1000ms
       * @property {Number} speed.fast    - 500ms
       */
      speed: {
          'slow': 2000,
          'normal': 1000,
          'fast': 500
      },
      /**
       * resolve styles for animation, get a style group of start style, styles to animate and end styles.
       * @param  {Object} styles - styles to resolve
       * @return {Object[]}  styles resolved
       * @private
       */
      //@internal
      _resolveStyles: function (styles) {
          if (!styles) {
              return null;
          }
          //resolve a child styles.
          function resolveChild(child) {
              if (!Array.isArray(child)) {
                  return Animation._resolveStyles(child);
              }
              var start = [], d = [], dest = [];
              for (var i = 0; i < child.length; i++) {
                  var styles_1 = Animation._resolveStyles(child[i]);
                  if (styles_1) {
                      start.push(styles_1[0]);
                      d.push(styles_1[1]);
                      dest.push(styles_1[2]);
                  }
              }
              if (!start.length) {
                  return null;
              }
              else {
                  return [start, d, dest];
              }
          }
          // resolve a style value.
          function resolveVal(val) {
              var values = val;
              var clazz;
              //val is just a destination value, so we set start value to 0 or a 0-point or a 0-coordinate.
              if (!Array.isArray(val)) {
                  if (isNumber(val)) {
                      values = [0, val];
                  }
                  else if (val instanceof Point || val instanceof Coordinate) {
                      clazz = val.constructor;
                      values = [new clazz(0, 0), val];
                  }
                  else {
                      values = [val, val];
                  }
              }
              //val is an array and val[0] is the start value and val[1] is the destination value.
              var v1 = values[0], v2 = values[1];
              if (isNumber(v1) && isNumber(v2)) {
                  if (v1 === v2) {
                      return null;
                  }
                  return [v1, v2 - v1, v2];
              }
              else if (Array.isArray(v1) && isNumber(v1[0]) || v1 instanceof Coordinate || v1 instanceof Point) {
                  // is a coordinate (array or a coordinate) or a point
                  if (Array.isArray(v1)) {
                      v1 = new Coordinate(v1);
                      v2 = new Coordinate(v2);
                  }
                  else {
                      clazz = v1.constructor;
                      v1 = new clazz(v1);
                      v2 = new clazz(v2);
                  }
                  if (v1.equals(v2)) {
                      //a Coordinate or a Point to be eql with each other
                      return null;
                  }
                  return [v1, v2.sub(v1), v2];
              }
              else {
                  return [v1, v2, v2];
              }
          }
          function isChild(val) {
              if (!Array.isArray(val) && val.constructor === Object) {
                  return true;
              }
              else if (Array.isArray(val) && val[0].constructor === Object) {
                  return true;
              }
              return false;
          }
          var d = {}, start = {}, dest = {};
          for (var p in styles) {
              if (styles.hasOwnProperty(p)) {
                  var values = styles[p];
                  // ignore null values
                  if (!values) {
                      continue;
                  }
                  else if (Array.isArray(values)) {
                      if (isNil(values[0]) || isNil(values[1])) {
                          continue;
                      }
                  }
                  var childStyles = void 0;
                  if (isChild(values)) {
                      childStyles = resolveChild(values);
                  }
                  else {
                      childStyles = resolveVal(values);
                  }
                  if (childStyles) {
                      start[p] = childStyles[0];
                      d[p] = childStyles[1];
                      dest[p] = childStyles[2];
                  }
              }
          }
          return [start, d, dest];
      },
      /**
       * Generate a framing function
       * @param  {Object[]} styles        - animation style group
       * @param  {Object} [options=null]  - options
       * @param  {Object} [options.easing=null]  - animation easing
       * @return {Function} framing function helps to generate animation frames.
       */
      framing: function (styles, options) {
          if (!options) {
              options = {};
          }
          var easing = options['easing'] ? Easing[options['easing']] : Easing.linear;
          if (!easing) {
              easing = Easing.linear;
          }
          var dStyles, startStyles, destStyles;
          styles = Animation._resolveStyles(styles);
          if (styles) {
              startStyles = styles[0];
              dStyles = styles[1];
              destStyles = styles[2];
          }
          var deltaStyles = function (delta, _startStyles, _dStyles) {
              if (!_startStyles || !_dStyles) {
                  return null;
              }
              var result = {};
              for (var p in _dStyles) {
                  if (_dStyles.hasOwnProperty(p)) {
                      if (_startStyles[p] === destStyles[p]) {
                          result[p] = _startStyles[p];
                          continue;
                      }
                      var s = _startStyles[p], d = _dStyles[p];
                      if (isNumber(d)) {
                          //e.g. radius, width, height
                          result[p] = s + delta * d;
                      }
                      else if (Array.isArray(d)) {
                          //e.g. a composite symbol, element in array can only be a object.
                          var children = [];
                          for (var i = 0; i < d.length; i++) {
                              children.push(deltaStyles(delta, s[i], d[i]));
                          }
                          result[p] = children;
                      }
                      else {
                          //e.g. translate or a child
                          var clazz = d.constructor;
                          if (clazz === Object) {
                              result[p] = deltaStyles(delta, s, d);
                          }
                          else if (s instanceof Point || s instanceof Coordinate) {
                              result[p] = s.add(d.multi(delta));
                          }
                          else {
                              result[p] = d;
                          }
                      }
                  }
              }
              return result;
          };
          return function (elapsed, duration) {
              var state, d;
              if (elapsed < 0) {
                  state = {
                      'playState': 'idle',
                      'delta': 0
                  };
                  d = startStyles;
              }
              else if (elapsed < duration) {
                  var delta = easing(elapsed / duration);
                  state = {
                      'playState': 'running',
                      'delta': delta
                  };
                  d = deltaStyles(delta, startStyles, dStyles);
              }
              else {
                  state = {
                      'playState': 'finished',
                      'delta': 1
                  };
                  d = destStyles;
              }
              state['startStyles'] = startStyles;
              state['destStyles'] = destStyles;
              state['progress'] = elapsed;
              state['remainingMs'] = duration - elapsed;
              return new Frame(state, d);
          };
      },
      //@internal
      _requestAnimFrame: function (fn) {
          if (!this._frameQueue) {
              this._frameQueue = [];
          }
          this._frameQueue.push(fn);
          this._a();
      },
      //@internal
      _a: function () {
          if (!this._animationFrameId) {
              this._animationFrameId = requestAnimFrame(Animation._frameFn);
          }
      },
      //@internal
      _run: function () {
          if (this._frameQueue.length) {
              var running = this._frameQueue;
              this._frameQueue = [];
              for (var i = 0, len = running.length; i < len; i++) {
                  running[i]();
              }
              if (this._frameQueue.length) {
                  this._animationFrameId = requestAnimFrame(Animation._frameFn);
              }
              else {
                  delete this._animationFrameId;
              }
          }
      },
      /**
       * Create an animation player
       * @param  {Object} styles  - styles to animate
       * @param  {Object} options - animation options
       * @param  {Function} step  - callback function for animation steps
       * @return {Player} player
       */
      animate: function (styles, options, step, target) {
          if (!options) {
              options = {};
          }
          var animation = Animation.framing(styles, options);
          var player = new Player(animation, options, step, target);
          return player;
      },
      //@internal
      _frameFn: function () { }
  };
  Animation._frameFn = Animation._run.bind(Animation);
  var animate = Animation.animate;

  var Animation$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Animation: Animation,
    Easing: Easing,
    Frame: Frame,
    Player: Player,
    animate: animate
  });

  var simplify$1 = {exports: {}};

  /*
   (c) 2017, Vladimir Agafonkin
   Simplify.js, a high-performance JS polyline simplification library
   mourner.github.io/simplify-js
  */

  (function (module) {
  	(function () {
  	// to suit your point format, run search/replace for '.x' and '.y';
  	// for 3D version, see 3d branch (configurability would draw significant performance overhead)

  	// square distance between 2 points
  	function getSqDist(p1, p2) {

  	    var dx = p1.x - p2.x,
  	        dy = p1.y - p2.y;

  	    return dx * dx + dy * dy;
  	}

  	// square distance from a point to a segment
  	function getSqSegDist(p, p1, p2) {

  	    var x = p1.x,
  	        y = p1.y,
  	        dx = p2.x - x,
  	        dy = p2.y - y;

  	    if (dx !== 0 || dy !== 0) {

  	        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

  	        if (t > 1) {
  	            x = p2.x;
  	            y = p2.y;

  	        } else if (t > 0) {
  	            x += dx * t;
  	            y += dy * t;
  	        }
  	    }

  	    dx = p.x - x;
  	    dy = p.y - y;

  	    return dx * dx + dy * dy;
  	}
  	// rest of the code doesn't care about point format

  	// basic distance-based simplification
  	function simplifyRadialDist(points, sqTolerance) {

  	    var prevPoint = points[0],
  	        newPoints = [prevPoint],
  	        point;

  	    for (var i = 1, len = points.length; i < len; i++) {
  	        point = points[i];

  	        if (getSqDist(point, prevPoint) > sqTolerance) {
  	            newPoints.push(point);
  	            prevPoint = point;
  	        }
  	    }

  	    if (prevPoint !== point) newPoints.push(point);

  	    return newPoints;
  	}

  	function simplifyDPStep(points, first, last, sqTolerance, simplified) {
  	    var maxSqDist = sqTolerance,
  	        index;

  	    for (var i = first + 1; i < last; i++) {
  	        var sqDist = getSqSegDist(points[i], points[first], points[last]);

  	        if (sqDist > maxSqDist) {
  	            index = i;
  	            maxSqDist = sqDist;
  	        }
  	    }

  	    if (maxSqDist > sqTolerance) {
  	        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
  	        simplified.push(points[index]);
  	        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  	    }
  	}

  	// simplification using Ramer-Douglas-Peucker algorithm
  	function simplifyDouglasPeucker(points, sqTolerance) {
  	    var last = points.length - 1;

  	    var simplified = [points[0]];
  	    simplifyDPStep(points, 0, last, sqTolerance, simplified);
  	    simplified.push(points[last]);

  	    return simplified;
  	}

  	// both algorithms combined for awesome performance
  	function simplify(points, tolerance, highestQuality) {

  	    if (points.length <= 2) return points;

  	    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

  	    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  	    points = simplifyDouglasPeucker(points, sqTolerance);

  	    return points;
  	}

  	// export as AMD module / Node module / browser or worker variable
  	{
  	    module.exports = simplify;
  	    module.exports.default = simplify;
  	}

  	})(); 
  } (simplify$1));

  var simplifyExports = simplify$1.exports;
  var simplify = /*@__PURE__*/getDefaultExportFromCjs(simplifyExports);

  var GEOMETRY_NOT_FIND_PROJECTION = 'not find Geometry\' Projection. please add Geometry to Layer and add Layer to Map';
  /**
   * other error
   */

  /**
   * @property {Object} options - configuration options
   * @property {Number} [options.smoothness=0]      - line smoothing by quad bezier interporating, 0 by default
   * @property {Boolean} [options.enableSimplify=true] - whether to simplify path before rendering
   * @property {Number}  [options.simplifyTolerance=2] - tolerance to simplify path, the higher the simplify is more intense
   * @property {Boolean} [options.enableClip=true] - whether to clip path with map's current extent
   * @property {Object} options.symbol - Path's default symbol
   * @memberOf Path
   * @instance
   */
  var options$z = {
      'smoothness': false,
      'enableClip': true,
      'enableSimplify': true,
      'simplifyTolerance': 2,
      'symbol': {
          'lineColor': '#000',
          'lineWidth': 2,
          'lineOpacity': 1,
          'polygonFill': '#fff', //default color in cartoCSS
          'polygonOpacity': 1,
          'opacity': 1
      }
  };
  /**
   * 一个抽象类Path，包含Path几何类的常用方法，例如LineString、Polygon
   * @english
   * An abstract class Path containing common methods for Path geometry classes, e.g. LineString, Polygon
   * @abstract
   * @category geometry
   * @extends Geometry
   */
  var Path = /** @class */ (function (_super) {
      __extends(Path, _super);
      function Path() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * 动画展示线条
       * @english
       * Show the linestring with animation
       * @param  {Object} [options=null] animation options
       * @param  {Number} [options.duration=1000] duration
       * @param  {String} [options.easing=out] animation easing
       * @param  {Function} [cb=null] callback function in animation, function parameters: frame, currentCoord
       * @example
       *  line.animateShow({
       *    duration : 2000,
       *    easing : 'linear'
       *  }, function (frame, currentCoord) {
       *    //frame is the animation frame
       *    //currentCoord is current coordinate of animation
       *  });
       * @return {LineString}         this
       */
      Path.prototype.animateShow = function (options, cb) {
          var _this = this;
          if (options === void 0) { options = {}; }
          if (this._showPlayer) {
              this._showPlayer.finish();
          }
          if (isFunction(options)) {
              options = {};
              cb = options;
          }
          var coordinates = this.getCoordinates();
          if (coordinates.length === 0) {
              return;
          }
          this._animIdx = 0;
          this._animLenSoFar = 0;
          this.show();
          var isPolygon = !!this.getShell;
          var animCoords = isPolygon ? this.getShell().concat(this.getShell()[0]) : coordinates;
          var projection = this._getProjection();
          if (!projection) {
              console.error(GEOMETRY_NOT_FIND_PROJECTION);
              return;
          }
          var prjAnimCoords = projection.projectCoords(animCoords, this.options['antiMeridian']);
          this._prjAniShowCenter = this._getPrjExtent().getCenter();
          this._aniShowCenter = projection.unproject(this._prjAniShowCenter);
          var duration = options['duration'] || 1000, easing = options['easing'] || 'out';
          this.setCoordinates([]);
          var length = 0;
          if (prjAnimCoords.length) {
              // @ts-expect-error todo
              prjAnimCoords[0]._distance = 0;
          }
          for (var i = 1; i < prjAnimCoords.length; i++) {
              var distance = prjAnimCoords[i].distanceTo(prjAnimCoords[i - 1]);
              // cache distance calc
              // @ts-expect-error todo
              prjAnimCoords[i]._distance = distance;
              length += distance;
          }
          this._tempCoord = new Coordinate(0, 0);
          this._tempPrjCoord = new Point(0, 0);
          var player = this._showPlayer = Animation.animate({
              't': duration
          }, {
              'duration': duration,
              'easing': easing
          }, function (frame) {
              if (!_this.getMap()) {
                  if (player.playState !== 'finished') {
                      player.finish();
                      if (cb) {
                          var coordinates_1 = _this.getCoordinates();
                          cb(frame, coordinates_1[coordinates_1.length - 1]);
                      }
                  }
                  return;
              }
              var currentCoord = _this._drawAnimShowFrame(frame.styles.t, duration, length, animCoords, prjAnimCoords);
              if (frame.state.playState === 'finished') {
                  delete _this._showPlayer;
                  delete _this._aniShowCenter;
                  delete _this._prjAniShowCenter;
                  delete _this._animIdx;
                  delete _this._animLenSoFar;
                  delete _this._animTailRatio;
                  delete _this._tempCoord;
                  delete _this._tempPrjCoord;
                  _this.setCoordinates(coordinates);
              }
              if (cb) {
                  cb(frame, currentCoord);
              }
          }, this);
          player.play();
          return player;
      };
      //@internal
      Path.prototype._drawAnimShowFrame = function (t, duration, length, coordinates, prjCoords) {
          if (t === 0) {
              return coordinates[0];
          }
          // const projection = this._getProjection();
          // const map = this.getMap();
          var targetLength = t / duration * length;
          var segLen = 0;
          var i, l;
          for (i = this._animIdx + 1, l = prjCoords.length; i < l; i++) {
              // segLen = prjCoords[i].distanceTo(prjCoords[i + 1]);
              segLen = prjCoords[i]._distance;
              if (this._animLenSoFar + segLen > targetLength) {
                  break;
              }
              this._animLenSoFar += segLen;
          }
          this._animIdx = i - 1;
          if (this._animIdx >= l - 1) {
              this.setCoordinates(coordinates);
              return coordinates[coordinates.length - 1];
          }
          var idx = this._animIdx;
          var p1 = prjCoords[idx], p2 = prjCoords[idx + 1], span = targetLength - this._animLenSoFar, r = span / segLen;
          this._animTailRatio = r;
          var x = p1.x + (p2.x - p1.x) * r, y = p1.y + (p2.y - p1.y) * r;
          this._tempPrjCoord.x = x;
          this._tempPrjCoord.y = y;
          var lastCoord = this._tempPrjCoord;
          var c1 = coordinates[idx], c2 = coordinates[idx + 1];
          var cx = c1.x + (c2.x - c1.x) * r, cy = c1.y + (c2.y - c1.y) * r;
          this._tempCoord.x = cx;
          this._tempCoord.y = cy;
          // const targetCoord = projection.unproject(lastCoord, this._tempCoord);
          var targetCoord = this._tempCoord;
          var isPolygon = !!this.getShell;
          if (!isPolygon && this.options['smoothness'] > 0) {
              //smooth line needs to set current coordinates plus 2 more to caculate correct control points
              var animCoords = [], prjAnimCoords = [];
              for (var i_1 = 0; i_1 <= this._animIdx; i_1++) {
                  animCoords.push(coordinates[i_1]);
                  prjAnimCoords.push(prjCoords[i_1]);
              }
              animCoords.push(targetCoord, targetCoord);
              prjAnimCoords.push(lastCoord, lastCoord);
              // const animCoords = coordinates.slice(0, this._animIdx + 3);
              this.setCoordinates(animCoords);
              // const prjAnimCoords = prjCoords.slice(0, this._animIdx + 3);
              this._setPrjCoordinates(prjAnimCoords);
          }
          else {
              var animCoords = coordinates.slice(0, this._animIdx + 1);
              animCoords.push(targetCoord);
              var prjAnimCoords = prjCoords.slice(0, this._animIdx + 1);
              prjAnimCoords.push(lastCoord);
              if (isPolygon) {
                  this.setCoordinates([this._aniShowCenter].concat(animCoords));
                  this._setPrjCoordinates([this._prjAniShowCenter].concat(prjAnimCoords));
              }
              else {
                  this.setCoordinates(animCoords);
                  this._setPrjCoordinates(prjAnimCoords);
              }
          }
          return targetCoord;
      };
      //@internal
      Path.prototype._getCenterInExtent = function (extent, coordinates, clipFn) {
          var meExtent = this.getExtent();
          if (!extent.intersects(meExtent)) {
              return null;
          }
          var clipped = clipFn(coordinates, extent);
          if (clipped.length === 0) {
              return null;
          }
          var _a = __read([0, 0, 0], 3), sumx = _a[0], sumy = _a[1], counter = _a[2];
          clipped.forEach(function (part) {
              if (Array.isArray(part)) {
                  part.forEach(function (c) {
                      if (c.point) {
                          c = c.point;
                      }
                      sumx += c.x;
                      sumy += c.y;
                      counter++;
                  });
              }
              else {
                  if (part.point) {
                      part = part.point;
                  }
                  sumx += part.x;
                  sumy += part.y;
                  counter++;
              }
          });
          var c = new Coordinate(sumx, sumy)._multi(1 / counter);
          // @ts-expect-error todo
          c.count = counter;
          return c;
      };
      /**
       * 将投影坐标转换为视点
       * @english
       * Transform projected coordinates to view points
       * @param  {Coordinate[]} prjCoords           - projected coordinates
       * @param  {Boolean} disableSimplify          - whether to disable simplify\
       * @param  {Number} zoom                      - 2d points' zoom level
       * @returns {Point[]}
       * @private
       */
      //@internal
      Path.prototype._getPath2DPoints = function (prjCoords, disableSimplify, res) {
          if (!isArrayHasData(prjCoords)) {
              return [];
          }
          var map = this.getMap(), isSimplify = !disableSimplify && this._shouldSimplify(), tolerance = this.options['simplifyTolerance'] * map._getResolution(), isMulti = Array.isArray(prjCoords[0]);
          delete this._simplified;
          if (isSimplify && !isMulti) {
              var count = prjCoords.length;
              prjCoords = simplify(prjCoords, tolerance, false);
              this._simplified = prjCoords.length < count;
          }
          if (!res) {
              res = map._getResolution();
          }
          if (!Array.isArray(prjCoords)) {
              return map._prjToPointAtRes(prjCoords, res);
          }
          else {
              var resultPoints = [];
              var glPointKey = '_glPt';
              if (!Array.isArray(prjCoords[0])) {
                  resultPoints = getPointsResultPts(prjCoords, glPointKey);
                  return map._prjsToPointsAtRes(prjCoords, res, resultPoints);
              }
              var pts = [];
              for (var i = 0, len = prjCoords.length; i < len; i++) {
                  var prjCoord = prjCoords[i];
                  resultPoints = getPointsResultPts(prjCoord, glPointKey);
                  var pt = map._prjsToPointsAtRes(prjCoord, res, resultPoints);
                  pts.push(pt);
              }
              return pts;
          }
          // return forEachCoord(prjCoords, c => map._prjToPoint(c, zoom));
      };
      //@internal
      Path.prototype._shouldSimplify = function () {
          var layer = this.getLayer();
          var hasAltitude = layer.options['enableAltitude'];
          return layer && layer.options['enableSimplify'] && !hasAltitude && this.options['enableSimplify'] && !this._showPlayer /* && !this.options['smoothness'] */;
      };
      //@internal
      Path.prototype._setPrjCoordinates = function (prjPoints) {
          this._prjCoords = prjPoints;
          this.onShapeChanged();
      };
      //@internal
      Path.prototype._getPrjCoordinates = function () {
          this._verifyProjection();
          if (!this._prjCoords && this._getProjection()) {
              this._prjCoords = this._projectCoords(this._coordinates);
          }
          return this._prjCoords;
      };
      //update cached variables if geometry is updated.
      //@internal
      Path.prototype._updateCache = function () {
          this._clearCache();
          var projection = this._getProjection();
          if (!projection) {
              return;
          }
          if (this._prjCoords) {
              this._coordinates = this._unprojectCoords(this._getPrjCoordinates());
          }
      };
      //@internal
      Path.prototype._clearProjection = function () {
          this._prjCoords = null;
          _super.prototype._clearProjection.call(this);
      };
      //@internal
      Path.prototype._projectCoords = function (points) {
          var projection = this._getProjection();
          if (projection) {
              return projection.projectCoords(points, this.options['antiMeridian']);
          }
          return [];
      };
      //@internal
      Path.prototype._unprojectCoords = function (prjPoints) {
          var projection = this._getProjection();
          if (projection) {
              return projection.unprojectCoords(prjPoints);
          }
          return [];
      };
      //@internal
      Path.prototype._computeCenter = function () {
          var ring = this._coordinates;
          if (!isArrayHasData(ring)) {
              return null;
          }
          var sumx = 0, sumy = 0, counter = 0;
          var size = ring.length;
          for (var i = 0; i < size; i++) {
              if (ring[i]) {
                  if (isNumber(ring[i].x) && isNumber(ring[i].y)) {
                      sumx += ring[i].x;
                      sumy += ring[i].y;
                      counter++;
                  }
              }
          }
          return new Coordinate(sumx / counter, sumy / counter);
      };
      //@internal
      Path.prototype._computeExtent = function (_) {
          var _a;
          var shell = this._coordinates;
          if (!isArrayHasData(shell)) {
              return null;
          }
          var rings = [shell];
          if (this.hasHoles && this.hasHoles()) {
              (_a = rings.push).call.apply(_a, __spreadArray([rings], __read(this.getHoles()), false));
          }
          return this._coords2Extent(rings, this._getProjection());
      };
      //@internal
      Path.prototype._computePrjExtent = function (_) {
          var _a;
          var coords = [this._getPrjCoordinates()];
          if (this.hasHoles && this.hasHoles()) {
              (_a = coords.push).call.apply(_a, __spreadArray([coords], __read(this._getPrjHoles()), false));
          }
          return this._coords2Extent(coords);
      };
      //@internal
      Path.prototype._get2DLength = function () {
          var vertexes = this._getPath2DPoints(this._getPrjCoordinates(), true);
          var len = 0;
          for (var i = 1, l = vertexes.length; i < l; i++) {
              len += vertexes[i].distanceTo(vertexes[i - 1]);
          }
          return len;
      };
      //@internal
      Path.prototype._hitTestTolerance = function () {
          var symbol = this._getInternalSymbol();
          var w;
          if (Array.isArray(symbol)) {
              w = 0;
              for (var i = 0; i < symbol.length; i++) {
                  if (isNumber(symbol[i]['lineWidth'])) {
                      if (symbol[i]['lineWidth'] > w) {
                          w = symbol[i]['lineWidth'];
                      }
                  }
              }
          }
          else {
              w = symbol['lineWidth'];
          }
          return _super.prototype._hitTestTolerance.call(this) + (isNumber(w) ? w / 2 : 1.5);
      };
      //@internal
      Path.prototype._coords2Extent = function (coords, proj) {
          // linestring,  polygon
          if (!coords || coords.length === 0 || (Array.isArray(coords[0]) && coords[0].length === 0)) {
              return null;
          }
          var result = new Extent(proj);
          for (var i = 0, l = coords.length; i < l; i++) {
              for (var j = 0, ll = coords[i].length; j < ll; j++) {
                  result._combine(coords[i][j]);
              }
          }
          return result;
      };
      return Path;
  }(Geometry));
  Path.mergeOptions(options$z);

  var JSON_TYPE = 'Polygon';
  var Polygon = /** @class */ (function (_super) {
      __extends(Polygon, _super);
      /**
       * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - coordinates, shell coordinates or all the rings.
       * @param {Object} [options=null] - construct options defined in [Polygon]{@link Polygon#options}
       */
      function Polygon(coordinates, options) {
          var _this = _super.call(this, options) || this;
          _this.type = 'Polygon';
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          return _this;
      }
      Polygon.prototype.getOutline = function () {
          var painter = this._getPainter();
          if (!painter) {
              return null;
          }
          var extent = this.getExtent();
          return new Polygon(extent.toArray(), {
              symbol: {
                  'lineWidth': 1,
                  'lineColor': '6b707b'
              }
          });
      };
      /**
       * 设置多边形坐标
       * @english
       * Set coordinates to the polygon
       *
       * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - new coordinates
       * @return {Polygon} this
       * @fires Polygon#shapechange
       */
      Polygon.prototype.setCoordinates = function (coordinates) {
          if (!coordinates) {
              this._coordinates = null;
              this._holes = null;
              this._projectRings();
              return this;
          }
          var rings = Coordinate.toCoordinates(coordinates);
          var len = rings.length;
          if (!Array.isArray(rings[0])) {
              this._coordinates = this._trimRing(rings);
          }
          else {
              this._coordinates = this._trimRing(rings[0]);
              if (len > 1) {
                  var holes = [];
                  for (var i = 1; i < len; i++) {
                      if (!rings[i]) {
                          continue;
                      }
                      holes.push(this._trimRing(rings[i]));
                  }
                  this._holes = holes;
              }
              else {
                  this._holes = null;
              }
          }
          this._projectRings();
          return this;
      };
      /**
       * 获取多边形坐标
       * @english
       * Gets polygons's coordinates
       *
       * @returns {Coordinate[][]}
       */
      Polygon.prototype.getCoordinates = function () {
          if (!this._coordinates) {
              return [];
          }
          var holes = this.getHoles();
          var rings = [this._copyAndCloseRing(this._coordinates)];
          for (var i = 0, l = holes.length; i < l; i++) {
              rings.push(this._copyAndCloseRing(holes[i]));
          }
          return rings;
      };
      /**
       * 获取具有给定范围的线串的交点的中心
       * @english
       * Get center of linestring's intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = line.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      Polygon.prototype.getCenterInExtent = function (extent) {
          return this._getCenterInExtent(extent, this.getShell(), clipPolygon);
      };
      /**
       * 获取多边形的外壳坐标
       * @english
       * Gets shell's coordinates of the polygon
       *
       * @returns {Coordinate[]}
       */
      Polygon.prototype.getShell = function () {
          return this._coordinates || [];
      };
      /**
       * 获取多边形的洞的坐标（如果有）。
       * @english
       * Gets holes' coordinates of the polygon if it has.
       * @returns {Coordinate[][]}
       */
      Polygon.prototype.getHoles = function () {
          return this._holes || [];
      };
      /**
       * 判断多边形是否带有洞
       * @english
       * Whether the polygon has any holes inside.
       *
       * @returns {Boolean}
       */
      Polygon.prototype.hasHoles = function () {
          return this.getHoles().length > 0;
      };
      //@internal
      Polygon.prototype._projectRings = function () {
          if (!this.getMap()) {
              this.onShapeChanged();
              return;
          }
          this._prjCoords = this._projectCoords(this._coordinates);
          this._prjHoles = this._projectCoords(this._holes);
          this.onShapeChanged();
      };
      //@internal
      Polygon.prototype._setPrjCoordinates = function (prjCoords) {
          this._prjCoords = prjCoords;
          this.onShapeChanged();
      };
      //@internal
      Polygon.prototype._cleanRing = function (ring) {
          for (var i = ring.length - 1; i >= 0; i--) {
              if (!ring[i]) {
                  ring.splice(i, 1);
              }
          }
      };
      /**
       * 检查环是否有效
       * @english
       * Check if ring is valid
       * @param  {*} ring ring to check
       * @return {Boolean} is ring a closed one
       * @private
       */
      //@internal
      Polygon.prototype._checkRing = function (ring) {
          this._cleanRing(ring);
          if (!ring || !isArrayHasData(ring)) {
              return false;
          }
          var lastPoint = ring[ring.length - 1];
          var isClose = true;
          if (ring[0].x !== lastPoint.x || ring[0].y !== lastPoint.y) {
              isClose = false;
          }
          return isClose;
      };
      /**
       * 如果第一个坐标与最后一个坐标相等，则删除最后一个座标。
       * @english
       * If the first coordinate is equal with the last one, then remove the last coordinates.
       * @private
       */
      //@internal
      Polygon.prototype._trimRing = function (ring) {
          var isClose = this._checkRing(ring);
          if (isArrayHasData(ring) && isClose) {
              ring.splice(ring.length - 1, 1);
          }
          return ring;
      };
      /**
       * 如果第一个坐标与最后一个不同，则复制第一个坐标并添加到环中。
       * @english
       * If the first coordinate is different with the last one, then copy the first coordinates and add to the ring.
       * @private
       */
      //@internal
      Polygon.prototype._copyAndCloseRing = function (ring) {
          ring = ring.slice(0);
          var isClose = this._checkRing(ring);
          if (isArrayHasData(ring) && !isClose) {
              ring.push(ring[0].copy());
              return ring;
          }
          else {
              return ring;
          }
      };
      //@internal
      Polygon.prototype._getPrjShell = function () {
          if (this.getJSONType() === JSON_TYPE) {
              return this._getPrjCoordinates();
          }
          //r.g. for Rectangle
          this._verifyProjection();
          if (this._getProjection() && !this._prjShell) {
              this._prjShell = this._projectCoords(this._getShell ? this._getShell() : this.getShell());
          }
          return this._prjShell;
      };
      //@internal
      Polygon.prototype._getPrjHoles = function () {
          var projection = this._getProjection();
          this._verifyProjection();
          if (projection && !this._prjHoles) {
              this._prjHoles = this._projectCoords(this.getHoles());
          }
          return this._prjHoles;
      };
      //@internal
      Polygon.prototype._computeGeodesicLength = function (measurer) {
          var rings = this.getCoordinates();
          if (!isArrayHasData(rings)) {
              return 0;
          }
          var result = 0;
          for (var i = 0, len = rings.length; i < len; i++) {
              result += measurer.measureLength(rings[i]);
          }
          return result;
      };
      //@internal
      Polygon.prototype._computeGeodesicArea = function (measurer) {
          var rings = this.getCoordinates();
          if (!isArrayHasData(rings)) {
              return 0;
          }
          var result = measurer.measureArea(rings[0]);
          //holes
          for (var i = 1, len = rings.length; i < len; i++) {
              result -= measurer.measureArea(rings[i]);
          }
          return result;
      };
      //@internal
      Polygon.prototype._updateCache = function () {
          _super.prototype._updateCache.call(this);
          if (this._prjHoles) {
              this._holes = this._unprojectCoords(this._getPrjHoles());
          }
      };
      //@internal
      Polygon.prototype._clearCache = function () {
          delete this._prjShell;
          return _super.prototype._clearCache.call(this);
      };
      //@internal
      Polygon.prototype._clearProjection = function () {
          if (this._prjHoles) {
              this._prjHoles = null;
          }
          if (this._prjShell) {
              this._prjShell = null;
          }
          _super.prototype._clearProjection.call(this);
      };
      return Polygon;
  }(Path));
  Polygon.registerJSONType(JSON_TYPE);

  /**
   * 基于几何图形的通用方法
   * @english
   * Common methods for geometry classes that base on a center, e.g. Marker, Circle, Ellipse , etc
   * @mixin CenterMixin
   */
  function CenterMixin (Base) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          /**
           * 获取几何图形的中心点
           * @english
           * Get geometry's center
           * @return {Coordinate} - center of the geometry
           * @function CenterMixin.getCoordinates
           */
          class_1.prototype.getCoordinates = function () {
              return this._coordinates;
          };
          /**
           * 设置几何图形的中心点
           * @english
           * Set a new center to the geometry
           * @param {Coordinate|Number[]} coordinates - new center
           * @return {Geometry} this
           * @fires Geometry#positionchange
           * @function CenterMixin.setCoordinates
           */
          class_1.prototype.setCoordinates = function (coordinates) {
              var center = (coordinates instanceof Coordinate) ? coordinates : new Coordinate(coordinates);
              this._translateRotatePivot(center);
              this._coordinates = center;
              if (!this.getMap()) {
                  //When not on a layer or when creating a new one, temporarily save the coordinates,
                  this._dirtyCoords = true;
                  this.onPositionChanged();
                  return this;
              }
              var projection = this._getProjection();
              this._setPrjCoordinates(projection.project(this._coordinates));
              return this;
          };
          //Gets view point of the geometry's center
          //@internal
          class_1.prototype._getCenter2DPoint = function (res) {
              var map = this.getMap();
              if (!map) {
                  return null;
              }
              var pcenter = this._getPrjCoordinates();
              if (!pcenter) {
                  return null;
              }
              if (!res) {
                  res = map._getResolution();
              }
              return map._prjToPointAtRes(pcenter, res);
          };
          //@internal
          class_1.prototype._getPrjCoordinates = function () {
              var projection = this._getProjection();
              this._verifyProjection();
              if (!this._pcenter && projection) {
                  if (this._coordinates) {
                      this._pcenter = projection.project(this._coordinates);
                  }
              }
              return this._pcenter;
          };
          //Set center by projected coordinates
          //@internal
          class_1.prototype._setPrjCoordinates = function (pcenter) {
              this._pcenter = pcenter;
              this.onPositionChanged();
          };
          //update cached const iables if geometry is updated.
          //@internal
          class_1.prototype._updateCache = function () {
              this._clearCache();
              var projection = this._getProjection();
              if (this._pcenter && projection) {
                  this._coordinates = projection.unproject(this._pcenter);
              }
          };
          //@internal
          class_1.prototype._clearProjection = function () {
              this._pcenter = null;
              // @ts-expect-error todo
              _super.prototype._clearProjection.call(this);
          };
          //@internal
          class_1.prototype._computeCenter = function () {
              return this._coordinates ? this._coordinates.copy() : null;
          };
          return class_1;
      }(Base));
  }

  var TEMP_EXTENT$3 = new PointExtent();
  /**
   * @property {String} [options.hitTestForEvent=false] - use hit testing for events, be careful, it may fail due to tainted canvas.
   * @property {Boolean}  [options.collision=true]   -  - whether collision
   * @memberOf Marker
   * @instance
   */
  var options$y = {
      'symbol': {
          'markerType': 'path',
          'markerPath': [{
                  'path': 'M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z',
                  'fill': '#DE3333'
              }],
          'markerPathWidth': 16,
          'markerPathHeight': 23,
          'markerWidth': 24,
          'markerHeight': 34
      },
      'hitTestForEvent': false,
      'collision': true
  };
  /**
   * @classdesc
   * Represents a Point type Geometry.
   * @category geometry
   * @extends Geometry
   * @mixes CenterMixin
   * @example
   * var marker = new Marker([100, 0], {
   *     'id' : 'marker0',
   *     'symbol' : {
   *         'markerFile'  : 'foo.png',
   *         'markerWidth' : 20,
   *         'markerHeight': 20,
   *     },
   *     'properties' : {
   *         'foo' : 'value'
   *     }
   * });
   */
  var Marker = /** @class */ (function (_super) {
      __extends(Marker, _super);
      /**
       * @param {Coordinate} coordinates      - coordinates of the marker
       * @param {Object} [options=null]       - construct options defined in [Marker]{@link Marker#options}
       */
      function Marker(coordinates, options) {
          var _this = _super.call(this, options) || this;
          _this.type = 'Point';
          //for subclass,Quickly determine whether a Geometry is a point
          _this.isPoint = true;
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          return _this;
      }
      Marker.prototype.getOutline = function () {
          var coord = this.getCoordinates();
          var extent = this.getContainerExtent();
          var anchor = this.getMap().coordToContainerPoint(coord);
          return new Marker(coord, {
              'symbol': {
                  'markerType': 'square',
                  'markerWidth': extent.getWidth(),
                  'markerHeight': extent.getHeight(),
                  'markerLineWidth': 1,
                  'markerLineColor': '6b707b',
                  'markerFill': 'rgba(0, 0, 0, 0)',
                  'markerDx': extent.xmin - (anchor.x - extent.getWidth() / 2),
                  'markerDy': extent.ymin - (anchor.y - extent.getHeight() / 2)
              }
          });
      };
      Marker.prototype.setSymbol = function (symbol) {
          delete this._fixedExtent;
          return _super.prototype.setSymbol.call(this, symbol);
      };
      //@internal
      Marker.prototype._getSizeSymbol = function (symbol) {
          var s = {};
          var dynamic = false;
          var dynamicSize = false;
          for (var i = 0; i < DYNAMIC_SYMBOL_PROPS.length; i++) {
              var v = symbol[DYNAMIC_SYMBOL_PROPS[i]];
              if (isNil(v)) {
                  continue;
              }
              if (!dynamic && isFunctionDefinition(v)) {
                  dynamic = true;
                  dynamicSize = true;
              }
              s[DYNAMIC_SYMBOL_PROPS[i]] = v;
          }
          for (var i = 0; i < SIZE_SYMBOL_PROPS.length; i++) {
              var v = symbol[SIZE_SYMBOL_PROPS[i]];
              if (isNil(v)) {
                  continue;
              }
              if (!dynamic && isFunctionDefinition(v)) {
                  dynamic = true;
              }
              s[SIZE_SYMBOL_PROPS[i]] = v;
          }
          var sizeSymbol;
          if (dynamic) {
              sizeSymbol = loadGeoSymbol(s, this);
              if (dynamicSize) {
                  sizeSymbol._dynamic = true;
              }
          }
          else {
              sizeSymbol = s;
          }
          return sizeSymbol;
      };
      //@internal
      Marker.prototype._setExternSymbol = function (symbol) {
          if (!this._symbol) {
              delete this._fixedExtent;
          }
          return _super.prototype._setExternSymbol.call(this, symbol);
      };
      //@internal
      Marker.prototype._isDynamicSize = function () {
          return this._sizeSymbol && this._sizeSymbol._dynamic;
      };
      //@internal
      Marker.prototype._getFixedExtent = function () {
          if (this._fixedExtent && !this._isDynamicSize()) {
              return this._fixedExtent;
          }
          this._fixedExtent = this._fixedExtent || new PointExtent();
          this._fixedExtent.set(null, null, null, null);
          var symbol = this._sizeSymbol;
          if (!symbol) {
              return this._fixedExtent;
          }
          var renderer = this.getLayer() && this.getLayer().getRenderer();
          var resources = renderer && renderer.resources;
          var textDesc = this.getTextDesc();
          if (Array.isArray(symbol)) {
              TEMP_EXTENT$3.set(Infinity, Infinity, -Infinity, -Infinity);
              for (var i = 0; i < symbol.length; i++) {
                  if (!symbol[i]) {
                      continue;
                  }
                  this._fixedExtent._combine(getMarkerFixedExtent(TEMP_EXTENT$3, symbol[i], resources, textDesc && textDesc[i]));
              }
          }
          else {
              this._fixedExtent = getMarkerFixedExtent(this._fixedExtent, symbol, resources, textDesc);
          }
          return this._fixedExtent;
      };
      //@internal
      Marker.prototype._isVectorMarker = function () {
          var symbol = this._getInternalSymbol();
          if (Array.isArray(symbol)) {
              return false;
          }
          return isVectorSymbol(symbol);
      };
      /**
       * 可以编辑，只能编辑带有矢量符号、矢量路径符号或图像符号的标记。
       * @english
       * Can be edited, only marker with a vector symbol, vector path symbol or a image symbol can be edited.
       * @return {Boolean}
       * @private
       */
      //@internal
      Marker.prototype._canEdit = function () {
          var symbol = this._getInternalSymbol();
          if (Array.isArray(symbol)) {
              return false;
          }
          return isVectorSymbol(symbol) || isPathSymbol(symbol) || isImageSymbol(symbol);
      };
      //@internal
      Marker.prototype._containsPoint = function (point, t) {
          var extent = this.getContainerExtent();
          if (t) {
              extent = extent.expand(t);
          }
          if (extent.contains(point)) {
              if (this.options['hitTestForEvent']) {
                  return _super.prototype._containsPoint.call(this, point, t);
              }
              else {
                  return true;
              }
          }
          else {
              return false;
          }
      };
      //@internal
      Marker.prototype._computeExtent = function () {
          return computeExtent$1.call(this, 'getCenter');
      };
      //@internal
      Marker.prototype._computePrjExtent = function () {
          return computeExtent$1.call(this, '_getPrjCoordinates');
      };
      //@internal
      Marker.prototype._computeGeodesicLength = function () {
          return 0;
      };
      //@internal
      Marker.prototype._computeGeodesicArea = function () {
          return 0;
      };
      //@internal
      Marker.prototype._getSprite = function (resources, canvasClass) {
          if (this._getPainter()) {
              return this._getPainter().getSprite(resources, canvasClass);
          }
          return new Painter(this).getSprite(resources, canvasClass);
      };
      return Marker;
  }(CenterMixin(Geometry)));
  Marker.mergeOptions(options$y);
  Marker.registerJSONType('Marker');
  function computeExtent$1(fn) {
      var coordinates = this[fn]();
      if (!coordinates) {
          return null;
      }
      return new Extent(coordinates, coordinates, this._getProjection());
  }

  /**
   * @property {Object} [options=null]
   * @property {String|Number[]} [options.arrowStyle=null]        - style of arrow, can be a pre-defined value or an array [arrow-width, arrow-height] (value in the array is times of linewidth), possible predefined values: classic ([3, 4])
   * @property {String} [options.arrowPlacement=vertex-last]      - arrow's placement: vertex-first, vertex-last, vertex-firstlast, point
   * @memberOf LineString
   * @instance
   */
  var options$x = {
      'arrowStyle': null,
      'arrowPlacement': 'vertex-last' //vertex-first, vertex-last, vertex-firstlast, point
  };
  /**
   * 表示LineString类型的Geometry。
   * @english
   * Represents a LineString type Geometry.
   * @category geometry
   * @extends Path
   * @example
   * var line = new LineString(
   *     [
   *         [121.45942, 31.24123],
   *         [121.46371, 31.24226],
   *         [121.46727, 31.23870],
   *         [121.47019, 31.24145]
   *     ]
   * ).addTo(layer);
   */
  var LineString = /** @class */ (function (_super) {
      __extends(LineString, _super);
      /**
       * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string
       * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}
       */
      function LineString(coordinates, options) {
          var _this = _super.call(this, options) || this;
          _this.type = 'LineString';
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          return _this;
      }
      LineString.prototype.getOutline = function () {
          return Polygon.prototype.getOutline.call(this);
      };
      /**
       * 给线段设置坐标
       * @english
       * Set new coordinates to the line string
       * @param {Coordinate[]|Number[][]} coordinates - new coordinates
       * @fires LineString#shapechange
       * @return {LineString} this
       */
      LineString.prototype.setCoordinates = function (coordinates) {
          if (!coordinates) {
              this._coordinates = null;
              this._setPrjCoordinates(null);
              return this;
          }
          this._coordinates = Coordinate.toCoordinates(coordinates);
          if (this.getMap()) {
              this._setPrjCoordinates(this._projectCoords(this._coordinates));
          }
          else {
              this.onShapeChanged();
          }
          return this;
      };
      /**
       * 获取线段的坐标
       * @english
       * Get coordinates of the line string
       * @return {Coordinate[]|Number[][]} coordinates
       */
      LineString.prototype.getCoordinates = function () {
          return this._coordinates || [];
      };
      /**
       * 获取具有给定范围的线串的交点的中心
       * @english
       * Get center of linestring's intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = line.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      LineString.prototype.getCenterInExtent = function (extent) {
          return this._getCenterInExtent(extent, this.getCoordinates(), clipLine);
      };
      //@internal
      LineString.prototype._computeGeodesicLength = function (measurer) {
          return measurer.measureLength(this.getCoordinates());
      };
      //@internal
      LineString.prototype._computeGeodesicArea = function () {
          return 0;
      };
      return LineString;
  }(Path));
  LineString.mergeOptions(options$x);
  LineString.registerJSONType('LineString');

  var TEMP_EXTENT$2 = new PointExtent();
  /**
   * @classdesc
   * Represents a GeometryCollection.
   * @category geometry
   * @extends Geometry
   * @example
   * var marker = new Marker([0, 0]),
   *     line = new LineString([[0, 0], [0, 1]]),
   *     polygon = new Polygon([[0, 0], [0, 1], [1, 3]]);
   * var collection = new GeometryCollection([marker, line, polygon])
   *     .addTo(layer);
   */
  var GeometryCollection = /** @class */ (function (_super) {
      __extends(GeometryCollection, _super);
      /**
       * @param {Geometry[]} geometries - GeometryCollection's geometries
       * @param {Object} [options=null] - options defined in [nGeometryCollection]{@link GeometryCollection#options}
       */
      function GeometryCollection(geometries, opts) {
          var _this = _super.call(this, opts) || this;
          _this.type = 'GeometryCollection';
          _this.setGeometries(geometries);
          return _this;
      }
      GeometryCollection.prototype.getContainerExtent = function (out) {
          var extent = out || new PointExtent();
          this.forEach(function (geo) {
              extent._combine(geo.getContainerExtent(TEMP_EXTENT$2));
          });
          return extent;
      };
      /**
       * 将多个几何图形设置到几何图形集合
       * @english
       * Set new geometries to the geometry collection
       * @param {Geometry[]} geometries
       * @return {GeometryCollection} this
       * @fires GeometryCollection#shapechange
       */
      GeometryCollection.prototype.setGeometries = function (_geometries) {
          var geometries = this._checkGeometries(_geometries || []);
          var symbol = this._getSymbol();
          var options = this.config();
          var properties = this.getProperties();
          //Set the collection as child geometries' parent.
          for (var i = geometries.length - 1; i >= 0; i--) {
              geometries[i]._initOptions(options);
              geometries[i]._setParent(this);
              geometries[i]._setEventParent(this);
              if (symbol) {
                  geometries[i].setSymbol(symbol);
              }
              if (properties) {
                  geometries[i].setProperties(properties);
              }
          }
          this._geometries = geometries;
          if (this.getLayer()) {
              this._bindGeometriesToLayer();
              this.onShapeChanged();
          }
          return this;
      };
      /**
       * 获取几何集合中的几何图形们
       * @english
       * Get geometries of the geometry collection
       * @return {Geometry[]} geometries
       */
      GeometryCollection.prototype.getGeometries = function () {
          return this._geometries || [];
      };
      /**
       * 按顺序对集合中存在的每个几何体执行一次提供的回调。
       * @english
       * Executes the provided callback once for each geometry present in the collection in order.
       * @param  {Function} fn             - a callback function
       * @param  {*} [context=undefined]   - callback's context
       * @return {GeometryCollection} this
       */
      GeometryCollection.prototype.forEach = function (fn, context) {
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              if (!context) {
                  fn(geometries[i], i);
              }
              else {
                  fn.call(context, geometries[i], i);
              }
          }
          return this;
      };
      /**
       * 创建一个几何集合类，这个集合类的所有元素都通过所提供的函数实现的测试
       * @english
       * Creates a GeometryCollection with all elements that pass the test implemented by the provided function.
       * @param  {Function} fn      - Function to test each geometry
       * @param  {*} [context=undefined]    - Function's context
       * @return {GeometryCollection} A GeometryCollection with all elements that pass the test
       * @example
       * var filtered = collection.filter(['==', 'foo', 'bar]);
       * @example
       * var filtered = collection.filter(geometry => geometry.getProperties().foo === 'bar');
       */
      GeometryCollection.prototype.filter = function (fn, context) {
          if (!fn) {
              return new GeometryCollection();
          }
          var selected = [];
          var isFn = isFunction(fn);
          var filter = isFn ? fn : createFilter(fn);
          this.forEach(function (geometry) {
              var g = isFn ? geometry : getFilterFeature(geometry);
              if (context ? filter.call(context, g) : filter(g)) {
                  selected.push(geometry);
              }
          }, this);
          return new GeometryCollection(selected);
      };
      /**
       * 按给定偏移平移或移动几何体集合。
       * @english
       * Translate or move the geometry collection by the given offset.
       * @param  {Coordinate} offset - translate offset
       * @return {GeometryCollection} this
       */
      GeometryCollection.prototype.translate = function (offset) {
          if (!offset) {
              return this;
          }
          if (this.isEmpty()) {
              return this;
          }
          // eslint-disable-next-line prefer-rest-params
          var args = arguments;
          this.forEach(function (geometry) {
              if (geometry && geometry.translate) {
                  // eslint-disable-next-line prefer-spread
                  geometry.translate.apply(geometry, args);
              }
          });
          return this;
      };
      /**
       * 几何图形集合是否为空
       * @english
       * Whether the geometry collection is empty
       * @return {Boolean}
       */
      GeometryCollection.prototype.isEmpty = function () {
          return !isArrayHasData(this.getGeometries());
      };
      /**
       * 移除本身，如果图层含有的话
       * @english
       * remove itself from the layer if any.
       * @returns {Geometry} this
       * @fires GeometryCollection#removestart
       * @fires GeometryCollection#remove
       * @fires GeometryCollection#removeend
       */
      GeometryCollection.prototype.remove = function () {
          this.forEach(function (geometry) {
              geometry._unbind();
          });
          // eslint-disable-next-line prefer-rest-params
          return Geometry.prototype.remove.apply(this, arguments);
      };
      /**
       * 显示几何集合
       * @english
       * Show the geometry collection.
       * @return {GeometryCollection} this
       * @fires GeometryCollection#show
       */
      GeometryCollection.prototype.show = function () {
          this.options['visible'] = true;
          this.forEach(function (geometry) {
              geometry.show();
          });
          return this;
      };
      /**
       * 隐藏几何集合
       * @english
       * Hide the geometry collection.
       * @return {GeometryCollection} this
       * @fires GeometryCollection#hide
       */
      GeometryCollection.prototype.hide = function () {
          this.options['visible'] = false;
          this.forEach(function (geometry) {
              geometry.hide();
          });
          return this;
      };
      GeometryCollection.prototype.onConfig = function (config) {
          this.forEach(function (geometry) {
              geometry.config(config);
          });
      };
      GeometryCollection.prototype.getSymbol = function () {
          var s = _super.prototype.getSymbol.call(this);
          if (!s) {
              var symbols_1 = [];
              var is_1 = false;
              this.forEach(function (g) {
                  var symbol = g.getSymbol();
                  if (symbol && !is_1) {
                      is_1 = true;
                  }
                  symbols_1.push(g.getSymbol());
              });
              if (is_1) {
                  s = {
                      'children': symbols_1
                  };
              }
          }
          return s;
      };
      GeometryCollection.prototype.setSymbol = function (s) {
          var _this = this;
          if (s && s['children']) {
              this._symbol = null;
              this.forEach(function (g, i) {
                  g._eventSymbolProperties = _this._eventSymbolProperties;
                  g.setSymbol(s['children'][i]);
              });
          }
          else {
              var symbol_1 = this._prepareSymbol(s);
              this._symbol = symbol_1;
              this.forEach(function (g) {
                  g._eventSymbolProperties = _this._eventSymbolProperties;
                  g.setSymbol(symbol_1);
              });
          }
          this.onSymbolChanged();
          return this;
      };
      //@internal
      GeometryCollection.prototype._setExternSymbol = function (symbol) {
          symbol = this._prepareSymbol(symbol);
          this._externSymbol = symbol;
          this.forEach(function (geometry) {
              geometry._setExternSymbol(symbol);
          });
          this.onSymbolChanged();
          return this;
      };
      /**
       * 绑定几何几何到一个图层
       * @english
       * bind this geometry collection to a layer
       * @param  {Layer} layer
       * @private
       */
      //@internal
      GeometryCollection.prototype._bindLayer = function () {
          // eslint-disable-next-line prefer-rest-params
          _super.prototype._bindLayer.apply(this, arguments);
          this._bindGeometriesToLayer();
      };
      //@internal
      GeometryCollection.prototype._bindGeometriesToLayer = function () {
          var layer = this.getLayer();
          this.forEach(function (geometry) {
              geometry._bindLayer(layer);
          });
      };
      /**
       * 检查几何图形的类型是否有效
       * @english
       * Check whether the type of geometries is valid
       * @param  {Geometry[]} geometries - geometries to check
       * @private
       */
      //@internal
      GeometryCollection.prototype._checkGeometries = function (geometries) {
          var invalidGeoError = 'The geometry added to collection is invalid.';
          geometries = Array.isArray(geometries) ? geometries : [geometries];
          var filterGeometries = [];
          for (var i = 0, l = geometries.length; i < l; i++) {
              var geometry = geometries[i];
              if (!geometry) {
                  continue;
              }
              if (!this._checkGeo(geometry)) {
                  console.error(invalidGeoError + ' Index: ' + i);
                  continue;
              }
              if (isSelf(geometry)) {
                  if (!GlobalConfig.isTest) {
                      console.error(geometry, ' is GeometryCollection sub class,it Cannot be placed in GeometryCollection');
                  }
                  continue;
              }
              filterGeometries.push(geometry);
          }
          return filterGeometries;
      };
      //@internal
      GeometryCollection.prototype._checkGeo = function (geo) {
          return (geo instanceof Geometry);
      };
      //@internal
      GeometryCollection.prototype._updateCache = function () {
          this._clearCache();
          if (this.isEmpty()) {
              return;
          }
          this.forEach(function (geometry) {
              if (geometry && geometry._updateCache) {
                  geometry._updateCache();
              }
          });
      };
      //@internal
      GeometryCollection.prototype._removePainter = function () {
          if (this._painter) {
              this._painter.remove();
          }
          delete this._painter;
          this.forEach(function (geometry) {
              geometry._removePainter();
          });
      };
      //@internal
      GeometryCollection.prototype._computeCenter = function (projection) {
          if (!projection || this.isEmpty()) {
              return null;
          }
          var sumX = 0, sumY = 0, counter = 0;
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              var center = geometries[i]._computeCenter(projection);
              if (center) {
                  sumX += center.x;
                  sumY += center.y;
                  counter++;
              }
          }
          if (counter === 0) {
              return null;
          }
          return new Coordinate(sumX / counter, sumY / counter);
      };
      //@internal
      GeometryCollection.prototype._containsPoint = function (point, t) {
          if (this.isEmpty()) {
              return false;
          }
          delete this._pickGeometryIndex;
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (geometries[i]._containsPoint(point, t)) {
                  this._pickGeometryIndex = i;
                  return true;
              }
          }
          return false;
      };
      // fix #2177 GeometryCollection hitTolerance always is 0
      //@internal
      GeometryCollection.prototype._hitTestTolerance = function () {
          var geometries = this.getGeometries();
          var hitTolerance = 0;
          for (var i = 0, len = geometries.length; i < len; i++) {
              var t = geometries[i]._hitTestTolerance();
              hitTolerance = Math.max(hitTolerance, t);
          }
          return hitTolerance;
      };
      //@internal
      GeometryCollection.prototype._computeExtent = function (projection) {
          return computeExtent.call(this, projection, '_computeExtent');
      };
      //@internal
      GeometryCollection.prototype._computePrjExtent = function (projection) {
          return computeExtent.call(this, projection, '_computePrjExtent');
      };
      //@internal
      GeometryCollection.prototype._computeGeodesicLength = function (projection) {
          if (!projection || this.isEmpty()) {
              return 0;
          }
          var geometries = this.getGeometries();
          var result = 0;
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              result += geometries[i]._computeGeodesicLength(projection);
          }
          return result;
      };
      //@internal
      GeometryCollection.prototype._computeGeodesicArea = function (projection) {
          if (!projection || this.isEmpty()) {
              return 0;
          }
          var geometries = this.getGeometries();
          var result = 0;
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              result += geometries[i]._computeGeodesicArea(projection);
          }
          return result;
      };
      //for toGeoJSON
      //@internal
      GeometryCollection.prototype._exportGeoJSONGeometry = function () {
          var children = [];
          if (!this.isEmpty()) {
              var geometries = this.getGeometries();
              for (var i = 0, l = geometries.length; i < l; i++) {
                  if (!geometries[i]) {
                      continue;
                  }
                  children.push(geometries[i]._exportGeoJSONGeometry());
              }
          }
          return {
              'type': 'GeometryCollection',
              'geometries': children
          };
      };
      //for toJSON
      //@internal
      GeometryCollection.prototype._toJSON = function (options) {
          //fix call from feature-filter package
          options = extend$2({}, options);
          //Geometry了用的是toGeoJSON(),如果里面包含特殊图形(Circle等),就不能简单的用toGeoJSON代替了，否则反序列化回来就不是原来的图形了
          var feature = {
              'type': 'Feature',
              'geometry': {
                  'type': 'GeometryCollection',
                  'geometries': this.getGeometries().filter(function (geo) {
                      return geo && geo._toJSON;
                  }).map(function (geo) {
                      var json = geo._toJSON();
                      if (json.subType) {
                          return json;
                      }
                      return geo._exportGeoJSONGeometry();
                  })
              }
          };
          var id = this.getId();
          if (!isNil(id)) {
              feature['id'] = id;
          }
          var properties;
          if (isNil(options['properties']) || options['properties']) {
              properties = this._exportProperties();
          }
          feature['properties'] = properties;
          options.feature = feature;
          return options;
      };
      //@internal
      GeometryCollection.prototype._clearProjection = function () {
          if (this.isEmpty()) {
              return;
          }
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              geometries[i]._clearProjection();
          }
      };
      /**
       * 如果通过[ConnectorLine]连接，则获取连接点
       * @english
       * Get connect points if being connected by [ConnectorLine]{@link ConnectorLine}
       * @private
       * @return {Coordinate[]}
       */
      //@internal
      GeometryCollection.prototype._getConnectPoints = function () {
          var extent = this.getExtent();
          var anchors = [
              new Coordinate(extent.xmin, extent.ymax),
              new Coordinate(extent.xmax, extent.ymin),
              new Coordinate(extent.xmin, extent.ymin),
              new Coordinate(extent.xmax, extent.ymax)
          ];
          return anchors;
      };
      //@internal
      GeometryCollection.prototype._getExternalResources = function () {
          if (this.isEmpty()) {
              return [];
          }
          var geometries = this.getGeometries(), resources = [];
          var cache = {};
          var symbol, res, key;
          for (var i = 0, l = geometries.length; i < l; i++) {
              if (!geometries[i]) {
                  continue;
              }
              symbol = geometries[i]._getInternalSymbol();
              res = getExternalResources(symbol);
              for (var ii = 0, ll = res.length; ii < ll; ii++) {
                  key = res[ii].join();
                  if (!cache[key]) {
                      resources.push(res[ii]);
                      cache[key] = 1;
                  }
              }
          }
          return resources;
      };
      //----------Overrides editor methods in Geometry-----------------
      GeometryCollection.prototype.startEdit = function (opts) {
          var _this = this;
          if (this.isEmpty()) {
              return this;
          }
          if (!opts) {
              opts = {};
          }
          if (opts['symbol']) {
              this._originalSymbol = this.getSymbol();
              this.setSymbol(opts['symbol']);
          }
          this._draggbleBeforeEdit = this.options['draggable'];
          this.config('draggable', false);
          this._recordVisible();
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              geometries[i].startEdit(opts);
          }
          this._editing = true;
          var layer = this.getLayer();
          var needShadow = layer && layer.options['renderer'] === 'canvas';
          if (needShadow) {
              this.hide();
          }
          setTimeout(function () {
              _this.fire('editstart');
          }, 1);
          return this;
      };
      GeometryCollection.prototype.endEdit = function () {
          if (this.isEmpty()) {
              return this;
          }
          this._recoveryVisible();
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              geometries[i].endEdit();
          }
          if (this._originalSymbol) {
              this.setSymbol(this._originalSymbol);
              delete this._originalSymbol;
          }
          this._editing = false;
          this.show();
          this.config('draggable', this._draggbleBeforeEdit);
          this.fire('editend');
          return this;
      };
      GeometryCollection.prototype.isEditing = function () {
          if (!this._editing) {
              return false;
          }
          return true;
      };
      return GeometryCollection;
  }(Geometry));
  GeometryCollection.registerJSONType('GeometryCollection');
  function computeExtent(projection, fn) {
      if (this.isEmpty()) {
          return null;
      }
      var extent = new Extent();
      var geometries = this.getGeometries();
      for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
              continue;
          }
          var e = geometries[i][fn](projection);
          if (e) {
              extent._combine(e);
          }
      }
      return extent;
  }
  function isSelf(geom) {
      return (geom instanceof GeometryCollection);
  }

  var MultiGeometry = /** @class */ (function (_super) {
      __extends(MultiGeometry, _super);
      /**
       * @param  {Class} geoType      Type of the geometry
       * @param  {String} type        type in String, e.g. "MultiPoint", "MultiLineString"
       * @param  {Geometry[]} data    data
       * @param  {Object} [options=null] configuration options
       */
      function MultiGeometry(geoType, type, data, options) {
          var _this = _super.call(this, null, options) || this;
          _this.GeometryType = geoType;
          _this.type = type;
          _this._initData(data);
          return _this;
      }
      /**
       * 获取集合中得坐标
       * @english
       * Get coordinates of the collection
       * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates
       */
      MultiGeometry.prototype.getCoordinates = function () {
          var coordinates = [];
          var geometries = this.getGeometries();
          for (var i = 0, l = geometries.length; i < l; i++) {
              var child = geometries[i];
              coordinates.push(child.getShell && child.getJSONType() !== 'Polygon' ? [child.getShell()] : child.getCoordinates());
          }
          return coordinates;
      };
      /**
       * 设置集合得坐标
       * @english
       * Set new coordinates to the collection
       * @param {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates
       * @returns {Geometry} this
       * @fires maptalk.Geometry#shapechange
       */
      MultiGeometry.prototype.setCoordinates = function (coordinates) {
          coordinates = coordinates || [];
          var geometries = [];
          for (var i = 0, l = coordinates.length; i < l; i++) {
              var g = new this.GeometryType(coordinates[i], this.config());
              geometries.push(g);
          }
          this.setGeometries(geometries);
          return this;
      };
      //@internal
      MultiGeometry.prototype._initData = function (data) {
          data = data || [];
          if (data.length) {
              if (data[0] instanceof this.GeometryType) {
                  this.setGeometries(data);
              }
              else {
                  this.setCoordinates(data);
              }
          }
      };
      //@internal
      MultiGeometry.prototype._checkGeo = function (geo) {
          return (geo instanceof this.GeometryType);
      };
      //override _exportGeoJSONGeometry in GeometryCollection
      // @ts-expect-error 确实需要重写父类的属性
      //@internal
      MultiGeometry.prototype._exportGeoJSONGeometry = function () {
          var points = this.getCoordinates();
          var coordinates = Coordinate.toNumberArrays(points);
          return {
              'type': this.getType(),
              'coordinates': coordinates
          };
      };
      //@internal
      MultiGeometry.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options)
          };
      };
      return MultiGeometry;
  }(GeometryCollection));

  /**
   * @classdesc
   * Represents a Geometry type of MultiPoint.
   * @category geometry
   * @extends MultiGeometry
   * @example
   * var multiPoint = new MultiPoint(
   *     [
   *         [121.5080881906138, 31.241128104458117],
   *         [121.50804527526954, 31.237238340103413],
   *         [121.5103728890997, 31.23888972560888]
   *     ]
   * ).addTo(layer);
   */
  var MultiPoint = /** @class */ (function (_super) {
      __extends(MultiPoint, _super);
      /**
       * @param {Number[][]|Coordinate[]|Marker[]} data - construct data, coordinates or an array of markers
       * @param {Object} [options=null] - options defined in [nMultiPoint]{@link MultiPoint#options}
       */
      function MultiPoint(data, opts) {
          return _super.call(this, Marker, 'MultiPoint', data, opts) || this;
      }
      /**
       * 找到给定坐标的最近点
       * @english
       * Find the closet point to the give coordinate
       * @param {Coordinate} coordinate coordinate
       * @returns {Coordinate} coordinate
       */
      MultiPoint.prototype.findClosest = function (coordinate) {
          if (!coordinate) {
              return null;
          }
          var coords = this.getCoordinates();
          var hit = null;
          var max = Infinity;
          coords.forEach(function (c) {
              var dist = distanceTo(c, coordinate);
              if (dist < max) {
                  hit = c;
                  max = dist;
              }
          });
          return hit;
      };
      return MultiPoint;
  }(MultiGeometry));
  MultiPoint.registerJSONType('MultiPoint');
  function distanceTo(p0, p1) {
      var x = p1.x - p0.x, y = p1.y - p0.y;
      return Math.sqrt(x * x + y * y);
  }

  /**
   * @classdesc
   * An abstract class for MultiPolygon and MultiLineString
   * @category geometry
   * @extends MultiGeometry
   */
  var MultiPath = /** @class */ (function (_super) {
      __extends(MultiPath, _super);
      function MultiPath() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * 获取（MultiLineString或MultiPolygon）与给定范围的交点的中心
       * @english
       * Get center of (MultiLineString or MultiPolygon)'s intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = geometry.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      MultiPath.prototype.getCenterInExtent = function (extent) {
          var children = this.getGeometries();
          var _a = __read([0, 0, 0], 3), sumx = _a[0], sumy = _a[1], counter = _a[2];
          children.forEach(function (l) {
              // @ts-expect-error todo
              var c = l.getCenterInExtent(extent);
              if (c) {
                  sumx += c.x * c.count;
                  sumy += c.y * c.count;
                  counter += c.count;
              }
          });
          if (counter === 0) {
              return null;
          }
          return new Coordinate(sumx, sumy)._multi(1 / counter);
      };
      return MultiPath;
  }(MultiGeometry));

  /**
   * @classdesc
   * Represents a Geometry type of MultiLineString
   * @category geometry
   * @extends MultiGeometry
   * @example
   * var multiLineString = new MultiLineString(
   *      [
   *          [
   *              [121.5289450479131, 31.2420083925986],
   *              [121.52860172515919, 31.238926401171824]
   *          ],
   *          [
   *              [121.53091915374796, 31.241898323208233],
   *              [121.53104789978069, 31.23859618183896]
   *          ],
   *          [
   *               [121.5324641061405, 31.241898323208233],
   *               [121.53242119079626, 31.239146546752256]
   *           ]
   *       ],
   *       {
   *           symbol:{
   *               'lineColor' : '#000000',
   *               'lineWidth' : 5,
   *               'lineOpacity' : 1
   *           },
   *          draggable:true
   *      }
   * ).addTo(layer);
   */
  var MultiLineString = /** @class */ (function (_super) {
      __extends(MultiLineString, _super);
      /**
       * @param {Number[][][]|Coordinate[][]|LineString[]} data - construct data, coordinates or an array of linestrings
       * @param {Object} [options=null]           - options defined in [MultiLineString]{@link MultiLineString#options}
       */
      function MultiLineString(data, options) {
          return _super.call(this, LineString, 'MultiLineString', data, options) || this;
      }
      return MultiLineString;
  }(MultiPath));
  MultiLineString.registerJSONType('MultiLineString');

  /**
   * @classdesc
   * Represents a Geometry type of MultiPolygon
   * @category geometry
   * @extends MultiGeometry
   * @example
   * var multiPolygon = new MultiPolygon(
   *       [
   *           [
   *               [
   *                   [121.55074604278596, 31.242008515751614],
   *                   [121.55074604278596, 31.23914637638951],
   *                   [121.55349262481711, 31.23914637638951],
   *                   [121.55349262481711, 31.24134802974913],
   *                   [121.5518618417361, 31.241384723537074],
   *                   [121.55074604278596, 31.242008515751614]
   *               ]
   *           ],
   *           [
   *               [
   *                   [121.5543080163576, 31.241054478932387],
   *                   [121.5543938470461, 31.240100432478293],
   *                   [121.55555256134048, 31.240173821009137],
   *                   [121.55542381530773, 31.240981091085693],
   *                   [121.5543080163576, 31.241054478932387]
   *               ]
   *           ]
   *
   *       ],
   *       {
   *           symbol:{
   *               'lineColor' : '#000000',
   *               'lineWidth' : 2,
   *               'lineDasharray' : null,//线形
   *               'lineOpacity' : 1,
   *               'polygonFill' : 'rgb(255, 0, 0)',
   *               'polygonOpacity' : 0.8
   *           },
   *           draggable:true
   * }).addTo(layer);
   */
  var MultiPolygon = /** @class */ (function (_super) {
      __extends(MultiPolygon, _super);
      /**
       * @param {Number[][][][]|Coordinate[][][]|Polygon[]} data - construct data, coordinates or an array of polygons
       * @param {Object} [options=null]           - options defined in [MultiPolygon]{@link MultiPolygon#options}
       */
      function MultiPolygon(data, opts) {
          return _super.call(this, Polygon, 'MultiPolygon', data, opts) || this;
      }
      return MultiPolygon;
  }(MultiPath));
  MultiPolygon.registerJSONType('MultiPolygon');

  var types = {
      'Marker': Marker,
      'LineString': LineString,
      'Polygon': Polygon,
      'MultiPoint': MultiPoint,
      'MultiLineString': MultiLineString,
      'MultiPolygon': MultiPolygon
  };
  var WORKER_KEY = 'geojson-fetch-worker-page-async';
  var WORKER_CODE = "\nfunction (exports) {\n    const resultMap = {};\n\n    function handleResult(msg, postResponse) {\n        const data = msg.data || {};\n        const { taskId } = data;\n        const features = resultMap[taskId];\n        if (!features) {\n            postResponse('not find geojson dataset the taskId:' + taskId);\n            return;\n        }\n        if (features.length === 0) {\n            delete resultMap[taskId];\n            postResponse(null, []);\n            return;\n        }\n        const pageSize = data.pageSize || 2000;\n        const pageFeatures = features.slice(0, pageSize);\n        resultMap[taskId] = features.slice(pageSize, Infinity);\n        postResponse(null, pageFeatures);\n    }\n    //worker init\n    exports.initialize = function () {\n        // console.log(\"geojson fetch init\");\n    };\n    //recive message\n    exports.onmessage = function (msg, postResponse) {\n        const { taskId, type, url } = msg.data || {};\n        if (!taskId) {\n            postResponse('not find task id for get geojson dataset,taskId=' + taskId);\n            return;\n        }\n        if (type === 'fetchdata') {\n            if (!url) {\n                postResponse('url is null,url=' + url);\n                return;\n            }\n            fetch(url).then(res => res.json()).then(geojson => {\n                let features;\n                if (Array.isArray(geojson)) {\n                    features = geojson;\n                } else if (geojson.features) {\n                    features = geojson.features;\n                } else {\n                    features = [geojson];\n                }\n                resultMap[taskId] = features;\n                handleResult(msg, postResponse);\n            }).catch(errror => {\n                postResponse(errror.message);\n            });\n        } else if (type === 'pagefeatures') {\n            handleResult(msg, postResponse);\n        } else {\n            postResponse('not support task type:' + type);\n        }\n    };\n}";
  var GeoJSONFetchActor = /** @class */ (function (_super) {
      __extends(GeoJSONFetchActor, _super);
      function GeoJSONFetchActor() {
          return _super.call(this, WORKER_KEY) || this;
      }
      //@internal
      GeoJSONFetchActor.prototype._sendMsg = function (options, featuresList, cb) {
          var _this = this;
          this.send(options, [], function (error, data) {
              if (error) {
                  cb(error);
              }
              else {
                  _this._pageFeatures(options, data, featuresList, cb);
              }
          }, options.workerId);
      };
      //@internal
      GeoJSONFetchActor.prototype._fetchGeoJSON = function (url, options, featuresList, cb) {
          if (featuresList === void 0) { featuresList = []; }
          var opts = extend$2({}, options);
          opts.type = 'fetchdata';
          opts.url = url;
          this._sendMsg(opts, featuresList, cb);
      };
      //@internal
      GeoJSONFetchActor.prototype._pageFeatures = function (options, features, featuresList, cb) {
          featuresList.push(features);
          if (features.length === 0) {
              cb(null, featuresList);
              return;
          }
          var opts = extend$2({}, options);
          opts.type = 'pagefeatures';
          this._sendMsg(opts, featuresList, cb);
      };
      return GeoJSONFetchActor;
  }(Actor));
  registerWorkerAdapter(WORKER_KEY, function () { return WORKER_CODE; });
  var fetchActor;
  /**
   * GeoJSON工具类
   * @english
   * GeoJSON utilities
   * @category geometry
   */
  var GeoJSON = {
      /**
       * 将一个或多个GeoJSON对象转换为几何体
       * @english
       * Convert one or more GeoJSON objects to geometry
       * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string
       * @param  {Function} [foreachFn=undefined] - callback function for each geometry
       * @return {Geometry|Geometry[]} a geometry array when input is a FeatureCollection
       * @example
       * var collection = {
       *      "type": "FeatureCollection",
       *      "features": [
       *          { "type": "Feature",
       *            "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
       *            "properties": {"prop0": "value0"}
       *           },
       *           { "type": "Feature",
       *             "geometry": {
       *                 "type": "LineString",
       *                 "coordinates": [
       *                     [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
       *                 ]
       *             },
       *             "properties": {
       *                 "prop0": "value0",
       *                 "prop1": 0.0
       *             }
       *           },
       *           { "type": "Feature",
       *             "geometry": {
       *                 "type": "Polygon",
       *                 "coordinates": [
       *                     [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
       *                       [100.0, 1.0], [100.0, 0.0] ]
       *                 ]
       *             },
       *             "properties": {
       *                 "prop0": "value0",
       *                 "prop1": {"this": "that"}
       *             }
       *          }
       *      ]
       *  }
       *  // A geometry array.
       *  const geometries = GeoJSON.toGeometry(collection, geometry => { geometry.config('draggable', true); });
       */
      toGeometry: function (geoJSON, foreachFn) {
          if (isString(geoJSON)) {
              geoJSON = parseJSON(geoJSON);
          }
          if (Array.isArray(geoJSON)) {
              var resultGeos = [];
              for (var i = 0, len = geoJSON.length; i < len; i++) {
                  var geo = GeoJSON._convert(geoJSON[i], foreachFn);
                  if (Array.isArray(geo)) {
                      pushIn(resultGeos, geo);
                  }
                  else {
                      resultGeos.push(geo);
                  }
              }
              return resultGeos;
          }
          else {
              var resultGeo = GeoJSON._convert(geoJSON, foreachFn);
              return resultGeo;
          }
      },
      /**
       * async将一个或多个GeoJSON对象转换为几何体
       * @english
      * async Convert one or more GeoJSON objects to geometry
      * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string
      * @param  {Function} [foreachFn=undefined] - callback function for each geometry
      * @param  {Number} [countPerTime=2000] - Number of graphics converted per time
      * @return {Promise}
      * @example
      *  GeoJSON.toGeometryAsync(geoJSON).then(geos=>{
      *    console.log(geos);
      * })
      * */
      toGeometryAsync: function (geoJSON, foreachFn, countPerTime) {
          if (countPerTime === void 0) { countPerTime = 2000; }
          if (isString(geoJSON)) {
              geoJSON = parseJSON(geoJSON);
          }
          return new Promise(function (resolve) {
              var resultGeos = [];
              if (geoJSON && (Array.isArray(geoJSON) || Array.isArray(geoJSON.features))) {
                  var pageSize_1 = isNumber(countPerTime) ? Math.round(countPerTime) : 2000;
                  var features_1 = geoJSON.features || geoJSON;
                  var count = Math.ceil(features_1.length / pageSize_1);
                  var page_1 = 1;
                  var run = function () {
                      var startIndex = (page_1 - 1) * pageSize_1, endIndex = (page_1) * pageSize_1;
                      var fs = features_1.slice(startIndex, endIndex);
                      var geos = GeoJSON.toGeometry(fs, foreachFn);
                      page_1++;
                      return geos;
                  };
                  runTaskAsync({ count: count, run: run }).then(function (geoList) {
                      for (var i = 0, len = geoList.length; i < len; i++) {
                          var geo = geoList[i];
                          if (!geo) {
                              continue;
                          }
                          if (Array.isArray(geo)) {
                              pushIn(resultGeos, geo);
                          }
                          else {
                              resultGeos.push(geo);
                          }
                      }
                      resolve(resultGeos);
                  });
              }
              else {
                  var geo = GeoJSON.toGeometry(geoJSON, foreachFn);
                  resolve(geo);
              }
          });
      },
      /**
       * 转换单个GeoJSON对象
       * @english
       * Convert single GeoJSON object
       * @param  {Object} geoJSONObj - a GeoJSON object
       * @return {Geometry}
       * @private
       */
      //@internal
      _convert: function (json, foreachFn) {
          if (!json || isNil(json['type'])) {
              return null;
          }
          var type = json['type'];
          if (type === 'Feature') {
              var g = json['geometry'];
              var geometry = GeoJSON._convert(g);
              if (!geometry) {
                  return null;
              }
              geometry.setId(json['id']);
              geometry.setProperties(json['properties']);
              if (foreachFn) {
                  foreachFn(geometry);
              }
              return geometry;
          }
          else if (type === 'FeatureCollection') {
              var features = json['features'];
              if (!features) {
                  return null;
              }
              return GeoJSON.toGeometry(features, foreachFn);
          }
          else if (['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'].indexOf(type) >= 0) {
              var clazz = (type === 'Point' ? 'Marker' : type);
              var result = new types[clazz](json['coordinates']);
              if (foreachFn) {
                  foreachFn(result);
              }
              return result;
          }
          else if (type === 'GeometryCollection') {
              var geometries = json['geometries'];
              if (!isArrayHasData(geometries)) {
                  var result_1 = new GeometryCollection();
                  if (foreachFn) {
                      foreachFn(result_1);
                  }
                  return result_1;
              }
              var mGeos = [];
              var size = geometries.length;
              for (var i = 0; i < size; i++) {
                  //circle ellipse etc...
                  //规范上geojson里是没有Circle等图形的，但是Circle json等的反序列化有用到该方法
                  if (geometries[i].subType) {
                      // @ts-expect-error todo
                      mGeos.push(Geometry.getJSONClass(geometries[i].subType).fromJSON(geometries[i]));
                  }
                  else {
                      mGeos.push(GeoJSON._convert(geometries[i]));
                  }
              }
              var result = new GeometryCollection(mGeos);
              if (foreachFn) {
                  foreachFn(result);
              }
              return result;
          }
          return null;
      },
      //@internal
      _isGeoJSON: function (json) {
          if (!json) {
              return false;
          }
          json = json || {};
          //is flat geometries,[geometry,geometry,...]
          if (Array.isArray(json) && json.length) {
              // @ts-expect-error todo
              return GeoJSON.isGeoJSON(json[0]);
          }
          var type = json.type;
          if (!type) {
              return false;
          }
          if (GEOJSON_TYPES.indexOf(type) === -1) {
              return false;
          }
          var features = json.features, geometries = json.geometries, geometry = json.geometry, coordinates = json.coordinates;
          //Geometry
          if (coordinates && Array.isArray(coordinates)) {
              return true;
          }
          //GeometryCollection
          if (Array.isArray(geometries)) {
              return true;
          }
          //FeatureCollection
          if (Array.isArray(features)) {
              return true;
          }
          //Feature
          if (geometry) {
              var coordinates_1 = geometry.coordinates;
              if (coordinates_1 && Array.isArray(coordinates_1)) {
                  return true;
              }
          }
          return false;
      },
      /**
       * 正在请求一个大容量的geojson文件。解决主线程阻塞问题
       * @english
      * Requesting a large volume geojson file.Solve the problem of main thread blocking
      * @param  {String} url - GeoJSON file path
      * @param  {Number} [countPerTime=2000] - Number of graphics converted per time
      * @return {Promise}
      * @example
      *  GeoJSON.fetch('https://abc.com/file.geojson',2000).then(geojson=>{
      *    console.log(geojson);
      * })
      * */
      fetch: function (url, countPerTime) {
          if (countPerTime === void 0) { countPerTime = 2000; }
          return new Promise(function (resolve, reject) {
              if (!url || !isString(url)) {
                  reject('url is error,It should be string');
                  return;
              }
              var options = extend$2({ pageSize: 2000 }, { pageSize: countPerTime });
              url = getAbsoluteURL(url);
              if (!fetchActor) {
                  fetchActor = new GeoJSONFetchActor();
              }
              var workerCount = fetchActor.workers.length;
              var workerId = Math.floor(Math.random() * workerCount);
              workerId = Math.min(workerCount - 1, workerId);
              options.workerId = workerId;
              options.taskId = GUID();
              fetchActor._fetchGeoJSON(url, options, [], function (error, featuresList) {
                  if (error) {
                      reject(error);
                      return;
                  }
                  var result = [];
                  featuresList.forEach(function (features) {
                      for (var i = 0, len = features.length; i < len; i++) {
                          result.push(features[i]);
                      }
                  });
                  resolve({
                      type: 'FeatureCollection',
                      features: result
                  });
              });
          });
      }
  };

  /**
   * @property {Object} options
   * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when converting the circle to a polygon.
   * @memberOf Circle
   * @instance
   */
  var options$w = {
      'numberOfShellPoints': 60
  };
  /**
   * @classdesc
   * Represents a Circle Geometry. <br>
   * @category geometry
   * @extends Polygon
   * @mixes Geometry.Center
   * @example
   * var circle = new Circle([100, 0], 1000, {
   *     id : 'circle0',
   *     properties : {
   *         foo : 'bar'
   *     }
   * });
   * @mixes CenterMixin
   */
  var Circle = /** @class */ (function (_super) {
      __extends(Circle, _super);
      /**
       * @param {Coordinate} center - center of the circle
       * @param {Number} radius           - radius of the circle, in meter
       * @param {Object} [options=null]   - construct options defined in [Circle]{@link Circle#options}
       */
      function Circle(coordinates, radius, options) {
          var _this = _super.call(this, null, options) || this;
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          _this._radius = radius;
          return _this;
      }
      Circle.fromJSON = function (json) {
          var feature = json['feature'];
          var circle = new Circle(json['coordinates'], json['radius'], json['options']);
          circle.setProperties(feature['properties']);
          return circle;
      };
      /**
       * 获取圆形的半径
       * @english
       * Get radius of the circle
       * @return {Number}
       */
      Circle.prototype.getRadius = function () {
          return this._radius;
      };
      /**
       * 给圆形设置新的半径
       * @english
       * Set a new radius to the circle
       * @param {Number} radius - new radius
       * @return {Circle} this
       * @fires Circle#shapechange
       */
      Circle.prototype.setRadius = function (radius) {
          this._radius = radius;
          this.onShapeChanged();
          return this;
      };
      /**
       * 获取作为多边形的圆的外壳，外壳点数由[options.numberOfShellPoints决定
       * @english
       * Gets the shell of the circle as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}
       * @return {Coordinate[]} - shell coordinates
       */
      Circle.prototype.getShell = function () {
          var measurer = this._getMeasurer(), center = this.getCoordinates(), numberOfPoints = this.options['numberOfShellPoints'], radius = this.getRadius();
          var shell = [];
          var rad, dx, dy;
          for (var i = 0, len = numberOfPoints - 1; i < len; i++) {
              rad = (360 * i / len) * Math.PI / 180;
              dx = radius * Math.cos(rad);
              dy = radius * Math.sin(rad);
              var vertex = measurer.locate(center, dx, dy);
              vertex.z = center.z;
              shell.push(vertex);
          }
          shell.push(shell[0]);
          return shell;
      };
      /**
       * 圆没有任何孔，总是返回null
       * @english
       * Circle won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      Circle.prototype.getHoles = function () {
          return [];
      };
      Circle.prototype.animateShow = function () {
          return this.show();
      };
      //@internal
      Circle.prototype._containsPoint = function (point, tolerance) {
          var map = this.getMap();
          if (map.getPitch()) {
              return _super.prototype._containsPoint.call(this, point, tolerance);
          }
          var center = map._pointToContainerPoint(this._getCenter2DPoint()), size = this.getSize(), t = this._hitTestTolerance() + (tolerance || 0), se = center.add(size.width / 2, size.height / 2);
          return withInEllipse(point, center, se, t);
      };
      //@internal
      Circle.prototype._computePrjExtent = function (projection) {
          var minmax = this._getMinMax(projection);
          if (!minmax) {
              return null;
          }
          var pcenter = this._getPrjCoordinates();
          var pminmax = minmax.map(function (c) { return projection.project(c); });
          var leftx = pminmax[0].x - pcenter.x;
          var rightx = pminmax[1].x - pcenter.x;
          var topy = pminmax[2].y - pcenter.y;
          var bottomy = pminmax[3].y - pcenter.y;
          return new Extent(pcenter.add(leftx, topy), pcenter.add(rightx, bottomy));
      };
      //@internal
      Circle.prototype._computeExtent = function (measurer) {
          var minmax = this._getMinMax(measurer);
          if (!minmax) {
              return null;
          }
          return new Extent(minmax[0].x, minmax[2].y, minmax[1].x, minmax[3].y, this._getProjection());
      };
      //@internal
      Circle.prototype._getMinMax = function (measurer) {
          if (!measurer || !this._coordinates || isNil(this._radius)) {
              return null;
          }
          var radius = this._radius;
          var p1 = measurer.locate(this._coordinates, -radius, 0), p2 = measurer.locate(this._coordinates, radius, 0), p3 = measurer.locate(this._coordinates, 0, radius), p4 = measurer.locate(this._coordinates, 0, -radius);
          return [p1, p2, p3, p4];
      };
      //@internal
      Circle.prototype._computeGeodesicLength = function () {
          if (isNil(this._radius)) {
              return 0;
          }
          return Math.PI * 2 * this._radius;
      };
      //@internal
      Circle.prototype._computeGeodesicArea = function () {
          if (isNil(this._radius)) {
              return 0;
          }
          return Math.PI * Math.pow(this._radius, 2);
      };
      //@internal
      Circle.prototype._exportGeoJSONGeometry = function () {
          var coordinates = Coordinate.toNumberArrays([this.getShell()]);
          return {
              'type': 'Polygon',
              'coordinates': coordinates
          };
      };
      //@internal
      Circle.prototype._toJSON = function (options) {
          var center = this.getCenter();
          var opts = extend$2({}, options);
          opts.geometry = false;
          var feature = this.toGeoJSON(opts);
          feature['geometry'] = {
              'type': 'Polygon'
          };
          return {
              'feature': feature,
              'subType': 'Circle',
              'coordinates': [center.x, center.y],
              'radius': this.getRadius()
          };
      };
      return Circle;
  }(CenterMixin(Polygon)));
  Circle.mergeOptions(options$w);
  Circle.registerJSONType('Circle');

  // https://zh.numberempire.com/graphingcalculator.php?functions=x%5E4&xmin=0&xmax=1&ymin=-1.0&ymax=1.0&var=x
  function quarticIn(k) {
      return k * k * k * k;
  }
  function angleT(numberOfShellPoints) {
      //利用曲线方程,让角度的变化变成非线性
      var fs = [];
      // [0,90] 变化曲线
      var ts1 = [];
      for (var i = 0; i < numberOfShellPoints; i++) {
          ts1.push(quarticIn(i / numberOfShellPoints));
      }
      // [90,180] 变化曲线
      var ts2 = ts1.map(function (t) {
          return t;
      }).reverse();
      var ts = [];
      pushIn(ts, ts1, ts2, ts1, ts2);
      var sum = 0;
      for (var i = 0, len = ts.length; i < len; i += 4) {
          fs.push(ts[i]);
          sum += ts[i];
      }
      return {
          fs: fs,
          sum: sum
      };
  }
  /**
   * @property {Object} [options=null]
   * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when exporting the ellipse's shell coordinates as a polygon.
   * @memberOf Ellipse
   * @instance
   */
  var options$v = {
      'numberOfShellPoints': 81
  };
  /**
   * 表示椭圆几何体
   * @english
   * Represents a Ellipse Geometry. <br>
   * @category geometry
   * @extends Polygon
   * @mixes CenterMixin
   * @example
   * var ellipse = new Ellipse([100, 0], 1000, 500, {
   *     id : 'ellipse0'
   * });
   */
  var Ellipse = /** @class */ (function (_super) {
      __extends(Ellipse, _super);
      /**
       * @param {Coordinate} center  - center of the ellipse
       * @param {Number} width  - width of the ellipse, in meter
       * @param {Number} height - height of the ellipse, in meter
       * @param {Object}  [options=null] - construct options defined in [Ellipse]{@link Ellipse#options}
       */
      function Ellipse(coordinates, width, height, options) {
          var _this = _super.call(this, null, options) || this;
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          _this.width = width;
          _this.height = height;
          return _this;
      }
      Ellipse.fromJSON = function (json) {
          var feature = json['feature'];
          var ellipse = new Ellipse(json['coordinates'], json['width'], json['height'], json['options']);
          ellipse.setProperties(feature['properties']);
          return ellipse;
      };
      /**
       * 获取椭圆的宽度
       * @english
       * Get ellipse's width
       * @return {Number}
       */
      Ellipse.prototype.getWidth = function () {
          return this.width;
      };
      /**
       * 设置椭圆的宽度
       * Set new width to ellipse
       * @param {Number} width - new width
       * @fires Ellipse#shapechange
       * @return {Ellipse} this
       */
      Ellipse.prototype.setWidth = function (width) {
          this.width = width;
          this.onShapeChanged();
          return this;
      };
      /**
       * 获取椭圆高度
       * @english
       * Get ellipse's height
       * @return {Number}
       */
      Ellipse.prototype.getHeight = function () {
          return this.height;
      };
      /**
       * 设置椭圆高度
       * @english
       * Set new height to ellipse
       * @param {Number} height - new height
       * @fires Ellipse#shapechange
       * @return {Ellipse} this
       */
      Ellipse.prototype.setHeight = function (height) {
          this.height = height;
          this.onShapeChanged();
          return this;
      };
      /**
       * 获取作为多边形的椭圆的外壳，外壳点数由决定
       * @english
       * Gets the shell of the ellipse as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}
       * @return {Coordinate[]} - shell coordinates
       */
      Ellipse.prototype.getShell = function () {
          if (this.isRotated()) {
              return this.getRotatedShell();
          }
          return this._getShell();
      };
      //@internal
      Ellipse.prototype._getShell = function () {
          var measurer = this._getMeasurer(), center = this.getCoordinates(), numberOfPoints = this.options['numberOfShellPoints'] - 1, width = this.getWidth(), height = this.getHeight();
          var shell = [];
          var s = Math.pow(width / 2, 2) * Math.pow(height / 2, 2), sx = Math.pow(width / 2, 2), sy = Math.pow(height / 2, 2);
          var angles = [];
          if (Math.max(width / height, height / width) > 2) {
              var _a = angleT(numberOfPoints), fs = _a.fs, sum = _a.sum;
              var dt = 360 / sum;
              var offsetAngle = 0;
              //Y > X
              if (height > width) {
                  offsetAngle = 90;
              }
              var angle = 0;
              for (var i = 0, len = fs.length; i < len; i++) {
                  angle += dt * fs[i];
                  angles.push(angle + offsetAngle);
              }
          }
          else {
              for (var i = 0; i < numberOfPoints; i++) {
                  var angle = 360 * i / numberOfPoints;
                  angles.push(angle);
              }
          }
          if (this.options.debug) {
              console.log(angles);
          }
          var deg, rad, dx, dy;
          for (var i = 0; i < angles.length; i++) {
              deg = angles[i];
              rad = deg * Math.PI / 180;
              dx = Math.sqrt(s / (sx * Math.pow(Math.tan(rad), 2) + sy));
              dy = Math.sqrt(s / (sy * Math.pow(1 / Math.tan(rad), 2) + sx));
              if (deg > 90 && deg < 270) {
                  dx *= -1;
              }
              if (deg > 180 && deg < 360) {
                  dy *= -1;
              }
              var vertex = measurer.locate(center, dx, dy);
              vertex.z = center.z;
              shell.push(vertex);
          }
          shell.push(shell[0].copy());
          return shell;
      };
      //@internal
      Ellipse.prototype._getPrjShell = function () {
          var shell = _super.prototype._getPrjShell.call(this);
          return this._rotatePrjCoordinates(shell);
      };
      /**
       * 椭圆没有任何孔，总是返回null
       * @english
       * Ellipse won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      Ellipse.prototype.getHoles = function () {
          return [];
      };
      Ellipse.prototype.animateShow = function () {
          return this.show();
      };
      //@internal
      Ellipse.prototype._containsPoint = function (point, tolerance) {
          var map = this.getMap();
          if (map.isTransforming()) {
              return _super.prototype._containsPoint.call(this, point, tolerance);
          }
          var projection = map.getProjection();
          var t = this._hitTestTolerance() + (tolerance || 0), pps = projection.projectCoords([this._coordinates, map.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2)], this.options['antiMeridian']), p0 = map.prjToContainerPoint(pps[0]), p1 = map.prjToContainerPoint(pps[1]);
          return withInEllipse(point, p0, p1, t);
      };
      //@internal
      Ellipse.prototype._computePrjExtent = function () {
          if (this.isRotated()) {
              return this._computeRotatedPrjExtent();
          }
          // eslint-disable-next-line prefer-rest-params
          return Circle.prototype._computePrjExtent.apply(this, arguments);
      };
      //@internal
      Ellipse.prototype._computeExtent = function () {
          // eslint-disable-next-line prefer-rest-params
          return Circle.prototype._computeExtent.apply(this, arguments);
      };
      //@internal
      Ellipse.prototype._getMinMax = function (measurer) {
          if (!measurer || !this._coordinates || isNil(this.width) || isNil(this.height)) {
              return null;
          }
          var width = this.getWidth(), height = this.getHeight();
          var p1 = measurer.locate(this._coordinates, -width / 2, 0), p2 = measurer.locate(this._coordinates, width / 2, 0), p3 = measurer.locate(this._coordinates, 0, -height / 2), p4 = measurer.locate(this._coordinates, 0, height / 2);
          return [p1, p2, p3, p4];
      };
      //@internal
      Ellipse.prototype._computeGeodesicLength = function () {
          if (isNil(this.width) || isNil(this.height)) {
              return 0;
          }
          //L=2πb+4(a-b)
          //近似值
          var longer = (this.width > this.height ? this.width : this.height);
          return 2 * Math.PI * longer / 2 - 4 * Math.abs(this.width - this.height);
      };
      //@internal
      Ellipse.prototype._computeGeodesicArea = function () {
          if (isNil(this.width) || isNil(this.height)) {
              return 0;
          }
          return Math.PI * this.width * this.height / 4;
      };
      //@internal
      Ellipse.prototype._exportGeoJSONGeometry = function () {
          var coordinates = Coordinate.toNumberArrays([this.getShell()]);
          return {
              'type': 'Polygon',
              'coordinates': coordinates
          };
      };
      //@internal
      Ellipse.prototype._toJSON = function (options) {
          var opts = extend$2({}, options);
          var center = this.getCenter();
          opts.geometry = false;
          var feature = this.toGeoJSON(opts);
          feature['geometry'] = {
              'type': 'Polygon'
          };
          return {
              'feature': feature,
              'subType': 'Ellipse',
              'coordinates': [center.x, center.y],
              'width': this.getWidth(),
              'height': this.getHeight()
          };
      };
      return Ellipse;
  }(CenterMixin(Polygon)));
  Ellipse.mergeOptions(options$v);
  Ellipse.registerJSONType('Ellipse');

  /**
   * @classdesc
   * Represents a Rectangle geometry.
   * @category geometry
   * @extends Polygon
   * @example
   * var rectangle = new Rectangle([100, 0], 1000, 500, {
   *     id : 'rectangle0'
   * });
   */
  var Rectangle = /** @class */ (function (_super) {
      __extends(Rectangle, _super);
      /**
       * @param {Coordinate} coordinates  - northwest of the rectangle
       * @param {Number} width                     - width of the rectangle, in meter
       * @param {Number} height                    - height of the rectangle, in meter
       * @param {Object} [options=null]            - options defined in [Rectangle]{@link Rectangle#options}
       */
      function Rectangle(coordinates, width, height, opts) {
          var _this = _super.call(this, null, opts) || this;
          if (coordinates) {
              _this.setCoordinates(coordinates);
          }
          _this._width = width;
          _this._height = height;
          return _this;
      }
      Rectangle.fromJSON = function (json) {
          var feature = json['feature'];
          var rect = new Rectangle(json['coordinates'], json['width'], json['height'], json['options']);
          rect.setProperties(feature['properties']);
          return rect;
      };
      /**
       * Get coordinates of rectangle's northwest
       * @return {Coordinate}
       */
      // @ts-expect-error 确实需要重写父类的属性
      Rectangle.prototype.getCoordinates = function () {
          return this._coordinates;
      };
      /**
       * Set a new coordinate for northwest of the rectangle
       * @param {Coordinate} nw - coordinates of new northwest
       * @return {Rectangle} this
       * @fires Rectangle#positionchange
       */
      // @ts-expect-error 确实需要重写父类的属性
      Rectangle.prototype.setCoordinates = function (nw) {
          var newCoordinate = (nw instanceof Coordinate) ? nw : new Coordinate(nw);
          this._translateRotatePivot(newCoordinate);
          this._coordinates = newCoordinate;
          if (!this._coordinates || !this.getMap()) {
              this.onPositionChanged();
              return this;
          }
          var projection = this._getProjection();
          this._setPrjCoordinates(projection.project(this._coordinates));
          return this;
      };
      /**
       * Get rectangle's width
       * @return {Number}
       */
      Rectangle.prototype.getWidth = function () {
          return this._width;
      };
      /**
       * Set new width to the rectangle
       * @param {Number} width - new width
       * @fires Rectangle#shapechange
       * @return {Rectangle} this
       */
      Rectangle.prototype.setWidth = function (width) {
          this._width = width;
          this.onShapeChanged();
          return this;
      };
      /**
       * Get rectangle's height
       * @return {Number}
       */
      Rectangle.prototype.getHeight = function () {
          return this._height;
      };
      /**
       * Set new height to rectangle
       * @param {Number} height - new height
       * @fires Rectangle#shapechange
       * @return {Rectangle} this
       */
      Rectangle.prototype.setHeight = function (height) {
          this._height = height;
          this.onShapeChanged();
          return this;
      };
      /**
       * Gets the shell of the rectangle as a polygon
       * @return {Coordinate[]} - shell coordinates
       */
      Rectangle.prototype.getShell = function () {
          if (this.isRotated()) {
              return this.getRotatedShell();
          }
          return this._getShell();
      };
      //@internal
      Rectangle.prototype._getShell = function () {
          var measurer = this._getMeasurer();
          var nw = this._coordinates;
          var map = this.getMap();
          var sx = 1, sy = -1;
          if (map) {
              var fExt = map.getFullExtent();
              if (fExt['left'] > fExt['right']) {
                  sx = -1;
              }
              if (fExt['bottom'] > fExt['top']) {
                  sy = 1;
              }
          }
          var points = [];
          points.push(nw);
          var p0 = measurer.locate(nw, sx * this._width, 0);
          p0.z = nw.z;
          points.push(p0);
          var p1 = measurer.locate(nw, sx * this._width, sy * this._height);
          p1.z = nw.z;
          points.push(p1);
          var p2 = measurer.locate(nw, 0, sy * this._height);
          points.push(p2);
          p2.z = nw.z;
          points.push(nw);
          return points;
      };
      /**
       * Rectangle won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      Rectangle.prototype.getHoles = function () {
          return [];
      };
      // @ts-expect-error 确实需要重写父类的属性
      Rectangle.prototype.animateShow = function () {
          return this.show();
      };
      // @ts-expect-error 确实需要重写父类的属性
      //@internal
      Rectangle.prototype._getPrjCoordinates = function () {
          var projection = this._getProjection();
          this._verifyProjection();
          if (!this._pnw && projection) {
              if (this._coordinates) {
                  this._pnw = projection.project(this._coordinates);
              }
          }
          return this._pnw;
      };
      //@internal
      Rectangle.prototype._setPrjCoordinates = function (pnw) {
          this._pnw = pnw;
          this.onPositionChanged();
      };
      //@internal
      Rectangle.prototype._getPrjShell = function () {
          var shell = _super.prototype._getPrjShell.call(this);
          var projection = this._getProjection();
          if (!projection.isSphere()) {
              // return shell;
              return this._rotatePrjCoordinates(shell);
          }
          var sphereExtent = projection.getSphereExtent(), sx = sphereExtent.sx, sy = sphereExtent.sy;
          var circum = this._getProjection().getCircum();
          var nw = shell[0];
          for (var i = 1, l = shell.length; i < l; i++) {
              var p = shell[i];
              var dx = 0, dy = 0;
              if (sx * (nw.x - p.x) > 0) {
                  dx = circum.x * sx;
              }
              if (sy * (nw.y - p.y) < 0) {
                  dy = circum.y * sy;
              }
              shell[i]._add(dx, dy);
          }
          return this._rotatePrjCoordinates(shell);
          // return shell;
      };
      //update cached variables if geometry is updated.
      //@internal
      Rectangle.prototype._updateCache = function () {
          this._clearCache();
          var projection = this._getProjection();
          if (this._pnw && projection) {
              this._coordinates = projection.unproject(this._pnw);
          }
      };
      //@internal
      Rectangle.prototype._clearProjection = function () {
          this._pnw = null;
          _super.prototype._clearProjection.call(this);
      };
      //@internal
      Rectangle.prototype._computeCenter = function (measurer) {
          return measurer.locate(this._coordinates, this._width / 2, -this._height / 2);
      };
      //@internal
      Rectangle.prototype._containsPoint = function (point, tolerance) {
          var map = this.getMap();
          if (map.isTransforming()) {
              return _super.prototype._containsPoint.call(this, point, tolerance);
          }
          var t = isNil(tolerance) ? this._hitTestTolerance() : tolerance, r = map._getResolution() * t;
          var extent = this._getPrjExtent().expand(r);
          var p = map._containerPointToPrj(point);
          return extent.contains(p);
      };
      //@internal
      Rectangle.prototype._computePrjExtent = function (projection) {
          if (this.isRotated()) {
              return this._computeRotatedPrjExtent();
          }
          var se = this._getSouthEast(projection);
          if (!se) {
              return null;
          }
          var prjs = projection.projectCoords([
              new Coordinate(this._coordinates.x, se.y),
              new Coordinate(se.x, this._coordinates.y)
          ], this.options['antiMeridian']);
          return new Extent(prjs[0], prjs[1]);
      };
      //@internal
      Rectangle.prototype._computeExtent = function (measurer) {
          var se = this._getSouthEast(measurer);
          if (!se) {
              return null;
          }
          return new Extent(this._coordinates, se, this._getProjection());
      };
      //@internal
      Rectangle.prototype._getSouthEast = function (measurer) {
          if (!measurer || !this._coordinates || isNil(this._width) || isNil(this._height)) {
              return null;
          }
          var width = this.getWidth(), height = this.getHeight();
          var w = width, h = -height;
          if (measurer.fullExtent) {
              var fullExtent = measurer.fullExtent, sx = fullExtent.right > fullExtent.left ? 1 : -1, sy = fullExtent.top > fullExtent.bottom ? 1 : -1;
              w *= sx;
              h *= sy;
          }
          // const se = measurer.locate(this._coordinates, w, h);
          var rightPoint = measurer.locate(this._coordinates, w, 0);
          var bottomPoint = measurer.locate(this._coordinates, 0, h);
          rightPoint.y = bottomPoint.y;
          return rightPoint;
      };
      //@internal
      Rectangle.prototype._computeGeodesicLength = function () {
          if (isNil(this._width) || isNil(this._height)) {
              return 0;
          }
          return 2 * (this._width + this._height);
      };
      //@internal
      Rectangle.prototype._computeGeodesicArea = function () {
          if (isNil(this._width) || isNil(this._height)) {
              return 0;
          }
          return this._width * this._height;
      };
      //@internal
      Rectangle.prototype._exportGeoJSONGeometry = function () {
          var coordinates = Coordinate.toNumberArrays([this.getShell()]);
          return {
              'type': 'Polygon',
              'coordinates': coordinates
          };
      };
      //@internal
      Rectangle.prototype._toJSON = function (options) {
          var opts = extend$2({}, options);
          var nw = this.getCoordinates();
          opts.geometry = false;
          var feature = this.toGeoJSON(opts);
          feature['geometry'] = {
              'type': 'Polygon'
          };
          return {
              'feature': feature,
              'subType': 'Rectangle',
              'coordinates': [nw.x, nw.y],
              'width': this.getWidth(),
              'height': this.getHeight()
          };
      };
      return Rectangle;
  }(Polygon));
  Rectangle.registerJSONType('Rectangle');

  /**
   * @property {Object} options -
   * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when converting the sector to a polygon.
   * @memberOf Sector
   * @instance
   */
  var options$u = {
      'numberOfShellPoints': 60
  };
  /**
   * @classdesc
   * Represents a sector Geometry.
   * @category geometry
   * @extends Circle
   * @example
   * var sector = new Sector([100, 0], 1000, 30, 120, {
   *     id : 'sector0'
   * });
   */
  var Sector = /** @class */ (function (_super) {
      __extends(Sector, _super);
      /**
       * @param {Coordinate} center - center of the sector
       * @param {Number} radius           - radius of the sector, in meter
       * @param {Number} startAngle       - start angle of the sector, in degree
       * @param {Number} endAngle         - end angle of the sector, in degree
       * @param {Object} [options=null]   - construct options defined in [Sector]{@link Sector#options}
       */
      function Sector(coordinates, radius, startAngle, endAngle, opts) {
          var _this = _super.call(this, coordinates, radius, opts) || this;
          _this.startAngle = startAngle;
          _this.endAngle = endAngle;
          return _this;
      }
      Sector.fromJSON = function (json) {
          var feature = json['feature'];
          var sector = new Sector(json['coordinates'], json['radius'], json['startAngle'], json['endAngle'], json['options']);
          sector.setProperties(feature['properties']);
          return sector;
      };
      /**
       * Get the sector's start angle
       * @return {Number}
       */
      Sector.prototype.getStartAngle = function () {
          return this.startAngle;
      };
      /**
       * Set a new start angle to the sector
       * @param {Number} startAngle
       * @return {Sector} this
       * @fires Sector#shapechange
       */
      Sector.prototype.setStartAngle = function (startAngle) {
          this.startAngle = startAngle;
          this.onShapeChanged();
          return this;
      };
      /**
       * Get the sector's end angle
       * @return {Number}
       */
      Sector.prototype.getEndAngle = function () {
          return this.endAngle;
      };
      /**
       * Set a new end angle to the sector
       * @param {Number} endAngle
       * @return {Sector} this
       * @fires Sector#shapechange
       */
      Sector.prototype.setEndAngle = function (endAngle) {
          this.endAngle = endAngle;
          this.onShapeChanged();
          return this;
      };
      // The corrected angle is used for calculation and rendering
      //@internal
      Sector.prototype._correctAngles = function () {
          var startAngle = this.getStartAngle(), endAngle = this.getEndAngle();
          if (endAngle < startAngle) {
              console.error('The ending angle should be greater than the starting angle ', startAngle, endAngle);
              return [0, 0];
          }
          var angle = 360;
          // const halfAngle = angle / 2;
          if (endAngle - startAngle > angle) {
              console.error('The difference between the end angle and the start angle is greater than 360 degrees ', startAngle, endAngle);
              return [0, 0];
          }
          if (startAngle < 0) {
              startAngle += angle;
              endAngle += angle;
          }
          return [startAngle, endAngle];
      };
      /**
       * Gets the shell of the sector as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Sector#options}
       * @return {Coordinate[]} - shell coordinates
       */
      Sector.prototype.getShell = function () {
          if (this.isRotated()) {
              return this.getRotatedShell();
          }
          return this._getShell();
      };
      //@internal
      Sector.prototype._getShell = function () {
          var _a = __read(this._correctAngles(), 2), startAngle = _a[0], endAngle = _a[1];
          var measurer = this._getMeasurer(), center = this.getCoordinates(), numberOfPoints = this.options['numberOfShellPoints'] - 2, radius = this.getRadius(), shell = [center.copy()], 
          // startAngle = this.getStartAngle(),
          angle = endAngle - startAngle;
          var rad, dx, dy;
          for (var i = 0; i < numberOfPoints; i++) {
              rad = (angle * i / (numberOfPoints - 1) + startAngle) * Math.PI / 180;
              dx = radius * Math.cos(rad);
              dy = radius * Math.sin(rad);
              var vertex = measurer.locate(center, dx, dy);
              vertex.z = center.z;
              shell.push(vertex);
          }
          shell.push(center.copy());
          return shell;
      };
      Sector.prototype.getRotateOffsetAngle = function () {
          return 90;
      };
      //@internal
      Sector.prototype._getPrjShell = function () {
          var shell = _super.prototype._getPrjShell.call(this);
          return this._rotatePrjCoordinates(shell);
      };
      //@internal
      Sector.prototype._computePrjExtent = function () {
          if (this.isRotated()) {
              return this._computeRotatedPrjExtent();
          }
          // eslint-disable-next-line prefer-rest-params
          return Circle.prototype._computePrjExtent.apply(this, arguments);
      };
      //@internal
      Sector.prototype._containsPoint = function (point, tolerance) {
          var map = this.getMap();
          if (map.isTransforming()) {
              return _super.prototype._containsPoint.call(this, point, tolerance);
          }
          var center = map._pointToContainerPoint(this._getCenter2DPoint()), t = this._hitTestTolerance() + (tolerance || 0), size = this.getSize(), pc = center, pp = point, x = pp.x - pc.x, y = pc.y - pp.y, atan2 = Math.atan2(y, x), 
          // [0.0, 360.0)
          angle = atan2 < 0 ? (atan2 + 2 * Math.PI) * 360 / (2 * Math.PI) :
              atan2 * 360 / (2 * Math.PI);
          var _a = __read(this._correctAngles(), 2), startAngle = _a[0], endAngle = _a[1];
          var sAngle = startAngle % 360, eAngle = endAngle % 360;
          var between = false;
          if (sAngle > eAngle) {
              between = !(angle > eAngle && angle < sAngle);
          }
          else {
              between = (angle >= sAngle && angle <= eAngle);
          }
          return pp.distanceTo(pc) <= (size.width / 2 + t) && between;
      };
      //@internal
      Sector.prototype._computeGeodesicLength = function () {
          if (isNil(this._radius)) {
              return 0;
          }
          var _a = __read(this._correctAngles(), 2), startAngle = _a[0], endAngle = _a[1];
          return Math.PI * 2 * this._radius * Math.abs(startAngle - endAngle) / 360 + 2 * this._radius;
      };
      //@internal
      Sector.prototype._computeGeodesicArea = function () {
          if (isNil(this._radius)) {
              return 0;
          }
          var _a = __read(this._correctAngles(), 2), startAngle = _a[0], endAngle = _a[1];
          return Math.PI * Math.pow(this._radius, 2) * Math.abs(startAngle - endAngle) / 360;
      };
      //@internal
      Sector.prototype._toJSON = function (options) {
          var opts = extend$2({}, options);
          var center = this.getCenter();
          opts.geometry = false;
          var feature = this.toGeoJSON(opts);
          feature['geometry'] = {
              'type': 'Polygon'
          };
          return {
              'feature': feature,
              'subType': 'Sector',
              'coordinates': [center.x, center.y],
              'radius': this.getRadius(),
              'startAngle': this.getStartAngle(),
              'endAngle': this.getEndAngle()
          };
      };
      return Sector;
  }(Circle));
  Sector.mergeOptions(options$u);
  Sector.registerJSONType('Sector');

  var options$t = {
      'enableSimplify': false,
      'enableClip': false
  };
  /**
   * 曲线样式LineString，所有曲线的抽象父类。
   * @english
   * Curve style LineString, an abstract parent class for all the curves.
   * @category geometry
   * @abstract
   * @extends LineString
   * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string
   * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}
   * @property {Boolean} [options.enableSimplify=false] - whether to simplify path before rendering
   * @property {Boolean} [options.enableClip=false] - whether to clip curve with map's current extent
   */
  var Curve = /** @class */ (function (_super) {
      __extends(Curve, _super);
      function Curve() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      //@internal
      Curve.prototype._arc = function (ctx, points, lineOpacity) {
          var arcDegree = this.options['arcDegree'];
          if (arcDegree === 0) {
              arcDegree = 1;
          }
          var degree = arcDegree * Math.PI / 180;
          for (var i = 1, l = points.length; i < l; i++) {
              // const c = Canvas2d._arcBetween(ctx, points[i - 1], points[i], degree);
              // //add control points to caculate normal of arrow
              // const ctrlPoint = [(points[i - 1].x + points[i].x) - c[0], (points[i - 1].y + points[i].y) - c[1]];
              // points[i - 1].nextCtrlPoint = ctrlPoint;
              // points[i].prevCtrlPoint = ctrlPoint;
              Canvas._arcBetween(ctx, points[i - 1], points[i], degree);
              Canvas._stroke(ctx, lineOpacity);
          }
      };
      //@internal
      Curve.prototype._quadraticCurve = function (ctx, points) {
          if (points.length <= 2) {
              Canvas._path(ctx, points);
              return;
          }
          var i, l;
          for (i = 2, l = points.length; i < l; i += 2) {
              ctx.quadraticCurveTo(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
          }
          i -= 1;
          if (i < l) {
              for (; i < l; i++) {
                  ctx.lineTo(points[i].x, points[i].y);
              }
          }
      };
      //@internal
      Curve.prototype._bezierCurve = function (ctx, points) {
          if (points.length <= 3) {
              Canvas._path(ctx, points);
              return;
          }
          var i, l;
          for (i = 1, l = points.length; i + 2 < l; i += 3) {
              ctx.bezierCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y);
          }
          if (i < l) {
              for (; i < l; i++) {
                  ctx.lineTo(points[i].x, points[i].y);
              }
          }
      };
      //@internal
      Curve.prototype._getCurveArrowPoints = function (arrows, segments, lineWidth, arrowStyle, tolerance, step) {
          var l = segments.length;
          var i;
          for (i = step; i < l; i += step) {
              var arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);
              if (arrow) {
                  arrows.push(arrow);
              }
          }
          i -= step;
          if (i < l - 1) {
              for (i += 1; i < l; i++) {
                  var arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);
                  if (arrow) {
                      arrows.push(arrow);
                  }
              }
          }
      };
      return Curve;
  }(LineString));
  Curve.mergeOptions(options$t);

  /**
   * @property {Object} options
   * @property {Number} [options.arcDegree=90]           - circle arc's degree.
   * @memberOf ArcCurve
   * @instance
   */
  var options$s = {
      'arcDegree': 90
  };
  /**
   * @classdesc
   * Circle Arc Curve
   * @category geometry
   * @extends Curve
   * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
   * @param {Object} [options=null]   - construct options defined in [ArcCurve]{@link ArcCurve#options}
   * @example
   * var curve = new ArcCurve(
   *     [
   *         [121.47083767181408,31.214448123476995],
   *         [121.4751292062378,31.215475523000404],
   *         [121.47869117980943,31.211916269810335]
   *     ],
   *     {
   *         arcDegree : 120,
   *         symbol : {
   *             'lineWidth' : 5
   *         }
   *     }
   * ).addTo(layer);
   */
  var ArcCurve = /** @class */ (function (_super) {
      __extends(ArcCurve, _super);
      function ArcCurve() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      //@internal
      ArcCurve.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options),
              'subType': 'ArcCurve'
          };
      };
      // paint method on canvas
      //@internal
      ArcCurve.prototype._paintOn = function (ctx, points, lineOpacity) {
          ctx.beginPath();
          this._arc(ctx, points, lineOpacity);
          Canvas._stroke(ctx, lineOpacity);
          this._paintArrow(ctx, points, lineOpacity);
      };
      ArcCurve.fromJSON = function (json) {
          var feature = json['feature'];
          var arc = new ArcCurve(feature['geometry']['coordinates'], json['options']);
          arc.setProperties(feature['properties']);
          return arc;
      };
      return ArcCurve;
  }(Curve));
  ArcCurve.registerJSONType('ArcCurve');
  ArcCurve.mergeOptions(options$s);

  /**
   * 三次贝塞尔曲线
   * @english
   * Cubic Bezier Curve
   * @category geometry
   * @extends Curve
   * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
   * @param {Object} [options=null]   - construct options defined in [CubicBezierCurve]{@link CubicBezierCurve#options}
   * @example
   * var curve = new CubicBezierCurve(
   *     [
   *         [121.47083767181408,31.214448123476995],
   *         [121.4751292062378,31.215475523000404],
   *         [121.47869117980943,31.211916269810335]
   *     ],
   *     {
   *         symbol : {
   *             'lineWidth' : 5
   *         }
   *     }
   * ).addTo(layer);
   */
  var CubicBezierCurve = /** @class */ (function (_super) {
      __extends(CubicBezierCurve, _super);
      function CubicBezierCurve() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CubicBezierCurve.fromJSON = function (json) {
          var feature = json['feature'];
          var curve = new CubicBezierCurve(feature['geometry']['coordinates'], json['options']);
          curve.setProperties(feature['properties']);
          return curve;
      };
      //@internal
      CubicBezierCurve.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options),
              'subType': 'CubicBezierCurve'
          };
      };
      // paint method on canvas
      //@internal
      CubicBezierCurve.prototype._paintOn = function (ctx, points, lineOpacity) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          this._bezierCurve(ctx, points);
          Canvas._stroke(ctx, lineOpacity);
          this._paintArrow(ctx, points, lineOpacity);
      };
      //@internal
      CubicBezierCurve.prototype._getArrowPoints = function (arrows, segments, lineWidth, arrowStyle, tolerance) {
          return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 3);
      };
      return CubicBezierCurve;
  }(Curve));
  CubicBezierCurve.registerJSONType('CubicBezierCurve');

  /**
   * @classdesc
   * Quadratic Bezier Curve
   * @category geometry
   * @extends Curve
   * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
   * @example
   * var curve = new QuadBezierCurve(
   *     [
   *         [121.47083767181408,31.214448123476995],
   *         [121.4751292062378,31.215475523000404],
   *         [121.47869117980943,31.211916269810335]
   *     ],
   *     {
   *         symbol : {
   *             'lineWidth' : 5
   *         }
   *     }
   * ).addTo(layer);
   */
  var QuadBezierCurve = /** @class */ (function (_super) {
      __extends(QuadBezierCurve, _super);
      function QuadBezierCurve() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      QuadBezierCurve.fromJSON = function (json) {
          var feature = json['feature'];
          var curve = new QuadBezierCurve(feature['geometry']['coordinates'], json['options']);
          curve.setProperties(feature['properties']);
          return curve;
      };
      //@internal
      QuadBezierCurve.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options),
              'subType': 'QuadBezierCurve'
          };
      };
      // paint method on canvas
      //@internal
      QuadBezierCurve.prototype._paintOn = function (ctx, points, lineOpacity) {
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          // @ts-expect-error todo
          this._quadraticCurve(ctx, points, lineOpacity);
          Canvas._stroke(ctx, lineOpacity);
          this._paintArrow(ctx, points, lineOpacity);
      };
      //@internal
      QuadBezierCurve.prototype._getArrowPoints = function (arrows, segments, lineWidth, arrowStyle, tolerance) {
          return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 2);
      };
      return QuadBezierCurve;
  }(Curve));
  QuadBezierCurve.registerJSONType('QuadBezierCurve');

  var defaultSymbol = {
      'textFaceName': 'monospace',
      'textSize': 12,
      'textLineSpacing': 8,
      'textWrapCharacter': '\n',
      'textHorizontalAlignment': 'middle', //left middle right
      'textVerticalAlignment': 'middle' //top middle bottom
  };
  var defaultBoxSymbol = {
      'markerType': 'square',
      'markerLineColor': '#000',
      'markerLineWidth': 2,
      'markerLineOpacity': 1,
      'markerFill': '#fff',
      'markerOpacity': 1
  };
  /**
   * @classdesc
   * Base class for  the Text marker classes, a marker which has text and background box. <br>
   * It is abstract and not intended to be instantiated.
   * @category geometry
   * @abstract
   * @extends Marker
   */
  var TextMarker = /** @class */ (function (_super) {
      __extends(TextMarker, _super);
      function TextMarker() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * 获取标签的文本内容
       * @english
       * Get text content of the label
       * @returns {String}
       */
      TextMarker.prototype.getContent = function () {
          return this._content;
      };
      /**
       * 给标签设置文本内容
       * @english
       * Set a new text content to the label
       * @return {Label} this
       * @fires Label#contentchange
       */
      TextMarker.prototype.setContent = function (content) {
          var old = this._content;
          this._content = escapeSpecialChars(content);
          this._refresh();
          /**
           * an event when changing label's text content
           * @event Label#contentchange
           * @type {Object}
           * @property {String} type - contentchange
           * @property {Label} target - label fires the event
           * @property {String} old - old content
           * @property {String} new - new content
           */
          this._fireEvent('contentchange', {
              'old': old,
              'new': content
          });
          return this;
      };
      TextMarker.prototype.onAdd = function () {
          this._refresh();
      };
      TextMarker.prototype.toJSON = function () {
          var json = _super.prototype.toJSON.call(this);
          delete json['symbol'];
          return json;
      };
      TextMarker.prototype.setSymbol = function (symbol) {
          if (this._refreshing || !symbol) {
              return _super.prototype.setSymbol.call(this, symbol);
          }
          var s = this._parseSymbol(symbol);
          if (this.setTextStyle) {
              var style = this.getTextStyle() || {};
              style.symbol = s[0];
              this.setTextStyle(style);
          }
          else if (this.setTextSymbol) {
              this.setTextSymbol(s[0]);
          }
          if (this.setBoxStyle) {
              var style = this.getBoxStyle() || {};
              style.symbol = s[1];
              this.setBoxStyle(style);
          }
          else if (this.setBoxSymbol) {
              this.setBoxSymbol(s[1]);
          }
          return this;
      };
      //@internal
      TextMarker.prototype._parseSymbol = function (symbol) {
          var t = {};
          var b = {};
          for (var p in symbol) {
              if (hasOwn(symbol, p)) {
                  if (p.indexOf('text') === 0) {
                      t[p] = symbol[p];
                  }
                  else {
                      b[p] = symbol[p];
                  }
              }
          }
          return [t, b];
      };
      //@internal
      TextMarker.prototype._getTextSize = function (symbol) {
          return splitTextToRow(this._content, symbol)['size'];
      };
      //@internal
      TextMarker.prototype._getInternalSymbol = function () {
          return this._symbol;
      };
      //@internal
      TextMarker.prototype._getDefaultTextSymbol = function () {
          return extend$2({}, defaultSymbol);
      };
      //@internal
      TextMarker.prototype._getDefaultBoxSymbol = function () {
          return extend$2({}, defaultBoxSymbol);
      };
      //@internal
      TextMarker.prototype._getDefaultPadding = function () {
          return [12, 8];
      };
      return TextMarker;
  }(Marker));

  /**
   * @property {Object} [options=null]                   - textbox's options, also including options of [Marker]{@link Marker#options}
   * @property {Boolean} [options.textStyle]             - the default text style of text
   * @property {Boolean} [options.textStyle.wrap=true]             - whether to autowrap text in the textbox
   * @property {Boolean} [options.textStyle.padding=[12, 8]]       - text padding in the box
   * @property {Boolean} [options.textStyle.verticalAlignment=middle]  - text's vertical alignment
   * @property {Boolean} [options.textStyle.horizontalAlignment=true]  - text's horizontal alignment
   * @property {Boolean} [options.boxSymbol=null]        - box symbol of textbox
   * @memberOf TextBox
   * @instance
   */
  var options$r = {
      'textStyle': {
          'wrap': true,
          'padding': [12, 8],
          'verticalAlignment': 'middle',
          'horizontalAlignment': 'middle'
      },
      'boxSymbol': null
  };
  /**
   * @classdesc
   * Represents point type geometry for text boxes.<br>
   * A TextBox is used to draw a box with text inside on a particular coordinate.
   * @category geometry
   * @extends TextMarker
   * @mixes TextEditable
   * @example
   * var textbox = new maptalks.TextBox('This is a textbox',
      [0, 0], 200, 90,
      {
        'draggable' : true,
        'textStyle' : {
          'wrap' : true,
          'padding' : [12, 8],
          'verticalAlignment' : 'top',
          'horizontalAlignment' : 'right',
          'symbol' : {
            'textFaceName' : 'monospace',
            'textFill' : '#34495e',
            'textHaloFill' : '#fff',
            'textHaloRadius' : 4,
            'textSize' : 18,
            'textWeight' : 'bold'
          }
        },
        'boxSymbol': {
          // box's symbol
          'markerType' : 'square',
          'markerFill' : 'rgb(135,196,240)',
          'markerFillOpacity' : 0.9,
          'markerLineColor' : '#34495e',
          'markerLineWidth' : 1
        }
      });
   */
  var TextBox = /** @class */ (function (_super) {
      __extends(TextBox, _super);
      /**
       * @param {String} content                 - TextBox's text content
       * @param {Coordinate} coordinates         - coordinates
       * @param {Number} width                   - width in pixel
       * @param {Number} height                  - height in pixel
       * @param {Object} [options=null]          - construct options defined in [TextBox]{@link TextBox#options}
       */
      function TextBox(content, coordinates, width, height, options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, coordinates, options) || this;
          _this._content = escapeSpecialChars(content);
          _this._width = isNil(width) ? 100 : width;
          _this._height = isNil(height) ? 40 : height;
          if (options.boxSymbol) {
              _this.setBoxSymbol(options.boxSymbol);
          }
          if (options.textStyle) {
              _this.setTextStyle(options.textStyle);
          }
          _this._refresh();
          return _this;
      }
      /**
       * 获取文本框得宽度
       * @english
       * Get textbox's width
       * @return {Number}
       */
      TextBox.prototype.getWidth = function () {
          return this._width;
      };
      /**
       * 设置文本框得宽度
       * @english
       * Set new width to textbox
       * @param {Number} width
       * returns {TextBox} this
       */
      TextBox.prototype.setWidth = function (width) {
          this._width = width;
          this._refresh();
          return this;
      };
      /**
       * 获取文本框高度
       * @english
       * Get textbox's height
       * @return {Number}
       */
      TextBox.prototype.getHeight = function () {
          return this._height;
      };
      /**
       * 设置文本框高度
       * @english
       * Set new height to textbox
       * @param {Number} height
       * returns {TextBox} this
       */
      TextBox.prototype.setHeight = function (height) {
          this._height = height;
          this._refresh();
          return this;
      };
      /**
       * 获取文本框边框样式
       * @english
       * Get textbox's boxSymbol
       * @return {Object} boxsymbol
       */
      TextBox.prototype.getBoxSymbol = function () {
          return extend$2({}, this.options.boxSymbol);
      };
      /**
       * 设置文本框边框样式
       * @english
       * Set a new box symbol to textbox
       * @param {Object} symbol
       * returns {TextBox} this
       */
      TextBox.prototype.setBoxSymbol = function (symbol) {
          this.options.boxSymbol = symbol ? extend$2({}, symbol) : symbol;
          if (this.getSymbol()) {
              this._refresh();
          }
          return this;
      };
      /**
       * 获取文本框文本样式
       * @english
       * Get textbox's text style
       * @return {Object}
       */
      TextBox.prototype.getTextStyle = function () {
          if (!this.options.textStyle) {
              return null;
          }
          return extend$2({}, this.options.textStyle);
      };
      /**
       * 设置文本框文本样式
       * @english
       * Set a new text style to the textbox
       * @param {Object} style new text style
       * returns {TextBox} this
       */
      TextBox.prototype.setTextStyle = function (style) {
          this.options.textStyle = style ? extend$2({}, style) : style;
          if (this.getSymbol()) {
              this._refresh();
          }
          return this;
      };
      TextBox.fromJSON = function (json) {
          var feature = json['feature'];
          var textBox = new TextBox(json['content'], feature['geometry']['coordinates'], json['width'], json['height'], json['options']);
          textBox.setProperties(feature['properties']);
          textBox.setId(feature['id']);
          if (json['symbol']) {
              textBox.setSymbol(json['symbol']);
          }
          return textBox;
      };
      //@internal
      TextBox.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options),
              'width': this.getWidth(),
              'height': this.getHeight(),
              'subType': 'TextBox',
              'content': this._content
          };
      };
      //@internal
      TextBox.prototype._refresh = function () {
          var textStyle = this.getTextStyle() || {}, padding = textStyle['padding'] || [12, 8];
          var maxWidth, maxHeight;
          if (isFunctionDefinition(this._width)) {
              maxWidth = JSON.parse(JSON.stringify(this._width));
              var stops = maxWidth.stops;
              if (stops) {
                  for (var i = 0; i < stops.length; i++) {
                      stops[i][1] = stops[i][1] - 2 * padding[0];
                  }
              }
          }
          else {
              maxWidth = this._width - 2 * padding[0];
          }
          if (isFunctionDefinition(this._height)) {
              maxHeight = JSON.parse(JSON.stringify(this._height));
              var stops = maxHeight.stops;
              if (stops) {
                  for (var i = 0; i < stops.length; i++) {
                      stops[i][1] = stops[i][1] - 2 * padding[1];
                  }
              }
          }
          else {
              maxHeight = this._height - 2 * padding[1];
          }
          var symbol = extend$2({}, textStyle.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
              'textName': this._content,
              'markerWidth': this._width,
              'markerHeight': this._height,
              'textHorizontalAlignment': 'middle',
              'textVerticalAlignment': 'middle',
              'textMaxWidth': maxWidth,
              'textMaxHeight': maxHeight
          });
          if (textStyle['wrap'] && !symbol['textWrapWidth']) {
              symbol['textWrapWidth'] = maxWidth;
          }
          // function-type markerWidth and markerHeight doesn't support left/right horizontalAlignment and top/bottom verticalAlignment now
          var hAlign = textStyle['horizontalAlignment'];
          symbol['textDx'] = symbol['markerDx'] || 0;
          var offsetX;
          if (isFunctionDefinition(this._width)) {
              offsetX = JSON.parse(JSON.stringify(this._width));
              var stops = offsetX.stops;
              if (stops) {
                  for (var i = 0; i < stops.length; i++) {
                      stops[i][1] = stops[i][1] / 2 - padding[0];
                      if (hAlign === 'left') {
                          stops[i][1] *= -1;
                      }
                  }
              }
          }
          else {
              offsetX = symbol['markerWidth'] / 2 - padding[0];
              if (hAlign === 'left') {
                  offsetX *= -1;
              }
          }
          if (hAlign === 'left') {
              symbol['textHorizontalAlignment'] = 'right';
              symbol['textDx'] = offsetX;
          }
          else if (hAlign === 'right') {
              symbol['textHorizontalAlignment'] = 'left';
              symbol['textDx'] = offsetX;
          }
          var vAlign = textStyle['verticalAlignment'];
          symbol['textDy'] = symbol['markerDy'] || 0;
          var offsetY;
          if (isFunctionDefinition(this._height)) {
              offsetY = JSON.parse(JSON.stringify(this._height));
              var stops = offsetY.stops;
              if (stops) {
                  for (var i = 0; i < stops.length; i++) {
                      stops[i][1] = stops[i][1] / 2 - padding[1];
                      if (vAlign === 'top') {
                          stops[i][1] *= -1;
                      }
                  }
              }
          }
          else {
              offsetY = symbol['markerHeight'] / 2 - padding[1];
              if (vAlign === 'top') {
                  offsetY *= -1;
              }
          }
          if (vAlign === 'top') {
              symbol['textVerticalAlignment'] = 'bottom';
              symbol['textDy'] = offsetY;
          }
          else if (vAlign === 'bottom') {
              symbol['textVerticalAlignment'] = 'top';
              symbol['textDy'] = offsetY;
          }
          this._refreshing = true;
          this.updateSymbol(symbol);
          delete this._refreshing;
      };
      TextBox.prototype.startEdit = function (opts) {
          var symbol = this._getCompiledSymbol();
          if (isFunctionDefinition(this._width)) {
              var markerWidth = symbol['markerWidth'];
              this._oldWidth = this._width;
              this.setWidth(markerWidth);
          }
          if (isFunctionDefinition(this._height)) {
              var markerHeight = symbol['markerHeight'];
              this._oldHeight = this._height;
              this.setHeight(markerHeight);
          }
          return _super.prototype.startEdit.call(this, opts);
      };
      TextBox.prototype.endEdit = function () {
          var map = this.getMap();
          var zoom = map && map.getZoom();
          if (this._oldWidth) {
              var markerWidth = this._width;
              var widthFn = interpolated(this._oldWidth);
              var oldExpectedWidth = widthFn(zoom);
              var scale = markerWidth / oldExpectedWidth;
              var stops = this._oldWidth.stops;
              for (var i = 0; i < stops.length; i++) {
                  stops[i][1] *= scale;
              }
              this.setWidth(this._oldWidth);
              delete this._oldWidth;
          }
          if (this._oldHeight) {
              var markerHeight = this._height;
              var heightFn = interpolated(this._oldHeight);
              var oldExpectedHeight = heightFn(zoom);
              var scale = markerHeight / oldExpectedHeight;
              var stops = this._oldHeight.stops;
              for (var i = 0; i < stops.length; i++) {
                  stops[i][1] *= scale;
              }
              this.setHeight(this._oldHeight);
              delete this._oldHeight;
          }
          return _super.prototype.endEdit.call(this);
      };
      return TextBox;
  }(TextMarker));
  TextBox.mergeOptions(options$r);
  TextBox.registerJSONType('TextBox');

  /**
   * @property {Object} [options=null]                   - textbox's options, also including options of [Marker]{@link Marker#options}
   * @property {Boolean} [options.boxStyle=null]             - the default box style of text
   * @property {Boolean} [options.boxStyle.padding=[12, 8]]           - text padding in the box
   * @property {Boolean} [options.boxStyle.verticalAlignment=middle]  - text's vertical alignment
   * @property {Boolean} [options.boxStyle.horizontalAlignment=true]  - text's horizontal alignment
   * @property {Number} [options.boxStyle.minWidth=0]                 - label box's minWidth
   * @property {Number} [options.boxStyle.minHeight=0]                - label box's minHeight
   * @property {Boolean} [options.textSymbol=null]        - text symbol of label
   * @memberOf Label
   * @instance
   */
  var options$q = {
      'boxStyle': null, /*{
          'padding' : [12, 8],
          'verticalAlignment' : 'middle',
          'horizontalAlignment' : 'middle',
          'minWidth' : 0,
          'minHeight' : 0,
          'symbol' : null
      }*/
      textSymbol: null
  };
  /**
   * @classdesc
   * Represents point type geometry for text labels.<br>
   * A label is used to draw text (with a box background if specified) on a particular coordinate.
   * @category geometry
   * @extends TextMarker
   * @mixes TextEditable
   * @example
   * var label = new maptalks.Label('label with a box',
      [0, 0],
      {
        'draggable' : true,
        'boxStyle' : {
          'padding' : [12, 8],
          'verticalAlignment' : 'top',
          'horizontalAlignment' : 'right',
          'minWidth' : 300,
          'minHeight' : 200,
          'symbol' : {
            'markerType' : 'square',
            'markerFill' : 'rgb(135,196,240)',
            'markerFillOpacity' : 0.9,
            'markerLineColor' : '#34495e',
            'markerLineWidth' : 1
          }
        },
        'textSymbol': {
          'textFaceName' : 'monospace',
          'textFill' : '#34495e',
          'textHaloFill' : '#fff',
          'textHaloRadius' : 4,
          'textSize' : 18,
          'textWeight' : 'bold',
          'textVerticalAlignment' : 'top'
        }
      });
   */
  var Label = /** @class */ (function (_super) {
      __extends(Label, _super);
      /**
       * @param {String} content                 - Label's text content
       * @param {Coordinate} coordinates         - coordinates
       * @param {Object} [options=null]          - construct options defined in [Label]{@link Label#options}
       */
      function Label(content, coordinates, options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, coordinates, options) || this;
          if (options.textSymbol) {
              _this.setTextSymbol(options.textSymbol);
          }
          if (options.boxStyle) {
              _this.setBoxStyle(options.boxStyle);
          }
          _this._content = escapeSpecialChars(content);
          _this._refresh();
          return _this;
      }
      /**
       * 获取标注的边框样式
       * @english
       * Get label's box style
       * @return {Object}
       */
      Label.prototype.getBoxStyle = function () {
          if (!this.options.boxStyle) {
              return null;
          }
          return extend$2({}, this.options.boxStyle);
      };
      /**
       * 设置标注的边框样式
       * @english
       * Set a new box style to the label
       * @param {Object}
       * @returns {Label} this
       */
      Label.prototype.setBoxStyle = function (style) {
          this.options.boxStyle = style ? extend$2({}, style) : style;
          this._refresh();
          return this;
      };
      /**
       * 获取标注的文本样式
       * Get label's text symbol
       * @return {Object}
       */
      Label.prototype.getTextSymbol = function () {
          return extend$2({}, this._getDefaultTextSymbol(), this.options.textSymbol);
      };
      /**
       * 给标注设置新的文本样式
       * @english
       * Set a new text symbol to the label
       * @param {Object} symbol
       * @returns {Label} this
       */
      Label.prototype.setTextSymbol = function (symbol) {
          this.options.textSymbol = symbol ? extend$2({}, symbol) : symbol;
          this._refresh();
          return this;
      };
      Label.fromJSON = function (json) {
          var feature = json['feature'];
          var label = new Label(json['content'], feature['geometry']['coordinates'], json['options']);
          label.setProperties(feature['properties']);
          label.setId(feature['id']);
          if (json['symbol']) {
              label.setSymbol(json['symbol']);
          }
          return label;
      };
      //@internal
      Label.prototype._canEdit = function () {
          return false;
      };
      //@internal
      Label.prototype._toJSON = function (options) {
          return {
              'feature': this.toGeoJSON(options),
              'subType': 'Label',
              'content': this._content
          };
      };
      //@internal
      Label.prototype._refresh = function () {
          var symbol = extend$2({}, this.getTextSymbol(), {
              'textName': this._content
          });
          var boxStyle = this.getBoxStyle();
          if (boxStyle) {
              extend$2(symbol, boxStyle.symbol);
              var sizes = this._getBoxSize(symbol), textSize = sizes[1], padding = boxStyle['padding'] || this._getDefaultPadding();
              var boxSize = sizes[0];
              //if no boxSize then use text's size in default
              symbol['markerWidth'] = boxSize['width'];
              symbol['markerHeight'] = boxSize['height'];
              var dx = symbol['textDx'] || 0, dy = symbol['textDy'] || 0, textAlignPoint = getAlignPoint(textSize, symbol['textHorizontalAlignment'], symbol['textVerticalAlignment'])
                  ._add(dx, dy);
              var hAlign = boxStyle['horizontalAlignment'] || 'middle';
              symbol['markerDx'] = textAlignPoint.x;
              if (hAlign === 'left') {
                  symbol['markerDx'] += symbol['markerWidth'] / 2 - padding[0];
              }
              else if (hAlign === 'right') {
                  symbol['markerDx'] -= symbol['markerWidth'] / 2 - textSize['width'] - padding[0];
              }
              else {
                  symbol['markerDx'] += textSize['width'] / 2;
              }
              var vAlign = boxStyle['verticalAlignment'] || 'middle';
              symbol['markerDy'] = textAlignPoint.y;
              if (vAlign === 'top') {
                  symbol['markerDy'] += symbol['markerHeight'] / 2 - padding[1];
              }
              else if (vAlign === 'bottom') {
                  symbol['markerDy'] -= symbol['markerHeight'] / 2 - textSize['height'] - padding[1];
              }
              else {
                  symbol['markerDy'] += textSize['height'] / 2;
              }
          }
          this._refreshing = true;
          this.updateSymbol(symbol);
          delete this._refreshing;
      };
      //@internal
      Label.prototype._getBoxSize = function (symbol) {
          if (!symbol['markerType']) {
              symbol['markerType'] = 'square';
          }
          var boxStyle = this.getBoxStyle();
          var size = this._getTextSize(symbol);
          var width, height;
          var padding = boxStyle['padding'] || this._getDefaultPadding();
          width = size['width'] + padding[0] * 2;
          height = size['height'] + padding[1] * 2;
          if (boxStyle['minWidth']) {
              if (!width || width < boxStyle['minWidth']) {
                  width = boxStyle['minWidth'];
              }
          }
          if (boxStyle['minHeight']) {
              if (!height || height < boxStyle['minHeight']) {
                  height = boxStyle['minHeight'];
              }
          }
          return [new Size(width, height), size];
      };
      return Label;
  }(TextMarker));
  Label.mergeOptions(options$q);
  Label.registerJSONType('Label');

  /**
   * 连接线的方法
   * @english
   * Mixin of connector line methods.
   * @mixin Connectable
   * @private
   */
  var Connectable = function (Base) {
      return /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              return _super.apply(this, __spreadArray([], __read(args), false)) || this;
          }
          class_1._hasConnectors = function (geometry) {
              return (!isNil(geometry.__connectors) && geometry.__connectors.length > 0);
          };
          class_1._getConnectors = function (geometry) {
              return geometry.__connectors;
          };
          /**
           * 获取连接线的源
           * @english
           * Gets the source of the connector line.
           * @return {Geometry|control.Control|UIComponent}
           * @function Connectable.getConnectSource
           */
          class_1.prototype.getConnectSource = function () {
              return this._connSource;
          };
          /**
           * 设置连接线的源
           * @english
           * Sets the source to the connector line.
           * @param {Geometry|control.Control|UIComponent} src
           * @return {ConnectorLine} this
           * @function Connectable.setConnectSource
           */
          class_1.prototype.setConnectSource = function (src) {
              var target = this._connTarget;
              this.onRemove();
              this._connSource = src;
              this._connTarget = target;
              this.onAdd();
              return this;
          };
          /**
           * 获取连接线的目标
           * @english
           * Gets the target of the connector line.
           * @return {Geometry|control.Control|UIComponent}
           * @function Connectable.getConnectTarget
           */
          class_1.prototype.getConnectTarget = function () {
              return this._connTarget;
          };
          /**
           * 设置连接线目标
           * @english
           * Sets the target to the connector line.
           * @param {Geometry|control.Control|UIComponent} target
           * @return {ConnectorLine} this
           * @function Connectable.setConnectTarget
           */
          class_1.prototype.setConnectTarget = function (target) {
              var src = this._connSource;
              this.onRemove();
              this._connSource = src;
              this._connTarget = target;
              this._updateCoordinates();
              this._registerEvents();
              return this;
          };
          //@internal
          class_1.prototype._updateCoordinates = function () {
              var map = this.getMap();
              if (!map && this._connSource) {
                  map = this._connSource.getMap();
              }
              if (!map && this._connTarget) {
                  map = this._connTarget.getMap();
              }
              if (!map) {
                  return;
              }
              if (!this._connSource || !this._connTarget) {
                  return;
              }
              var srcPoints = this._connSource._getConnectPoints();
              var targetPoints = this._connTarget._getConnectPoints();
              var minDist = 0;
              var oldCoordinates = this.getCoordinates();
              var c1, c2;
              for (var i = 0, len = srcPoints.length; i < len; i++) {
                  var p1 = srcPoints[i];
                  for (var j = 0, length_1 = targetPoints.length; j < length_1; j++) {
                      var p2 = targetPoints[j];
                      var dist = map.computeLength(p1, p2);
                      if (i === 0 && j === 0) {
                          c1 = p1;
                          c2 = p2;
                          minDist = dist;
                      }
                      else if (dist < minDist) {
                          c1 = p1;
                          c2 = p2;
                      }
                  }
              }
              if (!isArrayHasData(oldCoordinates) || (!oldCoordinates[0].equals(c1) || !oldCoordinates[1].equals(c2))) {
                  this.setCoordinates([c1, c2]);
              }
          };
          class_1.prototype.onAdd = function () {
              this._registerEvents();
              this._updateCoordinates();
          };
          class_1.prototype.onRemove = function () {
              if (this._connSource) {
                  if (this._connSource.__connectors) {
                      removeFromArray(this, this._connSource.__connectors);
                  }
                  this._connSource.off('dragging positionchange', this._updateCoordinates, this)
                      .off('remove', this.onRemove, this);
                  this._connSource.off('dragstart mousedown mouseover', this._showConnect, this);
                  this._connSource.off('dragend mouseup mouseout', this.hide, this);
                  this._connSource.off('show', this._showConnect, this).off('hide', this.hide, this);
                  delete this._connSource;
              }
              if (this._connTarget) {
                  removeFromArray(this, this._connTarget.__connectors);
                  this._connTarget.off('dragging positionchange', this._updateCoordinates, this)
                      .off('remove', this.onRemove, this);
                  this._connTarget.off('show', this._showConnect, this).off('hide', this.hide, this);
                  delete this._connTarget;
              }
              //not a geometry
              if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
                  var map = this.getMap();
                  if (map) {
                      map.off('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
                  }
              }
          };
          //@internal
          class_1.prototype._showConnect = function () {
              if (!this._connSource || !this._connTarget) {
                  return;
              }
              if (this._connSource.isVisible() && this._connTarget.isVisible()) {
                  this._updateCoordinates();
                  this.show();
              }
          };
          //@internal
          class_1.prototype._registerEvents = function () {
              if (!this._connSource || !this._connTarget) {
                  return;
              }
              if (!this._connSource.__connectors) {
                  this._connSource.__connectors = [];
              }
              if (!this._connTarget.__connectors) {
                  this._connTarget.__connectors = [];
              }
              this._connSource.__connectors.push(this);
              this._connTarget.__connectors.push(this);
              this._connSource.on('dragging positionchange', this._updateCoordinates, this)
                  .on('remove', this.remove, this);
              this._connTarget.on('dragging positionchange', this._updateCoordinates, this)
                  .on('remove', this.remove, this);
              this._connSource.on('show', this._showConnect, this).on('hide', this.hide, this);
              this._connTarget.on('show', this._showConnect, this).on('hide', this.hide, this);
              var trigger = this.options['showOn'];
              this.hide();
              if (trigger === 'moving') {
                  this._connSource.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);
                  this._connTarget.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);
              }
              else if (trigger === 'click') {
                  this._connSource.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);
                  this._connTarget.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);
              }
              else if (trigger === 'mouseover') {
                  this._connSource.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);
                  this._connTarget.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);
              }
              else {
                  this._showConnect();
              }
              //not a geometry
              if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
                  var map = this.getMap();
                  if (map) {
                      map.on('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
                  }
              }
          };
          return class_1;
      }(Base));
  };
  /**
   * @property {Object} options - ConnectorLine's options
   * @property {String} [options.showOn=always]  - when to show the connector line, possible values: 'moving', 'click', 'mouseover', 'always'
   * @memberOf ConnectorLine
   * @instance
   */
  /**
   * @property {Object} options - ConnectorLine's options
   * @property {String} [options.showOn=always]  - when to show the connector line, possible values: 'moving', 'click', 'mouseover', 'always'
   * @memberOf ArcConnectorLine
   * @instance
   */
  var options$p = {
      showOn: 'always'
  };
  /**
   * 直线连接线几何图形可以将几何图形或ui组件相互连接。
   * @english
   * A straight connector line geometry can connect geometries or ui components with each other. <br>
   *
   * @category geometry
   * @extends LineString
   * @example
   * var src = new Marker([0,0]).addTo(layer),
   *     dst = new Marker([1,0]).addTo(layer),
   *     line = new ConnectorLine(src, dst, {
   *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'
   *         arrowStyle : 'classic',
   *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point
   *         symbol: {
   *           lineColor: '#34495e',
   *           lineWidth: 2
   *        }
   *     }).addTo(layer);
   * @mixes connectorLineMixin
   */
  var ConnectorLine = /** @class */ (function (_super) {
      __extends(ConnectorLine, _super);
      /**
       * @param {Geometry|control.Control|UIComponent} src     - source to connect
       * @param {Geometry|control.Control|UIComponent} target  - target to connect
       * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}
       */
      function ConnectorLine(src, target, options) {
          var _this = _super.call(this, null, options) || this;
          if (arguments.length === 1) {
              options = src;
              src = null;
              target = null;
          }
          _this._connSource = src;
          _this._connTarget = target;
          return _this;
      }
      return ConnectorLine;
  }(Connectable(LineString)));
  ConnectorLine.mergeOptions(options$p);
  ConnectorLine.registerJSONType('ConnectorLine');
  /**
   * 弧形曲线连接线几何图形可以将几何图形或ui组件相互连接
   * @english
   * An arc curve connector line geometry can connect geometries or ui components with each other. <br>
   *
   * @category geometry
   * @extends ArcCurve
   * @example
   * var src = new Marker([0,0]).addTo(layer),
   *     dst = new Marker([1,0]).addTo(layer),
   *     line = new ArcConnectorLine(src, dst, {
   *         arcDegree : 120,
   *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'
   *         arrowStyle : 'classic',
   *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point
   *         symbol: {
   *           lineColor: '#34495e',
   *           lineWidth: 2
   *        }
   *     }).addTo(layer);
   * @mixes connectorLineMixin
   */
  var ArcConnectorLine = /** @class */ (function (_super) {
      __extends(ArcConnectorLine, _super);
      /**
       * @param {Geometry|control.Control|UIComponent} src     - source to connect
       * @param {Geometry|control.Control|UIComponent} target  - target to connect
       * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}
       */
      function ArcConnectorLine(src, target, options) {
          var _this = _super.call(this, null, options) || this;
          if (arguments.length === 1) {
              options = src;
              src = null;
              target = null;
          }
          _this._connSource = src;
          _this._connTarget = target;
          return _this;
      }
      return ArcConnectorLine;
  }(Connectable(ArcCurve)));
  ArcConnectorLine.mergeOptions(options$p);
  ArcConnectorLine.registerJSONType('ArcConnectorLine');

  function isGeometry(geo) {
      return geo && (geo instanceof Geometry);
  }
  /**
   * @property options.drawImmediate=false - (Only for layer rendered with [CanvasRenderer]{@link renderer.CanvasRenderer}) <br>
   *                                                    In default, for performance reason, layer will be drawn in a frame requested by RAF(RequestAnimationFrame).<br>
   *                                                    Set drawImmediate to true to draw immediately.<br>
   *                                                    This is necessary when layer's drawing is wrapped with another frame requested by RAF.
   * @property options.geometryEventTolerance=1         - tolerance for geometry events
   * @memberOf OverlayLayer
   * @instance
   */
  var options$o = {
      'drawImmediate': false,
      'geometryEvents': true,
      'geometryEventTolerance': 1
  };
  var TMP_EVENTS_ARR = [];
  /**
   * layers 的基础类，可用于 geometries 的添加移除
   * 抽象类,不准备实例化
   *
   * @english
   * @classdesc
   * Base class of all the layers that can add/remove geometries. <br>
   * It is abstract and not intended to be instantiated.
   * @category layer
   * @abstract
   * @extends Layer
   */
  var OverlayLayer = /** @class */ (function (_super) {
      __extends(OverlayLayer, _super);
      function OverlayLayer(id, geometries, options) {
          var _this = this;
          if (geometries && (!isGeometry(geometries) && !Array.isArray(geometries) && GEOJSON_TYPES.indexOf(geometries.type) < 0)) {
              options = geometries;
              geometries = null;
          }
          _this = _super.call(this, id, options) || this;
          _this._maxZIndex = 0;
          _this._minZIndex = 0;
          _this._initCache();
          if (geometries) {
              _this.addGeometry(geometries);
          }
          var style = _this.options['style'];
          if (style) {
              _this.setStyle(style);
          }
          return _this;
      }
      OverlayLayer.prototype.getAltitude = function () {
          return 0;
      };
      // isGeometryListening(types) {
      //     if (!this._geoList) {
      //         return false;
      //     }
      //     if (!Array.isArray(types)) {
      //         types = [types];
      //     }
      //     for (let i = 0, l = this._geoList.length; i < l; i++) {
      //         const geometry = this._geoList[i];
      //         if (!geometry) {
      //             continue;
      //         }
      //         if (geometry.options.cursor) {
      //             return true;
      //         }
      //         for (let j = 0; j < types.length; j++) {
      //             if (geometry.listens(types[j])) {
      //                 return true;
      //             }
      //         }
      //     }
      //     return false;
      // }
      /**
       * 通过 id 获取 geometry
       *
       * @english
       * Get a geometry by its id
       * @param id   - id of the geometry
       * @return
       */
      OverlayLayer.prototype.getGeometryById = function (id) {
          if (isNil(id) || id === '') {
              return null;
          }
          if (!this._geoMap[id]) {
              return null;
          }
          return this._geoMap[id];
      };
      /**
       * 获取所有geometries，如果提供 filter() 方法,则根据方法返回
       *
       * @english
       * Get all the geometries or the ones filtered if a filter function is provided.
       * @param filter=undefined   - a function to filter the geometries
       * @param context=undefined  - context of the filter function, value to use as this when executing filter.
       * @return
       */
      OverlayLayer.prototype.getGeometries = function (filter, context) {
          if (!filter) {
              return this._geoList.slice(0);
          }
          var result = [];
          var geometry, filtered;
          for (var i = 0, l = this._geoList.length; i < l; i++) {
              geometry = this._geoList[i];
              if (context) {
                  filtered = filter.call(context, geometry);
              }
              else {
                  filtered = filter(geometry);
              }
              if (filtered) {
                  result.push(geometry);
              }
          }
          return result;
      };
      /**
       * 获取第一个geometry, geometry 位于底部
       *
       * @english
       * Get the first geometry, the geometry at the bottom.
       * @return first geometry
       */
      OverlayLayer.prototype.getFirstGeometry = function () {
          if (!this._geoList.length) {
              return null;
          }
          return this._geoList[0];
      };
      /**
       * 获取最后一个geometry, geometry 位于上部
       *
       * @english
       * Get the last geometry, the geometry on the top
       * @return last geometry
       */
      OverlayLayer.prototype.getLastGeometry = function () {
          var len = this._geoList.length;
          if (len === 0) {
              return null;
          }
          return this._geoList[len - 1];
      };
      /**
       * 获取 geometries 个数
       *
       * Get count of the geometries
       * @return count
       */
      OverlayLayer.prototype.getCount = function () {
          return this._geoList.length;
      };
      /**
       * 获取 geometries 的 extent, 如果 layer 为空,返回 null
       *
       * @english
       * Get extent of all the geometries in the layer, return null if the layer is empty.
       * @return {Extent} - extent of the layer
       */
      OverlayLayer.prototype.getExtent = function () {
          if (this.getCount() === 0) {
              return null;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore /src/gro/Extent.js-Ts  获取Extent符合参数的type
          var extent = new Extent(this.getProjection());
          this.forEach(function (g) {
              extent._combine(g.getExtent());
          });
          return extent;
      };
      /**
       * 按顺序为图层中的每个 geometry 执行一次提供的回调。
       *
       * @english
       * Executes the provided callback once for each geometry present in the layer in order.
       * @param fn - a callback function
       * @param context=undefined   - callback's context, value to use as this when executing callback.
       * @return this
       */
      OverlayLayer.prototype.forEach = function (fn, context) {
          var copyOnWrite = this._geoList.slice(0);
          for (var i = 0, l = copyOnWrite.length; i < l; i++) {
              if (!context) {
                  fn(copyOnWrite[i], i);
              }
              else {
                  fn.call(context, copyOnWrite[i], i);
              }
          }
          return this;
      };
      /**
       * 创建一个包含所有通过由提供的函数实现的测试的 geometries 的 GeometryCollection。
       *
       * @english
       * Creates a GeometryCollection with all the geometries that pass the test implemented by the provided function.
       * @param fn      - Function to test each geometry
       * @param context=undefined  - Function's context, value to use as this when executing function.
       * @return  A GeometryCollection with all the geometries that pass the test
       */
      OverlayLayer.prototype.filter = function (fn, context) {
          var selected = [];
          var isFn = isFunction(fn);
          var filter = isFn ? fn : createFilter(fn);
          this.forEach(function (geometry) {
              var g = isFn ? geometry : getFilterFeature(geometry);
              if (context ? filter.call(context, g) : filter(g)) {
                  selected.push(geometry);
              }
          }, this);
          return selected;
      };
      /**
       * layer 是否为空
       *
       * @english
       * Whether the layer is empty.
       * @return {Boolean}
       */
      OverlayLayer.prototype.isEmpty = function () {
          return !this._geoList.length;
      };
      /**
       * 为 layer 添加 geometries
       *
       * @english
       * Adds one or more geometries to the layer
       * @param geometries - one or more geometries
       * @param fitView=false                                         - automatically set the map to a fit center and zoom for the geometries
       * @param fitView.easing=out                                    - default animation type
       * @param fitView.duration=map.options.zoomAnimationDuration    - default animation time
       * @param fitView.step=null                                     - step function during animation, animation frame as the parameter
       * @return this
       */
      OverlayLayer.prototype.addGeometry = function (geometries, fitView) {
          if (!geometries) {
              return this;
          }
          if (geometries.type === 'FeatureCollection') {
              return this.addGeometry(GeoJSON.toGeometry(geometries), fitView);
          }
          else if (!Array.isArray(geometries)) {
              var count = arguments.length;
              // eslint-disable-next-line prefer-rest-params
              var last = arguments[count - 1];
              // eslint-disable-next-line prefer-rest-params
              geometries = Array.prototype.slice.call(arguments, 0, count - 1);
              fitView = last;
              if (last && isObject$1(last) && (('type' in last) || isGeometry(last))) {
                  geometries.push(last);
                  fitView = false;
              }
              return this.addGeometry(geometries, fitView);
          }
          else if (geometries.length === 0) {
              return this;
          }
          this._initCache();
          var extent;
          if (fitView) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore /src/gro/Extent.js-Ts  允许Extent不传参数
              extent = new Extent();
          }
          this._toSort = this._maxZIndex > 0;
          var geos = [];
          for (var i = 0, l = geometries.length; i < l; i++) {
              var geo = geometries[i];
              if (!(geo && (GeoJSON._isGeoJSON(geo) || isGeometry(geo)))) {
                  throw new Error('Invalid geometry to add to layer(' + this.getId() + ') at index:' + i);
              }
              if (geo.getLayer && geo.getLayer() === this) {
                  continue;
              }
              if (!isGeometry(geo)) {
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore 未找到fromJSON属性
                  geo = Geometry.fromJSON(geo);
                  if (Array.isArray(geo)) {
                      for (var ii = 0, ll = geo.length; ii < ll; ii++) {
                          this._add(geo[ii], extent, i);
                          geos.push(geo[ii]);
                      }
                  }
              }
              // geojson to Geometry may be null
              if (!geo) {
                  throw new Error('Invalid geometry to add to layer(' + this.getId() + ') at index:' + i);
              }
              if (!Array.isArray(geo)) {
                  this._add(geo, extent, i);
                  geos.push(geo);
              }
          }
          var map = this.getMap();
          if (map) {
              this._getRenderer().onGeometryAdd(geos);
              if (extent && !isNil(extent.xmin)) {
                  var center = extent.getCenter();
                  var z = map.getFitZoom(extent);
                  if (isObject$1(fitView)) {
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-ignore
                      var step = isFunction(fitView.step) ? fitView.step : function () { return undefined; };
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-ignore 当前 map 接口中目前没有animateTo方法
                      map.animateTo({
                          center: center,
                          zoom: z,
                      }, extend$2({
                          duration: map.options.zoomAnimationDuration,
                          easing: 'out',
                      }, fitView), step);
                  }
                  else if (fitView === true) {
                      map.setCenterAndZoom(center, z);
                  }
              }
          }
          /**
           * addgeo 事件
           *
           * addgeo event.
           *
           * @event OverlayLayer#addgeo
           * @type {Object}
           * @property {String} type - addgeo
           * @property {OverlayLayer} target - layer
           * @property {Geometry[]} geometries - the geometries to add
           */
          this.fire('addgeo', {
              'type': 'addgeo',
              'target': this,
              'geometries': geometries
          });
          return this;
      };
      /**
       * 所有 geometries 最小的 zIndex
       *
       * @english
       * Get minimum zindex of geometries
       */
      OverlayLayer.prototype.getGeoMinZIndex = function () {
          return this._minZIndex;
      };
      /**
       * 所有 geometries 最大的 zIndex
       *
       * @english
       * Get maximum zindex of geometries
       */
      OverlayLayer.prototype.getGeoMaxZIndex = function () {
          return this._maxZIndex;
      };
      //@internal
      OverlayLayer.prototype._add = function (geo, extent, i) {
          if (!this._toSort) {
              this._toSort = geo.getZIndex() !== 0;
          }
          this._updateZIndex(geo.getZIndex());
          var geoId = geo.getId();
          if (!isNil(geoId)) {
              if (!isNil(this._geoMap[geoId])) {
                  throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + geoId + ', at index:' + i);
              }
              this._geoMap[geoId] = geo;
          }
          var internalId = UID();
          geo._setInternalId(internalId);
          this._geoList.push(geo);
          this.onAddGeometry(geo);
          geo._bindLayer(this);
          if (geo.onAdd) {
              geo.onAdd();
          }
          if (extent) {
              extent._combine(geo.getExtent());
          }
          /**
           * add 事件
           *
           * @english
           * add event.
           *
           * @event Geometry#add
           * @type {Object}
           * @property {String} type - add
           * @property {Geometry} target - geometry
           * @property {Layer} layer - the layer added to.
           */
          geo._fireEvent('add', {
              'layer': this
          });
          if (this._cookedStyles) {
              this._styleGeometry(geo);
          }
      };
      /**
       * 移除一个或多个geometries
       *
       * @english
       * Removes one or more geometries from the layer
       * @param  geometries - geometry ids or geometries to remove
       * @returns this
       */
      OverlayLayer.prototype.removeGeometry = function (geometries) {
          if (!Array.isArray(geometries)) {
              return this.removeGeometry([geometries]);
          }
          for (var i = geometries.length - 1; i >= 0; i--) {
              if (!(geometries[i] instanceof Geometry)) {
                  geometries[i] = this.getGeometryById(geometries[i]);
              }
              if (!geometries[i] || this !== geometries[i].getLayer())
                  continue;
              geometries[i].remove();
          }
          /**
           * removegeo 事件
           *
           * @english
           * removegeo event.
           *
           * @event OverlayLayer#removegeo
           * @type {Object}
           * @property {String} type - removegeo
           * @property {OverlayLayer} target - layer
           * @property {Geometry[]} geometries - the geometries to remove
           */
          this.fire('removegeo', {
              'type': 'removegeo',
              'target': this,
              'geometries': geometries
          });
          return this;
      };
      /**
       * 清除 layer
       *
       * @english
       * Clear all geometries in this layer
       * @returns this
       */
      OverlayLayer.prototype.clear = function () {
          this._clearing = true;
          this.forEach(function (geo) {
              geo.remove();
          });
          this._geoMap = {};
          var old = this._geoList;
          this._geoList = [];
          var renderer = this._getRenderer();
          if (renderer) {
              renderer.onGeometryRemove(old);
              if (renderer.clearImageData) {
                  renderer.clearImageData();
                  delete renderer._lastGeosToDraw;
              }
          }
          this._clearing = false;
          /**
           * clear 事件
           *
           * @english
           * clear event.
           *
           * @event OverlayLayer#clear
           * @type {Object}
           * @property {String} type - clear
           * @property {OverlayLayer} target - layer
           */
          this.fire('clear');
          return this;
      };
      /**
       * 移除geometry 回调函数
       *
       * @english
       * Called when geometry is being removed to clear the context concerned.
       * @param geometry - the geometry instance to remove
       * @protected
       */
      OverlayLayer.prototype.onRemoveGeometry = function (geometry) {
          if (!geometry || this._clearing) {
              return;
          }
          //考察geometry是否属于该图层
          if (this !== geometry.getLayer()) {
              return;
          }
          var internalId = geometry._getInternalId();
          if (isNil(internalId)) {
              return;
          }
          var geoId = geometry.getId();
          if (!isNil(geoId)) {
              delete this._geoMap[geoId];
          }
          var idx = this._findInList(geometry);
          if (idx >= 0) {
              this._geoList.splice(idx, 1);
          }
          if (this._getRenderer()) {
              this._getRenderer().onGeometryRemove([geometry]);
          }
      };
      /**
       * 获取 layer 的 style
       *
       * @english
       * Gets layer's style.
       * @return layer's style
       */
      OverlayLayer.prototype.getStyle = function () {
          if (!this.options['style']) {
              return null;
          }
          return this.options['style'];
      };
      /**
       * layer 设置 style, 用样式符号对满足条件的 geometries进行样式修改
       * 基于[mapbox-gl-js's style specification]， {https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.
       *
       * @english
       * Sets style to the layer, styling the geometries satisfying the condition with style's symbol. <br>
       * Based on filter type in [mapbox-gl-js's style specification]{https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.
       * @param style - layer's style
       * @returns this
       * @fires VectorLayer#setstyle
       * @example
       * layer.setStyle([
          {
            'filter': ['==', 'count', 100],
            'symbol': {'markerFile' : 'foo1.png'}
          },
          {
            'filter': ['==', 'count', 200],
            'symbol': {'markerFile' : 'foo2.png'}
          }
        ]);
       */
      OverlayLayer.prototype.setStyle = function (style) {
          this.options.style = style;
          style = parseStyleRootPath(style);
          this._cookedStyles = compileStyle(style);
          this.forEach(function (geometry) {
              this._styleGeometry(geometry);
          }, this);
          /**
           * setstyle 事件
           * @english
           * setstyle event.
           *
           * @event VectorLayer#setstyle
           * @type {Object}
           * @property {String} type - setstyle
           * @property {VectorLayer} target - layer
           * @property {Object|Object[]}       style - style to set
           */
          this.fire('setstyle', {
              'type': 'setstyle',
              'target': this,
              'style': style
          });
          return this;
      };
      //@internal
      OverlayLayer.prototype._styleGeometry = function (geometry) {
          if (!this._cookedStyles) {
              return false;
          }
          var g = getFilterFeature(geometry);
          for (var i = 0, len = this._cookedStyles.length; i < len; i++) {
              if (this._cookedStyles[i]['filter'](g) === true) {
                  geometry._setExternSymbol(this._cookedStyles[i]['symbol']);
                  return true;
              }
          }
          return false;
      };
      /**
       * 移除 style
       *
       * @english
       * Removes layers' style
       * @returns this
       * @fires VectorLayer#removestyle
       */
      OverlayLayer.prototype.removeStyle = function () {
          if (!this.options.style) {
              return this;
          }
          delete this.options.style;
          delete this._cookedStyles;
          this.forEach(function (geometry) {
              geometry._setExternSymbol(null);
          }, this);
          /**
           * removestyle 事件
           * @english
           * removestyle event.
           *
           * @event VectorLayer#removestyle
           * @type {Object}
           * @property {String} type - removestyle
           * @property {VectorLayer} target - layer
           */
          this.fire('removestyle');
          return this;
      };
      OverlayLayer.prototype.onAddGeometry = function (geo) {
          var style = this.getStyle();
          if (style) {
              this._styleGeometry(geo);
          }
      };
      OverlayLayer.prototype.hide = function () {
          for (var i = 0, l = this._geoList.length; i < l; i++) {
              this._geoList[i].onHide();
          }
          return Layer.prototype.hide.call(this);
      };
      //@internal
      OverlayLayer.prototype._initCache = function () {
          if (!this._geoList) {
              this._geoList = [];
              this._geoMap = {};
          }
      };
      //@internal
      OverlayLayer.prototype._updateZIndex = function () {
          var zIndex = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              zIndex[_i] = arguments[_i];
          }
          this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, __spreadArray([], __read(zIndex), false)));
          this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, __spreadArray([], __read(zIndex), false)));
      };
      //@internal
      OverlayLayer.prototype._sortGeometries = function () {
          var _this = this;
          if (!this._toSort) {
              return;
          }
          this._maxZIndex = 0;
          this._minZIndex = 0;
          this._geoList.sort(function (a, b) {
              _this._updateZIndex(a.getZIndex(), b.getZIndex());
              return _this._compare(a, b);
          });
          this._toSort = false;
      };
      //@internal
      OverlayLayer.prototype._compare = function (a, b) {
          if (a.getZIndex() === b.getZIndex()) {
              return a._getInternalId() - b._getInternalId();
          }
          return a.getZIndex() - b.getZIndex();
      };
      //binarySearch
      //@internal
      OverlayLayer.prototype._findInList = function (geo) {
          var len = this._geoList.length;
          if (len === 0) {
              return -1;
          }
          this._sortGeometries();
          var low = 0, high = len - 1, middle;
          while (low <= high) {
              middle = Math.floor((low + high) / 2);
              if (this._geoList[middle] === geo) {
                  return middle;
              }
              else if (this._compare(this._geoList[middle], geo) > 0) {
                  high = middle - 1;
              }
              else {
                  low = middle + 1;
              }
          }
          return -1;
      };
      //@internal
      OverlayLayer.prototype._onGeometryEvent = function (param) {
          if (!param || !param['target']) {
              return;
          }
          var type = param['type'];
          if (type === 'idchange') {
              this._onGeometryIdChange(param);
          }
          else if (type === 'zindexchange') {
              this._onGeometryZIndexChange(param);
          }
          else if (type === 'positionchange') {
              this._onGeometryPositionChange(param);
          }
          else if (type === 'shapechange') {
              this._onGeometryShapeChange(param);
          }
          else if (type === 'symbolchange') {
              this._onGeometrySymbolChange(param);
          }
          else if (type === 'show') {
              this._onGeometryShow(param);
          }
          else if (type === 'hide') {
              this._onGeometryHide(param);
          }
          else if (type === 'propertieschange') {
              this._onGeometryPropertiesChange(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryIdChange = function (param) {
          if (param['new'] === param['old']) {
              if (this._geoMap[param['old']] && this._geoMap[param['old']] === param['target']) {
                  return;
              }
          }
          if (!isNil(param['new'])) {
              if (this._geoMap[param['new']]) {
                  throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + param['new']);
              }
              this._geoMap[param['new']] = param['target'];
          }
          if (!isNil(param['old']) && param['new'] !== param['old']) {
              delete this._geoMap[param['old']];
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryZIndexChange = function (param) {
          if (param['old'] !== param['new']) {
              this._updateZIndex(param['new']);
              this._toSort = true;
              if (this._getRenderer()) {
                  this._getRenderer().onGeometryZIndexChange(param);
              }
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryPositionChange = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometryPositionChange(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryShapeChange = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometryShapeChange(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometrySymbolChange = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometrySymbolChange(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryShow = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometryShow(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryHide = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometryHide(param);
          }
      };
      //@internal
      OverlayLayer.prototype._onGeometryPropertiesChange = function (param) {
          if (this._getRenderer()) {
              this._getRenderer().onGeometryPropertiesChange(param);
          }
      };
      //@internal
      OverlayLayer.prototype._hasGeoListeners = function (eventTypes) {
          if (!eventTypes) {
              return false;
          }
          if (!Array.isArray(eventTypes)) {
              TMP_EVENTS_ARR[0] = eventTypes;
              eventTypes = TMP_EVENTS_ARR;
          }
          var geos = this.getGeometries() || [];
          for (var i = 0, len = geos.length; i < len; i++) {
              var geometry = geos[i];
              if (!geometry) {
                  continue;
              }
              if (geometry.options.cursor) {
                  return true;
              }
              for (var j = 0, len1 = eventTypes.length; j < len1; j++) {
                  var eventType = eventTypes[j];
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore
                  var listens = geometry.listens(eventType);
                  if (listens > 0) {
                      return true;
                  }
              }
          }
          return false;
      };
      //override for typing
      //@internal
      OverlayLayer.prototype._getRenderer = function () {
          return _super.prototype._getRenderer.call(this);
      };
      return OverlayLayer;
  }(Layer));
  OverlayLayer.mergeOptions(options$o);

  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore /src/geo/PointExtent.js -> Ts 支持不传参数
  var TEMP_EXTENT$1 = new PointExtent();
  /**
   * 配置参数
   *
   * @english
   * @property {Object}  options - VectorLayer's options
   * @property {Boolean} options.debug=false           - whether the geometries on the layer is in debug mode.
   * @property {Boolean} options.enableSimplify=true   - whether to simplify geometries before rendering.
   * @property {String}  options.cursor=default        - the cursor style of the layer
   * @property {Boolean} options.geometryEvents=true   - enable/disable firing geometry events, disable it to improve performance.
   * @property {Boolean} options.defaultIconSize=[20,20] - default size of a marker's icon
   * @property {Boolean} [options.enableAltitude=false]  - whether to enable render geometry with altitude, false by default
   * @property {Boolean} [options.altitudeProperty=altitude] - geometry's altitude property name, if enableAltitude is true, "altitude" by default
   * @property {Boolean} [options.drawAltitude=false]  - whether to draw altitude: a vertical line for marker, a vertical polygon for line
   * @property {Boolean} [options.sortByDistanceToCamera=false]  - markers Sort by camera distance
   * @property {Boolean} [options.roundPoint=false]  - round point before painting to improve performance, but will cause geometry shaking in animation
   * @property {Number} [options.altitude=0]           - layer altitude
   * @property {Boolean} [options.debug=false]         - whether the geometries on the layer is in debug mode.
   * @property {Boolean}  [options.collision=false]  - whether collision
   * @property {Number}  [options.collisionBufferSize=2]  - collision buffer size
   * @property {Number}  [options.collisionDelay=250]  - collision delay time when map Interacting
   * @property {String}  [options.collisionScope=layer]  - Collision range:layer or map
   * @property {Boolean}  [options.progressiveRender=false]  - progressive Render
   * @property {Number}  [options.progressiveRenderCount=1000]  - progressive Render page size
   * @property {Boolean}  [options.progressiveRenderDebug=false]  - progressive Render debug
   * @memberOf VectorLayer
   * @instance
   */
  var options$n = {
      'debug': false,
      'enableSimplify': true,
      'defaultIconSize': [20, 20],
      'cacheVectorOnCanvas': true,
      'cacheSvgOnCanvas': Browser$1.gecko,
      'enableAltitude': false,
      'altitudeProperty': 'altitude',
      'drawAltitude': false,
      'sortByDistanceToCamera': false,
      'roundPoint': false,
      'altitude': 0,
      'clipBBoxBufferSize': 3,
      'collision': false,
      'collisionBufferSize': 2,
      'collisionDelay': 250,
      'collisionScope': 'layer',
      'progressiveRender': false,
      'progressiveRenderCount': 1000,
      'progressiveRenderDebug': false
  };
  // Polyline is for custom line geometry
  // const TYPES = ['LineString', 'Polyline', 'Polygon', 'MultiLineString', 'MultiPolygon'];
  /**
   * 用于管理、呈现 geometries 的 layer
   *
   * @english
   * @classdesc
   * A layer for managing and rendering geometries.
   * @category layer
   * @extends OverlayLayer
   */
  var VectorLayer = /** @class */ (function (_super) {
      __extends(VectorLayer, _super);
      /**
       * @param id                    - layer's id
       * @param geometries=null       - geometries to add
       * @param options=null          - construct options
       * @param options.style=null    - vectorlayer's style
       * @param options.*=null        - options defined in [VectorLayer]{@link VectorLayer#options}
       */
      function VectorLayer(id, geometries, options) {
          var _this = _super.call(this, id, geometries, options) || this;
          _this.isVectorLayer = true;
          return _this;
      }
      VectorLayer.prototype.onConfig = function (conf) {
          _super.prototype.onConfig.call(this, conf);
          if (!isNil(conf['enableAltitude'])) {
              var geos = this.getGeometries() || [];
              for (var i = 0, len = geos.length; i < len; i++) {
                  var geo = geos[i];
                  if (geo) {
                      geo._clearAltitudeCache();
                      geo.fire('positionchange');
                  }
              }
          }
          if (conf['enableAltitude'] || conf['drawAltitude'] || conf['altitudeProperty']) {
              var renderer = this.getRenderer();
              if (renderer && renderer.setToRedraw) {
                  renderer.setToRedraw();
              }
          }
      };
      /**
       * 通过给定 coordinate 识别 geometries
       *
       * @english
       * Identify the geometries on the given coordinate
       * @param  {maptalks.Coordinate} coordinate   - coordinate to identify
       * @param  {Object} [options=null]  - options
       * @param  {Object} [options.tolerance=0] - identify tolerance in pixel
       * @param  {Object} [options.count=null]  - result count
       * @return {Geometry[]} geometries identified
       */
      VectorLayer.prototype.identify = function (coordinate, options) {
          options = options || {};
          var renderer = this.getRenderer();
          if (!(coordinate instanceof Coordinate)) {
              coordinate = new Coordinate(coordinate);
          }
          var cp = this.getMap().coordToContainerPoint(coordinate);
          // only iterate drawn geometries when onlyVisible is true.
          if (options['onlyVisible'] && renderer && renderer.identifyAtPoint) {
              return renderer.identifyAtPoint(cp, options);
          }
          return this._hitGeos(this._geoList, cp, options);
      };
      /**
       * 通过给定 point 识别 geometries
       *
       * @english
       * Identify the geometries on the given container point
       * @param  {maptalks.Point} point   - container point to identify
       * @param  {Object} [options=null]  - options
       * @param  {Object} [options.tolerance=0] - identify tolerance in pixel
       * @param  {Object} [options.count=null]  - result count
       * @return {Geometry[]} geometries identified
       */
      VectorLayer.prototype.identifyAtPoint = function (point, options) {
          options = options || {};
          var renderer = this.getRenderer();
          if (!(point instanceof Point)) {
              point = new Point(point);
          }
          // only iterate drawn geometries when onlyVisible is true.
          if (options['onlyVisible'] && renderer && renderer.identifyAtPoint) {
              return renderer.identifyAtPoint(point, options);
          }
          return this._hitGeos(this._geoList, point, options);
      };
      //@internal
      VectorLayer.prototype._hitGeos = function (geometries, cp, options) {
          if (!geometries || !geometries.length) {
              return [];
          }
          var filter = options['filter'], hits = [];
          var tolerance = options['tolerance'];
          var map = this.getMap();
          var renderer = this.getRenderer();
          var imageData = renderer && renderer.getImageData && renderer.getImageData();
          if (imageData) {
              var hitTolerance = 0;
              var maxTolerance = renderer.maxTolerance;
              //for performance
              if (isNumber(maxTolerance)) {
                  hitTolerance = maxTolerance;
              }
              else {
                  for (var i = geometries.length - 1; i >= 0; i--) {
                      var t = geometries[i]._hitTestTolerance() + (tolerance || 0);
                      if (t > hitTolerance) {
                          hitTolerance = t;
                      }
                  }
              }
              var r = map.getDevicePixelRatio();
              imageData.r = r;
              var hit = false;
              var cpx = cp.x - hitTolerance;
              var cpy = cp.y - hitTolerance;
              for (var i = -hitTolerance; i <= hitTolerance; i++) {
                  for (var j = -hitTolerance; j <= hitTolerance; j++) {
                      var x = Math.round((cpx + i) * r), y = Math.round((cpy + j) * r);
                      var idx = y * imageData.width * 4 + x * 4;
                      if (imageData.data[idx + 3] > 0) {
                          hit = true;
                          break;
                      }
                  }
                  if (hit) {
                      break;
                  }
              }
              //空白的直接返回，避免下面的逻辑,假设有50%的概率不命中(要么命中,要么不命中)，可以节省大量的时间
              if (!hit) {
                  return hits;
              }
          }
          var onlyVisible = options.onlyVisible;
          for (var i = geometries.length - 1; i >= 0; i--) {
              var geo = geometries[i];
              if (!geo || !geo.options['interactive']) {
                  continue;
              }
              //当onlyVisible===false时才需要判断isVisible,因为渲染时已经判断过isVisible的值了
              if (!onlyVisible && (!geo.isVisible())) {
                  continue;
              }
              var painter = geo._getPainter();
              if (!painter) {
                  continue;
              }
              var bbox = painter.getRenderBBOX && painter.getRenderBBOX();
              if (bbox) {
                  var x = cp.x, y = cp.y;
                  if (x < bbox[0] || y < bbox[1] || x > bbox[2] || y > bbox[3]) {
                      continue;
                  }
              }
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore /src/geometry/LineString.js -> ts LineString 无 _getArrowStyle 属性
              if (!(geo instanceof LineString) || (!geo._getArrowStyle() && !(geo instanceof Curve))) {
                  // Except for LineString with arrows or curves
                  var extent = geo.getContainerExtent(TEMP_EXTENT$1);
                  if (tolerance) {
                      extent = extent._expand(tolerance);
                  }
                  if (!extent || !extent.contains(cp)) {
                      continue;
                  }
              }
              if (geo._containsPoint(cp, tolerance) && (!filter || filter(geo))) {
                  hits.push(geo);
                  if (options['count']) {
                      if (hits.length >= options['count']) {
                          break;
                      }
                  }
              }
          }
          return hits;
      };
      VectorLayer.prototype.getAltitude = function () {
          return this.options['altitude'] || 0;
      };
      /**
       * 输出 VectorLayer 的 json
       *
       * @english
       * Export the VectorLayer's JSON. <br>
       * @param  {Object} [options=null] - export options
       * @param  {Object} [options.geometries=null] - If not null and the layer is a [OverlayerLayer]{@link OverlayLayer},
       *                                            the layer's geometries will be exported with the given "options.geometries" as a parameter of geometry's toJSON.
       * @param  {Extent} [options.clipExtent=null] - if set, only the geometries intersectes with the extent will be exported.
       * @return layer's JSON
       */
      VectorLayer.prototype.toJSON = function (options) {
          if (!options) {
              options = {
                  'clipExtent': null,
                  'geometries': null
              };
          }
          var profile = {
              'type': this.getJSONType(),
              'id': this.getId(),
              'options': this.config()
          };
          if (isNil(options['geometries']) || options['geometries']) {
              var clipExtent = void 0;
              if (options['clipExtent']) {
                  var map = this.getMap();
                  var projection = map ? map.getProjection() : null;
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore 需/src/geo/Extent.js -> ts 并支持只传两个个参数
                  clipExtent = new Extent(options['clipExtent'], projection);
              }
              var geoJSONs = [];
              var geometries = this.getGeometries();
              for (var i = 0, len = geometries.length; i < len; i++) {
                  var geo = geometries[i];
                  var geoExt = geo.getExtent();
                  if (!geoExt || (clipExtent && !clipExtent.intersects(geoExt))) {
                      continue;
                  }
                  var json = geo.toJSON(options['geometries']);
                  geoJSONs.push(json);
              }
              profile['geometries'] = geoJSONs;
          }
          return profile;
      };
      VectorLayer.prototype.getRenderer = function () {
          return _super.prototype.getRenderer.call(this);
      };
      /**
       * 通过 json 生成 VectorLayer
       *
       * @english
       * Reproduce a VectorLayer from layer's JSON.
       * @param  {Object} layerJSON - layer's JSON
       * @return {VectorLayer}
       * @static
       * @private
       * @function
       */
      VectorLayer.fromJSON = function (json) {
          if (!json || json['type'] !== 'VectorLayer') {
              return null;
          }
          var layer = new VectorLayer(json['id'], json['options']);
          var geoJSONs = json['geometries'];
          var geometries = [];
          for (var i = 0; i < geoJSONs.length; i++) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore 未找到fromJSON属性
              var geo = Geometry.fromJSON(geoJSONs[i]);
              if (geo) {
                  geometries.push(geo);
              }
          }
          layer.addGeometry(geometries);
          return layer;
      };
      VectorLayer.getPainterClass = function () {
          return Painter;
      };
      VectorLayer.getCollectionPainterClass = function () {
          return CollectionPainter;
      };
      return VectorLayer;
  }(OverlayLayer));
  VectorLayer.mergeOptions(options$n);
  VectorLayer.registerJSONType('VectorLayer');

  var key = '_map_tool';
  /**
   * @classdesc
   * <pre>
   * The parent class for all the map tools.
   * It is abstract and not intended to be instantiated.
   * Some interface methods to implement:
   * 1. onAdd: optional, a callback method to do some prepares before enabled when the map tool is added to a map
   * 2. onEnable: optional, called when the map tool is enabled, used to setup the context such as adding more event listeners other than the map, disabling map's default handlers (draggable, scrollWheelZoom, etc) and creating temporary layers.
   * 3. getEvents: required, provide an event map to register event listeners on the map.
   * 4. onDisable: optional, called when the map tool is disabled, used to cleanup such as unregistering event listeners, enable map's original handlers and remove temporary layers.
   * </pre>
   * @abstract
   * @category maptool
   * @extends Class
   * @mixes Eventable
   */
  var MapTool = /** @class */ (function (_super) {
      __extends(MapTool, _super);
      function MapTool() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Adds the map tool to a map.
       * @param {Map} map
       * @return {MapTool} this
       * @fires MapTool#add
       */
      MapTool.prototype.addTo = function (map) {
          if (!map) {
              return this;
          }
          this._map = map;
          // map tool is unique on one map
          if (map[key]) {
              map[key].disable();
          }
          if (this.onAdd) {
              this.onAdd();
          }
          this.enable();
          map[key] = this;
          /**
           * add event.
           *
           * @event MapTool#add
           * @type {Object}
           * @property {String} type - add
           * @property {MapTool} target - map tool
           */
          this._fireEvent('add');
          return this;
      };
      /**
       * Gets the map it added to.
       * @return {Map} map
       */
      MapTool.prototype.getMap = function () {
          return this._map;
      };
      /**
       * Enable the map tool.
       * @return {MapTool} this
       * @fires MapTool#enable
       */
      MapTool.prototype.enable = function () {
          var map = this._map;
          if (!map || this._enabled) {
              return this;
          }
          this._enabled = true;
          this._switchEvents('off');
          this._registerEvents();
          if (this.onEnable) {
              this.onEnable();
          }
          /**
           * enable event.
           *
           * @event MapTool#enable
           * @type {Object}
           * @property {String} type - enable
           * @property {MapTool} target - map tool
           */
          this._fireEvent('enable');
          return this;
      };
      /**
       * Disable the map tool
       * @return {MapTool} this
       * @fires MapTool#disable
       */
      MapTool.prototype.disable = function () {
          if (!this._enabled || !this._map) {
              return this;
          }
          this._enabled = false;
          this._switchEvents('off');
          if (this.onDisable) {
              this.onDisable();
          }
          /**
           * disable event.
           *
           * @event MapTool#disable
           * @type {Object}
           * @property {String} type - disable
           * @property {MapTool} target - map tool
           */
          this._fireEvent('disable');
          return this;
      };
      /**
       * Returns whether the tool is enabled
       * @return {Boolean} true | false
       */
      MapTool.prototype.isEnabled = function () {
          if (!this._enabled) {
              return false;
          }
          return true;
      };
      MapTool.prototype.remove = function () {
          if (!this._map) {
              return this;
          }
          this.disable();
          if (this._map) {
              delete this._map[key];
              delete this._map;
          }
          /**
           * remove event.
           *
           * @event MapTool#remove
           * @type {Object}
           * @property {String} type - remove
           * @property {MapTool} target - map tool
           */
          this._fireEvent('remove');
          return this;
      };
      //@internal
      MapTool.prototype._registerEvents = function () {
          this._switchEvents('on');
      };
      //@internal
      MapTool.prototype._switchEvents = function (to) {
          var events = this.getEvents();
          if (events) {
              this._map[to](events, this);
          }
      };
      //@internal
      MapTool.prototype._fireEvent = function (eventName, param) {
          if (!param) {
              param = {};
          }
          this.fire(eventName, param);
      };
      return MapTool;
  }(Eventable(Class)));

  /**
   * 配置项
   *
   * @english
   * @property {Object} [options=null] - construct options
   * @property {String} [options.mode=null]   - mode of the draw tool
   * @property {Object} [options.symbol=null] - symbol of the geometries drawn
   * @property {Boolean} [options.once=null]  - whether disable immediately once drawn a geometry.
   * @property {Boolean} [options.autoPanAtEdge=false]  - Whether to make edge judgement or not.
   * @property {Boolean} [options.blockGeometryEvents=false]  - Whether Disable geometryEvents when drawing.
   * @property {Number} [options.zIndex=Number.MAX_VALUE]  - drawlayer zIndex.The default drawn layer will be at the top
   * @property {Boolean} [options.enableAltitude=true]  - enable altitude
   * @property {Boolean} [options.interactive=true] - whether the mouse can be interactived.
   * @memberOf DrawTool
   * @instance
   */
  var options$m = {
      'symbol': {
          'lineColor': '#000',
          'lineWidth': 2,
          'lineOpacity': 1,
          'polygonFill': '#fff',
          'polygonOpacity': 0.3
      },
      'doubleClickZoom': false,
      'mode': null,
      'once': false,
      'autoPanAtEdge': false,
      'ignoreMouseleave': true,
      'blockGeometryEvents': false,
      'zIndex': Number.MAX_VALUE,
      'enableAltitude': true,
      'interactive': true,
      'transformCoordinate': null
  };
  var registeredMode = {};
  /**
   * 图形绘制工具类
   *
   * @english
   * A map tool to help draw geometries.
   * @category maptool
   * @extends MapTool
   * @example
   * var drawTool = new DrawTool({
   *     mode : 'Polygon',
   *     symbol : {
   *         'lineColor' : '#000',
   *         'lineWidth' : 5
   *     },
   *     once : true
   * }).addTo(map);
   */
  var DrawTool = /** @class */ (function (_super) {
      __extends(DrawTool, _super);
      /**
       * 实例化DrawTool工具
       *
       * @english
       * In default, DrawTool supports the following modes: <br>
       * [Point, LineString, Polygon, Circle, Ellipse, Rectangle, ArcCurve, QuadBezierCurve, CubicBezierCurve] <br>
       * You can easily add new mode to DrawTool by calling [registerMode]{@link DrawTool.registerMode}
       * @param options=null                  - construct options
       * @param options.mode=null             - mode of the draw tool
       * @param options.symbol=null           - symbol of the geometries drawn
       * @param options.once=null             - whether disable immediately once drawn a geometry.
       * @param options.autoPanAtEdge=false   - Whether to make edge judgement or not.
       */
      function DrawTool(options) {
          var _this = _super.call(this, options) || this;
          _this._checkMode();
          /**
           * events
           * @type {{click: DrawTool._clickHandler, mousemove: DrawTool._mouseMoveHandler, dblclick: DrawTool._doubleClickHandler, mousedown: DrawTool._mouseDownHandler, mouseup: DrawTool._mouseUpHandler}}
           * @private
           */
          _this._events = {
              'click': _this._clickHandler,
              'mousemove touchmove': _this._mouseMoveHandler,
              'dblclick': _this._doubleClickHandler,
              'mousedown touchstart': _this._mouseDownHandler,
              'mouseup touchend': _this._mouseUpHandler,
              'mousemove': _this._mouseMoveHandler,
              'mousedown': _this._mouseDownHandler,
              'mouseup': _this._mouseUpHandler
          };
          return _this;
      }
      /**
       * 为DrawTool注册一个新mode
       *
       * @english
       * Register a new mode for DrawTool
       * @param name                  mode name
       * @param modeAction            modeActions
       * @param modeAction.action     the action of DrawTool: click, mousedown, clickDblclick
       * @param modeAction.create     the create method of drawn geometry
       * @param modeAction.update     the update method of drawn geometry
       * @param modeAction.generate   the method to generate geometry at the end of drawing.
       * @example
       * //Register "CubicBezierCurve" mode to draw Cubic Bezier Curves.
       * DrawTool.registerMode('CubicBezierCurve', {
          'action': 'clickDblclick',
          'create': path => new CubicBezierCurve(path),
          'update': (path, geometry) => {
              geometry.setCoordinates(path);
          },
          'generate': geometry => geometry
         }
       });
       */
      DrawTool.registerMode = function (name, modeAction) {
          registeredMode[name.toLowerCase()] = modeAction;
      };
      /**
       * 根据name获取mode actions
       *
       * @english
       * Get mode actions by mode name
       * @param name      DrawTool mode name
       * @return          mode actions
       */
      DrawTool.getRegisterMode = function (name) {
          return registeredMode[name.toLowerCase()];
      };
      /**
       * 获取当前mode
       *
       * @english
       * Get current mode of draw tool
       * @return mode
       */
      DrawTool.prototype.getMode = function () {
          if (this.options['mode']) {
              return this.options['mode'].toLowerCase();
          }
          return null;
      };
      /**
       * 设置mode
       *
       * @english
       * Set mode of the draw tool
       * @param mode - mode of the draw tool
       * @returns {DrawTool} this
       * @expose
       */
      DrawTool.prototype.setMode = function (mode) {
          if (this._geometry) {
              this._geometry.remove();
              delete this._geometry;
          }
          this._clearStage();
          this._switchEvents('off');
          this.options['mode'] = mode;
          this._checkMode();
          if (this.isEnabled()) {
              this._switchEvents('on');
              this._restoreMapCfg();
              this._saveMapCfg();
          }
          return this;
      };
      /**
       * 获取DrawTool的symbol属性
       *
       * @english
       * Get symbol of the draw tool
       * @return symbol
       */
      DrawTool.prototype.getSymbol = function () {
          var symbol = this.options['symbol'];
          if (symbol) {
              return extendSymbol(symbol);
          }
          else {
              return extendSymbol(this.options['symbol']);
          }
      };
      /**
       * 设置DrawTool的symbol属性
       *
       * @english
       * Set draw tool's symbol
       * @param symbol - symbol set
       * @returns {DrawTool} this
       */
      DrawTool.prototype.setSymbol = function (symbol) {
          if (!symbol) {
              return this;
          }
          this.options['symbol'] = symbol;
          if (this._geometry) {
              this._geometry.setSymbol(symbol);
          }
          return this;
      };
      /**
       * 获取当前绘制图形
       *
       * @english
       * Get geometry is currently drawing
       * @return geometry currently drawing
       */
      DrawTool.prototype.getCurrentGeometry = function () {
          return this._geometry;
      };
      DrawTool.prototype.onAdd = function () {
          this._checkMode();
      };
      DrawTool.prototype.onEnable = function () {
          this._saveMapCfg();
          this._drawToolLayer = this._getDrawLayer();
          this._clearStage();
          this._loadResources();
          var map = this.getMap();
          if (this.options['autoPanAtEdge']) {
              this._mapAutoPanAtEdge = map.options['autoPanAtEdge'];
              if (!this._mapAutoPanAtEdge) {
                  map.config({ autoPanAtEdge: true });
              }
          }
          this._geometryEvents = map.options['geometryEvents'];
          if (this.options['blockGeometryEvents']) {
              map.config('geometryEvents', false);
          }
          return this;
      };
      DrawTool.prototype.onDisable = function () {
          var map = this.getMap();
          this._restoreMapCfg();
          this.endDraw({ ignoreEndEvent: true });
          if (this._map) {
              map.removeLayer(this._getDrawLayer());
              if (this.options['autoPanAtEdge']) {
                  if (!this._mapAutoPanAtEdge) {
                      map.config({ autoPanAtEdge: false });
                  }
              }
          }
          if (this.options['blockGeometryEvents']) {
              map.config('geometryEvents', this._geometryEvents);
          }
          return this;
      };
      /**
       * 撤消绘图，仅适用于点击/删除模式
       *
       * @english
       * Undo drawing, only applicable for click/dblclick mode
       * @return this
       */
      DrawTool.prototype.undo = function () {
          var registerMode = this._getRegisterMode();
          var action = registerMode.action;
          if (!this._shouldRecordHistory(action) || !this._historyPointer) {
              return this;
          }
          var coords = this._clickCoords.slice(0, --this._historyPointer);
          registerMode.update(this.getMap().getProjection(), coords, this._geometry);
          return this;
      };
      /**
       * 重做绘图，只适用于click/dblclick模式
       *
       * @english
       * Redo drawing, only applicable for click/dblclick mode
       * @return this
       */
      DrawTool.prototype.redo = function () {
          var registerMode = this._getRegisterMode();
          var action = registerMode.action;
          if (!this._shouldRecordHistory(action) || isNil(this._historyPointer) || this._historyPointer === this._clickCoords.length) {
              return this;
          }
          var coords = this._clickCoords.slice(0, ++this._historyPointer);
          registerMode.update(this.getMap().getProjection(), coords, this._geometry);
          return this;
      };
      /**
       * 检查历史记录
       *
       * @english
       * check should recor history
       * @param actions
       * @returns {boolean}
       * @private
       */
      //@internal
      DrawTool.prototype._shouldRecordHistory = function (actions) {
          return Array.isArray(actions) && actions[0] === 'click' && actions[1] === 'mousemove' && actions[2] === 'dblclick';
      };
      //@internal
      DrawTool.prototype._checkMode = function () {
          this._getRegisterMode();
      };
      //@internal
      DrawTool.prototype._saveMapCfg = function () {
          var map = this.getMap();
          this._mapDoubleClickZoom = map.options['doubleClickZoom'];
          map.config({
              'doubleClickZoom': this.options['doubleClickZoom']
          });
          var actions = this._getRegisterMode()['action'];
          var dragging = false;
          for (var i = 0; i < actions.length; i++) {
              if (actions[i].indexOf('mousedown') >= 0 || actions[i].indexOf('touchstart') >= 0) {
                  dragging = true;
                  break;
              }
          }
          if (dragging) {
              var map_1 = this.getMap();
              this._mapDraggable = map_1.options['draggable'];
              map_1.config({
                  'draggable': false
              });
          }
      };
      //@internal
      DrawTool.prototype._restoreMapCfg = function () {
          var map = this.getMap();
          map.config({
              'doubleClickZoom': this._mapDoubleClickZoom
          });
          if (!isNil(this._mapDraggable)) {
              map.config('draggable', this._mapDraggable);
          }
          delete this._mapDraggable;
          delete this._mapDoubleClickZoom;
      };
      //@internal
      DrawTool.prototype._loadResources = function () {
          var symbol = this.getSymbol();
          var resources = getExternalResources(symbol);
          if (resources.length > 0) {
              //load external resources at first
              this._drawToolLayer._getRenderer().loadResources(resources);
          }
      };
      //@internal
      DrawTool.prototype._getProjection = function () {
          return this._map.getProjection();
      };
      //@internal
      DrawTool.prototype._getRegisterMode = function () {
          var mode = this.getMode();
          var registerMode = DrawTool.getRegisterMode(mode);
          if (!registerMode) {
              throw new Error(mode + ' is not a valid mode of DrawTool.');
          }
          return registerMode;
      };
      DrawTool.prototype.getEvents = function () {
          var action = this._getRegisterMode()['action'];
          var _events = {};
          if (Array.isArray(action)) {
              for (var i = 0; i < action.length; i++) {
                  //@internal
                  _events[action[i]] = this._events[action[i]];
              }
              return _events;
          }
          return null;
      };
      /**
       * 鼠标按下开始绘画
       *
       * @english
       * mouse down start draw
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._mouseDownHandler = function (event) {
          this._createGeometry(event);
      };
      /**
       * 监听 mouse up 事件
       *
       * @english
       * handle mouse up event
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._mouseUpHandler = function (event) {
          this.endDraw(event);
      };
      /**
       * 监听mouse first click点击事件
       *
       * @english
       * handle mouse first click handle
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._clickHandler = function (event) {
          if (!this.options.interactive) {
              return this;
          }
          event.enableAltitude = this.options.enableAltitude;
          var map = this.getMap();
          var registerMode = this._getRegisterMode();
          // const coordinate = event['coordinate'];
          //dbclick will trigger two click
          if (this._clickCoords && this._clickCoords.length) {
              var len = this._clickCoords.length;
              var prjCoord = map._pointToPrj(event['point2d']);
              if (this._clickCoords[len - 1].equals(prjCoord)) {
                  return;
              }
          }
          if (!this._geometry) {
              this._createGeometry(event);
          }
          else {
              var prjCoord = map._pointToPrj(event['point2d']);
              if (!isNil(this._historyPointer)) {
                  this._clickCoords = this._clickCoords.slice(0, this._historyPointer);
              }
              //for snap effect
              var snapTo = this._geometry.snapTo;
              if (snapTo && isFunction(snapTo)) {
                  var snapResult = this._getSnapResult(snapTo, event.containerPoint);
                  prjCoord = snapResult.prjCoord;
                  this._clickCoords = this._clickCoords.concat(snapResult.effectedVertex);
                  // ensure snap won't trigger again when dblclick
                  if (this._clickCoords[this._clickCoords.length - 1].equals(prjCoord)) {
                      return;
                  }
              }
              this._clickCoords.push(prjCoord);
              this._historyPointer = this._clickCoords.length;
              event.drawTool = this;
              registerMode['update'](map.getProjection(), this._clickCoords, this._geometry, event);
              if (this.getMode() === 'point') {
                  this.endDraw(event);
                  return;
              }
              /**
               * drawvertex事件
               *
               * @english
               * drawvertex event.
               *
               * @event DrawTool#drawvertex
               * @type {Object}
               * @property {String} type              - drawvertex
               * @property {DrawTool} target          - draw tool
               * @property {Geometry} geometry        - geometry drawn
               * @property {Coordinate} coordinate    - coordinate of the event
               * @property {Point} containerPoint     - container point of the event
               * @property {Point} viewPoint          - view point of the event
               * @property {Event} domEvent           - dom event
               */
              if (this._clickCoords.length <= 1) {
                  this._fireEvent('drawstart', event);
              }
              else {
                  this._fireEvent('drawvertex', event);
              }
              if (registerMode['clickLimit'] && registerMode['clickLimit'] === this._historyPointer) {
                  // registerMode['update']([coordinate], this._geometry, event);
                  this.endDraw(event);
              }
          }
      };
      /**
       * 第一次事件创建相关geometry
       *
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._createGeometry = function (event) {
          var mode = this.getMode();
          var map = this.getMap();
          var registerMode = this._getRegisterMode();
          var prjCoord = map._pointToPrj(event['point2d']);
          var symbol = this.getSymbol();
          if (!this._geometry) {
              /**
              * drawprepare事件。在drawstart之前。
              *
              * @english
              * drawprepare event.Note that it occurs before drawstart
              *
              * @event DrawTool#drawprepare
              * @type {Object}
              * @property {String} type           - drawprepare
              * @property {DrawTool} target       - draw tool
              * @property {Coordinate} coordinate - coordinate of the event
              * @property {Point} containerPoint  - container point of the event
              * @property {Point} viewPoint       - view point of the event
              * @property {Event} domEvent        - dom event
              */
              this._fireEvent('drawprepare', event);
              this._clickCoords = [prjCoord];
              event.drawTool = this;
              this._geometry = registerMode['create'](this.getMap().getProjection(), this._clickCoords, event);
              if (symbol && mode !== 'point') {
                  this._geometry.setSymbol(symbol);
              }
              else if (this.options.hasOwnProperty('symbol')) {
                  this._geometry.setSymbol(this.options['symbol']);
              }
              this._addGeometryToStage(this._geometry);
              /**
               * drawstart事件
               *
               * @english
               * drawstart event.
               *
               * @event DrawTool#drawstart
               * @type {Object}
               * @property {String} type - drawstart
               * @property {DrawTool} target - draw tool
               * @property {Coordinate} coordinate - coordinate of the event
               * @property {Point} containerPoint  - container point of the event
               * @property {Point} viewPoint       - view point of the event
               * @property {Event} domEvent                 - dom event
               */
              this._fireEvent('drawstart', event);
              // snapTo First coordinate point
              var snapTo = this._geometry.snapTo;
              if (snapTo && isFunction(snapTo)) {
                  var snapResult = this._getSnapResult(snapTo, event.containerPoint);
                  var map_2 = this.getMap();
                  if (map_2 && snapResult) {
                      var prjCoord_1 = snapResult.prjCoord;
                      this._clickCoords = [prjCoord_1];
                      registerMode['update'](map_2.getProjection(), this._clickCoords, this._geometry, event);
                  }
              }
          }
          if (mode === 'point' && event.type !== 'mousemove') {
              this.endDraw(event);
          }
      };
      /**
       * 监听鼠标移动
       *
       * @english
       * handle mouse move event
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._mouseMoveHandler = function (event) {
          if (!this.options.interactive) {
              return this;
          }
          event.enableAltitude = this.options.enableAltitude;
          var map = this.getMap();
          if (!map || map.isInteracting()) {
              return;
          }
          if (this.getMode() === 'point' && !this._geometry) {
              this._createGeometry(event);
              return;
          }
          if (!this._geometry) {
              return;
          }
          var containerPoint = this._getMouseContainerPoint(event);
          if (!this._isValidContainerPoint(containerPoint)) {
              return;
          }
          var prjCoord = map._pointToPrj(event['point2d']);
          // for snap effect
          var snapAdditionVertex = [];
          var snapTo = this._geometry.snapTo;
          if (snapTo && isFunction(snapTo)) {
              var snapResult = this._getSnapResult(snapTo, containerPoint);
              prjCoord = snapResult.prjCoord;
              snapAdditionVertex = snapResult.effectedVertex;
          }
          var projection = map.getProjection();
          event.drawTool = this;
          var registerMode = this._getRegisterMode();
          if (this._shouldRecordHistory(registerMode.action)) {
              var path = this._clickCoords.slice(0, this._historyPointer);
              if (path && path.length > 0 && prjCoord.equals(path[path.length - 1])) {
                  return;
              }
              registerMode['update'](projection, path.concat(snapAdditionVertex, [prjCoord]), this._geometry, event);
          }
          else {
              //free hand mode
              registerMode['update'](projection, prjCoord, this._geometry, event);
          }
          /**
           * mousemove事件
           *
           * @english
           * mousemove event.
           *
           * @event DrawTool#mousemove
           * @type {Object}
           * @property {String} type - mousemove
           * @property {DrawTool} target - draw tool
           * @property {Geometry} geometry - geometry drawn
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this._fireEvent('mousemove', event);
      };
      /**
       * 监听double click事件
       *
       * @english
       * handle mouse double click event
       * @param event
       * @private
       */
      //@internal
      DrawTool.prototype._doubleClickHandler = function (event) {
          if (!this.options.interactive) {
              return this;
          }
          event.enableAltitude = this.options.enableAltitude;
          if (!this._geometry) {
              return;
          }
          var containerPoint = this._getMouseContainerPoint(event);
          if (!this._isValidContainerPoint(containerPoint)) {
              return;
          }
          var registerMode = this._getRegisterMode();
          var clickCoords = this._clickCoords;
          if (!clickCoords || clickCoords.length < 2) {
              return;
          }
          var mode = this.getMode();
          // Polygon ,FreeHandPolygon
          if (mode && mode.indexOf('polygon') > -1 && clickCoords.length < 3) {
              return;
          }
          var projection = this.getMap().getProjection();
          //remove duplicate vertexes
          var path = [clickCoords[0]];
          for (var i = 1, len = clickCoords.length; i < len; i++) {
              if (clickCoords[i].x !== clickCoords[i - 1].x || clickCoords[i].y !== clickCoords[i - 1].y) {
                  path.push(clickCoords[i]);
              }
          }
          if (path.length < 2 || (this._geometry && (this._geometry instanceof Polygon) && path.length < 3)) {
              return;
          }
          event.drawTool = this;
          registerMode['update'](projection, path, this._geometry, event);
          this.endDraw(event);
      };
      //@internal
      DrawTool.prototype._addGeometryToStage = function (geometry) {
          var drawLayer = this._getDrawLayer();
          drawLayer.addGeometry(geometry);
      };
      /**
       * 结束当前绘制
       *
       * @english
       * End current draw
       * @param [param=null] params of drawend event
       * @returns this
       */
      DrawTool.prototype.endDraw = function (param) {
          if (!this._geometry || this._ending) {
              return this;
          }
          this._ending = true;
          var geometry = this._geometry;
          this._clearStage();
          param = param || {};
          this._geometry = geometry;
          /**
           * drawend event.
           *
           * @event DrawTool#drawend
           * @type {Object}
           * @property {String} type - drawend
           * @property {DrawTool} target - draw tool
           * @property {Geometry} geometry - geometry drawn
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          if (!param.ignoreEndEvent) {
              this._fireEvent('drawend', param);
          }
          delete this._geometry;
          if (this.options['once']) {
              this.disable();
          }
          delete this._ending;
          delete this._historyPointer;
          if (this._vertexes) {
              this._vertexes = [];
          }
          return this;
      };
      //@internal
      DrawTool.prototype._clearStage = function () {
          this._getDrawLayer().clear();
          delete this._geometry;
          delete this._clickCoords;
      };
      /**
       * 获取鼠标事件 ontainer point 信息
       *
       * @english
       * Get container point of the mouse event
       * @param event -  mouse event
       * @return
       * @private
       */
      //@internal
      DrawTool.prototype._getMouseContainerPoint = function (event) {
          var action = this._getRegisterMode()['action'];
          if (action[0].indexOf('mousedown') >= 0 || action[0].indexOf('touchstart') >= 0) {
              //prevent map's event propogation
              stopPropagation(event['domEvent']);
          }
          return event['containerPoint'];
      };
      //@internal
      DrawTool.prototype._isValidContainerPoint = function (containerPoint) {
          var mapSize = this._map.getSize();
          var w = mapSize['width'], h = mapSize['height'];
          if (containerPoint.x < 0 || containerPoint.y < 0) {
              return false;
          }
          else if (containerPoint.x > w || containerPoint.y > h) {
              return false;
          }
          return true;
      };
      //@internal
      DrawTool.prototype._getSnapResult = function (snapTo, containerPoint) {
          var map = this.getMap();
          var lastContainerPoints = [];
          if (this.options.edgeAutoComplete) {
              var lastCoord = this._clickCoords[(this._historyPointer || 1) - 1];
              lastContainerPoints.push(map.prjToContainerPoint(lastCoord));
              var beforeLastCoord = this._clickCoords[(this._historyPointer || 1) - 2];
              if (beforeLastCoord) {
                  lastContainerPoints.push(map.prjToContainerPoint(beforeLastCoord));
              }
          }
          var snapResult = snapTo(containerPoint, lastContainerPoints);
          containerPoint = (snapResult.effectedVertex ? snapResult.point : snapResult) || containerPoint;
          var prjCoord = map._containerPointToPrj(containerPoint);
          if (snapResult.effectedVertex) {
              snapResult.effectedVertex = snapResult.effectedVertex.map(function (vertex) { return map._containerPointToPrj(vertex); });
          }
          return {
              prjCoord: prjCoord,
              effectedVertex: snapResult.effectedVertex || []
          };
      };
      //@internal
      DrawTool.prototype._getDrawLayer = function () {
          var drawLayerId = INTERNAL_LAYER_PREFIX + 'drawtool';
          var drawToolLayer = this._map.getLayer(drawLayerId);
          if (!drawToolLayer) {
              drawToolLayer = new VectorLayer(drawLayerId, {
                  'enableSimplify': false,
                  'enableAltitude': this.options['enableAltitude'],
                  'zIndex': this.options.zIndex
              });
              this._map.addLayer(drawToolLayer);
          }
          this._pushLayers(drawToolLayer);
          return drawToolLayer;
      };
      //@internal
      DrawTool.prototype._fireEvent = function (eventName, param) {
          if (!param) {
              param = {};
          }
          param = extend$2({}, param);
          if (this._geometry) {
              param['geometry'] = this._getRegisterMode()['generate'](this._geometry, { drawTool: this });
              param.tempGeometry = this._geometry;
          }
          MapTool.prototype._fireEvent.call(this, eventName, param);
      };
      //@internal
      DrawTool.prototype._pushLayers = function (layers) {
          var _this = this;
          if (!layers) {
              return this;
          }
          if (!Array.isArray(layers)) {
              layers = [layers];
          }
          this._layers = this._layers || [];
          layers.forEach(function (layer) {
              if (_this._layers.indexOf(layer) === -1) {
                  _this._layers.push(layer);
              }
          });
          return this;
      };
      //@internal
      DrawTool.prototype._outLayers = function (layers) {
          var _this = this;
          if (!layers) {
              return this;
          }
          if (!Array.isArray(layers)) {
              layers = [layers];
          }
          this._layers = this._layers || [];
          layers.forEach(function (layer) {
              for (var i = 0, len = _this._layers.length; i < len; i++) {
                  if (layer === _this._layers[i]) {
                      _this._layers.splice(i, 1);
                      break;
                  }
              }
          });
          return this;
      };
      /**
      * 设置Layer的zIndex
      * @english
      * set draw inner layers zIndex
      * @param  {Number} zIndex -  draw layer zIndex
      * @return this
      */
      DrawTool.prototype.setLayerZIndex = function (zIndex) {
          if (!isNumber(zIndex)) {
              return this;
          }
          this.options.zIndex = zIndex;
          this._layers = this._layers || [];
          this._layers.forEach(function (layer) {
              if (layer && layer.setZIndex) {
                  layer.setZIndex(zIndex);
              }
          });
          return this;
      };
      /**
      * 添加一个自定义的坐标点
      * @english
      * add a custom Coordinate
      * @param  {Coordinate} coordinate -  coordinate
      * @return this
      */
      DrawTool.prototype.addCoordinate = function (coordinate) {
          if (!this.isEnabled()) {
              return this;
          }
          var map = this.getMap();
          if (!map) {
              return this;
          }
          coordinate = new Coordinate(coordinate);
          var eventParam = map._parseEventFromCoord(coordinate);
          this._clickHandler(eventParam);
          return this;
      };
      /**
       * 获取临时的Geometry
       * @english
       * get temp Geometry
       * @return Geometry
      */
      DrawTool.prototype.getTempGeometry = function () {
          return this._geometry;
      };
      return DrawTool;
  }(MapTool));
  DrawTool.mergeOptions(options$m);

  var MapBoxZoomHander = /** @class */ (function (_super) {
      __extends(MapBoxZoomHander, _super);
      function MapBoxZoomHander(target) {
          var _this = _super.call(this, target) || this;
          _this.drawTool = new DrawTool({
              'mode': 'boxZoom',
              // TODO: 等待DrawTool补充类型
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              'ignoreMouseleave': false
          });
          return _this;
      }
      MapBoxZoomHander.prototype.addHooks = function () {
          this.target.on('_mousedown', this._onMouseDown, this);
      };
      MapBoxZoomHander.prototype.removeHooks = function () {
          this.target.off('_mousedown', this._onMouseDown, this);
          if (this.drawTool.isEnabled()) {
              this.drawTool.remove();
          }
      };
      //@internal
      MapBoxZoomHander.prototype._onMouseDown = function (param) {
          if (!this.target.options['boxZoom']) {
              return;
          }
          if (param.domEvent.shiftKey) {
              // TODO: 等待DrawTool补充类型
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              this.drawTool.setSymbol(this.target.options['boxZoomSymbol']).on('drawend', this._boxZoom, this).addTo(this.target);
          }
      };
      //@internal
      MapBoxZoomHander.prototype._boxZoom = function (param) {
          var map = this.target;
          this.drawTool.remove();
          var geometry = param.geometry, center = geometry.getCenter(), symbol = geometry.getSymbol(), w = symbol.markerWidth, h = symbol.markerHeight;
          // TODO: 等待Geometry补充类型
          var extent = new Extent(center, map.locateByPoint(center, w, h), map.getProjection());
          var zoom = map.getFitZoom(extent);
          map._animateTo({
              center: extent.getCenter(),
              zoom: zoom
          });
      };
      return MapBoxZoomHander;
  }(Handler));
  Map$1.mergeOptions({
      'boxZoom': true,
      'boxZoomSymbol': {
          'markerType': 'rectangle',
          'markerLineWidth': 3,
          'markerLineColor': '#1bbc9b',
          'markerLineDasharray': [10, 5],
          'markerFillOpacity': 0.1,
          'markerFill': '#1bbc9b',
          'markerWidth': 1,
          'markerHeight': 1
      }
  });
  Map$1.addOnLoadHook('addHandler', 'boxZoom', MapBoxZoomHander);

  // Edge Detection Distance(Units are pixels).
  var PANOFFSET = 30;
  var MapAutoPanAtEdgeHandler = /** @class */ (function (_super) {
      __extends(MapAutoPanAtEdgeHandler, _super);
      function MapAutoPanAtEdgeHandler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MapAutoPanAtEdgeHandler.prototype.addHooks = function () {
          if (!this.target) {
              return;
          }
          this.target.on('_mousemove', this._onMouseMove, this);
      };
      MapAutoPanAtEdgeHandler.prototype.removeHooks = function () {
          if (!this.target) {
              return;
          }
          this.target.off('_mousemove', this._onMouseMove, this);
      };
      //@internal
      MapAutoPanAtEdgeHandler.prototype._onMouseMove = function (event) {
          var map = this.target;
          if (map.options['autoPanAtEdge']) {
              var containerPoint = event.containerPoint;
              var containerExtent = map.getContainerExtent();
              if (containerExtent) {
                  var x = containerPoint.x, y = containerPoint.y;
                  var xmax = containerExtent.xmax, ymax = containerExtent.ymax;
                  var p = void 0;
                  if (x < PANOFFSET) {
                      p = [Math.abs(x - PANOFFSET), 0];
                  }
                  if (y < PANOFFSET) {
                      p = [0, Math.abs(y - PANOFFSET)];
                  }
                  if ((x + PANOFFSET) > xmax) {
                      p = [-Math.abs((x + PANOFFSET) - xmax), 0];
                  }
                  if ((y + PANOFFSET) > ymax) {
                      p = [0, -Math.abs((y + PANOFFSET) - ymax)];
                  }
                  if (p) {
                      map.panBy(p, { duration: 1 });
                  }
              }
          }
      };
      return MapAutoPanAtEdgeHandler;
  }(Handler));
  Map$1.mergeOptions({
      'autoPanAtEdge': false
  });
  Map$1.addOnLoadHook('addHandler', 'autoPanAtEdge', MapAutoPanAtEdgeHandler);

  // function equalView(view1, view2) {
  //     for (const p in view1) {
  //         if (hasOwn(view1, p)) {
  //             if (p === 'center') {
  //                 if (view1[p][0] !== view2[p][0] || view1[p][1] !== view2[p][1]) {
  //                     return false;
  //                 }
  //             } else if (view1[p] !== view2[p]) {
  //                 return false;
  //             }
  //         }
  //     }
  //     return true;
  // }
  Map$1.include(/** @lends Map.prototype */ {
      /**
       * Update map's view with animation.
       * @example
       * map.animateTo({
       *     zoom : 13,
       *     center : [0, 0],
       *     pitch : 30,
       *     bearing : 60
       * }, {
       *     duration : 6000,
       *     easing : 'out'
       * }, function(frame) {
       *     if (frame.state.playState === 'finished') {
       *         console.log('animation finished');
       *     }
       * });
       * @param  {Object} view    view object
       * @param  {Object} [options=null]
       * @param  {String} [options.easing=out]
       * @param  {Number} [options.duration=map.options.zoomAnimationDuration]
       * @param  {Function} [step=null]  - step function during animation, animation frame as the parameter
       * @return {Map}         this
       */
      animateTo: function (view, options, step) {
          var _this = this;
          if (options === void 0) { options = {}; }
          view = extend$2({}, this.getView(), view);
          this._validateView(view);
          // this._stopAnim(this._animPlayer);
          if (isFunction(options)) {
              step = options;
              options = {};
          }
          var projection = this.getProjection(), currView = this.getView(), props = {};
          var empty = true;
          for (var p in view) {
              if (hasOwn(view, p) && !isNil(view[p]) && (p === 'prjCenter' || !isNil(currView[p]))) {
                  empty = false;
                  if (p === 'center') {
                      var from = new Coordinate(currView[p]), to = new Coordinate(view[p]);
                      if (!from.equals(to)) {
                          props['center'] = [from, to];
                      }
                  }
                  else if (p === 'prjCenter') {
                      var from = new Coordinate(this._getPrjCenter());
                      var to = new Coordinate(view[p]);
                      if (!from.equals(to)) {
                          props['prjCenter'] = [from, to];
                      }
                  }
                  else if (currView[p] !== view[p] && p !== 'around') {
                      props[p] = [currView[p], view[p]];
                  }
              }
          }
          if (empty) {
              return null;
          }
          if (this._animPlayer) {
              if (this._isInternalAnimation) {
                  if (this._animPlayer.playState === 'running') {
                      this._animPlayer.pause();
                      this._prevAnimPlayer = this._animPlayer;
                  }
              }
              else {
                  delete this._prevAnimPlayer;
                  this._stopAnim(this._animPlayer);
              }
          }
          var zoomOrigin = view['around'] || null;
          // let preView = this.getView();
          var renderer = this._getRenderer(), framer = function (fn) {
              renderer.callInNextFrame(fn);
          };
          var player = this._animPlayer = Animation.animate(props, {
              'easing': options['easing'] || 'out',
              'duration': options['duration'] || this.options['zoomAnimationDuration'],
              'framer': framer,
              'repeat': options['repeat']
          }, function (frame) {
              if (_this.isRemoved()) {
                  player.finish();
                  return;
              }
              if (player.playState === 'running') {
                  // const view = this.getView();
                  // if (!options['continueOnViewChanged'] && !equalView(view, preView)) {
                  //     // map's view is updated by another operation, animation should stop
                  //     this._stopAnim(player);
                  //     return;
                  // }
                  if (frame.styles['center']) {
                      var center = frame.styles['center'];
                      _this._setPrjCenter(projection.project(center));
                      _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
                  }
                  else if (frame.styles['prjCenter']) {
                      var center = frame.styles['prjCenter'];
                      _this._setPrjCenter(center);
                      _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
                  }
                  if (!isNil(frame.styles['zoom'])) {
                      _this.onZooming(frame.styles['zoom'], zoomOrigin);
                  }
                  if (!isNil(frame.styles['pitch'])) {
                      _this._setPitch(frame.styles['pitch']);
                  }
                  if (!isNil(frame.styles['bearing'])) {
                      _this._setBearing(frame.styles['bearing']);
                  }
                  // preView = this.getView();
                  /**
                   * fired when map is animating.  (panning, zooming, rotating)
                   *
                   * @event Map#animating
                   * @type {Object}
                   * @property {String} type - animating
                   * @property {Map} target - the map fires the event
                   */
                  _this._fireEvent('animating');
              }
              else if (player.playState !== 'paused' || player === _this._mapAnimPlayer) {
                  if (!player._interupted) {
                      if (props['center']) {
                          _this._setPrjCenter(projection.project(props['center'][1]));
                      }
                      else if (props['prjCenter']) {
                          _this._setPrjCenter(props['prjCenter'][1]);
                      }
                      if (!isNil(props['pitch'])) {
                          _this._setPitch(props['pitch'][1]);
                      }
                      if (!isNil(props['bearing'])) {
                          _this._setBearing(props['bearing'][1]);
                      }
                  }
                  _this._endAnim(player, props, zoomOrigin, options);
                  // preView = this.getView();
              }
              if (step) {
                  step(frame);
              }
          }, this);
          this._startAnim(props, zoomOrigin);
          return player;
      },
      //@internal
      _animateTo: function (view, options, step) {
          if (options === void 0) { options = {}; }
          if (this._mapAnimPlayer) {
              this._stopAnim(this._mapAnimPlayer);
          }
          this._isInternalAnimation = true;
          this._mapAnimPlayer = this.animateTo(view, options, step);
          delete this._isInternalAnimation;
          return this._mapAnimPlayer;
      },
      /**
       * Fly to given view in a smooth pan-zoom animation.
       * @example
       * map.flyTo({
       *     zoom : 13,
       *     center : [0, 0],
       *     pitch : 30,
       *     bearing : 60
       * }, {
       *     duration : 6000,
       *     easing : 'out'
       * }, function(frame) {
       *     if (frame.state.playState === 'finished') {
       *         console.log('animation finished');
       *     }
       * });
       * @param  {Object} view    view object
       * @param  {Object} [options=null]
       * @param  {String} [options.easing=out]
       * @param  {Number} [options.duration=8]
       * @param  {Function} [step=null]  - step function during animation, animation frame as the parameter
       * @return {Map}         this
      */
      flyTo: function (view, options, step) {
          var _this = this;
          if (options === void 0) { options = {}; }
          // based on implementation of flyTo of mapbox-gl-js
          // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS
          //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
          //
          // Where applicable, local variable documentation begins with the associated variable or
          // function in van Wijk (2003).
          view = extend$2({}, this.getView(), view);
          this._validateView(view);
          if (this._animPlayer) {
              if (this._isInternalAnimation) {
                  if (this._animPlayer.playState === 'running') {
                      this._animPlayer.pause();
                      this._prevAnimPlayer = this._animPlayer;
                  }
              }
              else {
                  delete this._prevAnimPlayer;
                  this._stopAnim(this._animPlayer);
              }
          }
          if (isFunction(options)) {
              step = options;
              options = {};
          }
          options = extend$2({
              // offset: [0, 0],
              // speed: 1.2,
              curve: 1.42
          }, options);
          var map = this;
          function zoomScale(z0, z1) {
              return map.getResolution(z1) / map.getResolution(z0);
          }
          var zoomOrigin = view['around'] || new Point(this.width / 2, this.height / 2);
          var minZoom = this.getMinZoom();
          var maxZoom = this.getMaxZoom();
          var projection = this.getProjection();
          var currView = this.getView();
          var startZoom = currView.zoom;
          var startBearing = currView.bearing;
          var startPitch = currView.pitch;
          var zoom = 'zoom' in view ? clamp(+view.zoom, minZoom, maxZoom) : startZoom;
          var bearing = 'bearing' in view ? +view.bearing : startBearing;
          var pitch = 'pitch' in view ? +view.pitch : startPitch;
          var center = projection.project(view.center && new Coordinate(view.center) || this.getCenter());
          var scale = zoomScale(zoom, startZoom);
          var from = projection.project(this.getCenter());
          var delta = center.sub(from);
          var rho = options.curve;
          // w₀: Initial visible span, measured in pixels at the initial scale.
          var w0 = Math.max(this.width, this.height), 
          // w₁: Final visible span, measured in pixels with respect to the initial scale.
          w1 = w0 / scale, 
          // Length of the flight path as projected onto the ground plane, measured in pixels from
          // the world image origin at the initial scale.
          u1 = delta.mag();
          if ('minZoom' in options) {
              var animMinZoom = clamp(Math.min(options.minZoom, startZoom, zoom), minZoom, maxZoom);
              // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
              // scale.
              var wMax = w0 / zoomScale(animMinZoom, startZoom);
              rho = Math.sqrt(wMax / u1 * 2);
          }
          // ρ²
          var rho2 = rho * rho;
          function r(i) {
              var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
              return Math.log(Math.sqrt(b * b + 1) - b);
          }
          function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
          function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
          function tanh(n) { return sinh(n) / cosh(n); }
          // r₀: Zoom-out factor during ascent.
          var r0 = r(0);
          // w(s): Returns the visible span on the ground, measured in pixels with respect to the
          // initial scale. Assumes an angular field of view of 2 arctan ½ ≈ 53°.
          var w = function (s) {
              return (cosh(r0) / cosh(r0 + rho * s));
          };
          // u(s): Returns the distance along the flight path as projected onto the ground plane,
          // measured in pixels from the world image origin at the initial scale.
          var u = function (s) {
              return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;
          };
          // S: Total length of the flight path, measured in ρ-screenfuls.
          var S = (r(1) - r0) / rho;
          // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
          if (Math.abs(u1) < 0.000001 || !isFinite(S)) {
              // Perform a more or less instantaneous transition if the path is too short.
              if (Math.abs(w0 - w1) < 0.000001)
                  return this.animateTo(view, options, step);
              var k_1 = w1 < w0 ? -1 : 1;
              S = Math.abs(Math.log(w1 / w0)) / rho;
              u = function () { return 0; };
              w = function (s) { return Math.exp(k_1 * rho * s); };
          }
          // let preView = this.getView();
          var renderer = this._getRenderer();
          var framer = function (fn) {
              renderer.callInNextFrame(fn);
          };
          var player = this._animPlayer = Animation.animate({ k: [0, 1] }, {
              'easing': options['easing'] || 'out',
              'duration': options['duration'] || 8,
              'framer': framer
          }, function (frame) {
              if (_this.isRemoved()) {
                  player.finish();
                  return;
              }
              var k = frame.styles.k;
              // s: The distance traveled along the flight path, measured in ρ-screenfuls.
              var s = k * S;
              var scale = 1 / w(s);
              var props = {};
              if (view.center) {
                  var newCenter = k === 1 ? center : from.add(delta.multi(u(s)));
                  props.prjCenter = [center, newCenter];
              }
              if (startZoom !== zoom) {
                  var newZoom = k === 1 ? zoom : _this.getZoomForScale(scale, startZoom, true);
                  props.zoom = [startZoom, newZoom];
              }
              if (startPitch !== pitch) {
                  var newPitch = interpolate(startPitch, pitch, k);
                  props.pitch = [pitch, newPitch];
              }
              if (startBearing !== bearing) {
                  var newBearing = interpolate(startBearing, bearing, k);
                  props.bearing = [bearing, newBearing];
              }
              if (player.playState === 'running') {
                  if (props['prjCenter']) {
                      var center_1 = props['prjCenter'];
                      _this._setPrjCenter(center_1[1]);
                      _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
                  }
                  if (props['zoom']) {
                      _this.onZooming(props['zoom'][1], zoomOrigin);
                  }
                  if (props['pitch']) {
                      _this._setPitch(props['pitch'][1]);
                  }
                  if (props['bearing']) {
                      _this._setBearing(props['bearing'][1]);
                  }
                  _this._fireEvent('animating');
              }
              else if (player.playState !== 'paused' || player === _this._mapAnimPlayer) {
                  if (!player._interupted) {
                      if (props['prjCenter']) {
                          _this._setPrjCenter(props['prjCenter'][1]);
                      }
                      if (props['pitch']) {
                          _this._setPitch(props['pitch'][1]);
                      }
                      if (props['bearing']) {
                          _this._setBearing(props['bearing'][1]);
                      }
                  }
                  _this._endAnim(player, props, zoomOrigin, options);
              }
              if (step) {
                  step(frame);
              }
          }, {});
          this._startAnim({
              center: view.center,
              zoom: view.zoom !== startZoom,
              pitch: pitch !== startPitch,
              bearing: bearing !== startBearing
          }, zoomOrigin);
          return this;
      },
      /**
       * Whether the map is animating with .animateTo
       * @return {Boolean}
       */
      isAnimating: function () {
          return !!(this._animPlayer);
      },
      isRotating: function () {
          return this.isDragRotating() || !!this._animRotating;
      },
      //@internal
      _endAnim: function (player, props, zoomOrigin, options) {
          delete this._animRotating;
          /**
           * fired when map's animation is interrupted by mouse event or else.
           *
           * @event Map#animateinterrupted
           * @type {Object}
           * @property {String} type - animateinterrupted
           * @property {Map} target - the map fires the event
           */
          /**
           * fired when map's animation ended (panning, zooming, rotating).
           *
           * @event Map#animateend
           * @type {Object}
           * @property {String} type - animateend
           * @property {Map} target - the map fires the event
           */
          var evtType = player._interupted ? 'animateinterrupted' : 'animateend';
          if (player === this._animPlayer) {
              delete this._animPlayer;
          }
          if (player === this._mapAnimPlayer) {
              delete this._mapAnimPlayer;
          }
          if (props['center']) {
              var endCoord = void 0;
              if (player._interupted) {
                  endCoord = this.getCenter();
              }
              else {
                  endCoord = props['center'][1];
              }
              this.onMoveEnd(this._parseEventFromCoord(endCoord));
          }
          else if (props['prjCenter']) {
              var endCoord = void 0;
              if (player._interupted) {
                  endCoord = this._getPrjCenter();
              }
              else {
                  endCoord = props['prjCenter'][1];
              }
              var event_1 = this._parseEventFromCoord(this.getProjection().unproject(endCoord));
              event_1['point2d'] = this._prjToPoint(endCoord);
              this.onMoveEnd(event_1);
          }
          if (!isNil(props['zoom'])) {
              // remove origin in onZoomEnd, because center may be updated during animation but zoomOrigin here may reset center to the center value when starting animation
              if (player._interupted) {
                  this.onZoomEnd(this.getZoom());
              }
              else if (!options['wheelZoom']) {
                  this.onZoomEnd(props['zoom'][1]);
              }
              else {
                  this.onZooming(props['zoom'][1], zoomOrigin);
              }
          }
          if (evtType) {
              this._fireEvent(evtType);
          }
          if (!isNil(props['pitch']) && !this.getPitch()) {
              //https://github.com/maptalks/maptalks.js/issues/732
              //fix blank map when pitch changes to 0
              this.getRenderer().setToRedraw();
          }
          if (!options['wheelZoom']) {
              this._resumePrev(player);
          }
      },
      //@internal
      _startAnim: function (props, zoomOrigin) {
          if (!this._animPlayer) {
              return;
          }
          if (props['center'] || props['prjCenter']) {
              this.onMoveStart();
          }
          if (props['zoom'] && !this.isZooming()) {
              this.onZoomStart(props['zoom'][1], zoomOrigin);
          }
          if (props['pitch'] || props['bearing']) {
              this._animRotating = true;
          }
          /**
           * fired when map starts to animate (panning, zooming, rotating).
           *
           * @event Map#animatestart
           * @type {Object}
           * @property {String} type - animatestart
           * @property {Map} target - the map fires the event
           */
          this._fireEvent('animatestart');
          this._animPlayer.play();
      },
      //@internal
      _stopAnim: function (player) {
          if (!player) {
              return;
          }
          delete this._animRotating;
          if (player.playState !== 'finished') {
              player._interupted = true;
              player.cancel();
          }
          if (player === this._animPlayer) {
              delete this._animPlayer;
          }
          if (player === this._mapAnimPlayer) {
              delete this._mapAnimPlayer;
          }
          // this._resumePrev(player);
      },
      //@internal
      _resumePrev: function (player) {
          if (!this._prevAnimPlayer) {
              return;
          }
          var prevPlayer = this._prevAnimPlayer;
          if (prevPlayer.playState !== 'paused') {
              delete this._prevAnimPlayer;
          }
          if (player !== prevPlayer) {
              this._animPlayer = prevPlayer;
              prevPlayer.play();
          }
      }
  });
  function interpolate(a, b, t) {
      return (a * (1 - t)) + (b * t);
  }

  function dragEventHanlder(event) {
      event.stopPropagation();
      event.preventDefault();
  }
  var DRAGEVENTS = ['dragstart', 'dragenter', 'dragend', 'dragleave', 'dragover'].join(' ').toString();
  var events = 
  /**
   * mousedown event
   * @event Map#mousedown
   * @type {Object}
   * @property {String} type                    - mousedown
   * @property {Map} target            - the map fires event
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  'mousedown ' +
      /**
       * mouseup event
       * @event Map#mouseup
       * @type {Object}
       * @property {String} type                    - mouseup
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseup ' +
      /**
       * mouseover event
       * @event Map#mouseover
       * @type {Object}
       * @property {String} type                    - mouseover
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseover ' +
      /**
       * mouseout event
       * @event Map#mouseout
       * @type {Object}
       * @property {String} type                    - mouseout
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseout ' +
      /**
       * mouseenter event
       * @event Map#mouseenter
       * @type {Object}
       * @property {String} type                    - mouseenter
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseenter ' +
      /**
       * mouseleave event
       * @event Map#mouseleave
       * @type {Object}
       * @property {String} type                    - mouseleave
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseleave ' +
      /**
       * mousemove event
       * @event Map#mousemove
       * @type {Object}
       * @property {String} type                    - mousemove
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mousemove ' +
      /**
       * click event
       * @event Map#click
       * @type {Object}
       * @property {String} type                    - click
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'click ' +
      /**
       * dblclick event
       * @event Map#dblclick
       * @type {Object}
       * @property {String} type                    - dblclick
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'dblclick ' +
      /**
       * contextmenu event
       * @event Map#contextmenu
       * @type {Object}
       * @property {String} type                    - contextmenu
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'contextmenu ' +
      /**
       * keypress event
       * @event Map#keypress
       * @type {Object}
       * @property {String} type                    - keypress
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'keypress ' +
      /**
       * touchstart event
       * @event Map#touchstart
       * @type {Object}
       * @property {String} type                    - touchstart
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchstart ' +
      /**
       * touchmove event
       * @event Map#touchmove
       * @type {Object}
       * @property {String} type                    - touchmove
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchmove ' +
      /**
       * touchend event
       * @event Map#touchend
       * @type {Object}
       * @property {String} type                    - touchend
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchend ' +
      /**
       * drop event
       * @event Map#drop
       * @type {Object}
       * @property {String} type                    - drop
       * @property {Map} target            - the map fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'drop ';
  Map$1.include(/** @lends Map.prototype */ {
      //@internal
      _registerDomEvents: function () {
          var dom = this._panels.mapWrapper || this._containerDOM;
          addDomEvent(dom, events, this._handleDOMEvent, this);
          addDomEvent(dom, DRAGEVENTS, dragEventHanlder, this);
      },
      //@internal
      _removeDomEvents: function () {
          var dom = this._panels.mapWrapper || this._containerDOM;
          removeDomEvent(dom, events, this._handleDOMEvent);
          removeDomEvent(dom, DRAGEVENTS, dragEventHanlder);
      },
      //@internal
      _handleDOMEvent: function (e) {
          if (e && e.type === 'drop') {
              // https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API
              e.stopPropagation();
              e.preventDefault();
              var eventParam = this._parseEvent(e, e.type);
              eventParam = extend$2({}, eventParam, { dataTransfer: e.dataTransfer });
              this._fireEvent(e.type, eventParam);
              return;
          }
          var clickTimeThreshold = this.options['clickTimeThreshold'];
          var type = e.type;
          if (isMoveEvent(type) && !GlobalConfig.isTest && isMousemoveEventBlocked(this, this.options['mousemoveThrottleTime'])) {
              return;
          }
          var isMouseDown = type === 'mousedown' || (type === 'touchstart' && (!e.touches || e.touches.length === 1));
          // prevent default contextmenu
          if (isMouseDown) {
              this._domMouseDownTime = now();
              this._domMouseDownView = this.getView();
          }
          var isRotating = type === 'contextmenu' && isRotatingMap(this);
          if (type === 'contextmenu') {
              // prevent context menu, if duration from mousedown > 300ms
              preventDefault(e);
              var downTime = this._domMouseDownTime;
              var time = now();
              if (time - downTime <= clickTimeThreshold && !isRotating) {
                  this._fireDOMEvent(this, e, 'dom:' + e.type);
              }
          }
          else {
              this._fireDOMEvent(this, e, 'dom:' + e.type);
          }
          if (this._ignoreEvent(e) || this._isEventOutMap(e)) {
              return;
          }
          var mimicClick = false;
          // ignore click lasted for more than 300ms.
          // happen.js produce event without touches
          if (isMouseDown) {
              this._mouseDownTime = now();
          }
          else if ((type === 'click' || type === 'touchend' || type === 'contextmenu')) {
              if (!this._mouseDownTime) {
                  //mousedown | touchstart propogation is stopped
                  //ignore the click/touchend/contextmenu
                  return;
              }
              else {
                  var downTime = this._mouseDownTime;
                  delete this._mouseDownTime;
                  var time = now();
                  if (time - downTime > clickTimeThreshold) {
                      if (type === 'click' || type === 'contextmenu') {
                          return;
                      }
                  }
                  else if (type === 'contextmenu') {
                      if (isRotating) {
                          return;
                      }
                  }
                  else if (type === 'touchend') {
                      mimicClick = true;
                  }
              }
          }
          var mimicEvent;
          if (mimicClick) {
              if (this._clickTime && (now() - this._clickTime <= clickTimeThreshold)) {
                  delete this._clickTime;
                  mimicEvent = 'dblclick';
                  this._fireDOMEvent(this, e, 'dom:dblclick');
              }
              else {
                  this._clickTime = now();
                  mimicEvent = 'click';
                  this._fireDOMEvent(this, e, 'dom:click');
              }
          }
          if (this._ignoreEvent(e) || this._isEventOutMap(e)) {
              return;
          }
          this._fireDOMEvent(this, e, type);
          if (mimicEvent) {
              this._fireDOMEvent(this, e, mimicEvent);
          }
      },
      //@internal
      _ignoreEvent: function (domEvent) {
          //ignore events originated from control and ui doms.
          if (!domEvent || !this._panels.control) {
              return false;
          }
          // if (this._isEventOutMap(domEvent)) {
          //     return true;
          // }
          var target = domEvent.srcElement || domEvent.target;
          var preTarget;
          if (target) {
              while (target && target !== this._containerDOM) {
                  if (target.className && target.className.indexOf &&
                      (target.className.indexOf('maptalks-control') >= 0 || (target.className.indexOf('maptalks-ui') >= 0 && preTarget && !preTarget['eventsPropagation']))) {
                      return true;
                  }
                  preTarget = target;
                  target = target.parentNode;
              }
          }
          return false;
      },
      //@internal
      _isEventOutMap: function (domEvent) {
          if (this.getPitch() > this.options['maxVisualPitch']) {
              var actualEvent = this._getActualEvent(domEvent);
              var eventPos = getEventContainerPoint(actualEvent, this._containerDOM);
              if (!this.getContainerExtent().contains(eventPos)) {
                  return true;
              }
          }
          return false;
      },
      //@internal
      _wrapTerrainData: function (eventParam) {
          if (eventParam.containerPoint && !eventParam.terrain) {
              eventParam.terrain = this._queryTerrainInfo(eventParam.containerPoint);
          }
      },
      //@internal
      _parseEvent: function (e, type) {
          if (!e) {
              return null;
          }
          var eventParam = {
              'domEvent': e
          };
          if (type !== 'keypress') {
              var actual = this._getActualEvent(e);
              if (actual && actual.clientX !== undefined) {
                  var containerPoint = getEventContainerPoint(actual, this._containerDOM);
                  eventParam = extend$2(eventParam, {
                      'containerPoint': containerPoint,
                      'viewPoint': this.containerPointToViewPoint(containerPoint)
                  });
                  var maxVisualPitch = this.options['maxVisualPitch'];
                  // ignore coorindate out of visual extent
                  if (this.getPitch() <= maxVisualPitch || containerPoint.y >= (this.height - this._getVisualHeight(maxVisualPitch))) {
                      eventParam = extend$2(eventParam, {
                          'coordinate': this.containerPointToCoord(containerPoint),
                          'point2d': this._containerPointToPoint(containerPoint)
                      });
                  }
              }
          }
          this._wrapTerrainData(eventParam);
          return eventParam;
      },
      //@internal
      _parseEventFromCoord: function (coord) {
          var containerPoint = this.coordToContainerPoint(coord), viewPoint = this.containerPointToViewPoint(containerPoint);
          var e = {
              'coordinate': coord,
              'containerPoint': containerPoint,
              'viewPoint': viewPoint,
              'point2d': this.coordToPoint(coord)
          };
          return e;
      },
      //@internal
      _getActualEvent: function (e) {
          e = e;
          return e.touches && e.touches.length > 0 ?
              e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ?
              e.changedTouches[0] : e;
      },
      //@internal
      _fireDOMEvent: function (target, e, type) {
          var _this = this;
          if (this.isRemoved()) {
              return;
          }
          var eventParam = this._parseEvent(e, type);
          this._wrapTerrainData(eventParam);
          if (isMoveEvent(type)) {
              this.getRenderer().callInNextFrame(function () {
                  if (eventParam.domEvent && eventParam.domEvent._cancelBubble) {
                      // Always trigger _moumove _touchmove event
                      // for hit test etc
                      _this._fireEvent('_' + type, eventParam);
                      return;
                  }
                  _this._fireEvent(type, eventParam);
              });
          }
          else {
              this._fireEvent(type, eventParam);
          }
      },
      // _onKeyPress(e) {
      //     if (!this.isRemoved() && e.keyCode === 48 && e.ctrlKey) {
      //         this.setBearing(0);
      //     }
      // }
      // Extract _ geteventparams is reused in other plug-ins,such as maptalks.three plugin
      //@internal
      _getEventParams: function (e) {
          var map = this;
          var eventParam = {
              'domEvent': e
          };
          var actual = e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
          if (actual) {
              var containerPoint = getEventContainerPoint(actual, map.getContainer());
              eventParam['coordinate'] = map.containerPointToCoordinate(containerPoint);
              eventParam['containerPoint'] = containerPoint;
              eventParam['viewPoint'] = map.containerPointToViewPoint(containerPoint);
              eventParam['point2d'] = map._containerPointToPoint(containerPoint);
          }
          this._wrapTerrainData(eventParam);
          return eventParam;
      }
  });
  Map$1.addOnLoadHook('_registerDomEvents');
  function isRotatingMap(map) {
      if (!map._domMouseDownView) {
          return true;
      }
      var view = map.getView(), mouseDownView = map._domMouseDownView;
      return (view.bearing !== mouseDownView.bearing || view.pitch !== mouseDownView.pitch);
  }

  Map$1.include(/** @lends Map.prototype */ {
      /**
       * @return {Boolean} Element is currently in fullscreen.
       */
      isFullScreen: function () {
          var doc = document;
          return !!(doc.webkitIsFullScreen || doc.mozFullScreen ||
              doc.msFullscreenElement || doc.fullscreenElement);
      },
      /**
       * Request for the full screen
       * @property {Object} dom -containerDOM to requestFullScreen
       * @return {Map} this
       * @fires Map#fullscreenstart
       * @fires Map#fullscreenend
       */
      requestFullScreen: function (dom) {
          /**
           * fullscreenstart event
           * @event Map#fullscreenstart
           * @type {Object}
           * @property {String} type                    - fullscreenstart
           * @property {Map} target            - the map fires event
           */
          this._fireEvent('fullscreenstart');
          this._requestFullScreen(dom || this._containerDOM);
          /**
           * fullscreenend event
           * @event Map#fullscreenend
           * @type {Object}
           * @property {String} type                    - fullscreenend
           * @property {Map} target            - the map fires event
           */
          this._fireEvent('fullscreenend');
          return this;
      },
      /**
       * Cancel full screen
       * @return {Map} this
       * @fires Map#cancelfullscreen
       */
      cancelFullScreen: function () {
          this._cancelFullScreen();
          /**
           * cancelfullscreen event
           * @event Map#cancelfullscreen
           * @type {Object}
           * @property {String} type                    - cancelfullscreen
           * @property {Map} target            - the map fires event
           */
          this._fireEvent('cancelfullscreen');
          return this;
      },
      //@internal
      _requestFullScreen: function (dom) {
          if (dom.requestFullscreen) {
              dom.requestFullscreen();
          }
          else if (dom.mozRequestFullScreen) {
              dom.mozRequestFullScreen();
          }
          else if (dom.webkitRequestFullScreen) {
              dom.webkitRequestFullScreen();
          }
          else if (dom.msRequestFullScreen) {
              dom.msRequestFullScreen();
          }
          else {
              var features = 'fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,' +
                  'titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,' +
                  'width=' + (screen.availWidth - 8) + ',height=' + (screen.availHeight - 45);
              var newWin = window.open(location.href, '_blank', features);
              if (newWin !== null) {
                  window.opener = null;
                  //close parent window
                  window.close();
              }
          }
      },
      //@internal
      _cancelFullScreen: function () {
          var doc = document;
          if (document.exitFullscreen) {
              document.exitFullscreen();
          }
          else if (doc.mozCancelFullScreen) {
              doc.mozCancelFullScreen();
          }
          else if (doc.webkitCancelFullScreen) {
              doc.webkitCancelFullScreen();
          }
          else {
              var features = 'fullscreen=no,status=yes,resizable=yes,scrollbars=no,' +
                  'titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes';
              var newWin = window.open(location.href, '_blank', features);
              if (newWin !== null) {
                  window.opener = null;
                  //close parent window
                  window.close();
              }
          }
      }
  });

  Map$1.include(/** @lends Map.prototype */ {
      /**
       * Pan to the given coordinate
       * @param {Coordinate} coordinate - coordinate to pan to
       * @param {Object} [options=null] - pan options
       * @param {Boolean} [options.animation=null] - whether pan with animation
       * @param {Boolean} [options.duration=600] - pan animation duration
       * @return {Map} this
       */
      panTo: function (coordinate, options, step) {
          if (options === void 0) { options = {}; }
          if (!coordinate) {
              return this;
          }
          if (isFunction(options)) {
              step = options;
              options = {};
          }
          coordinate = new Coordinate(coordinate);
          if (typeof (options['animation']) === 'undefined' || options['animation']) {
              var prjCoord = this.getProjection().project(coordinate);
              return this._panAnimation(prjCoord, options['duration'], step);
          }
          else {
              this.setCenter(coordinate);
          }
          return this;
      },
      //@internal
      _panTo: function (prjCoord, options) {
          if (options === void 0) { options = {}; }
          if (typeof (options['animation']) === 'undefined' || options['animation']) {
              return this._panAnimation(prjCoord, options['duration']);
          }
          else {
              this.onMoveStart();
              this._setPrjCenter(prjCoord);
              this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
              return this;
          }
      },
      /**
       * Pan the map by the give point
       * @param  {Point} point - distance to pan, in pixel
       * @param {Object} [options=null] - pan options
       * @param {Boolean} [options.animation=null] - whether pan with animation
       * @param {Boolean} [options.duration=600] - pan animation duration
       * @return {Map} this
       */
      panBy: function (offset, options, step) {
          if (options === void 0) { options = {}; }
          if (!offset) {
              return this;
          }
          if (isFunction(options)) {
              step = options;
              options = {};
          }
          offset = new Point(offset);
          var containerExtent = this.getContainerExtent();
          var ymin = containerExtent.ymin;
          if (ymin > 0 && offset.y > 30) {
              //limit offset'y when tilted to max pitch
              var y = offset.y;
              offset.y = 30;
              offset.x = offset.x * 30 / y;
              console.warn('offset is limited to panBy when pitch is above maxPitch');
              // return this;
          }
          if (typeof (options['animation']) === 'undefined' || options['animation']) {
              offset = offset.multi(-1);
              // const point0 = this._prjToPoint(this._getPrjCenter());
              // const point1 =
              // point._add(offset.x, offset.y);
              // const target = this._pointToPrj(point);
              var target = this._containerPointToPrj(new Point(this.width / 2 + offset.x, this.height / 2 + offset.y));
              // const target = this.locateByPoint(this.getCenter(), offset.x, offset.y);
              this._panAnimation(target, options['duration'], step);
          }
          else {
              this.onMoveStart();
              this._offsetCenterByPixel(offset);
              var endCoord = this.containerPointToCoord(new Point(this.width / 2, this.height / 2));
              this.onMoveEnd(this._parseEventFromCoord(endCoord));
          }
          return this;
      },
      //@internal
      _panAnimation: function (target, t, cb) {
          return this._animateTo({
              'prjCenter': target
          }, {
              'duration': t || this.options['panAnimationDuration'],
          }, cb);
      }
  });

  /**
   * Methods of topo computations
   */
  Map$1.include(/** @lends Map.prototype */ {
      /**
       * Caculate distance of two coordinates.
       * @param {Number[]|Coordinate} coord1 - coordinate 1
       * @param {Number[]|Coordinate} coord2 - coordinate 2
       * @return {Number} distance, unit is meter
       * @example
       * var distance = map.computeLength([0, 0], [0, 20]);
       */
      computeLength: function (coord1, coord2) {
          if (!this.getProjection()) {
              return null;
          }
          var p1 = new Coordinate(coord1), p2 = new Coordinate(coord2);
          if (p1.equals(p2)) {
              return 0;
          }
          return this.getProjection().measureLength(p1, p2);
      },
      /**
       * Caculate a geometry's length.
       * @param {Geometry} geometry - geometry to caculate
       * @return {Number} length, unit is meter
       */
      computeGeometryLength: function (geometry) {
          return geometry._computeGeodesicLength(this.getProjection());
      },
      /**
       * Caculate a geometry's area.
       * @param  {Geometry} geometry - geometry to caculate
       * @return {Number} area, unit is sq.meter
       */
      computeGeometryArea: function (geometry) {
          return geometry._computeGeodesicArea(this.getProjection());
      },
      /**
       * Identify the geometries on the given coordinate.
       * @param {Object} opts - the identify options
       * @param {Coordinate} opts.coordinate - coordinate to identify
       * @param {Object}   opts.layers        - the layers to perform identify on.
       * @param {Function} [opts.filter=null] - filter function of the result geometries, return false to exclude.
       * @param {Number}   [opts.count=null]  - limit of the result count.
       * @param {Number}   [opts.tolerance=0] - identify tolerance in pixel.
       * @param {Boolean}  [opts.includeInternals=false] - whether to identify internal layers.
       * @param {Boolean}  [opts.includeInvisible=false] - whether to identify invisible layers.
       * @param {Function} callback           - the callback function using the result geometries as the parameter.
       * @return {Map} this
       * @example
       * map.identify({
       *      coordinate: [0, 0],
       *      layers: [layer]
       *  },
       *  geos => {
       *      console.log(geos);
       *  });
       */
      identify: function (opts, callback) {
          opts = (opts || {});
          var coordinate = new Coordinate(opts.coordinate);
          return this._identify(opts, callback, function (layer) { return layer.identify(coordinate, opts); });
      },
      /**
       * Identify the geometries on the given container point.
       * @param {Object} opts - the identify options
       * @param {Point} opts.containerPoint - container point to identify
       * @param {Object}   opts.layers        - the layers to perform identify on.
       * @param {Function} [opts.filter=null] - filter function of the result geometries, return false to exclude.
       * @param {Number}   [opts.count=null]  - limit of the result count.
       * @param {Number}   [opts.tolerance=0] - identify tolerance in pixel.
       * @param {Boolean}  [opts.includeInternals=false] - whether to identify internal layers.
       * @param {Boolean}  [opts.includeInvisible=false] - whether to identify invisible layers.
       * @param {Function} callback           - the callback function using the result geometries as the parameter.
       * @return {Map} this
       * @example
       * map.identifyAtPoint({
       *      containerPoint: [200, 300],
       *      layers: [layer]
       *  },
       *  geos => {
       *      console.log(geos);
       *  });
       */
      identifyAtPoint: function (opts, callback) {
          var isMapGeometryEvent = opts.includeInternals;
          var tolerance = opts.tolerance;
          opts = (opts || {});
          var containerPoint = new Point(opts['containerPoint']);
          var coordinate = this.containerPointToCoord(containerPoint);
          return this._identify(opts, callback, function (layer) {
              var result;
              var containerPoint = opts.containerPoint;
              if (isMapGeometryEvent && !isNil(layer.options.geometryEventTolerance)) {
                  opts.tolerance = opts.tolerance || 0;
                  opts.tolerance += layer.options.geometryEventTolerance;
              }
              if (layer._hasGeoListeners && isMapGeometryEvent && opts.eventTypes.indexOf('mousemove') >= 0) {
                  if (!layer._hasGeoListeners(opts.eventTypes)) {
                      return [];
                  }
              }
              if (layer.identifyAtPoint) {
                  result = layer.identifyAtPoint(containerPoint, opts);
              }
              else if (coordinate && layer.identify) {
                  result = layer.identify(coordinate, opts);
              }
              else {
                  result = [];
              }
              if (isMapGeometryEvent) {
                  if (isNil(tolerance)) {
                      delete opts.tolerance;
                  }
                  else {
                      opts.tolerance = tolerance;
                  }
              }
              //fire layer identify empty event
              if ((!result || !result.length)) {
                  layer.fire('identifyempty', opts);
                  //such as GroupGLLayer
                  if (layer.getLayers && isFunction(layer.getLayers)) {
                      var layers = (layer.getLayers() || []).filter(function (childLayer) {
                          return childLayer;
                      });
                      layers.forEach(function (childLayer) {
                          childLayer.fire('identifyempty', opts);
                      });
                  }
              }
              return result;
          });
      },
      //@internal
      _identify: function (opts, callback, fn) {
          var reqLayers = opts['layers'];
          if (!isArrayHasData(reqLayers)) {
              return this;
          }
          var eventTypes = opts.eventTypes;
          var layers = [];
          for (var i = 0, len = reqLayers.length; i < len; i++) {
              if (isString(reqLayers[i])) {
                  layers.push(this.getLayer(reqLayers[i]));
              }
              else {
                  layers.push(reqLayers[i]);
              }
          }
          if (eventTypes) {
              layers = layers.filter(function (layer) {
                  if (!layer._hasGeoListeners) {
                      return true;
                  }
                  return layer._hasGeoListeners(eventTypes);
              });
          }
          var hits = [];
          for (var i = layers.length - 1; i >= 0; i--) {
              if (opts['count'] && hits.length >= opts['count']) {
                  break;
              }
              var layer = layers[i];
              if (!layer || !layer.getMap() || (!opts['includeInvisible'] && !layer.isVisible()) || (!opts['includeInternals'] && layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0)) {
                  continue;
              }
              var layerHits = fn(layer);
              var layerId = layer.getId();
              if (layerHits) {
                  if (Array.isArray(layerHits)) {
                      for (var i_1 = 0; i_1 < layerHits.length; i_1++) {
                          if (layerHits[i_1] && !layerHits[i_1].getLayer && isNil(layerHits[i_1].layer)) {
                              layerHits[i_1].layer = layerId;
                          }
                      }
                      pushIn(hits, layerHits);
                  }
                  else {
                      if (!layerHits.getLayer && isNil(layerHits.layer)) {
                          layerHits.layer = layerId;
                      }
                      hits.push(layerHits);
                  }
              }
          }
          callback.call(this, hits);
          return this;
      }
  });

  Map$1.include(/** @lends Map.prototype */ {
      //@internal
      _zoom: function (nextZoom, origin) {
          if (!this.options['zoomable'] || this.isZooming()) {
              return;
          }
          origin = this._checkZoomOrigin(origin);
          nextZoom = this._checkZoom(nextZoom);
          this.onZoomStart(nextZoom, origin);
          this._frameZoom = this.getZoom();
          this.onZoomEnd(nextZoom, origin);
      },
      //@internal
      _zoomAnimation: function (nextZoom, origin, startScale) {
          if (!this.options['zoomable'] || this.isZooming()) {
              return;
          }
          nextZoom = this._checkZoom(nextZoom);
          if (this.getZoom() === nextZoom) {
              return;
          }
          origin = this._checkZoomOrigin(origin);
          this._startZoomAnim(nextZoom, origin, startScale);
      },
      //@internal
      _checkZoomOrigin: function (origin) {
          if (!origin || this.options['zoomInCenter']) {
              origin = new Point(this.width / 2, this.height / 2);
          }
          if (this.options['zoomOrigin']) {
              origin = new Point(this.options['zoomOrigin']);
          }
          return origin;
      },
      //@internal
      _startZoomAnim: function (nextZoom, origin, startScale) {
          if (isNil(startScale)) {
              startScale = 1;
          }
          var endScale = this._getResolution(this._startZoomVal) / this._getResolution(nextZoom);
          var duration = this.options['zoomAnimationDuration'] * Math.abs(endScale - startScale) / Math.abs(endScale - 1);
          this._frameZoom = this._startZoomVal;
          this._animateTo({
              'zoom': nextZoom,
              'around': origin
          }, {
              'continueOnViewChanged': true,
              'duration': duration
          });
      },
      onZoomStart: function (nextZoom, origin) {
          if (!this.options['zoomable'] || this.isZooming()) {
              return;
          }
          if (this._mapAnimPlayer) {
              this._stopAnim(this._mapAnimPlayer);
          }
          delete this.cameraZenithDistance;
          this._zooming = true;
          this._startZoomVal = this.getZoom();
          this._startZoomCoord = origin && this._containerPointToPrj(origin);
          /**
            * zoomstart event
            * @event Map#zoomstart
            * @type {Object}
            * @property {String} type                    - zoomstart
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - zoom level zooming from
            * @property {Number} to                      - zoom level zooming to
            */
          this._fireEvent('zoomstart', { 'from': this._startZoomVal, 'to': nextZoom });
      },
      onZooming: function (nextZoom, origin, startScale) {
          if (!this.options['zoomable']) {
              return;
          }
          var frameZoom = this._frameZoom;
          if (frameZoom === nextZoom) {
              return;
          }
          if (isNil(startScale)) {
              startScale = 1;
          }
          this._zoomTo(nextZoom, origin);
          var res = this.getResolution(nextZoom), fromRes = this.getResolution(this._startZoomVal), scale = fromRes / res / startScale, startPoint = this._startZoomCoord && this.prjToContainerPoint(this._startZoomCoord, this._startZoomVal);
          var offset = this.getViewPoint();
          if (!this.isRotating() && startPoint && !startPoint.equals(origin) && scale !== 1) {
              var pitch = this.getPitch();
              // coordinate at origin changed, usually by map.setCenter
              // add origin offset
              var originOffset = startPoint._sub(origin)._multi(1 / (1 - scale));
              if (pitch) {
                  //FIXME Math.cos(pitch * Math.PI / 180) is just a magic num, works when tilting but may have problem when rotating
                  originOffset.y /= Math.cos(pitch * Math.PI / 180);
              }
              origin = origin.add(originOffset);
          }
          var originX = origin && origin.x || this.width / 2;
          var originY = origin && origin.y || this.height / 2;
          var matrix = {
              'view': [scale, 0, 0, scale, (originX - offset.x) * (1 - scale), (originY - offset.y) * (1 - scale)]
          };
          var dpr = this.getDevicePixelRatio();
          matrix['container'] = [scale, 0, 0, scale, originX * dpr * (1 - scale), originY * dpr * (1 - scale)];
          /**
            * zooming event
            * @event Map#zooming
            * @type {Object}
            * @property {String} type                    - zooming
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - zoom level zooming from
            * @property {Number} to                      - zoom level zooming to
            */
          this._fireEvent('zooming', { 'from': this._startZoomVal, 'to': nextZoom, 'origin': new Point(originX, originY), 'matrix': matrix });
          this._frameZoom = nextZoom;
      },
      onZoomEnd: function (nextZoom, origin) {
          if (!this.options['zoomable']) {
              return;
          }
          var startZoomVal = this._startZoomVal;
          this._zoomTo(nextZoom, origin);
          this._zooming = false;
          this._getRenderer().onZoomEnd();
          if (!this._suppressRecenter) {
              this._recenterOnTerrain();
          }
          /**
            * zoomend event
            * @event Map#zoomend
            * @type {Object}
            * @property {String} type                    - zoomend
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - zoom level zooming from
            * @property {Number} to                      - zoom level zooming to
            */
          this._fireEvent('zoomend', { 'from': startZoomVal, 'to': nextZoom });
          if (!this._verifyExtent(this._getPrjCenter()) && !this.options.limitExtentOnMaxExtent) {
              this._panTo(this._prjMaxExtent.getCenter());
          }
      },
      //@internal
      _zoomTo: function (nextZoom, origin) {
          this._zoomLevel = nextZoom;
          this._calcMatrices();
          if (origin && this._startZoomCoord) {
              var p = this._containerPointToPoint(origin);
              var offset = p._sub(this._prjToPoint(this._getPrjCenter()));
              this._setPrjCoordAtOffsetToCenter(this._startZoomCoord, offset);
          }
      },
      //@internal
      _checkZoom: function (nextZoom) {
          var maxZoom = this.getMaxZoom(), minZoom = this.getMinZoom();
          if (nextZoom < minZoom) {
              nextZoom = minZoom;
          }
          if (nextZoom > maxZoom) {
              nextZoom = maxZoom;
          }
          return nextZoom;
      }
  });

  /**
   * Set the components of a vec3 to the given values
   * @ignore
   * @param out the receiving vector
   * @param x X component
   * @param y Y component
   * @param z Z component
   * @returns out
   */
  function set(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
  }
  /**
   * Adds two vec3's
   * @ignore
   * @param out the receiving vector
   * @param a the first operand
   * @param b the second operand
   * @returns out
   */
  function add(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out;
  }
  /**
   * Subtracts vector b from vector a
   * @ignore
   * @param out the receiving vector
   * @param a the first operand
   * @param b the second operand
   * @returns out
   */
  function subtract(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out;
  }
  /**
   * Calculates the length of a vec3
   * @ignore
   * @param a vector to calculate length of
   * @returns length of a
   */
  function length(a) {
      var x = a[0], y = a[1], z = a[2];
      return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Normalize a vec3
   * @ignore
   * @param out the receiving vector
   * @param a vector to normalize
   * @returns out
   */
  function normalize(out, a) {
      var x = a[0], y = a[1], z = a[2];
      var len = x * x + y * y + z * z;
      if (len > 0) {
          //TODO: evaluate use of glm_invsqrt here?
          len = 1 / Math.sqrt(len);
          out[0] = a[0] * len;
          out[1] = a[1] * len;
          out[2] = a[2] * len;
      }
      return out;
  }
  /**
   * Calculates the dot product of two vec3's
   * @ignore
   * @param a the first operand
   * @param b the second operand
   * @returns dot product of a and b
   */
  function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Scales a vec3 by a scalar number
   * @ignore
   * @param out the receiving vector
   * @param a the vector to scale
   * @param b amount to scale the vector by
   * @returns out
   */
  function scale(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      return out;
  }
  /**
   * Computes the cross product of two vec3's
   * @ignore
   * @param out the receiving vector
   * @param a the first operand
   * @param b the second operand
   * @returns out
   */
  function cross(out, a, b) {
      var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   * @ignore
   * @param a the first operand
   * @param b the second operand
   * @returns distance between a and b
   */
  function distance(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      var z = b[2] - a[2];
      return Math.hypot ? Math.hypot(x, y, z) : hypot(x, y, z);
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @ignore
   * @param out the receiving vector
   * @param a the vector to transform
   * @param m matrix to transform with
   * @returns out
   */
  function transformMat4(out, a, m) {
      var x = a[0], y = a[1], z = a[2];
      var w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1.0;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
  }
  function hypot() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var y = 0;
      var i = args.length;
      while (i--)
          y += args[i] * args[i];
      return Math.sqrt(y);
  }
  function angle(a, b) {
      normalize(a, a);
      normalize(b, b);
      var cosine = dot(a, b);
      if (cosine > 1.0) {
          return 0;
      }
      else if (cosine < -1.0) {
          return Math.PI;
      }
      else {
          return Math.acos(cosine);
      }
  }

  //contains code from THREE.js
  function applyMatrix(out, v, e) {
      var x = v[0], y = v[1], z = v[2];
      // const e = in;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      out[0] = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      out[1] = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      out[2] = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return out;
  }
  function matrixToQuaternion(out, te) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      var m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
      var s;
      if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          out.w = 0.25 / s;
          out.x = (m32 - m23) * s;
          out.y = (m13 - m31) * s;
          out.z = (m21 - m12) * s;
      }
      else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          out.w = (m32 - m23) / s;
          out.x = 0.25 * s;
          out.y = (m12 + m21) / s;
          out.z = (m13 + m31) / s;
      }
      else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          out.w = (m13 - m31) / s;
          out.x = (m12 + m21) / s;
          out.y = 0.25 * s;
          out.z = (m23 + m32) / s;
      }
      else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          out.w = (m21 - m12) / s;
          out.x = (m13 + m31) / s;
          out.y = (m23 + m32) / s;
          out.z = 0.25 * s;
      }
      return this;
  }
  function quaternionToMatrix(out, q) {
      var te = out;
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x, y2 = y + y, z2 = z + z;
      var xx = x * x2, xy = x * y2, xz = x * z2;
      var yy = y * y2, yz = y * z2, zz = z * z2;
      var wx = w * x2, wy = w * y2, wz = w * z2;
      te[0] = 1 - (yy + zz);
      te[4] = xy - wz;
      te[8] = xz + wy;
      te[1] = xy + wz;
      te[5] = 1 - (xx + zz);
      te[9] = yz - wx;
      te[2] = xz - wy;
      te[6] = yz + wx;
      te[10] = 1 - (xx + yy);
      // last column
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      // bottom row
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return te;
  }
  function setPosition(out, v) {
      var te = out;
      te[12] = v[0];
      te[13] = v[1];
      te[14] = v[2];
      return out;
  }
  function lookAt(te, eye, target, up) {
      var x = [0, 0, 0];
      var y = [0, 0, 0];
      var z = [0, 0, 0];
      subtract(z, eye, target);
      if (length(z) === 0) {
          // eye and target are in the same position
          z[2] = 1;
      }
      normalize(z, z);
      cross(x, up, z);
      if (length(z) === 0) {
          // up and z are parallel
          if (Math.abs(up[2]) === 1) {
              z[0] += 0.0001;
          }
          else {
              z[2] += 0.0001;
          }
          normalize(z, z);
          cross(x, up, z);
      }
      normalize(x, x);
      cross(y, z, x);
      te[0] = x[0];
      te[4] = y[0];
      te[8] = z[0];
      te[1] = x[1];
      te[5] = y[1];
      te[9] = z[1];
      te[2] = x[2];
      te[6] = y[2];
      te[10] = z[2];
      return te;
  }

  var RADIAN = Math.PI / 180;
  var DEFAULT_FOV = 0.6435011087932844;
  var TEMP_COORD$1 = new Coordinate(0, 0);
  var TEMP_POINT$4 = new Point(0, 0);
  var SOUTH = [0, -1, 0], BEARING = [];
  var altitudesHasData = function (altitudes) {
      if (isNumber(altitudes)) {
          return altitudes !== 0;
      }
      else if (Array.isArray(altitudes) && altitudes.length > 0) {
          for (var i = 0, len = altitudes.length; i < len; i++) {
              if (isNumber(altitudes[i]) && altitudes[i] !== 0) {
                  return true;
              }
          }
      }
      return false;
  };
  /*!
   * contains code from mapbox-gl-js
   * https://github.com/mapbox/mapbox-gl-js
   * LICENSE : MIT
   * (c) mapbox
   *
   */
  Map$1.include(/** @lends Map.prototype */ {
      /**
       * Get map's fov (field of view);
       * @return {Number} fov in degree
       */
      getFov: function () {
          if (!this._fov) {
              this._fov = DEFAULT_FOV;
          }
          return this._fov / RADIAN;
      },
      /**
       * Set a new fov to map
       * @param {Number} fov new fov in degree
       * @return {Map} this
       */
      setFov: function (fov) {
          if (this.isZooming()) {
              return this;
          }
          fov = Math.max(0.01, Math.min(60, fov));
          if (this._fov === fov)
              return this;
          var from = this.getFov();
          this._fov = fov * RADIAN;
          this._calcMatrices();
          this._renderLayers();
          /*
            * fovchange event
            * @event Map#fovchange
            * @type {Object}
            * @property {String} type                    - fovchange
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - fovchange from
            * @property {Number} to                      - fovchange to
          */
          this._fireEvent('fovchange', { 'from': from, 'to': this.getFov() });
          return this;
      },
      /**
       * Get map's bearing
       * @return {Number} bearing in degree
       */
      getBearing: function () {
          if (!this._angle) {
              return 0;
          }
          return -this._angle / RADIAN;
      },
      /**
       * Set a new bearing to map
       * @param {Number} bearing new bearing in degree
       * @return {Map} this
       */
      setBearing: function (bearing) {
          var view = { bearing: bearing };
          this._validateView(view);
          if (this._mapAnimPlayer) {
              this._stopAnim(this._mapAnimPlayer);
          }
          return this._setBearing(view.bearing);
      },
      //@internal
      _setBearing: function (bearing) {
          if (Browser$1.ie9) {
              throw new Error('map can\'t rotate in IE9.');
          }
          var b = -wrap(bearing, -180, 180) * RADIAN;
          if (this._angle === b)
              return this;
          var from = this.getBearing();
          /*
            * rotate event
            * @event Map#rotatestart
            * @type {Object}
            * @property {String} type                    - rotatestart
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - bearing rotate from
            * @property {Number} to                      - bearing rotate to
          */
          this._fireEvent('rotatestart', { 'from': from, 'to': b });
          this._angle = b;
          this._calcMatrices();
          this._renderLayers();
          /*
            * rotate event, alias of rotateend, deprecated
            *
            * @event Map#rotate
            * @type {Object}
            * @property {String} type                    - rotate
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - bearing rotate from
            * @property {Number} to                      - bearing rotate to
          */
          this._fireEvent('rotate', { 'from': from, 'to': b });
          /*
            * rotateend event
            * @event Map#rotateend
            * @type {Object}
            * @property {String} type                    - rotateend
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - bearing rotate from
            * @property {Number} to                      - bearing rotate to
          */
          this._fireEvent('rotateend', { 'from': from, 'to': b });
          return this;
      },
      /**
       * Get map's pitch
       * @return {Number} pitch in degree
       */
      getPitch: function () {
          if (!this._pitch) {
              return 0;
          }
          return this._pitch / Math.PI * 180;
      },
      /**
       * Set a new pitch to map
       * @param {Number} pitch new pitch in degree
       * @return {Map} this
       */
      setPitch: function (pitch) {
          var view = { pitch: pitch };
          this._validateView(view);
          if (this._mapAnimPlayer) {
              this._stopAnim(this._mapAnimPlayer);
          }
          return this._setPitch(view.pitch);
      },
      //@internal
      _setPitch: function (pitch) {
          if (Browser$1.ie9) {
              throw new Error('map can\'t tilt in IE9.');
          }
          var p = clamp(pitch, 0, this.options['maxPitch']) * RADIAN;
          if (this._pitch === p)
              return this;
          var from = this.getPitch();
          /*
            * rotate event
            * @event Map#pitchstart
            * @type {Object}
            * @property {String} type                    - pitchstart
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - pitch from
            * @property {Number} to                      - pitch to
          */
          this._fireEvent('pitchstart', { 'from': from, 'to': p });
          this._pitch = p;
          this._calcMatrices();
          this._renderLayers();
          /**
            * pitch event, alias of pitchend, deprecated
            * @event Map#pitch
            * @type {Object}
            * @property {String} type                    - pitch
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - pitch from
            * @property {Number} to                      - pitch to
            */
          this._fireEvent('pitch', { 'from': from, 'to': p });
          /**
            * pitchend event
            * @event Map#pitchend
            * @type {Object}
            * @property {String} type                    - pitchend
            * @property {Map} target                     - the map fires event
            * @property {Number} from                    - pitchend from
            * @property {Number} to                      - pitchend to
            */
          this._fireEvent('pitchend', { 'from': from, 'to': p });
          return this;
      },
      /**
       * set camera movements
       * @param {Array} frameOptions
       * [{ center: [114, 32], zoom: 14, pitch: 45, bearing: 90, timestamp: 0 }]
       * @param {Object} extraOptions
       * { autoRotate: true }
       */
      setCameraMovements: function (frameOptions, extraOptions) {
          var _this = this;
          if (!Array.isArray(frameOptions) || !frameOptions.length) {
              return this;
          }
          frameOptions.forEach(function (frameOption) {
              _this._validateView(frameOption);
          });
          this.setView({
              center: frameOptions[0].center,
              zoom: frameOptions[0].zoom,
              pitch: frameOptions[0].pitch,
              bearing: frameOptions[0].bearing
          });
          if (frameOptions.length === 1)
              return this;
          var index = 1;
          var onFrame = function (frame) {
              if (frame.state.playState === 'finished') {
                  index++;
                  if (index === frameOptions.length - 1)
                      onFrame = null;
                  var frameOption = frameOptions[index];
                  frameOption.duration = frameOption.timestamp - frameOptions[index - 1].timestamp;
                  if (extraOptions && extraOptions.autoRotate) {
                      frameOption.bearing = calculateBearing(frameOptions[index - 1].center, frameOption.center);
                  }
                  _this._setCameraMovement(frameOption, onFrame);
              }
          };
          if (frameOptions.length === 2)
              onFrame = null;
          var currentBearing = this.getBearing();
          this._setCameraMovement(__assign({ bearing: currentBearing, duration: frameOptions[index].timestamp - frameOptions[index - 1].timestamp }, frameOptions[index]), onFrame);
          var play = function () {
              _this._animPlayer.play();
          };
          var pause = function () {
              _this._animPlayer.pause();
          };
          var cancel = function () {
              _this._animPlayer.cancel();
          };
          var finish = function () {
              _this._animPlayer.finish();
          };
          var reverse = function () {
              _this._animPlayer.reverse();
          };
          return {
              play: play,
              pause: pause,
              cancel: cancel,
              finish: finish,
              reverse: reverse
          };
      },
      //@internal
      _setCameraMovement: function (frameOption, frame) {
          this.animateTo({
              zoom: frameOption.zoom,
              center: frameOption.center,
              pitch: frameOption.pitch,
              bearing: frameOption.bearing
          }, {
              duration: frameOption.duration,
              easing: 'out'
          }, frame);
      },
      /**
       * Set camera's orientation
       * @param {Object}   options - options
       * @param {Coordinate | Array}  options.position  - position of the camera.
       * @param {Number}   [options.pitch = 0]  - pitch of the camera
       * @param {Number}   [options.bearing = 0]  - bearing of the camera
       * @returns {Map} this
       */
      setCameraOrientation: function (params) {
          var position = params.position;
          var pitch = params.pitch, bearing = params.bearing;
          this._validateView(params);
          pitch = pitch || 0;
          bearing = bearing || 0;
          var _a = this.getFitZoomForCamera(position, pitch), zoom = _a.zoom, cameraToGroundDistance = _a.cameraToGroundDistance;
          var dist = Math.sin((pitch) * RADIAN) * cameraToGroundDistance;
          var wrapBearing = wrap(bearing, -180, 180);
          var bearingRadian = wrapBearing * RADIAN;
          var glRes = this.getGLRes();
          var tempCoord = new Coordinate(position[0], position[1]);
          var tempPoint = this.coordToPointAtRes(tempCoord, glRes);
          var point = new Point(0, 0);
          point.x = tempPoint.x + dist * Math.sin(bearingRadian);
          point.y = tempPoint.y + dist * Math.cos(bearingRadian);
          var prjCenter = this._pointToPrjAtRes(point, this.getGLRes());
          this._setPrjCenter(prjCenter);
          this.setView({
              bearing: bearing,
              pitch: pitch,
              zoom: zoom
          });
          return this;
      },
      //设置相机的坐标, 根据地图中心点和相机位置，反算地图的bearing、pitch、zoom
      /**
       * Set camera's position
       * @param {Coordinate}   coordinate - camera's position
       * @returns {Map} this
       */
      setCameraPosition: function (coordinate) {
          var glRes = this.getGLRes();
          var cameraPoint = this.coordToPointAtRes(coordinate, glRes);
          cameraPoint.z = this.altitudeToPoint(coordinate.z || 0, glRes);
          var center = this.getCenter();
          var centerPoint = this.coordToPointAtRes(center, glRes);
          centerPoint.z = this.altitudeToPoint(center.z, glRes);
          var direction = subtract([], cameraPoint.toArray(), centerPoint.toArray());
          set(this.cameraUp || [0, 0, 0], 0, 0, 1);
          this._pitch = angle(direction, this.cameraUp);
          set(BEARING, direction[0], direction[1], 0);
          this._angle = -angle(BEARING, SOUTH);
          this._zoomLevel = this.getFitZoomForCamera(coordinate, this._pitch).zoom;
          this._calcMatrices();
      },
      getFitZoomForCamera: function (cameraPosition, pitch) {
          var z = Array.isArray(cameraPosition) ? cameraPosition[2] : cameraPosition.z;
          var cameraAltitude = z * this._meterToGLPoint;
          var centerAltitude = this.centerAltitude || 0;
          var centerPointZ = centerAltitude * this._meterToGLPoint;
          var cz = cameraAltitude - centerPointZ;
          var pitchRadian = pitch * RADIAN;
          var cameraToGroundDistance = cz / Math.cos(pitchRadian);
          var cameraToCenterDistance = cameraToGroundDistance + centerPointZ;
          var zoom = this.getFitZoomForAltitude(cameraToCenterDistance);
          return { zoom: zoom, cameraToGroundDistance: cameraToGroundDistance };
      },
      getFitZoomForAltitude: function (distance) {
          var ratio = this._getFovRatio();
          var scale = distance * ratio * 2 / (this.height || 1) * this.getGLRes();
          var resolutions = this._getResolutions();
          var z = 0;
          for (z; z < resolutions.length - 1; z++) {
              if (resolutions[z] === scale) {
                  return z;
              }
              else if (resolutions[z + 1] === scale) {
                  return z + 1;
              }
              else if (scale < resolutions[z] && scale > resolutions[z + 1]) {
                  z = (scale - resolutions[z]) / (resolutions[z + 1] - resolutions[z]) + z;
                  return z - 1;
              }
              else {
                  continue;
              }
          }
          return z;
      },
      /**
       * Whether the map is rotating or tilting.
       * @return {Boolean}
       * @private
       */
      isTransforming: function () {
          return !!(this._pitch || this._angle);
      },
      getFrustumAltitude: function () {
          return this._frustumAltitude;
      },
      //@internal
      _calcFrustumAltitude: function () {
          var pitch = 90 - this.getPitch();
          var fov = this.getFov() / 2;
          var cameraAlt = this.cameraPosition ? this.cameraPosition[2] : 0;
          if (fov <= pitch) {
              return cameraAlt;
          }
          fov = Math.PI * fov / 180;
          var d1 = new Point(this.cameraPosition).distanceTo(new Point(this.cameraLookAt)), d2 = cameraAlt * Math.tan(fov * 2);
          var d = Math.tan(fov) * (d1 + d2);
          return cameraAlt + d;
      },
      /**
       * Convert 2d point at target zoom to containerPoint at current zoom
       * @param  {Point} point 2d point at target zoom
       * @param  {Number} zoom  point's zoom
       * @param  {Number} [altitude=0]  target's altitude in 2d point system at target zoom
       * @return {Point}       containerPoint at current zoom
       * @private
       * @function
       */
      //@internal
      _pointToContainerPoint: function (point, zoom, altitude, out) {
          if (altitude === void 0) { altitude = 0; }
          var res = this._getResolution(zoom);
          return this._pointAtResToContainerPoint(point, res, altitude, out);
      },
      //@internal
      _pointAtResToContainerPoint: function (point, res, altitude, out) {
          if (altitude === void 0) { altitude = 0; }
          if (!out) {
              out = new Point(0, 0);
          }
          point = this._pointAtResToPoint(point, res, out);
          var isTransforming = this.isTransforming();
          var centerPoint;
          if (!isTransforming && !altitude) {
              centerPoint = this._prjToPoint(this._getPrjCenter(), undefined, TEMP_COORD$1);
          }
          this._toContainerPoint(out, isTransforming, altitude, centerPoint);
          return out;
      },
      /**
       *Batch conversion for better performance
       */
      //@internal
      _pointsAtResToContainerPoints: function (points, targetRes, altitudes, resultPoints) {
          if (altitudes === void 0) { altitudes = []; }
          if (resultPoints === void 0) { resultPoints = []; }
          var pitch = this.getPitch(), bearing = this.getBearing();
          var scale = targetRes / this._getResolution();
          if (pitch === 0 && bearing === 0 && !altitudesHasData(altitudes)) {
              var _a = this.get2DExtent(), xmin = _a.xmin, ymin = _a.ymin, xmax = _a.xmax, ymax = _a.ymax;
              if (xmax > xmin && ymax > ymin) {
                  var _b = this.getSize(), width = _b.width, height = _b.height;
                  var dxPerPixel = (xmax - xmin) / width, dyPerPixel = (ymax - ymin) / height;
                  for (var i = 0, len = points.length; i < len; i++) {
                      if (!points[i]) {
                          resultPoints[i] = null;
                          continue;
                      }
                      var pt = resultPoints[i];
                      pt.x = points[i].x;
                      pt.y = points[i].y;
                      pt._multi(scale);
                      pt.x = (pt.x - xmin) * dxPerPixel;
                      pt.y = height - (pt.y - ymin) * dyPerPixel;
                  }
                  return resultPoints;
              }
          }
          var altitudeIsArray = Array.isArray(altitudes);
          var isTransforming = this.isTransforming();
          var centerPoint = this._prjToPoint(this._getPrjCenter(), undefined, TEMP_COORD$1);
          for (var i = 0, len = points.length; i < len; i++) {
              if (!points[i]) {
                  resultPoints[i] = null;
                  continue;
              }
              var pt = resultPoints[i];
              pt.x = points[i].x;
              pt.y = points[i].y;
              pt._multi(scale);
              var altitude = altitudeIsArray ? (altitudes[i] || 0) : altitudes;
              this._toContainerPoint(pt, isTransforming, altitude, centerPoint);
          }
          return resultPoints;
      },
      //@internal
      _toContainerPoint: function () {
          var a = [0, 0, 0];
          return function (out, isTransforming, altitude, centerPoint) {
              var w2 = this.width / 2, h2 = this.height / 2;
              if (isTransforming || altitude) {
                  if (!this._altitudeScale) {
                      this._altitudeScale = this.altitudeToPoint(100, this.getGLRes()) / 100;
                  }
                  var scale_1 = this._glScale;
                  set(a, out.x * scale_1, out.y * scale_1, altitude * this._altitudeScale);
                  var t = this._projIfBehindCamera(a, this.cameraPosition, this.cameraForward);
                  applyMatrix(t, t, this.projViewMatrix);
                  out.x = (t[0] * w2) + w2;
                  out.y = -(t[1] * h2) + h2;
              }
              else {
                  out._sub(centerPoint.x, centerPoint.y);
                  out.set(out.x, -out.y);
                  out._add(w2, h2);
              }
          };
      }(),
      // https://forum.unity.com/threads/camera-worldtoscreenpoint-bug.85311/#post-2121212
      //@internal
      _projIfBehindCamera: function () {
          var vectorFromCam = new Array(3);
          var proj = new Array(3);
          var sub = new Array(3);
          return function (position, cameraPos, camForward) {
              subtract(vectorFromCam, position, cameraPos);
              var camNormDot = dot(camForward, vectorFromCam);
              if (camNormDot <= 0) {
                  scale(proj, camForward, camNormDot * 1.01);
                  add(position, cameraPos, subtract(sub, vectorFromCam, proj));
              }
              return position;
          };
      }(),
      /**
       * Convert containerPoint at current zoom to 2d point at target zoom
       * from mapbox-gl-js
       * @param  {Point} p    container point at current zoom
       * @param  {Number} zoom target zoom, current zoom in default
       * @return {Point}      2d point at target zoom
       * @private
       * @function
       */
      //@internal
      _containerPointToPoint: function (p, zoom, out, height) {
          var res = this._getResolution(zoom);
          return this._containerPointToPointAtRes(p, res, out, height);
      },
      //@internal
      _containerPointToPointAtRes: function () {
          var cp = [0, 0, 0], coord0 = [0, 0, 0, 1], coord1 = [0, 0, 0, 1];
          return function (p, res, out, height) {
              if (this.isTransforming()) {
                  var w2 = this.width / 2 || 1, h2 = this.height / 2 || 1;
                  set(cp, (p.x - w2) / w2, (h2 - p.y) / h2, 0);
                  set(coord0, cp[0], cp[1], 0);
                  set(coord1, cp[0], cp[1], 1);
                  coord0[3] = coord1[3] = 1;
                  applyMatrix(coord0, coord0, this.projViewMatrixInverse);
                  applyMatrix(coord1, coord1, this.projViewMatrixInverse);
                  var x0 = coord0[0];
                  var x1 = coord1[0];
                  var y0 = coord0[1];
                  var y1 = coord1[1];
                  var z0 = coord0[2];
                  var z1 = coord1[2];
                  //container plane maybe has height, although it is 0 in most cases.
                  var altitudePoint = !height ? 0 : this.altitudeToPoint(height, res) * this._glScale;
                  var t = z0 === z1 ? altitudePoint : (altitudePoint - z0) / (z1 - z0);
                  var x_1 = interpolate$3(x0, x1, t);
                  var y_1 = interpolate$3(y0, y1, t);
                  if (out) {
                      out.x = x_1;
                      out.y = y_1;
                  }
                  else {
                      out = new Point(x_1, y_1);
                  }
                  out._multi(1 / this._glScale);
                  return ((this._getResolution() === res) ? out : this._pointToPointAtRes(out, res, out));
              }
              var centerPoint = this._prjToPointAtRes(this._getPrjCenter(), res, out), scale = this._getResolution() / res;
              var x = scale * (p.x - this.width / 2), y = scale * (p.y - this.height / 2);
              return centerPoint._add(x, -y);
          };
      }(),
      /**
       * GL Matrices in maptalks (based on THREE):
       * //based on point at map's gl world space, by map.coordToPointAtRes(coord, map.getGLRes()))
       * map.cameraPosition
       * map.cameraLookAt
       * map.cameraUp       //camera's up vector
       * map.cameraForward  //camera's forward vector
       * map.cameraWorldMatrix
       * map.projMatrix
       * map.viewMatrix = cameraWorldMatrix.inverse()
       * map.projViewMatrix = projMatrix * viewMatrix
       * map.projViewMatrixInverse = projViewMatrix.inverse()
       *  @private
       */
      //@internal
      _calcMatrices: function () {
          // closure matrixes to reuse
          var m1 = createMat4();
          return function () {
              //必须先删除缓存的常用值，否则后面计算常用值时，会循环引用造成错误
              delete this._mapRes;
              delete this._mapGlRes;
              delete this._mapExtent2D;
              delete this._mapGlExtent2D;
              var size = this.getSize();
              var w = size.width || 1, h = size.height || 1;
              this._glScale = this.getGLScale();
              // const pitch = this.getPitch() * Math.PI / 180;
              // camera world matrix
              var worldMatrix = this._getCameraWorldMatrix();
              // get field of view
              var fov = this.getFov() * Math.PI / 180;
              var farZ = this._getCameraFar(fov, this.getPitch());
              this.cameraFar = farZ;
              this.cameraNear = this.cameraCenterDistance / 20;
              // camera projection matrix
              var projMatrix = this.projMatrix || createMat4();
              perspective(projMatrix, fov, w / h, this.cameraNear, farZ);
              this.projMatrix = projMatrix;
              // view matrix
              this.viewMatrix = invert(this.viewMatrix || createMat4(), worldMatrix);
              // matrix for world point => screen point
              this.projViewMatrix = multiply(this.projViewMatrix || createMat4(), projMatrix, this.viewMatrix);
              this._calcCascadeMatrixes();
              // matrix for screen point => world point
              this.projViewMatrixInverse = multiply(this.projViewMatrixInverse || createMat4(), worldMatrix, invert(m1, projMatrix));
              this.domCssMatrix = this._calcDomMatrix();
              this._frustumAltitude = this._calcFrustumAltitude();
              //缓存常用的值
              this._mapRes = this._getResolution();
              this._mapGlRes = this.getGLRes();
              this._mapExtent2D = this.get2DExtent();
              this._mapGlExtent2D = this.get2DExtentAtRes(this._mapGlRes);
          };
      }(),
      //@internal
      _getCameraFar: function (fov, pitch) {
          var cameraCenterDistance = this.cameraCenterDistance = distance(this.cameraPosition, this.cameraLookAt);
          var distanceInMeter = cameraCenterDistance / this._meterToGLPoint;
          pitch = pitch * Math.PI / 180;
          var cameraFarDistance = distanceInMeter + this.options['cameraFarUndergroundInMeter'] / Math.cos(pitch);
          return Math.max(cameraFarDistance * this._meterToGLPoint, cameraCenterDistance * 5);
      },
      //@internal
      _calcCascadeMatrixes: function () {
          // const cameraLookAt = [];
          // const cameraPosition = [];
          // const cameraUp = [];
          // const cameraForward = [];
          // const cameraWorldMatrix = createMat4();
          var projMatrix = createMat4();
          // const viewMatrix = createMat4();
          function cal(curPitch, pitch, out) {
              var w = this.width;
              var h = this.height;
              var fov = this.getFov() * Math.PI / 180;
              // const worldMatrix = this._getCameraWorldMatrix(
              //     pitch, this.getBearing(),
              //     cameraLookAt, cameraPosition, cameraUp, cameraForward, cameraWorldMatrix
              // );
              // get field of view
              var farZ = this._getCameraFar(fov, pitch);
              var cameraCenterDistance = this.cameraCenterDistance;
              farZ = cameraCenterDistance + (farZ - cameraCenterDistance) / Math.cos((90 - pitch) * Math.PI / 180) * Math.cos((90 - curPitch) * Math.PI / 180);
              // camera projection matrix
              perspective(projMatrix, fov, w / h, 0.1, farZ);
              // view matrix
              // mat4.invert(viewMatrix, worldMatrix);
              var viewMatrix = this.viewMatrix;
              // matrix for world point => screen point
              return multiply(out, projMatrix, viewMatrix);
          }
          return function () {
              var pitch = this.getPitch();
              var cascadePitch0 = this.options['cascadePitches'][0];
              var cascadePitch1 = this.options['cascadePitches'][1];
              var projViewMatrix0 = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || createMat4();
              var projViewMatrix1 = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || createMat4();
              if (pitch > cascadePitch0) {
                  cal.call(this, pitch, cascadePitch0, projViewMatrix0);
              }
              else {
                  copy(this.cascadeFrustumMatrix0, this.projViewMatrix);
              }
              if (pitch > cascadePitch1) {
                  cal.call(this, pitch, cascadePitch1, projViewMatrix1);
              }
              else {
                  copy(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0);
              }
          };
      }(),
      //@internal
      _calcDomMatrix: function () {
          var m = createMat4(), m1 = createMat4(), minusY = [1, -1, 1], arr = [0, 0, 0];
          return function () {
              var width = this.width || 1;
              var height = this.height || 1;
              var cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * height;
              scale$1(m, this.projMatrix, minusY);
              translate(m, m, set(arr, 0, 0, -cameraToCenterDistance)); //[0, 0, cameraToCenterDistance]
              if (this._pitch) {
                  rotateX(m, m, this._pitch);
              }
              if (this._angle) {
                  rotateZ(m, m, this._angle);
              }
              identity$1(m1);
              scale$1(m1, m1, set(arr, width / 2, -height / 2, 1)); //[this.width / 2, -this.height / 2, 1]
              return multiply(this.domCssMatrix || createMat4(), m1, m);
          };
      }(),
      //@internal
      _getFovZ: function (zoom) {
          var scale = this.getGLScale(zoom);
          var ratio = this._getFovRatio();
          return scale * (this.height || 1) / 2 / ratio;
      },
      //@internal
      _getCameraWorldMatrix: function () {
          var q = {};
          return function () {
              var glRes = this.getGLRes();
              if (!this._meterToGLPoint) {
                  this._meterToGLPoint = this.distanceToPointAtRes(100, 0, glRes).x / 100;
              }
              var center2D = this._prjToPointAtRes(this._prjCenter, glRes, TEMP_POINT$4);
              var altitude = this.getCenter().z;
              var centerAltitude = altitude !== undefined ? altitude : this.centerAltitude || 0;
              var centerPointZ = centerAltitude * this._meterToGLPoint;
              this.cameraLookAt = set(this.cameraLookAt || [0, 0, 0], center2D.x, center2D.y, centerPointZ);
              var pitch = this.getPitch() * RADIAN;
              var bearing = this.getBearing() * RADIAN;
              // const ratio = this._getFovRatio();
              // const z = scale * (size.height || 1) / 2 / ratio;
              // const cz = z * Math.cos(pitch);
              var cameraToCenterDistance = this._getFovZ();
              var cameraZenithDistance = this.cameraZenithDistance === undefined ? cameraToCenterDistance : this.cameraZenithDistance;
              var cameraToGroundDistance = cameraZenithDistance - centerPointZ;
              var cz = cameraToGroundDistance * Math.cos(pitch);
              // and [dist] away from map's center on XY plane to tilt the scene.
              var dist = Math.sin(pitch) * cameraToGroundDistance;
              // when map rotates, the camera's xy position is rotating with the given bearing and still keeps [dist] away from map's center
              var cx = center2D.x - dist * Math.sin(bearing);
              var cy = center2D.y - dist * Math.cos(bearing);
              this.cameraPosition = set(this.cameraPosition || [0, 0, 0], cx, cy, cz + centerPointZ);
              // console.log('0.camera', this.cameraPosition);
              // console.log('0.center', center2D, this.centerAltitude);
              // console.log('0.cameraToGroundDistance', cameraToGroundDistance);
              // const adjustedZoom = this._adjustZoomOnTerrain();
              // if (adjustedZoom >= 0) {
              //     this._zoom(adjustedZoom);
              //     return this._getCameraWorldMatrix();
              // }
              // this.cameraToCenterDistance = distance(this.cameraPosition, this.cameraLookAt);
              this.cameraToCenterDistance = cameraToCenterDistance;
              // when map rotates, camera's up axis is pointing to bearing from south direction of map
              // default [0,1,0] is the Y axis while the angle of inclination always equal 0
              // if you want to rotate the map after up an incline,please rotateZ like this:
              // let up = new vec3(0,1,0);
              // up.rotateZ(target,radians);
              var d = dist || 1;
              // const up = this.cameraUp = set(this.cameraUp || [0, 0, 0], Math.sin(bearing) * d, Math.cos(bearing) * d, 0);
              this.cameraUp = this.cameraUp || [0, 0, 0];
              var up = this.cameraUp = set(this.cameraUp, Math.sin(bearing) * d, Math.cos(bearing) * d, Math.sin(pitch) * d);
              var m = this.cameraWorldMatrix = this.cameraWorldMatrix || createMat4();
              lookAt(m, this.cameraPosition, this.cameraLookAt, up);
              var cameraForward = this.cameraForward || [0, 0, 0];
              subtract(cameraForward, this.cameraLookAt, this.cameraPosition);
              // similar with unity's camera.transform.forward
              this.cameraForward = normalize(cameraForward, cameraForward);
              // math from THREE.js
              matrixToQuaternion(q, m);
              quaternionToMatrix(m, q);
              setPosition(m, this.cameraPosition);
              // mat4.scale(m, m, minusY);
              return m;
          };
      }(),
      updateCenterAltitude: function () {
          this.getRenderer().setToRedraw();
          if (!this.centerAltitude && this._hasAltitudeLayer()) {
              this.centerAltitude = 0;
          }
          this._recenterOnTerrain();
      },
      //@internal
      _recenterOnTerrain: function () {
          if (this.centerAltitude === undefined || this._centerZ !== undefined) {
              return;
          }
          var queriedAltitude = this._queryTerrainByProjCoord(this._prjCenter);
          if (isNil(queriedAltitude) && this._hasAltitudeLayer()) {
              // remains previous center altitude if queried altitude is null
              queriedAltitude = this.centerAltitude;
          }
          var centerAltitude = queriedAltitude || 0;
          var pitch = this.getPitch() * RADIAN;
          var bearing = this.getBearing() * RADIAN;
          var altDist = (centerAltitude - this.centerAltitude) * this._meterToGLPoint;
          var cameraToCenterDistance = this._getFovZ();
          var cameraZenithDistance = this.cameraZenithDistance === undefined ? cameraToCenterDistance : this.cameraZenithDistance;
          var cameraToGroundDistance = cameraZenithDistance - this.centerAltitude * this._meterToGLPoint;
          var newCameraToGroundDistance = cameraToGroundDistance - altDist / Math.cos(pitch);
          var cameraPosition = this.cameraPosition;
          var dist = Math.sin(pitch) * newCameraToGroundDistance;
          var center2D = TEMP_POINT$4;
          center2D.x = cameraPosition[0] + dist * Math.sin(bearing);
          center2D.y = cameraPosition[1] + dist * Math.cos(bearing);
          // console.log(centerAltitude);
          // centerAltitude = (cameraPosition[2] - Math.cos(pitch) * newCameraToGroundDistance) / this._meterToGLPoint;
          // console.log(centerAltitude, (this.cameraToCenterDistance - newCameraToGroundDistance) / this._meterToGLPoint);
          // centerAltitude = (this.cameraToCenterDistance - newCameraToGroundDistance) / this._meterToGLPoint;
          var centerPointZ = centerAltitude * this._meterToGLPoint;
          this.cameraZenithDistance = (cameraPosition[2] - centerPointZ) / Math.cos(pitch) + centerPointZ;
          // const newCameraToGroundDistance = cameraToGroundDistance - altDist / Math.sin(pitch);
          // console.log('1.camera', this.cameraPosition);
          // console.log('1.center', center2D, centerAltitude);
          // console.log('1.newCameraToGroundDistance', newCameraToGroundDistance);
          // console.log(newCameraToGroundDistance, newCameraToGroundDistance1);
          // const newPrjCenter = this._pointToPrjAtRes(center2D, this.getGLRes(), TEMP_COORD);
          this.centerAltitude = centerAltitude;
          // this._setPrjCenter(newPrjCenter);
          var newCenter = this.pointAtResToCoordinate(center2D, this.getGLRes(), TEMP_COORD$1);
          this._eventSilence = true;
          this._suppressRecenter = true;
          this.setCenter(newCenter);
          delete this._suppressRecenter;
          delete this._eventSilence;
          if (isNil(queriedAltitude)) {
              delete this.centerAltitude;
          }
      },
      // _adjustZoomOnTerrain() {
      //     const z = this._eventCameraZ;
      //     const cameraDelta = 1E-10;
      //     if (z === undefined || Math.abs(z - this.cameraPosition[2]) < cameraDelta) {
      //         return -1;
      //     }
      //     if (!this._eventCenterAltitude) {
      //         delete this._eventCameraZ;
      //     }
      //     const centerZ = this.cameraLookAt[2];
      //     const cameraHeight = z - centerZ;
      //     const pitch = this.getPitch() * RADIAN;
      //     const newDistance = cameraHeight / Math.cos(pitch);
      //     const ratio = this._getFovRatio();
      //     const scale = newDistance * 2 * ratio / (this.height || 1);
      //     const glRes = this.getGLRes();
      //     const res = scale * glRes;
      //     const zoom = this.getZoomFromRes(res);
      //     return zoom;
      // },
      //@internal
      _queryTerrainByProjCoord: function (coord) {
          var layers = this._getLayers();
          for (var i = 0; i < layers.length; i++) {
              if (layers[i].queryTerrainByProjCoord) {
                  return layers[i].queryTerrainByProjCoord(coord)[0];
              }
          }
          return 0;
      },
      //@internal
      _hasAltitudeLayer: function () {
          var layers = this._getLayers();
          for (var i = 0; i < layers.length; i++) {
              if (layers[i].getTerrainLayer && layers[i].getTerrainLayer()) {
                  return true;
              }
          }
          return false;
      },
      //@internal
      _queryTerrainInfo: function (containerPoint) {
          var layers = this._getLayers() || [];
          for (var i = 0; i < layers.length; i++) {
              var layer = layers[i];
              if (containerPoint && layer && layer.queryTerrainAtPoint && layer.getTerrainLayer && layer.getTerrainLayer()) {
                  var coordinate = layer.queryTerrainAtPoint(containerPoint);
                  if (coordinate) {
                      return {
                          coordinate: coordinate,
                          altitude: coordinate.z
                      };
                  }
                  else {
                      break;
                  }
              }
          }
          return null;
      },
      //@internal
      _getFovRatio: function () {
          var fov = this.getFov();
          return Math.tan(fov / 2 * RADIAN);
      },
      //@internal
      _renderLayers: function () {
          if (this.isInteracting()) {
              return;
          }
          var layers = this._getLayers();
          // clear canvas layers to prevent unsync painting with tile layers.
          layers.forEach(function (layer) {
              if (!layer) {
                  return;
              }
              var renderer = layer._getRenderer();
              if (renderer && renderer.setToRedraw) {
                  renderer.setToRedraw();
              }
          });
      }
  });
  function createMat4() {
      return identity$1(new Array(16));
  }
  function calculateBearing(start, end) {
      var lon1 = toRadian(start[0]);
      var lon2 = toRadian(end[0]);
      var lat1 = toRadian(start[1]);
      var lat2 = toRadian(end[1]);
      var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
      var b = Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      return toDegree(Math.atan2(a, b));
  }

  Map$1.include(/** @lends Map.prototype */ {
      //@internal
      _onViewChange: function (view) {
          if (!this._viewHistory) {
              this._viewHistory = [];
              this._viewHistoryPointer = 0;
          }
          var old = this._getCurrentView();
          for (var i = this._viewHistory.length - 1; i >= 0; i--) {
              if (equalMapView(view, this._viewHistory[i])) {
                  this._viewHistoryPointer = i;
                  this._fireViewChange(old, view);
                  return;
              }
          }
          if (this._viewHistoryPointer < this._viewHistory.length - 1) {
              // remove old 'next views'
              this._viewHistory.splice(this._viewHistoryPointer + 1);
          }
          this._viewHistory.push(view);
          var count = this.options['viewHistoryCount'];
          if (count > 0 && this._viewHistory.length > count) {
              // remove redundant view
              this._viewHistory.splice(0, this._viewHistory.length - count);
          }
          this._viewHistoryPointer = this._viewHistory.length - 1;
          /**
           * viewchange event
           * @event Map#viewchange
           * @type {Object}
           * @property {String} type - viewchange
           * @property {Map} target - map fires the event
           * @property {Object} old - old view
           * @property {Point} new  - new view
           */
          this._fireViewChange(old, view);
      },
      /**
       * Zoom to the previous map view in view history
       * @return {Object} map view
       */
      zoomToPreviousView: function (options) {
          if (options === void 0) { options = {}; }
          if (!this.hasPreviousView()) {
              return null;
          }
          var view = this._viewHistory[--this._viewHistoryPointer];
          this._zoomToView(view, options);
          return view;
      },
      /**
       * Whether has more previous view
       * @return {Boolean}
       */
      hasPreviousView: function () {
          if (!this._viewHistory || this._viewHistoryPointer === 0) {
              return false;
          }
          return true;
      },
      /**
       * Zoom to the next view in view history
       * @return {Object} map view
       */
      zoomToNextView: function (options) {
          if (options === void 0) { options = {}; }
          if (!this.hasNextView()) {
              return null;
          }
          var view = this._viewHistory[++this._viewHistoryPointer];
          this._zoomToView(view, options);
          return view;
      },
      /**
       * Whether has more next view
       * @return {Boolean}
       */
      hasNextView: function () {
          if (!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1) {
              return false;
          }
          return true;
      },
      //@internal
      _zoomToView: function (view, options) {
          var _this = this;
          var old = this.getView();
          if (options['animation']) {
              this._animateTo(view, {
                  'duration': options['duration']
              }, function (frame) {
                  if (frame.state.playState === 'finished') {
                      _this._fireViewChange(old, view);
                  }
              });
          }
          else {
              this.setView(view);
              this._fireViewChange(old, view);
          }
      },
      /**
       * Get map view history
       * @return {Object[]}
       */
      getViewHistory: function () {
          return this._viewHistory;
      },
      //@internal
      _fireViewChange: function (old, view) {
          this._fireEvent('viewchange', {
              'old': old,
              'new': view
          });
          this._insertUICollidesQueue();
      },
      //@internal
      _getCurrentView: function () {
          if (!this._viewHistory) {
              return null;
          }
          return this._viewHistory[this._viewHistoryPointer];
      }
  });
  Map$1.mergeOptions({
      'viewHistory': true,
      'viewHistoryCount': 10
  });

  var UICollisionIndex = new CollisionIndex();
  Map$1.include({
      /**
       * 获取碰撞检测索引
       * @english
       * Get map scope collision index
       * @memberof Map
       */
      getCollisionIndex: function () {
          if (!this._collisionIndex) {
              this.createCollisionIndex();
          }
          return this._collisionIndex || this.createCollisionIndex();
      },
      /**
       * 创建一个新的碰撞检测索引
       * @english
       * Create a new collisionIndex
       * @memberof Map
       */
      createCollisionIndex: function () {
          this.clearCollisionIndex();
          this._collisionIndex = new CollisionIndex();
          return this._collisionIndex;
      },
      /**
       * 清除碰撞索引
       * @english
       * Clear collision index
       * @memberof Map
       */
      clearCollisionIndex: function () {
          this.collisionFrameTime = 0;
          if (this._collisionIndex) {
              this._collisionIndex.clear();
          }
          return this;
      },
      //@internal
      _insertUICollidesQueue: function () {
          if (!this._uiCollidesQueue) {
              this._uiCollidesQueue = [];
          }
          this._uiCollidesQueue.push(1);
          return this;
      },
      uiCollides: function () {
          if (!this.uiList || this.uiList.length === 0 || !this._uiCollidesQueue || this._uiCollidesQueue.length === 0) {
              return this;
          }
          var collisionIndex = UICollisionIndex;
          collisionIndex.clear();
          var uiList = this.uiList;
          for (var i = 0, len = uiList.length; i < len; i++) {
              var ui = uiList[i];
              var _a = ui.options, collisionBufferSize = _a.collisionBufferSize, collision = _a.collision;
              if (!collision) {
                  continue;
              }
              var dom = ui.getDOM();
              if (!ui.isVisible() || !dom) {
                  continue;
              }
              if (!dom.getBoundingClientRect) {
                  continue;
              }
              if (!ui.bbox) {
                  ui.bbox = [0, 0, 0, 0];
              }
              //https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
              var bcRect = dom.getBoundingClientRect();
              var x = bcRect.x, y = bcRect.y;
              var width = bcRect.width, height = bcRect.height;
              // fix 1904
              //in firefox,the dom init Cannot get width and height,why? I don't know either
              //该问题仅仅发生在dom刚加入文档流,后期是可以正常获取到的
              if (width === 0 || height === 0) {
                  var size = ui.getSize();
                  if (size) {
                      width = size.width;
                      height = size.height;
                  }
              }
              var minX = x - collisionBufferSize, maxX = x + width + collisionBufferSize;
              var minY = y - collisionBufferSize, maxY = y + height + collisionBufferSize;
              ui.bbox[0] = minX;
              ui.bbox[1] = minY;
              ui.bbox[2] = maxX;
              ui.bbox[3] = maxY;
              if (collisionIndex.collides(ui.bbox)) {
                  ui._collidesEffect(false);
                  continue;
              }
              collisionIndex.insertBox(ui.bbox);
              ui._collidesEffect(true);
          }
          this._uiCollidesQueue = [];
          return this;
      },
      /**
       * @memberof Map
       * @private
       * @param ui - UIComponent对象
       */
      //@internal
      _addUI: function (ui) {
          if (!this.uiList) {
              this.uiList = [];
          }
          var index = this.uiList.indexOf(ui);
          if (index > -1) {
              return this;
          }
          this.uiList.push(ui);
          this.uiList = this.uiList.sort(function (a, b) {
              return b.options['collisionWeight'] - a.options['collisionWeight'];
          });
          return this;
      },
      /**
       * @memberof Map
       * @private
       * @param ui - UIComponent对象
       */
      //@internal
      _removeUI: function (ui) {
          if (!this.uiList) {
              return -1;
          }
          var index = this.uiList.indexOf(ui);
          if (index < 0) {
              return index;
          }
          this.uiList.splice(index, 1);
          return index;
      }
  });

  var TEMP_COORD = new Coordinate(0, 0);
  Map$1.include(/** @lends Map.prototype */ {
      coordinateToPoint: function (coordinate, zoom, out) {
          var res = this._getResolution(zoom);
          return this.coordinateToPointAtRes(coordinate, res, out);
      },
      coordinateToPointAtRes: function () {
          var COORD = new Coordinate(0, 0);
          return function (coordinate, res, out) {
              var prjCoord = this.getProjection().project(coordinate, COORD);
              return this._prjToPointAtRes(prjCoord, res, out);
          };
      }(),
      pointToCoordinate: function () {
          var COORD = new Coordinate(0, 0);
          return function (point, zoom, out) {
              var prjCoord = this._pointToPrj(point, zoom, COORD);
              return this.getProjection().unproject(prjCoord, out);
          };
      }(),
      pointAtResToCoordinate: function () {
          var COORD = new Coordinate(0, 0);
          return function (point, res, out) {
              var prjCoord = this._pointToPrjAtRes(point, res, COORD);
              return this.getProjection().unproject(prjCoord, out);
          };
      }(),
      coordinateToViewPoint: function () {
          var COORD = new Coordinate(0, 0);
          return function (coordinate, out, altitude) {
              return this._prjToViewPoint(this.getProjection().project(coordinate, COORD), out, altitude);
          };
      }(),
      viewPointToCoordinate: function () {
          var COORD = new Coordinate(0, 0);
          return function (viewPoint, out) {
              return this.getProjection().unproject(this._viewPointToPrj(viewPoint, COORD), out);
          };
      }(),
      coordinateToContainerPoint: function (coordinate, zoom, out) {
          var res = this._getResolution(zoom);
          return this.coordinateToContainerPointAtRes(coordinate, res, out);
      },
      coordinateToContainerPointAtRes: function () {
          var COORD = new Coordinate(0, 0);
          return function (coordinate, res, out) {
              var pCoordinate = this.getProjection().project(coordinate, COORD);
              return this._prjToContainerPointAtRes(pCoordinate, res, out);
          };
      }(),
      coordinatesToContainerPoints: function (coordinates, zoom) {
          var res = this._getResolution(zoom);
          return this.coordinatesToContainerPointsAtRes(coordinates, res);
      },
      coordinatesToContainerPointsAtRes: function () {
          return function (coordinates, resolution) {
              var pts = [];
              var transformation = this._spatialReference.getTransformation();
              var res = resolution / this._getResolution();
              var projection = this.getProjection();
              var prjOut = new Coordinate(0, 0);
              var isTransforming = this.isTransforming();
              var centerPoint = this._prjToPoint(this._getPrjCenter(), undefined, TEMP_COORD);
              for (var i = 0, len = coordinates.length; i < len; i++) {
                  var pCoordinate = projection.project(coordinates[i], prjOut);
                  var point = transformation.transform(pCoordinate, resolution);
                  point = point._multi(res);
                  this._toContainerPoint(point, isTransforming, coordinates[i].z, centerPoint);
                  pts.push(point);
              }
              return pts;
          };
      }(),
      containerPointToCoordinate: function () {
          var COORD = new Coordinate(0, 0);
          return function (containerPoint, out) {
              var pCoordinate = this._containerPointToPrj(containerPoint, COORD);
              return this.getProjection().unproject(pCoordinate, out);
          };
      }(),
      containerToExtent: function () {
          var POINT0 = new Point(0, 0);
          var POINT1 = new Point(0, 0);
          return function (containerExtent) {
              var extent2D = new PointExtent(this._containerPointToPoint(containerExtent.getMin(POINT0), undefined, POINT0), this._containerPointToPoint(containerExtent.getMax(POINT1), undefined, POINT1));
              return this._pointToExtent(extent2D);
          };
      }(),
      distanceToPixel: function () {
          var POINT0 = new Point(0, 0);
          var POINT1 = new Point(0, 0);
          return function (xDist, yDist, zoom) {
              var projection = this.getProjection();
              if (!projection) {
                  return null;
              }
              var scale = this.getScale() / this.getScale(zoom);
              var center = this.getCenter(), target = projection.locate(center, xDist, yDist);
              var p0 = this.coordToContainerPoint(center, undefined, POINT0), p1 = this.coordToContainerPoint(target, undefined, POINT1);
              p1._sub(p0)._multi(scale)._abs();
              return new Size(p1.x, p1.y);
          };
      }(),
      distanceToPoint: function (xDist, yDist, zoom, paramCenter) {
          var res = this._getResolution(zoom);
          return this.distanceToPointAtRes(xDist, yDist, res, paramCenter);
      },
      distanceToPointAtRes: function () {
          var POINT = new Point(0, 0);
          var COORD = new Coordinate(0, 0);
          return function (xDist, yDist, res, paramCenter, out) {
              var projection = this.getProjection();
              if (!projection) {
                  return null;
              }
              var center = paramCenter || this.getCenter(), target = projection.locate(center, xDist, yDist, COORD);
              var p0 = this.coordToPointAtRes(center, res, POINT), p1 = this.coordToPointAtRes(target, res, out);
              p1._sub(p0)._abs();
              return p1;
          };
      }(),
      altitudeToPoint: function () {
          var DEFAULT_CENTER = new Coordinate(0, 40);
          var POINT = new Point(0, 0);
          return function (altitude, res, originCenter) {
              if (altitude === void 0) { altitude = 0; }
              if (this._altitudeOriginDirty) {
                  DEFAULT_CENTER.x = this._originLng;
                  this._altitudeOriginDirty = false;
              }
              var p = this.distanceToPointAtRes(altitude, altitude, res, originCenter || DEFAULT_CENTER, POINT);
              if (altitude < 0 && p.x > 0) {
                  p.x = -p.x;
              }
              var heightFactor = this.options['heightFactor'];
              if (heightFactor && heightFactor !== 1) {
                  p.x *= heightFactor;
                  p.y *= heightFactor;
              }
              return p.x;
          };
      }(),
      pointAtResToAltitude: function () {
          var DEFAULT_CENTER = new Coordinate(0, 40);
          return function (point, res, originCenter) {
              if (point === void 0) { point = 0; }
              var altitude = this.pointAtResToDistance(point, 0, res, originCenter || DEFAULT_CENTER);
              return altitude;
          };
      }(),
      pixelToDistance: function () {
          var COORD0 = new Coordinate(0, 0);
          var COORD1 = new Coordinate(0, 0);
          var TARGET0 = new Coordinate(0, 0);
          var TARGET1 = new Coordinate(0, 0);
          return function (width, height) {
              var projection = this.getProjection();
              if (!projection) {
                  return null;
              }
              var fullExt = this.getFullExtent();
              var d = fullExt['top'] > fullExt['bottom'] ? -1 : 1;
              var coord0 = COORD0.set(this.width / 2, this.height / 2);
              var coord1 = COORD1.set(this.width / 2 + width, this.height / 2 + d * height);
              // 考虑高度海拔后，容器中心点的坐标就不一定是center了
              var target0 = this.containerPointToCoord(coord0, TARGET0);
              var target1 = this.containerPointToCoord(coord1, TARGET1);
              return projection.measureLength(target0, target1);
          };
      }(),
      pointToDistance: function (dx, dy, zoom) {
          var res = this.getResolution(zoom);
          return this.pointAtResToDistance(dx, dy, res);
      },
      pointAtResToDistance: function () {
          var POINT = new Point(0, 0);
          var PRJ_COORD = new Coordinate(0, 0);
          var COORD0 = new Coordinate(0, 0);
          var COORD1 = new Coordinate(0, 0);
          return function (dx, dy, res, paramCenter) {
              var projection = this.getProjection();
              if (!projection) {
                  return null;
              }
              var prjCoord = paramCenter ? projection.project(paramCenter, PRJ_COORD) : this._getPrjCenter();
              var c = this._prjToPointAtRes(prjCoord, res, POINT);
              c._add(dx, dy);
              var target = this.pointAtResToCoord(c, res, COORD0);
              var src = paramCenter ? paramCenter : projection.unproject(prjCoord, COORD1);
              return projection.measureLength(src, target);
          };
      }(),
      locateByPoint: function () {
          var POINT = new Point(0, 0);
          return function (coordinate, px, py) {
              var point = this.coordToContainerPoint(coordinate, undefined, POINT);
              return this.containerPointToCoord(point._add(px, py));
          };
      }(),
      //@internal
      _get2DExtent: function (zoom, out) {
          var cached;
          if ((zoom === undefined || zoom === this._zoomLevel) && this._mapExtent2D) {
              cached = this._mapExtent2D;
          }
          if (cached) {
              if (out) {
                  out.set(cached['xmin'], cached['ymin'], cached['xmax'], cached['ymax']);
                  return out;
              }
              return cached.copy();
          }
          var res = this._getResolution(zoom);
          return this._get2DExtentAtRes(res, out);
      },
      get2DExtent: function (zoom, out) {
          return this._get2DExtent(zoom, out);
      },
      //@internal
      _get2DExtentAtRes: function () {
          var POINT = new Point(0, 0);
          return function (res, out) {
              var _this = this;
              if (res === this._mapGlRes && this._mapGlExtent2D) {
                  return this._mapGlExtent2D;
              }
              var cExtent = this.getContainerExtent();
              return cExtent.convertTo(function (c) { return _this._containerPointToPointAtRes(c, res, POINT); }, out);
          };
      }(),
      get2DExtentAtRes: function (res, out) {
          return this._get2DExtentAtRes(res, out);
      },
      pointToExtent: function (extent2D) {
          return this._pointToExtent(extent2D);
      },
      //@internal
      _pointToExtent: function () {
          var COORD0 = new Coordinate(0, 0);
          var COORD1 = new Coordinate(0, 0);
          return function (extent2D) {
              var min2d = extent2D.getMin(), max2d = extent2D.getMax();
              var fullExtent = this.getFullExtent();
              var _a = __read((!fullExtent || fullExtent.left <= fullExtent.right) ? [min2d.x, max2d.x] : [max2d.x, min2d.x], 2), minx = _a[0], maxx = _a[1];
              var _b = __read((!fullExtent || fullExtent.top > fullExtent.bottom) ? [max2d.y, min2d.y] : [min2d.y, max2d.y], 2), miny = _b[0], maxy = _b[1];
              var min = min2d.set(minx, maxy);
              var max = max2d.set(maxx, miny);
              return new Extent(this.pointToCoord(min, undefined, COORD0), this.pointToCoord(max, undefined, COORD1), this.getProjection());
          };
      }(),
      getViewPointFrameOffset: function () {
          var POINT = new Point(0, 0);
          return function () {
              // when zooming, view point is not updated, and container is being transformed with matrix.
              // so ignore the frame offset
              if (this.isZooming()) {
                  return null;
              }
              var pcenter = this._getPrjCenter();
              if (this._mapViewCoord && !this._mapViewCoord.equals(pcenter)) {
                  return this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(pcenter, undefined, POINT));
              }
              return null;
          };
      }(),
      //@internal
      _viewPointToPrj: function () {
          var POINT = new Point(0, 0);
          return function (viewPoint, out) {
              return this._containerPointToPrj(this.viewPointToContainerPoint(viewPoint, POINT), out);
          };
      }(),
      viewPointToPrj: function (viewPoint, out) {
          return this._viewPointToPrj(viewPoint, out);
      },
      //@internal
      _prjToContainerPoint: function (pCoordinate, zoom, out, altitude) {
          var res = this._getResolution(zoom);
          return this._prjToContainerPointAtRes(pCoordinate, res, out, altitude);
      },
      prjToContainerPoint: function (pCoordinate, zoom, out, altitude) {
          return this._prjToContainerPoint(pCoordinate, zoom, out, altitude);
      },
      //@internal
      _prjToContainerPointAtRes: function () {
          var POINT = new Point(0, 0);
          return function (pCoordinate, res, out, altitude) {
              return this._pointAtResToContainerPoint(this._prjToPointAtRes(pCoordinate, res, POINT), res, altitude || 0, out);
          };
      }(),
      prjToContainerPointAtRes: function (pCoordinate, res, out, altitude) {
          return this.prjToContainerPointAtRes(pCoordinate, res, out, altitude);
      },
      //@internal
      _prjToViewPoint: function () {
          var POINT = new Point(0, 0);
          return function (pCoordinate, out, altitude) {
              var containerPoint = this._prjToContainerPoint(pCoordinate, undefined, POINT, altitude);
              return this.containerPointToViewPoint(containerPoint, out);
          };
      }(),
      prjToViewPoint: function (pCoordinate, out, altitude) {
          return this._prjToViewPoint(pCoordinate, out, altitude);
      },
      //@internal
      _viewPointToPoint: function () {
          var POINT = new Point(0, 0);
          return function (viewPoint, zoom, out) {
              return this._containerPointToPoint(this.viewPointToContainerPoint(viewPoint, POINT), zoom, out);
          };
      }(),
      viewPointToPoint: function (viewPoint, zoom, out) {
          return this._viewPointToPoint(viewPoint, zoom, out);
      },
      //@internal
      _pointToViewPoint: function () {
          var COORD = new Coordinate(0, 0);
          return function (point, zoom, out) {
              return this._prjToViewPoint(this._pointToPrj(point, zoom, COORD), out);
          };
      }(),
      pointToViewPoint: function (point, zoom, out) {
          return this._pointToViewPoint(point, zoom, out);
      }
  });

  var distancetool$2 = {
  	start: "起点",
  	units: {
  		mile: " 英里",
  		feet: " 英尺",
  		kilometer: " 公里",
  		meter: " 米"
  	}
  };
  var areatool$2 = {
  	units: {
  		mile: " 平方英里",
  		feet: " 平方英尺",
  		kilometer: " 平方公里",
  		meter: " 平方米"
  	}
  };
  var zhCn = {
  	distancetool: distancetool$2,
  	areatool: areatool$2
  };

  var distancetool$1 = {
  	start: "Inicio",
  	units: {
  		mile: " mi",
  		feet: " ft",
  		kilometer: " km",
  		meter: " m"
  	}
  };
  var areatool$1 = {
  	units: {
  		mile: " mi²",
  		feet: " ft²",
  		kilometer: " km²",
  		meter: " m²"
  	}
  };
  var esMX = {
  	distancetool: distancetool$1,
  	areatool: areatool$1
  };

  var distancetool = {
  	start: "Start",
  	units: {
  		mile: " mi",
  		feet: " ft",
  		kilometer: " km",
  		meter: " m"
  	}
  };
  var areatool = {
  	units: {
  		mile: " mi²",
  		feet: " ft²",
  		kilometer: " km²",
  		meter: " m²"
  	}
  };
  var enUS = {
  	distancetool: distancetool,
  	areatool: areatool
  };

  /**
   *  Maptalks text's language
  */
  var TranslatorError = /** @class */ (function (_super) {
      __extends(TranslatorError, _super);
      function TranslatorError(msg) {
          var _this = _super.call(this, 'Translator: ' + msg) || this;
          _this.name = 'TranslatorError';
          return _this;
      }
      return TranslatorError;
  }(Error));
  var Translator = /** @class */ (function (_super) {
      __extends(Translator, _super);
      function Translator(lang) {
          var _this = _super.call(this) || this;
          _this.languages = {
              'zh-CN': zhCn,
              'es-MX': esMX,
              'en-US': enUS
          };
          // this.nodes = {};
          _this.setLang(lang || 'zh-CN');
          return _this;
      }
      /**
       *  Method to update the language of maptalks
       *  @param {string} lang - Available Langs (zh-CN, en-US, es-MX)
       *  @example setLang('zh-CN')
      */
      Translator.prototype.setLang = function (lang) {
          var newLanguageNodes = this.languages[lang];
          if (!newLanguageNodes)
              throw new TranslatorError('Setted Lang does not exist');
          this.nodes = newLanguageNodes;
      };
      //@internal
      Translator.prototype._validateNestedProps = function (nestedProps) {
          nestedProps.forEach(function (p) {
              if (p === '')
                  throw new TranslatorError('Any of sides of a dot "." cannot be empty');
          });
      };
      /**
       *  method to return the text of the current language available on lang json's
       *  @param {string} textNode - Accesible property with the current language text.
       *  @return {string} Text to show in screen
       *  @example document.write(translate('areatool.units.kilometer'))
      */
      Translator.prototype.translate = function (textNode) {
          if (textNode === void 0) { textNode = null; }
          if (textNode == null)
              throw new TranslatorError('Missing parameter textNode');
          if (typeof textNode === 'string') {
              var translatedText = null;
              if (textNode.includes('.')) {
                  var nestedProps = textNode.split('.');
                  if (nestedProps.length > 3)
                      throw new TranslatorError("Translate function can only access through 3 nested properties, trying to access -> ".concat(nestedProps.length));
                  this._validateNestedProps(nestedProps);
                  try {
                      var translatedText_1 = null;
                      switch (nestedProps.length) {
                          case 2:
                              translatedText_1 = this.nodes[nestedProps[0]][nestedProps[1]];
                              break;
                          case 3:
                              translatedText_1 = this.nodes[nestedProps[0]][nestedProps[1]][nestedProps[2]];
                              break;
                      }
                      return translatedText_1;
                  }
                  catch (err) {
                      throw new TranslatorError('Unable to find the text translated in lang json' + err.message);
                  }
              }
              else {
                  translatedText = this.nodes[textNode];
                  return translatedText;
              }
          }
          else {
              throw new TranslatorError('Param passed has to be a String');
          }
      };
      return Translator;
  }(Class));

  /**
   * 配置项说明
   *
   * @english
   * @property options
   * @property {String}  options.language         - language of the distance tool, zh-CN or en-US
   * @property {Boolean} options.metric           - display result in metric system
   * @property {Boolean} options.imperial         - display result in imperial system.
   * @property {Object}  options.symbol           - symbol of the line
   * @property {Object}  options.vertexSymbol     - symbol of the vertice
   * @property {Object}  options.labelOptions     - construct options of the vertice labels.
   * @property {Number}  options.decimalPlaces     - The  decimal places of the measured value
   * @property {Function}  options.formatLabelContent     - Content function for custom measurement result labels
   * @memberOf DistanceTool
   * @instance
   */
  var options$l = {
      'formatLabelContent': null,
      'decimalPlaces': 2,
      'mode': 'LineString',
      'language': 'zh-CN', //'en-US'
      'metric': true,
      'imperial': false,
      'symbol': {
          'lineColor': '#000',
          'lineWidth': 3,
          'lineOpacity': 1
      },
      'vertexSymbol': {
          'markerType': 'ellipse',
          'markerFill': '#fff',
          'markerLineColor': '#000',
          'markerLineWidth': 3,
          'markerWidth': 11,
          'markerHeight': 11
      },
      'labelOptions': {
          'textSymbol': {
              'textFaceName': 'monospace',
              'textLineSpacing': 1,
              'textHorizontalAlignment': 'right',
              'textDx': 15
          },
          'boxStyle': {
              'padding': [6, 2],
              'symbol': {
                  'markerType': 'square',
                  'markerFill': '#fff',
                  'markerFillOpacity': 0.9,
                  'markerLineColor': '#b4b3b3',
              }
          }
      },
      'clearButtonSymbol': [{
              'markerType': 'square',
              'markerFill': '#fff',
              'markerLineColor': '#b4b3b3',
              'markerLineWidth': 2,
              'markerWidth': 15,
              'markerHeight': 15,
              'markerDx': 20
          }, {
              'markerType': 'x',
              'markerWidth': 10,
              'markerHeight': 10,
              'markerDx': 20
          }]
  };
  /**
   * 距离测量工具类
   *
   * @english
   * A map tool to help measure distance on the map
   * @category maptool
   * @extends DrawTool
   * @example
   * var distanceTool = new DistanceTool({
   *     'once' : true,
   *     'symbol': {
   *       'lineColor' : '#34495e',
   *       'lineWidth' : 2
   *     },
   *     'vertexSymbol' : {
   *       'markerType'        : 'ellipse',
   *       'markerFill'        : '#1bbc9b',
   *       'markerLineColor'   : '#000',
   *       'markerLineWidth'   : 3,
   *       'markerWidth'       : 10,
   *      'markerHeight'      : 10
   *    },
   *    'language' : 'en-US'
   *  }).addTo(map);
   *
   */
  var DistanceTool = /** @class */ (function (_super) {
      __extends(DistanceTool, _super);
      /**
       * 配置项
       *
       * @param options=null                  - construct options
       * @param options.language=zh-CN        - language of the distance tool, zh-CN or en-US
       * @param options.metric=true           - display result in metric system
       * @param options.imperial=false        - display result in imperial system.
       * @param options.symbol=null           - symbol of the line
       * @param options.vertexSymbol=null     - symbol of the vertice
       * @param options.labelOptions=null     - construct options of the vertice labels.
       */
      function DistanceTool(options) {
          var _this = _super.call(this, options) || this;
          _this.on('enable', _this._afterEnable, _this)
              .on('disable', _this._afterDisable, _this);
          _this._measureLayers = [];
          _this.translator = new Translator(_this.options['language']);
          return _this;
      }
      /**
       * 清空测量
       *
       * @english
       * Clear the measurements
       * @return {DistanceTool} this
       */
      DistanceTool.prototype.clear = function () {
          if (isArrayHasData(this._measureLayers)) {
              for (var i = 0; i < this._measureLayers.length; i++) {
                  this._measureLayers[i].remove();
              }
          }
          delete this._lastMeasure;
          delete this._lastVertex;
          this._outLayers(this._measureLayers);
          this._measureLayers = [];
          return this;
      };
      /**
       * 获取在绘制图形期间的VectorLayers
       *
       * @english
       * Get the VectorLayers with the geometries drawn on the map during measuring.
       * @return {Array<Layer>}
       */
      DistanceTool.prototype.getMeasureLayers = function () {
          return this._measureLayers;
      };
      /**
       * 获取最后测量结果
       *
       * @english
       * Get last measuring result
       * @return {Number}
       */
      DistanceTool.prototype.getLastMeasure = function () {
          if (!this._lastMeasure) {
              return 0;
          }
          return this._lastMeasure;
      };
      /**
       * 撤消绘图，仅适用于点击/删除模式
       *
       * @english
       * Undo drawing, only applicable for click/dblclick mode
       * @return {DistanceTool} this
       */
      DistanceTool.prototype.undo = function () {
          _super.prototype.undo.call(this);
          var pointer = this._historyPointer;
          if (pointer !== this._vertexes.length) {
              for (var i = pointer; i < this._vertexes.length; i++) {
                  if (this._vertexes[i].label) {
                      this._vertexes[i].label.remove();
                  }
                  this._vertexes[i].marker.remove();
              }
          }
          return this;
      };
      /**
       * 重做绘图，只适用于click/dblclick模式
       *
       * @english
       * Redo drawing, only applicable for click/dblclick mode
       * @return {DistanceTool} this
       */
      DistanceTool.prototype.redo = function () {
          _super.prototype.redo.call(this);
          var i = this._historyPointer - 1;
          if (this._vertexes[i]) {
              if (!this._vertexes[i].marker.getLayer()) {
                  if (this._vertexes[i].label) {
                      this._vertexes[i].label.addTo(this._measureMarkerLayer);
                  }
                  this._vertexes[i].marker.addTo(this._measureMarkerLayer);
              }
          }
          return this;
      };
      //@internal
      DistanceTool.prototype._formatLabelContent = function (params) {
          var formatLabelContent = this.options.formatLabelContent;
          if (formatLabelContent && isFunction(formatLabelContent)) {
              return formatLabelContent.call(this, params) + '';
          }
          return null;
      };
      //@internal
      DistanceTool.prototype._measure = function (toMeasure) {
          var map = this.getMap();
          var length;
          if (toMeasure instanceof Geometry) {
              length = map.computeGeometryLength(toMeasure);
          }
          else if (Array.isArray(toMeasure)) {
              length = map.getProjection().measureLength(toMeasure);
          }
          this._lastMeasure = length;
          var result = this._formatLabelContent(length);
          if (result) {
              return result;
          }
          var units = [
              this.translator.translate('distancetool.units.meter'),
              this.translator.translate('distancetool.units.kilometer'),
              this.translator.translate('distancetool.units.feet'),
              this.translator.translate('distancetool.units.mile')
          ];
          var content = '';
          var decimals = this.options['decimalPlaces'];
          if (this.options['metric']) {
              content += length < 1000 ? length.toFixed(decimals) + units[0] : (length / 1000).toFixed(decimals) + units[1];
          }
          if (this.options['imperial']) {
              length *= 3.2808399;
              if (content.length > 0) {
                  content += '\n';
              }
              content += length < 5280 ? length.toFixed(decimals) + units[2] : (length / 5280).toFixed(decimals) + units[3];
          }
          return content;
      };
      //@internal
      DistanceTool.prototype._registerMeasureEvents = function () {
          this.on('drawstart', this._msOnDrawStart, this)
              .on('drawvertex', this._msOnDrawVertex, this)
              .on('mousemove', this._msOnMouseMove, this)
              .on('drawend', this._msOnDrawEnd, this);
      };
      //@internal
      DistanceTool.prototype._afterEnable = function () {
          this._registerMeasureEvents();
      };
      //@internal
      DistanceTool.prototype._afterDisable = function () {
          this.off('drawstart', this._msOnDrawStart, this)
              .off('drawvertex', this._msOnDrawVertex, this)
              .off('mousemove', this._msOnMouseMove, this)
              .off('drawend', this._msOnDrawEnd, this);
      };
      //@internal
      DistanceTool.prototype._msOnDrawStart = function (param) {
          var map = this.getMap();
          // const prjCoord = map._pointToPrj(param['point2d']);
          var uid = UID();
          var layerId = 'distancetool_' + uid;
          var markerLayerId = 'distancetool_markers_' + uid;
          var zIndex = this.options.zIndex;
          var enableAltitude = this.options.enableAltitude;
          if (!map.getLayer(layerId)) {
              this._measureLineLayer = new VectorLayer(layerId, {
                  zIndex: zIndex,
                  enableAltitude: enableAltitude
              }).addTo(map);
              this._measureMarkerLayer = new VectorLayer(markerLayerId, {
                  zIndex: zIndex,
                  enableAltitude: enableAltitude
              }).addTo(map);
          }
          else {
              this._measureLineLayer = map.getLayer(layerId);
              this._measureMarkerLayer = map.getLayer(markerLayerId);
          }
          this._measureLayers.push(this._measureLineLayer);
          this._measureLayers.push(this._measureMarkerLayer);
          this._pushLayers([this._measureLineLayer, this._measureMarkerLayer]);
          //start marker
          var firstCoordinate = this._getFirstCoordinate() || param.coordinate;
          var marker = new Marker(firstCoordinate.copy(), {
              'symbol': this.options['vertexSymbol']
          });
          //调用_setPrjCoordinates主要是为了解决repeatworld下，让它能标注在其他世界的问题
          // marker._setPrjCoordinates(prjCoord);
          var content = this.translator.translate('distancetool.start');
          var startLabel = new Label(content, firstCoordinate.copy(), this.options['labelOptions']);
          // startLabel._setPrjCoordinates(prjCoord);
          this._lastVertex = startLabel;
          this._addVertexMarker(marker, startLabel);
      };
      //@internal
      DistanceTool.prototype._msOnMouseMove = function (param) {
          var ms = this._measure(this._msGetCoordsToMeasure(param));
          if (!this._tailMarker) {
              var symbol = extendSymbol(this.options['vertexSymbol']);
              symbol['markerWidth'] /= 2;
              symbol['markerHeight'] /= 2;
              this._tailMarker = new Marker(param['coordinate'], {
                  'symbol': symbol
              }).addTo(this._measureMarkerLayer);
              this._tailLabel = new Label(ms, param['coordinate'], this.options['labelOptions'])
                  .addTo(this._measureMarkerLayer);
          }
          // const prjCoords = this._geometry._getPrjCoordinates();
          // const lastCoord = prjCoords[prjCoords.length - 1];
          var lastCoordinate = this._getLasttCoordinate() || param.coordinate;
          this._tailMarker.setCoordinates(lastCoordinate.copy());
          // this._tailMarker._setPrjCoordinates(lastCoord);
          this._tailLabel.setContent(ms);
          this._tailLabel.setCoordinates(lastCoordinate.copy());
          // this._tailLabel._setPrjCoordinates(lastCoord);
      };
      //@internal
      DistanceTool.prototype._msGetCoordsToMeasure = function (param) {
          return param['geometry'].getCoordinates().concat([param['coordinate']]);
      };
      //@internal
      DistanceTool.prototype._msOnDrawVertex = function (param) {
          // const prjCoords = this._geometry._getPrjCoordinates();
          // const lastCoord = prjCoords[prjCoords.length - 1];
          var lastCoordinate = this._getLasttCoordinate() || param.coordinate;
          var geometry = param['geometry'];
          //vertex marker
          var marker = new Marker(lastCoordinate.copy(), {
              'symbol': this.options['vertexSymbol']
          });
          var length = this._measure(geometry);
          var vertexLabel = new Label(length, lastCoordinate.copy(), this.options['labelOptions']);
          this._addVertexMarker(marker, vertexLabel);
          // vertexLabel._setPrjCoordinates(lastCoord);
          // marker._setPrjCoordinates(lastCoord);
          this._lastVertex = vertexLabel;
      };
      //@internal
      DistanceTool.prototype._addVertexMarker = function (marker, vertexLabel) {
          if (!this._vertexes) {
              this._vertexes = [];
          }
          if (this._historyPointer !== undefined && this._vertexes.length > this._historyPointer - 1) {
              this._vertexes.length = this._historyPointer - 1;
          }
          this._vertexes.push({ label: vertexLabel, marker: marker });
          this._measureMarkerLayer.addGeometry(marker);
          if (vertexLabel) {
              this._measureMarkerLayer.addGeometry(vertexLabel);
          }
      };
      //@internal
      DistanceTool.prototype._msOnDrawEnd = function (param) {
          this._clearTailMarker();
          if (param['geometry'].getCoordinates().length < 2) {
              this._lastMeasure = 0;
              this._clearMeasureLayers();
              return;
          }
          var size = this._lastVertex.getSize();
          if (!size) {
              size = new Size(10, 10);
          }
          this._addClearMarker(this._lastVertex.getCoordinates(), this._lastVertex._getPrjCoordinates(), size['width']);
          var geo = param['geometry'].copy();
          geo.setCoordinates(param.geometry.getCoordinates());
          // geo._setPrjCoordinates(param['geometry']._getPrjCoordinates());
          geo.addTo(this._measureLineLayer);
          this._lastMeasure = geo.getLength();
      };
      //@internal
      DistanceTool.prototype._addClearMarker = function (coordinates, prjCoord, dx) {
          var symbol = this.options['clearButtonSymbol'];
          var dxSymbol = {
              'markerDx': (symbol['markerDx'] || 0) + dx,
              'textDx': (symbol['textDx'] || 0) + dx
          };
          if (Array.isArray(symbol)) {
              dxSymbol = symbol.map(function (s) {
                  if (s) {
                      return {
                          'markerDx': (s['markerDx'] || 0) + dx,
                          'textDx': (s['textDx'] || 0) + dx
                      };
                  }
                  return null;
              });
          }
          symbol = extendSymbol(symbol, dxSymbol);
          var endMarker = new Marker(coordinates, {
              'symbol': symbol
          });
          var measureLineLayer = this._measureLineLayer, measureMarkerLayer = this._measureMarkerLayer;
          endMarker.on('click', function () {
              measureLineLayer.remove();
              measureMarkerLayer.remove();
              //return false to stop propagation of event.
              return false;
          }, this);
          endMarker.addTo(this._measureMarkerLayer);
          // endMarker._setPrjCoordinates(prjCoord);
      };
      //@internal
      DistanceTool.prototype._clearTailMarker = function () {
          if (this._tailMarker) {
              this._tailMarker.remove();
              delete this._tailMarker;
          }
          if (this._tailLabel) {
              this._tailLabel.remove();
              delete this._tailLabel;
          }
      };
      //@internal
      DistanceTool.prototype._clearMeasureLayers = function () {
          this._measureLineLayer.remove();
          this._measureMarkerLayer.remove();
      };
      //@internal
      DistanceTool.prototype._getFirstCoordinate = function () {
          if (!this._geometry) {
              return null;
          }
          var coordinates = this._geometry.getCoordinates() || [];
          return coordinates[0];
      };
      //@internal
      DistanceTool.prototype._getLasttCoordinate = function () {
          if (!this._geometry) {
              return null;
          }
          var coordinates = this._geometry.getCoordinates() || [];
          return coordinates[coordinates.length - 1];
      };
      return DistanceTool;
  }(DrawTool));
  DistanceTool.mergeOptions(options$l);

  /**
   * options 配置项说明
   *
   * @english
   * @property options
   * @property options.language         - language of the distance tool, zh-CN or en-US
   * @property options.metric           - display result in metric system
   * @property options.imperial         - display result in imperial system.
   * @property options.symbol          - symbol of the line
   * @property options.vertexSymbol    - symbol of the vertice
   * @property options.labelOptions    - construct options of the vertice labels.
   * @memberOf AreaTool
   * @instance
   */
  var options$k = {
      'mode': 'Polygon',
      'symbol': {
          'lineColor': '#000000',
          'lineWidth': 2,
          'lineOpacity': 1,
          'lineDasharray': '',
          'polygonFill': '#ffffff',
          'polygonOpacity': 0.5
      },
      'language': 'zh-CN'
  };
  /**
   * 一个继承于DistanceTool类，测量面积的地图工具类。
   *
   * @english
   * A map tool to help measure area on the map .it is extends DistanceTool
   * @category maptool
   * @extends DistanceTool
   * @example
   * var areaTool = new AreaTool({
   *     'once' : true,
   *     'symbol': {
   *       'lineColor' : '#34495e',
   *       'lineWidth' : 2
   *     },
   *     'vertexSymbol' : {
   *       'markerType'        : 'ellipse',
   *       'markerFill'        : '#1bbc9b',
   *       'markerLineColor'   : '#000',
   *       'markerLineWidth'   : 3,
   *       'markerWidth'       : 10,
   *      'markerHeight'      : 10
   *    },
   *    'language' : 'en-US'
   *  }).addTo(map);
   */
  var AreaTool = /** @class */ (function (_super) {
      __extends(AreaTool, _super);
      /**
       * 配置项
       *
       * @english
       * @param options option              - construct options
       * @param options.language=zh-CN      - language of the distance tool, zh-CN or en-US
       * @param options.metric=true         - display result in metric system
       * @param options.imperial=false      - display result in imperial system.
       * @param options.symbol=null         - symbol of the line
       * @param options.vertexSymbol=null   - symbol of the vertice
       * @param options.labelOptions=null   - construct options of the vertice labels.
       */
      function AreaTool(options) {
          var _this = _super.call(this, options) || this;
          // this.on('enable', this._afterEnable, this)
          //     .on('disable', this._afterDisable, this);
          _this.translator = new Translator(_this.options['language']);
          _this._measureLayers = [];
          return _this;
      }
      //@internal
      AreaTool.prototype._measure = function (toMeasure) {
          var map = this.getMap();
          var area;
          if (toMeasure instanceof Geometry) {
              area = map.computeGeometryArea(toMeasure);
          }
          else if (Array.isArray(toMeasure)) {
              area = map.getProjection().measureArea(toMeasure);
          }
          this._lastMeasure = area;
          var result = this._formatLabelContent(area);
          if (result) {
              return result;
          }
          var units = [
              this.translator.translate('areatool.units.meter'),
              this.translator.translate('areatool.units.kilometer'),
              this.translator.translate('areatool.units.feet'),
              this.translator.translate('areatool.units.mile')
          ];
          var content = '';
          var decimals = this.options['decimalPlaces'];
          if (this.options['metric']) {
              content += area < 1E6 ? area.toFixed(decimals) + units[0] : (area / 1E6).toFixed(decimals) + units[1];
          }
          if (this.options['imperial']) {
              area *= Math.pow(3.2808399, 2);
              if (content.length > 0) {
                  content += '\n';
              }
              var sqmi = 5280 * 5280;
              content += area < sqmi ? area.toFixed(decimals) + units[2] : (area / sqmi).toFixed(decimals) + units[3];
          }
          return content;
      };
      //@internal
      AreaTool.prototype._msGetCoordsToMeasure = function (param) {
          return param['geometry'].getShell().concat([param['coordinate']]);
      };
      //@internal
      AreaTool.prototype._msOnDrawVertex = function (param) {
          // const prjCoord = this.getMap()._pointToPrj(param['point2d']);
          var lastCoordinate = this._getLasttCoordinate() || param.coordinate;
          var vertexMarker = new Marker(lastCoordinate.copy(), {
              'symbol': this.options['vertexSymbol']
          });
          // vertexMarker._setPrjCoordinates(prjCoord);
          this._measure(param['geometry']);
          this._lastVertex = vertexMarker;
          this._addVertexMarker(vertexMarker);
      };
      //@internal
      AreaTool.prototype._msOnDrawEnd = function (param) {
          this._clearTailMarker();
          var prjCoord;
          var map = this.getMap();
          if (param['point2d']) {
              prjCoord = map._pointToPrj(param['point2d']);
          }
          else {
              var prjCoords = param['geometry']._getPrjCoordinates() || [];
              prjCoords = prjCoords.slice(0, prjCoords.length - 1);
              // param['geometry']._setPrjCoordinates(prjCoords);
              prjCoord = prjCoords[prjCoords.length - 1];
          }
          if (param['geometry'].getShell().length < 3) {
              this._lastMeasure = 0;
              this._clearMeasureLayers();
              return;
          }
          var ms = this._measure(param['geometry']);
          // const projection = this.getMap().getProjection();
          // const coord = projection.unproject(prjCoord);
          var lastCoordinate = this._getLasttCoordinate();
          var endLabel = new Label(ms, lastCoordinate.copy(), this.options['labelOptions'])
              .addTo(this._measureMarkerLayer);
          // endLabel._setPrjCoordinates(prjCoord);
          var size = endLabel.getSize();
          if (!size) {
              size = new Size(10, 10);
          }
          this._addClearMarker(lastCoordinate.copy(), prjCoord, size['width']);
          var geo = param['geometry'].copy();
          geo.setCoordinates(param.geometry.getCoordinates());
          // geo._setPrjCoordinates(param['geometry']._getPrjCoordinates());
          geo.addTo(this._measureLineLayer);
          this._lastMeasure = geo.getArea();
      };
      return AreaTool;
  }(DistanceTool));
  AreaTool.mergeOptions(options$k);

  /**
   * 当地形存在时就不能通过update prj来控制Geometry的坐标数据了,因为有了地形后prj对应的
   * Coordinate是另外一个Coordinate,如果还是update prj,那么就会导致Geometry的coordinates又变成非地形下的coordinate了
   * 因为prj里没有考虑海拔
   * @param {*} projection
   * @param {*} prjCoords
   * @param {*} mapEvent
   * @returns Coordinate | Coordinate[]
   */
  function queryTerrainCoordinates(projection, prjCoords, mapEvent) {
      var isArray = Array.isArray(prjCoords);
      if (!isArray) {
          prjCoords = [prjCoords];
      }
      var coordinates;
      var transformCoordinate;
      if (mapEvent && mapEvent.drawTool && mapEvent.drawTool.options) {
          transformCoordinate = mapEvent.drawTool.options.transformCoordinate;
      }
      if (transformCoordinate && isFunction(transformCoordinate)) {
          coordinates = prjCoords.map(function (c) {
              return projection.unproject(c);
          });
          coordinates = coordinates.map(function (c) {
              var newCoordinata = transformCoordinate(c, mapEvent);
              return newCoordinata || c;
          });
      }
      else {
          if (!mapEvent || !mapEvent.target || !mapEvent.target._queryTerrainInfo) {
              coordinates = prjCoords.map(function (c) {
                  return projection.unproject(c);
              });
              return isArray ? coordinates : coordinates[0];
          }
          var map_1 = mapEvent.target;
          var enableAltitude_1 = mapEvent.enableAltitude;
          coordinates = prjCoords.map(function (c) {
              //prj to container point
              if (enableAltitude_1) {
                  var point = map_1.prjToContainerPoint(c);
                  var terrain = map_1._queryTerrainInfo(point);
                  if (terrain && terrain.coordinate) {
                      return terrain.coordinate;
                  }
              }
              return projection.unproject(c);
          });
      }
      return isArray ? coordinates : coordinates[0];
  }
  var circleHooks = {
      'create': function (projection, prjCoord, mapEvent) {
          // const center = projection.unproject(prjCoord[0]);
          var center = queryTerrainCoordinates(projection, prjCoord[0], mapEvent);
          var circle = new Circle(center, 0);
          // circle._setPrjCoordinates(prjCoord[0]);
          return circle;
      },
      'update': function (projection, prjPath, geometry, mapEvent) {
          var map = geometry.getMap();
          var prjCoord = Array.isArray(prjPath) ? prjPath[prjPath.length - 1] : prjPath;
          // const nextCoord = projection.unproject(prjCoord);
          var nextCoord = queryTerrainCoordinates(projection, prjCoord, mapEvent);
          var radius = map.computeLength(geometry.getCenter(), nextCoord);
          geometry.setRadius(radius);
      },
      'generate': function (geometry) {
          return geometry;
      }
  };
  DrawTool.registerMode('circle', extend$2({
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click'],
  }, circleHooks));
  DrawTool.registerMode('freeHandCircle', extend$2({
      'action': ['mousedown touchstart', 'mousemove touchmove', 'mouseup touchend']
  }, circleHooks));
  var ellipseHooks = {
      'create': function (projection, prjCoord, mapEvent) {
          // const center = projection.unproject(prjCoord[0]);
          var center = queryTerrainCoordinates(projection, prjCoord[0], mapEvent);
          var ellipse = new Ellipse(center, 0, 0);
          // ellipse._setPrjCoordinates(prjCoord[0]);
          return ellipse;
      },
      'update': function (projection, prjPath, geometry, mapEvent) {
          var map = geometry.getMap();
          var center = geometry.getCenter();
          var prjCoord = Array.isArray(prjPath) ? prjPath[prjPath.length - 1] : prjPath;
          // const nextCoord = projection.unproject(prjCoord);
          var nextCoord = queryTerrainCoordinates(projection, prjCoord, mapEvent);
          var rx = map.computeLength(center, new Coordinate({
              x: nextCoord.x,
              y: center.y
          }));
          var ry = map.computeLength(center, new Coordinate({
              x: center.x,
              y: nextCoord.y
          }));
          geometry.setWidth(rx * 2);
          geometry.setHeight(ry * 2);
      },
      'generate': function (geometry) {
          return geometry;
      }
  };
  DrawTool.registerMode('ellipse', extend$2({
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click']
  }, ellipseHooks));
  DrawTool.registerMode('freeHandEllipse', extend$2({
      'action': ['mousedown touchstart', 'mousemove touchmove', 'mouseup touchend']
  }, ellipseHooks));
  var rectangleHooks = {
      'create': function (projection, prjCoords) {
          var rect = new Polygon([]);
          rect._firstClick = prjCoords[0];
          return rect;
      },
      'update': function (projection, prjCoords, geometry, mapEvent) {
          var map = geometry.getMap();
          var containerPoint = mapEvent['containerPoint'];
          var firstClick = map.prjToContainerPoint(geometry._firstClick);
          var ring = [
              [firstClick.x, firstClick.y],
              [containerPoint.x, firstClick.y],
              [containerPoint.x, containerPoint.y],
              [firstClick.x, containerPoint.y],
          ];
          var prjs = ring.map(function (c) { return map._containerPointToPrj(new Point(c)); });
          var coordinates = queryTerrainCoordinates(projection, prjs, mapEvent);
          // geometry.setCoordinates(ring.map(c => map.containerPointToCoord(new Point(c))));
          // geometry._setPrjCoordinates(prjs);
          geometry.setCoordinates(coordinates);
      },
      'generate': function (geometry) {
          return geometry;
      }
  };
  DrawTool.registerMode('rectangle', extend$2({
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click'],
  }, rectangleHooks));
  DrawTool.registerMode('freeHandRectangle', extend$2({
      'action': ['mousedown touchstart', 'mousemove touchmove', 'mouseup touchend']
  }, rectangleHooks));
  DrawTool.registerMode('point', {
      'clickLimit': 1,
      'action': ['click', 'mousemove'],
      'create': function (projection, prjCoord, mapEvent) {
          // const center = projection.unproject(prjCoord[0]);
          var center = queryTerrainCoordinates(projection, prjCoord[0], mapEvent);
          var marker = new Marker(center);
          // marker._setPrjCoordinates(prjCoord[0]);
          return marker;
      },
      'generate': function (geometry) {
          return geometry;
      },
      'update': function (projection, prjCoord, geometry, mapEvent) {
          if (Array.isArray(prjCoord)) {
              prjCoord = prjCoord[prjCoord.length - 1];
          }
          if (!prjCoord) {
              return geometry;
          }
          // const coordinate = projection.unproject(prjCoord);
          var coordinate = queryTerrainCoordinates(projection, prjCoord, mapEvent);
          geometry.setCoordinates(coordinate);
          return geometry;
      }
  });
  var polygonHooks = {
      'create': function (projection, prjPath, mapEvent) {
          // const path = prjPath.map(c => projection.unproject(c));
          var path = queryTerrainCoordinates(projection, prjPath, mapEvent);
          var line = new LineString(path);
          // line._setPrjCoordinates(prjPath);
          line.setCoordinates(path);
          return line;
      },
      'update': function (projection, path, geometry, mapEvent) {
          var symbol = geometry.getSymbol();
          var prjCoords;
          if (Array.isArray(path)) {
              prjCoords = path;
          }
          else {
              // prjCoords = geometry._getPrjCoordinates();
              prjCoords = geometry._drawPrjs || [];
              prjCoords.push(path);
          }
          geometry._drawPrjs = prjCoords;
          // const coordinates = prjCoords.map(c => projection.unproject(c));
          var coordinates = queryTerrainCoordinates(projection, prjCoords, mapEvent);
          // geometry._setPrjCoordinates(prjCoords);
          geometry.setCoordinates(coordinates);
          var layer = geometry.getLayer();
          if (layer) {
              var polygon = layer.getGeometryById('polygon');
              if (!polygon && prjCoords.length >= 3) {
                  polygon = new Polygon([coordinates], {
                      'id': 'polygon',
                      'zIndex': -1
                  });
                  if (symbol) {
                      var pSymbol = extendSymbol(symbol, {
                          'lineOpacity': 0
                      });
                      polygon.setSymbol(pSymbol);
                  }
                  polygon.addTo(layer);
              }
              if (polygon) {
                  // polygon._setPrjCoordinates(prjCoords);
                  polygon.setCoordinates([coordinates]);
              }
          }
      },
      'generate': function (geometry) {
          var polygon = new Polygon(geometry.getCoordinates(), {
              'symbol': geometry.getSymbol(),
              'properties': geometry.getProperties()
          });
          // polygon._setPrjCoordinates(geometry._getPrjCoordinates());
          polygon._projCode = geometry._projCode;
          return polygon;
      }
  };
  DrawTool.registerMode('polygon', extend$2({
      'action': ['click', 'mousemove', 'dblclick']
  }, polygonHooks));
  DrawTool.registerMode('freeHandPolygon', extend$2({
      'action': ['mousedown touchstart', 'mousemove touchmove', 'mouseup touchend']
  }, polygonHooks));
  var lineStringHooks = {
      'create': function (projection, prjPath, mapEvent) {
          // const path = prjPath.map(c => projection.unproject(c));
          var path = queryTerrainCoordinates(projection, prjPath, mapEvent);
          var line = new LineString(path);
          // line._setPrjCoordinates(prjPath);
          line.setCoordinates(path);
          return line;
      },
      'update': function (projection, prjPath, geometry, mapEvent) {
          var prjCoords;
          if (Array.isArray(prjPath)) {
              prjCoords = prjPath;
          }
          else {
              // prjCoords = geometry._getPrjCoordinates();
              prjCoords = geometry._drawPrjs || [];
              prjCoords.push(prjPath);
          }
          // const path = prjCoords.map(c => projection.unproject(c));
          // geometry.setCoordinates(path);
          // geometry._setPrjCoordinates(prjCoords);
          geometry._drawPrjs = prjCoords;
          var path = queryTerrainCoordinates(projection, prjCoords, mapEvent);
          geometry.setCoordinates(path);
      },
      'generate': function (geometry) {
          return geometry;
      }
  };
  DrawTool.registerMode('linestring', extend$2({
      'action': ['click', 'mousemove', 'dblclick']
  }, lineStringHooks));
  DrawTool.registerMode('freeHandLinestring', extend$2({
      'action': ['mousedown touchstart', 'mousemove touchmove', 'mouseup touchend']
  }, lineStringHooks));
  DrawTool.registerMode('arccurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function (projection, prjPath) {
          var path = prjPath.map(function (c) { return projection.unproject(c); });
          var arc = new ArcCurve(path);
          arc._setPrjCoordinates(prjPath);
          return arc;
      },
      'update': lineStringHooks.update,
      'generate': function (geometry) {
          return geometry;
      }
  });
  DrawTool.registerMode('quadbeziercurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function (projection, prjPath) {
          var path = prjPath.map(function (c) { return projection.unproject(c); });
          var curve = new QuadBezierCurve(path);
          curve._setPrjCoordinates(prjPath);
          return curve;
      },
      'update': lineStringHooks.update,
      'generate': function (geometry) {
          return geometry;
      }
  });
  DrawTool.registerMode('cubicbeziercurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function (projection, prjPath) {
          var path = prjPath.map(function (c) { return projection.unproject(c); });
          var curve = new CubicBezierCurve(path);
          curve._setPrjCoordinates(prjPath);
          return curve;
      },
      'update': lineStringHooks.update,
      'generate': function (geometry) {
          return geometry;
      }
  });
  // TODO When action contains 'mousedown', It is in drag mode.
  DrawTool.registerMode('boxZoom', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function (projection, prjCoord) {
          prjCoord = prjCoord[0];
          var center = projection.unproject(prjCoord);
          var marker = new Marker(center);
          marker._firstClick = prjCoord;
          return marker;
      },
      'update': function (projection, prjCoord, geometry, param) {
          var map = geometry.getMap();
          var p1 = map.prjToContainerPoint(geometry._firstClick), p2 = param['containerPoint'];
          prjCoord = map._containerPointToPrj(new Coordinate(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)));
          var center = projection.unproject(prjCoord);
          geometry.setCoordinates(center)
              ._setPrjCoordinates(prjCoord);
          geometry.updateSymbol({
              markerWidth: Math.abs(p1.x - p2.x),
              markerHeight: Math.abs(p1.y - p2.y)
          });
      },
      'generate': function (geometry) {
          return geometry;
      }
  });

  /**
   * @property {Object} options
   * @property {Boolean} [options.eventsPropagation=false]  - whether stop ALL events' propagation.
   * @property {Boolean} [options.eventsToStop=null]  - UI's dom events to stop propagation if eventsPropagation is true.
   * @property {Number}  [options.dx=0]     - pixel offset on x axis
   * @property {Number}  [options.dy=0]     - pixel offset on y axis
   * @property {Boolean} [options.autoPan=false]  - set it to false if you don't want the map to do panning animation to fit the opened UI.
   * @property {Boolean} [options.autoPanDuration=600]    - duration for auto panning animation.
   * @property {Boolean} [options.single=true]    - whether the UI is a global single one, only one UI will be shown at the same time if set to true.
   * @property {Boolean} [options.animation=null]         - fade | scale | fade,scale, add animation effect when showing and hiding.
   * @property {Number}  [options.animationDuration=300]  - animation duration, in milliseconds.
   * @property {Number}  [options.animationOnHide=false]  - if calls animation on hiding.
   * @property {Boolean}  [options.pitchWithMap=false]    - whether tilt with map
   * @property {Boolean}  [options.rotateWithMap=false]  - whether rotate with map
   * @property {Boolean}  [options.collision=false]  - whether collision
   * @property {Number}  [options.collisionBufferSize=2]  - collision buffer size
   * @property {Number}  [options.collisionWeight=0]  - Collision weight, large priority collision
   * @property {Boolean}  [options.collisionFadeIn=false]  - Collision fade in animation
   * @property {Number}  [options.zIndex=0]  - dom zindex
   * @memberOf ui.UIComponent
   * @instance
   */
  var options$j = {
      'eventsPropagation': false,
      'eventsToStop': null,
      'dx': 0,
      'dy': 0,
      'autoPan': false,
      'autoPanDuration': 600,
      'single': true,
      'animation': 'scale',
      'animationOnHide': false,
      'animationDuration': 500,
      'pitchWithMap': false,
      'rotateWithMap': false,
      'visible': true,
      'roundPoint': false,
      'collision': false,
      'collisionBufferSize': 2,
      'collisionWeight': 0,
      'collisionFadeIn': false,
      'zIndex': 0
  };
  /**
   * @classdesc
   * Base class for all the UI component classes, a UI component is a HTMLElement positioned with geographic coordinate. <br>
   * It is abstract and not intended to be instantiated.
   *
   * @category ui
   * @abstract
   * @mixes Eventable
   * @memberOf ui
   * @extends Class
   */
  var UIComponent = /** @class */ (function (_super) {
      __extends(UIComponent, _super);
      /**
       *  Some instance methods subclasses needs to implement:  <br>
       *  <br>
       * 1. Optional, returns the Dom element's position offset  <br>
       * function getOffset : Point  <br>
       *  <br>
       * 2. Method to create UI's Dom element  <br>
       * function buildOn : HTMLElement  <br>
       *  <br>
       * 3 Optional, to provide an event map to register event listeners.  <br>
       * function getEvents : void  <br>
       * 4 Optional, a callback when dom is removed.  <br>
       * function onDomRemove : void  <br>
       * 5 Optional, a callback when UI Component is removed.  <br>
       * function onRemove : void  <br>
       * @param  {Object} options configuration options
       */
      function UIComponent(options) {
          var _this = _super.call(this, options) || this;
          _this.proxyOptions();
          return _this;
      }
      //@internal
      UIComponent.prototype._appendCustomClass = function (dom) {
          if (!dom) {
              console.warn('dom is null:', dom);
              return this;
          }
          if (this.options.cssName) {
              var cssName = this.options.cssName;
              if (!Array.isArray(cssName)) {
                  cssName = [cssName];
              }
              cssName.forEach(function (name) {
                  dom.classList.add(name);
              });
          }
          return this;
      };
      UIComponent.prototype.onAdd = function () {
      };
      UIComponent.prototype.onRemove = function () {
      };
      UIComponent.prototype.onDomRemove = function () {
      };
      UIComponent.prototype.getEvents = function () {
          return {};
      };
      UIComponent.prototype.getOwnerEvents = function () {
          return {};
      };
      UIComponent.prototype.buildOn = function () {
          return null;
      };
      /**
       * Adds the UI Component to a geometry or a map
       * @param {Geometry|Map} owner - geometry or map to addto.
       * @returns {ui.UIComponent} this
       * @fires ui.UIComponent#add
       */
      UIComponent.prototype.addTo = function (owner) {
          this._owner = owner;
          // first time
          this._switchEvents('on');
          if (this.onAdd) {
              this.onAdd();
          }
          /**
           * add event.
           *
           * @event ui.UIComponent#add
           * @type {Object}
           * @property {String} type - add
           * @property {ui.UIComponent} target - UIComponent
           */
          this.fire('add');
          return this;
      };
      /**
       * Get the map it added to
       * @return {Map} map instance
       * @override
       */
      UIComponent.prototype.getMap = function () {
          if (!this._owner) {
              return null;
          }
          // is a map
          if (this._owner.getBaseLayer) {
              return this._owner;
          }
          return this._owner.getMap();
      };
      //@internal
      UIComponent.prototype._collides = function () {
          var map = this.getMap();
          if (!map) {
              return this;
          }
          map._addUI(this);
          map._insertUICollidesQueue();
          return this;
      };
      //@internal
      UIComponent.prototype._collidesEffect = function (show) {
          var dom = this.getDOM();
          if (!dom) {
              return this;
          }
          var visibility = show ? 'visible' : 'hidden';
          dom.style.visibility = visibility;
          if (!dom.classList || !dom.classList.add) {
              return this;
          }
          if (!this.options['collisionFadeIn']) {
              return this;
          }
          var classList = dom.classList;
          var className = 'mtk-ui-fadein';
          var hasClass = classList.contains(className);
          if (show && !hasClass) {
              dom.classList.add(className);
          }
          else if (!show && hasClass) {
              dom.classList.remove(className);
          }
          return this;
      };
      /**
       * Show the UI Component, if it is a global single one, it will close previous one.
       * @param {Coordinate} [coordinate=null] - coordinate to show, default is owner's center
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#showstart
       * @fires ui.UIComponent#showend
       */
      UIComponent.prototype.show = function (coordinate) {
          var _this = this;
          var map = this.getMap();
          if (!map) {
              return this;
          }
          this.options['visible'] = true;
          coordinate = coordinate || this._coordinate || this._owner.getCenter();
          if (!(coordinate instanceof Coordinate)) {
              coordinate = new Coordinate(coordinate);
          }
          var visible = this.isVisible();
          /**
           * showstart event.
           *
           * @event ui.UIComponent#showstart
           * @type {Object}
           * @property {String} type - showstart
           * @property {ui.UIComponent} target - UIComponent
           */
          if (!this._showBySymbolChange) {
              this.fire('showstart');
          }
          var container = this._getUIContainer();
          this._coordinate = coordinate;
          //when single will off map events
          this._removePrevDOM();
          if (!this._mapEventsOn) {
              this._switchMapEvents('on');
          }
          var dom = this.__uiDOM = this.buildOn();
          dom['eventsPropagation'] = this.options['eventsPropagation'];
          this._observerDomSize(dom);
          var zIndex = this.options.zIndex;
          if (!dom) {
              /**
               * showend event.
               *
               * @event ui.UIComponent#showend
               * @type {Object}
               * @property {String} type - showend
               * @property {ui.UIComponent} target - UIComponent
               */
              if (!this._showBySymbolChange) {
                  this.fire('showend');
              }
              this._collides();
              this.setZIndex(zIndex);
              return this;
          }
          this._measureSize(dom);
          if (this._singleton()) {
              dom._uiComponent = this;
              map[this._uiDomKey()] = dom;
          }
          this._setPosition();
          dom.style[TRANSITION] = null;
          container.appendChild(dom);
          var anim = this._getAnimation();
          if (visible) {
              anim.ok = false;
          }
          if (anim.ok) {
              if (anim.fade) {
                  dom.style.opacity = 0 + '';
              }
              if (anim.scale) {
                  if (this.getTransformOrigin) {
                      var origin_1 = this.getTransformOrigin();
                      dom.style[TRANSFORMORIGIN] = origin_1;
                  }
                  dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
              }
          }
          //not support zoom filter show dom
          if (!this.isSupportZoomFilter()) {
              dom.style.display = '';
          }
          if (this.options['eventsToStop']) {
              on(dom, this.options['eventsToStop'], stopPropagation);
          }
          // //autoPan
          // if (this.options['autoPan']) {
          //     this._autoPan();
          // }
          var transition = anim.transition;
          if (anim.ok && transition) {
              /* eslint-disable no-unused-expressions */
              // trigger transition
              dom.offsetHeight;
              /* eslint-enable no-unused-expressions */
              if (transition) {
                  dom.style[TRANSITION] = transition;
              }
              if (anim.fade) {
                  dom.style.opacity = 1 + '';
              }
              if (anim.scale) {
                  dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(1)';
              }
          }
          if (!this._showBySymbolChange) {
              this.fire('showend');
          }
          this._collides();
          //autoPan
          clearTimeout(this._autoPanId);
          if (this.options['autoPan']) {
              this._autoPanId = setTimeout(function () {
                  _this._autoPan();
              }, 32);
          }
          this.setZIndex(zIndex);
          return this;
      };
      /**
       * Hide the UI Component.
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#hide
       */
      UIComponent.prototype.hide = function () {
          var _this = this;
          if (!this.getDOM()) {
              return this;
          }
          if (this._onDomMouseout) {
              this._onDomMouseout();
          }
          this.options['visible'] = false;
          var anim = this._getAnimation(), dom = this.getDOM();
          if (!this.options['animationOnHide']) {
              anim.ok = false;
          }
          if (!anim.ok) {
              dom.style.display = 'none';
              /**
             * hide event.
             *
             * @event ui.UIComponent#hide
             * @type {Object}
             * @property {String} type - hide
             * @property {ui.UIComponent} target - UIComponent
             */
              this.fire('hide');
          }
          else {
              /* eslint-disable no-unused-expressions */
              dom.offsetHeight;
              /* eslint-enable no-unused-expressions */
              dom.style[TRANSITION] = anim.transition;
              setTimeout(function () {
                  dom.style.display = 'none';
                  _this.fire('hide');
              }, this.options['animationDuration']);
          }
          if (anim.fade) {
              dom.style.opacity = 0 + '';
          }
          if (anim.scale) {
              dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
          }
          //remove map bind events
          this._switchMapEvents('off');
          this._collides();
          return this;
      };
      /**
       * Decide whether the ui component is open
       * @returns {Boolean} true|false
       */
      UIComponent.prototype.isVisible = function () {
          if (!this.options['visible']) {
              return false;
          }
          var dom = this.getDOM();
          return this.getMap() && dom && dom.parentNode && dom.style.display !== 'none';
      };
      /**
       * Remove the UI Component
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#hide
       * @fires ui.UIComponent#remove
       */
      UIComponent.prototype.remove = function () {
          delete this._mapEventsOn;
          if (!this._owner) {
              return this;
          }
          var map = this.getMap();
          if (map) {
              map._removeUI(this);
          }
          this.hide();
          this._switchEvents('off');
          if (this.onRemove) {
              this.onRemove();
          }
          if (!this._singleton() && this.__uiDOM) {
              this._removePrevDOM();
          }
          delete this._owner;
          /**
           * remove event.
           *
           * @event ui.UIComponent#remove
           * @type {Object}
           * @property {String} type - remove
           * @property {ui.UIComponent} target - UIComponent
           */
          this.fire('remove');
          this._collides();
          return this;
      };
      /**
       * Get pixel size of the UI Component.
       * @return {Size} size
       */
      UIComponent.prototype.getSize = function () {
          if (this._domContentRect && this._size) {
              //update size by resizeObserver result
              this._size.width = this._domContentRect.width;
              this._size.height = this._domContentRect.height;
          }
          if (this._size) {
              return this._size.copy();
          }
          else {
              return null;
          }
      };
      UIComponent.prototype.getOwner = function () {
          return this._owner;
      };
      /**
       * get Dom Node
       * @returns {HTMLDivElement} dom|null
       */
      UIComponent.prototype.getDOM = function () {
          return this.__uiDOM;
      };
      /**
       * set Dom Node zIndex
       *
       */
      UIComponent.prototype.setZIndex = function (zIndex) {
          if (!isNumber(zIndex)) {
              return this;
          }
          var dom = this.getDOM();
          if (!dom) {
              return this;
          }
          dom.style.zIndex = zIndex + '';
          if (zIndex !== this.options.zIndex) {
              this.options.zIndex = zIndex;
          }
          return this;
      };
      //@internal
      UIComponent.prototype._roundPoint = function (point) {
          if (this.options.roundPoint) {
              point = point._round();
          }
          return point;
      };
      UIComponent.prototype.getPosition = function () {
          if (!this.getMap()) {
              return null;
          }
          var p = this._roundPoint(this._getViewPoint());
          if (this.getOffset) {
              var o = this._roundPoint(this.getOffset());
              if (o) {
                  p._add(o);
              }
          }
          return p;
      };
      //@internal
      UIComponent.prototype._getAnimation = function () {
          var anim = {
              'fade': false,
              'scale': false,
              'ok': false,
              'transition': ''
          };
          var animations = this.options['animation'] ? this.options['animation'].split(',') : [];
          for (var i = 0; i < animations.length; i++) {
              var trimed = trim(animations[i]);
              if (trimed === 'fade') {
                  anim.fade = true;
              }
              else if (trimed === 'scale') {
                  anim.scale = true;
              }
          }
          var transition = null;
          if (anim.fade) {
              transition = 'opacity ' + this.options['animationDuration'] + 'ms';
          }
          if (anim.scale) {
              transition = transition ? transition + ',' : '';
              transition += TRANSFORM + ' ' + this.options['animationDuration'] + 'ms';
          }
          anim.transition = transition;
          anim.ok = (transition !== null);
          return anim;
      };
      //@internal
      UIComponent.prototype._getViewPoint = function () {
          var altitude = 0;
          //后期有了地形后，拿到的数据会带altitude，这里适配下,以后点击地图拿到的数据应该带海拔的（lng,lat,alt）
          var coordinates = this._coordinate || {};
          if (isNumber(coordinates.z)) {
              altitude = coordinates.z;
          }
          else if (this._owner && this._owner.getAltitude) {
              altitude = this._owner.getAltitude() || 0;
              //altitude is array from linestring ,polygon etc when coordinates carry z value [[x,y,z],[x,y,z],....];
              if (!isNumber(altitude)) {
                  altitude = 0;
              }
          }
          if (this._owner.getLayer) {
              var layer = this._owner.getLayer();
              //VectorLayer
              if (layer && layer.isVectorLayer) {
                  altitude = this._owner._getAltitude() || 0;
                  if (!isNumber(altitude)) {
                      altitude = 0;
                  }
              }
          }
          var alt = this._meterToPoint(this._coordinate, altitude);
          return this.getMap().coordToViewPoint(this._coordinate, undefined, alt)
              ._add(this.options['dx'], this.options['dy']);
      };
      //@internal
      UIComponent.prototype._meterToPoint = function (center, altitude) {
          return altitude;
          // const map = this.getMap();
          // return map.altitudeToPoint(altitude, map._getResolution()) * sign(altitude);
      };
      //@internal
      UIComponent.prototype._autoPan = function () {
          var map = this.getMap(), dom = this.getDOM();
          if (!dom || !map || map.isMoving()) {
              return;
          }
          var point = this._getViewPoint()._round();
          var mapWidth = map.width;
          var mapHeight = map.height;
          var mapContainer = map.getContainer();
          if (dom && mapContainer && dom.getBoundingClientRect) {
              var mapRect = mapContainer.getBoundingClientRect();
              //map left ,top value
              var mapLeft = mapRect.left;
              var mapTop = mapRect.top;
              var margin_1 = 50;
              var rect = dom.getBoundingClientRect();
              var offsetX = 0, offsetY = 0;
              var left_1 = rect.left, right = rect.right, top_1 = rect.top, bottom = rect.bottom;
              var width = rect.width, height = rect.height;
              //sub map left,top,Position values relative to the map should be used
              left_1 -= mapLeft;
              right -= mapLeft;
              top_1 -= mapTop;
              bottom -= mapTop;
              if (width > 0 && height > 0) {
                  if (left_1 < margin_1) {
                      offsetX = margin_1 - left_1;
                  }
                  if (offsetX === 0 && (right + margin_1) > mapWidth) {
                      offsetX = -((right + margin_1) - mapWidth);
                  }
                  if (top_1 < margin_1) {
                      offsetY = margin_1 - top_1;
                  }
                  if (offsetY === 0 && (bottom + margin_1) > mapHeight) {
                      offsetY = -((bottom + margin_1) - mapHeight);
                  }
                  if (offsetX !== 0 || offsetY !== 0) {
                      var pitch = map.getPitch();
                      if (pitch > 40 && offsetY !== 0 && this._coordinate) {
                          map.animateTo({ center: this._coordinate }, { duration: map.options['panAnimationDuration'] });
                      }
                      else {
                          map.panBy([Math.ceil(offsetX), Math.ceil(offsetY)]);
                      }
                  }
                  return;
              }
          }
          var containerPoint0 = map.viewPointToContainerPoint(point);
          var offset = this.getOffset();
          var containerPoint = containerPoint0.add(offset);
          var prjCoord = map.viewPointToPrj(point);
          var domWidth = parseInt(dom.clientWidth + '');
          var domHeight = parseInt(dom.clientHeight + '');
          var margin = 50;
          var left = 0, top = 0;
          if ((containerPoint.x) < 0) {
              left = -containerPoint.x + margin;
          }
          else if ((containerPoint.x + domWidth) > mapWidth) {
              left = -((containerPoint.x + domWidth) - mapWidth) - margin;
          }
          if (containerPoint.y - domHeight < 0) {
              top = Math.abs(containerPoint.y - domHeight) + margin;
          }
          else if (containerPoint.y + domHeight > mapHeight) {
              top = (mapHeight - (containerPoint.y + domHeight)) - margin;
          }
          //if dom width > map width
          if (domWidth >= mapWidth) {
              left = mapWidth / 2 - containerPoint0.x;
          }
          if (top !== 0 || left !== 0) {
              var newContainerPoint = containerPoint0.add(left, top);
              var t = map._containerPointToPoint(newContainerPoint)._sub(map._prjToPoint(map._getPrjCenter()));
              var target = map._pointToPrj(map._prjToPoint(prjCoord).sub(t));
              // map.panBy(new Point(left, top), { 'duration': this.options['autoPanDuration'] });
              map._panAnimation(target);
          }
      };
      /**
       * Measure dom's size
       * @param  {HTMLElement} dom - element to measure
       * @return {Size} size
       * @private
       */
      //@internal
      UIComponent.prototype._measureSize = function (dom) {
          var container = this._getUIContainer();
          dom.style.position = 'absolute';
          // dom.style.left = -99999 + 'px';
          var anchor = dom.style.bottom ? 'bottom' : 'top';
          // dom.style[anchor] = -99999 + 'px';
          dom.style.display = '';
          container.appendChild(dom);
          if (dom.getBoundingClientRect) {
              var rect = dom.getBoundingClientRect();
              this._size = new Size(rect.width, rect.height);
          }
          else {
              this._size = new Size(dom.clientWidth, dom.clientHeight);
          }
          dom.style.display = 'none';
          dom.style.left = '0px';
          dom.style[anchor] = '0px';
          return this._size;
      };
      /**
       * Remove previous UI DOM if it has.
       *
       * @private
       */
      //@internal
      UIComponent.prototype._removePrevDOM = function () {
          if (this.onDomRemove) {
              this.onDomRemove();
          }
          var eventsToStop = this.options['eventsToStop'];
          if (this._singleton()) {
              var map = this.getMap(), key = this._uiDomKey();
              if (map[key]) {
                  if (eventsToStop) {
                      off(map[key], eventsToStop, stopPropagation);
                  }
                  var uiComponent = map[key]._uiComponent;
                  //fire pre uicomponent(when it isVisible) hide event
                  if (uiComponent && uiComponent !== this && uiComponent.isVisible()) {
                      uiComponent.fire('hide');
                  }
                  removeDomNode(map[key]);
                  //remove map bind events
                  if (uiComponent && !this.hideDom) {
                      uiComponent._switchMapEvents('off');
                  }
                  delete map[key];
              }
              delete this.__uiDOM;
          }
          else if (this.__uiDOM) {
              if (eventsToStop) {
                  off(this.__uiDOM, eventsToStop, stopPropagation);
              }
              removeDomNode(this.__uiDOM);
              delete this.__uiDOM;
          }
          if (this._resizeObserver) {
              //dispose resizeObserver
              this._resizeObserver.disconnect();
              delete this._resizeObserver;
              delete this._domContentRect;
          }
      };
      /**
       * generate the cache key to store the singletong UI DOM
       * @private
       * @return {String} cache key
       */
      //@internal
      UIComponent.prototype._uiDomKey = function () {
          return '__ui_' + this._getClassName();
      };
      //@internal
      UIComponent.prototype._singleton = function () {
          return this.options['single'];
      };
      //@internal
      UIComponent.prototype._getUIContainer = function () {
          return this.getMap().getPanels()['ui'];
      };
      //@internal
      UIComponent.prototype._getClassName = function () {
          return 'UIComponent';
      };
      //@internal
      UIComponent.prototype._switchMapEvents = function (to) {
          var map = this.getMap();
          if (!map) {
              return;
          }
          this._mapEventsOn = (to === 'on');
          var events = this._getDefaultEvents();
          if (this.getEvents) {
              extend$2(events, this.getEvents());
          }
          if (events) {
              for (var p in events) {
                  if (events.hasOwnProperty(p)) {
                      map[to](p, events[p], this);
                  }
              }
          }
      };
      //@internal
      UIComponent.prototype._switchEvents = function (to) {
          //At the beginning,not bind map events,bind evetns when show
          // this._switchMapEvents(to);
          var ownerEvents = this._getOwnerEvents();
          if (this._owner) {
              for (var p in ownerEvents) {
                  if (ownerEvents.hasOwnProperty(p)) {
                      this._owner[to](p, ownerEvents[p], this);
                  }
              }
          }
      };
      //@internal
      UIComponent.prototype._getDefaultEvents = function () {
          return {
              'zooming rotate pitch': this.onEvent,
              'zoomend': this.onZoomEnd,
              'moving': this.onMoving,
              'moveend': this.onMoving,
              'resize': this.onResize
          };
      };
      //@internal
      UIComponent.prototype._getOwnerEvents = function () {
          var events = {};
          if (this._owner && (this._owner instanceof Geometry)) {
              events.positionchange = this.onGeometryPositionChange;
              events.symbolchange = this._updatePosition;
          }
          if (this.getOwnerEvents) {
              extend$2(events, this.getOwnerEvents());
          }
          return events;
      };
      UIComponent.prototype.onGeometryPositionChange = function (param) {
          if (this._owner && this.isVisible()) {
              this._showBySymbolChange = true;
              var target = param.target;
              var center = target.getCenter();
              if (target._getAltitude) {
                  var altitude = target._getAltitude();
                  if (isNumber(altitude)) {
                      center.z = altitude;
                  }
              }
              this.show(center);
              delete this._showBySymbolChange;
          }
      };
      UIComponent.prototype.onMoving = function () {
          if (this.isVisible() && this.getMap().isTransforming()) {
              this._updatePosition();
          }
      };
      UIComponent.prototype.onEvent = function () {
          if (this.isVisible()) {
              this._updatePosition();
          }
      };
      UIComponent.prototype.onZoomEnd = function () {
          if (this.isVisible()) {
              // when zoomend, map container is reset, position should be updated in current frame
              this._setPosition();
          }
      };
      UIComponent.prototype.onResize = function () {
          if (this.isVisible()) {
              //when map resize , update position
              this._setPosition();
          }
      };
      UIComponent.prototype.onDomSizeChange = function () {
          if (this.isVisible()) {
              //when dom resize , update position
              this._setPosition();
              this._collides();
          }
      };
      //@internal
      UIComponent.prototype._updatePosition = function () {
          if (!this.getMap()) {
              return this;
          }
          // update position in the next frame to sync with layers
          var renderer = this.getMap()._getRenderer();
          renderer.callInNextFrame(this._setPosition.bind(this));
          return this;
      };
      //@internal
      UIComponent.prototype._setPosition = function () {
          var dom = this.getDOM();
          if (!dom)
              return;
          dom.style[TRANSITION] = null;
          var p = this.getPosition();
          this._pos = p;
          dom.style[TRANSFORM] = this._toCSSTranslate(p) + ' scale(1)';
      };
      //@internal
      UIComponent.prototype._toCSSTranslate = function (p) {
          if (!p) {
              return '';
          }
          if (Browser$1.any3d) {
              var map = this.getMap(), bearing = map ? map.getBearing() : 0, pitch = map ? map.getPitch() : 0;
              var r = '';
              if (this.options['pitchWithMap'] && pitch) {
                  r += " rotateX(".concat(Math.round(pitch), "deg)");
              }
              if (this.options['rotateWithMap'] && bearing) {
                  r += " rotateZ(".concat(Math.round(-bearing), "deg)");
              }
              return 'translate3d(' + Math.fround(p.x) + 'px,' + Math.fround(p.y) + 'px, 0px)' + r;
          }
          else {
              return 'translate(' + Math.fround(p.x) + 'px,' + Math.fround(p.y) + 'px)';
          }
      };
      //@internal
      UIComponent.prototype._observerDomSize = function (dom) {
          var _this = this;
          if (!dom || !Browser$1.resizeObserver || this._resizeObserver) {
              return this;
          }
          this._resizeObserver = new ResizeObserver(function (entries) {
              if (entries.length) {
                  var borderBoxSize = entries[0].borderBoxSize;
                  if (borderBoxSize && borderBoxSize.length) {
                      _this._domContentRect = {
                          width: borderBoxSize[0].inlineSize,
                          height: borderBoxSize[0].blockSize
                      };
                  }
                  else {
                      _this._domContentRect = entries[0].contentRect;
                  }
              }
              else {
                  delete _this._domContentRect;
              }
              //update dom position
              if (_this.onDomSizeChange) {
                  _this.onDomSizeChange();
              }
          });
          this._resizeObserver.observe(dom);
          return this;
      };
      UIComponent.prototype.isSupportZoomFilter = function () {
          return false;
      };
      UIComponent.prototype.onConfig = function () {
          this._updatePosition();
          return this;
      };
      /*
       *
       * @param {Geometry||ui.UIMarker} owner
       * @return {Boolean}
       */
      UIComponent.isSupport = function (owner) {
          if (owner && isFunction(owner.on) && isFunction(owner.off) && isFunction(owner.getCenter)) {
              return true;
          }
          return false;
      };
      //@internal
      UIComponent.prototype._bindDomEvents = function (dom, to) {
          if (!dom) {
              return;
          }
          var events = this._getDomEvents() || {};
          var bindEvent = to === 'on' ? on : off;
          for (var eventName in events) {
              if (to === 'on') {
                  //remove old  handler
                  off(dom, eventName, events[eventName]);
              }
              bindEvent(dom, eventName, events[eventName], this);
          }
      };
      //@internal
      UIComponent.prototype._getDomEvents = function () {
          return {
              'mouseover': this._onDomMouseover,
              'mouseout': this._onDomMouseout
          };
      };
      //@internal
      UIComponent.prototype._configMapPreventWheelScroll = function (preventWheelScroll) {
          var map = this.getMap();
          if (!map) {
              return;
          }
          if (this.options.eventsPropagation) {
              return;
          }
          map.options['preventWheelScroll'] = preventWheelScroll;
      };
      // eslint-disable-next-line no-unused-vars
      //@internal
      UIComponent.prototype._onDomMouseover = function () {
          this._configMapPreventWheelScroll(false);
      };
      // eslint-disable-next-line no-unused-vars
      //@internal
      UIComponent.prototype._onDomMouseout = function () {
          this._configMapPreventWheelScroll(true);
      };
      return UIComponent;
  }(Eventable(Class)));
  UIComponent.mergeOptions(options$j);

  /**
   * @property {Object} options - construct options
   * @property {String} [options.containerClass=null]  - css class name applied to UIMarker's DOM container
   * @property {Boolean} [options.draggable=false]  - if the marker can be dragged.
   * @property {Number}  [options.single=false]     - if the marker is a global single one.
   * @property {String|HTMLElement}  options.content - content of the marker, can be a string type HTML code or a HTMLElement.
   * @property {Number}  [options.altitude=0] - altitude.
   * @property {Number}  [options.minZoom=0] - the minimum zoom to display .
   * @property {Number}  [options.maxZoom=null] - the maximum zoom to display.
   * @property {String}  [options.horizontalAlignment=middle] - horizontal Alignment 'middle','left','right'
   * @property {String}  [options.verticalAlignment=middle] - vertical Alignment 'middle','top','bottom'
   * @memberOf ui.UIMarker
   * @instance
   */
  var options$i = {
      'containerClass': null,
      'eventsPropagation': true,
      'draggable': false,
      'single': false,
      'content': null,
      'altitude': 0,
      'minZoom': 0,
      'maxZoom': null,
      'horizontalAlignment': 'middle',
      'verticalAlignment': 'middle'
  };
  var domEvents = 
  /**
   * mousedown event
   * @event ui.UIMarker#mousedown
   * @type {Object}
   * @property {String} type                    - mousedown
   * @property {UIMarker} target    - the uimarker fires event
   * @property {Coordinate} coordinate - coordinate of the event
   * @property {Point} containerPoint  - container point of the event
   * @property {Point} viewPoint       - view point of the event
   * @property {Event} domEvent                 - dom event
   */
  'mousedown ' +
      /**
       * mouseup event
       * @event ui.UIMarker#mouseup
       * @type {Object}
       * @property {String} type                    - mouseup
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseup ' +
      /**
       * mouseenter event
       * @event ui.UIMarker#mouseenter
       * @type {Object}
       * @property {String} type                    - mouseenter
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseenter ' +
      /**
       * mouseover event
       * @event ui.UIMarker#mouseover
       * @type {Object}
       * @property {String} type                    - mouseover
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseover ' +
      /**
       * mouseout event
       * @event ui.UIMarker#mouseout
       * @type {Object}
       * @property {String} type                    - mouseout
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mouseout ' +
      /**
       * mousemove event
       * @event ui.UIMarker#mousemove
       * @type {Object}
       * @property {String} type                    - mousemove
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'mousemove ' +
      /**
       * click event
       * @event ui.UIMarker#click
       * @type {Object}
       * @property {String} type                    - click
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'click ' +
      /**
       * dblclick event
       * @event ui.UIMarker#dblclick
       * @type {Object}
       * @property {String} type                    - dblclick
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'dblclick ' +
      /**
       * contextmenu event
       * @event ui.UIMarker#contextmenu
       * @type {Object}
       * @property {String} type                    - contextmenu
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'contextmenu ' +
      /**
       * keypress event
       * @event ui.UIMarker#keypress
       * @type {Object}
       * @property {String} type                    - keypress
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'keypress ' +
      /**
       * touchstart event
       * @event ui.UIMarker#touchstart
       * @type {Object}
       * @property {String} type                    - touchstart
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchstart ' +
      /**
       * touchmove event
       * @event ui.UIMarker#touchmove
       * @type {Object}
       * @property {String} type                    - touchmove
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchmove ' +
      /**
       * touchend event
       * @event ui.UIMarker#touchend
       * @type {Object}
       * @property {String} type                    - touchend
       * @property {UIMarker} target    - the uimarker fires event
       * @property {Coordinate} coordinate - coordinate of the event
       * @property {Point} containerPoint  - container point of the event
       * @property {Point} viewPoint       - view point of the event
       * @property {Event} domEvent                 - dom event
       */
      'touchend';
  /**
   *
   * @classdesc
   * Class for UI Marker, a html based marker positioned by geographic coordinate. <br>
   *
   * @category ui
   * @extends ui.UIComponent
   * @mixes Handlerable
   * @memberOf ui
   * @example
   * var dom = document.createElement('div');
   * dom.innerHTML = 'hello ui marker';
   * var marker = new maptalks.ui.UIMarker([0, 0], {
   *      draggable : true,
   *      content : dom
   *  }).addTo(map);
   */
  var UIMarker = /** @class */ (function (_super) {
      __extends(UIMarker, _super);
      /**
       * As it's renderered by HTMLElement such as a DIV, it: <br>
       * 1. always on the top of all the map layers <br>
       * 2. can't be snapped as it's not drawn on the canvas. <br>
       * @param  {Coordinate} coordinate - UIMarker's coordinates
       * @param {Object} options - options defined in [UIMarker]{@link UIMarker#options}
       */
      function UIMarker(coordinate, options) {
          var _this = _super.call(this, options) || this;
          _this._markerCoord = new Coordinate(coordinate);
          return _this;
      }
      // TODO: obtain class in super
      //@internal
      UIMarker.prototype._getClassName = function () {
          return 'UIMarker';
      };
      /**
       * Sets the coordinates
       * @param {Coordinate} coordinates - UIMarker's coordinate
       * @returns {UIMarker} this
       * @fires UIMarker#positionchange
       */
      UIMarker.prototype.setCoordinates = function (coordinates) {
          this._markerCoord = coordinates;
          /**
           * positionchange event.
           *
           * @event ui.UIMarker#positionchange
           * @type {Object}
           * @property {String} type - positionchange
           * @property {UIMarker} target - ui marker
           */
          this.fire('positionchange');
          if (this.isVisible()) {
              this._coordinate = this._markerCoord;
              this._setPosition();
              this._collides();
          }
          return this;
      };
      /**
       * Gets the coordinates
       * @return {Coordinate} coordinates
       */
      UIMarker.prototype.getCoordinates = function () {
          return this._markerCoord;
      };
      //accord with isSupport for tooltip
      UIMarker.prototype.getCenter = function () {
          return this.getCoordinates();
      };
      // for infowindow
      UIMarker.prototype.getAltitude = function () {
          var coordinates = this.getCoordinates() || {};
          if (isNumber(coordinates.z)) {
              return coordinates.z;
          }
          return this.options.altitude || 0;
      };
      UIMarker.prototype.setAltitude = function (alt) {
          if (isNumber(alt) && this._markerCoord) {
              this._markerCoord.z = alt;
              if (this._updatePosition) {
                  this._updatePosition();
                  this._collides();
              }
          }
          return this;
      };
      /**
       * Sets the content of the UIMarker
       * @param {String|HTMLElement} content - UIMarker's content
       * @returns {UIMarker} this
       * @fires UIMarker#contentchange
       */
      UIMarker.prototype.setContent = function (content) {
          var old = this.options['content'];
          this.options['content'] = content;
          /**
           * contentchange event.
           *
           * @event ui.UIMarker#contentchange
           * @type {Object}
           * @property {String} type - contentchange
           * @property {UIMarker} target - ui marker
           * @property {String|HTMLElement} old      - old content
           * @property {String|HTMLElement} new      - new content
           */
          this.fire('contentchange', {
              'old': old,
              'new': content
          });
          if (this.isVisible()) {
              this.show();
          }
          return this;
      };
      /**
       * Gets the content of the UIMarker
       * @return {String|HTMLElement} content
       */
      UIMarker.prototype.getContent = function () {
          return this.options['content'];
      };
      UIMarker.prototype.onAdd = function () {
          if (this._owner && !this._owner.isMap) {
              var owner = this._owner;
              throw new Error('UIMarker Can only be added to the map, but owner is:' + owner.getJSONType && owner.getJSONType());
          }
          this.show();
          return this;
      };
      /**
       * Show the UIMarker
       * @returns {UIMarker} this
       * @fires UIMarker#showstart
       * @fires UIMarker#showend
       */
      UIMarker.prototype.show = function () {
          return _super.prototype.show.call(this, this._markerCoord);
      };
      /**
       * Flash the UIMarker, show and hide by certain internal for times of count.
       *
       * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)
       * @param {Number} [count=4]          - flash times
       * @param {Function} [cb=null]        - callback function when flash ended
       * @param {*} [context=null]          - callback context
       * @return {UIMarker} this
       */
      UIMarker.prototype.flash = function (interval, count, cb, context) {
          return flash.call(this, interval, count, cb, context);
      };
      /**
       * A callback method to build UIMarker's HTMLElement
       * @protected
       * @param {Map} map - map to be built on
       * @return {HTMLElement} UIMarker's HTMLElement
       */
      UIMarker.prototype.buildOn = function () {
          var oldDom = this.getDOM();
          this._bindDomEvents(oldDom, 'off');
          var dom;
          var content = this.options['content'];
          var isStr = isString(content);
          if (isStr || isFunction(content)) {
              dom = createEl('div');
              if (isStr) {
                  dom.innerHTML = this.options['content'];
              }
              else {
                  //dymatic render dom content
                  content.bind(this)(dom);
              }
          }
          else {
              dom = this.options['content'];
          }
          if (this.options['containerClass']) {
              dom.className = this.options['containerClass'];
          }
          this._registerDOMEvents(dom);
          this._bindDomEvents(dom, 'on');
          this._appendCustomClass(dom);
          return dom;
      };
      /**
       * Gets UIMarker's HTMLElement's position offset, it's caculated dynamically accordiing to its actual size.
       * @protected
       * @return {Point} offset
       */
      UIMarker.prototype.getOffset = function () {
          var size = this.getSize();
          //default is middle
          var offsetX = -size.width / 2, offsetY = -size.height / 2;
          var _a = this.options, horizontalAlignment = _a.horizontalAlignment, verticalAlignment = _a.verticalAlignment;
          if (horizontalAlignment === 'left') {
              offsetX = -size.width;
          }
          else if (horizontalAlignment === 'right') {
              offsetX = 0;
          }
          if (verticalAlignment === 'top') {
              offsetY = -size.height;
          }
          else if (verticalAlignment === 'bottom') {
              offsetY = 0;
          }
          return new Point(offsetX, offsetY);
      };
      /**
       * Gets UIMarker's transform origin for animation transform
       * @protected
       * @return {Point} transform origin
       */
      UIMarker.prototype.getTransformOrigin = function () {
          return 'center center';
      };
      UIMarker.prototype.onDomRemove = function () {
          var dom = this.getDOM();
          this._removeDOMEvents(dom);
      };
      /**
       * Whether the uimarker is being dragged.
       * @returns {Boolean}
       */
      UIMarker.prototype.isDragging = function () {
          if (this['draggable']) {
              return this['draggable'].isDragging();
          }
          return false;
      };
      //@internal
      UIMarker.prototype._registerDOMEvents = function (dom) {
          on(dom, domEvents, this._onDomEvents, this);
      };
      //@internal
      UIMarker.prototype._onDomEvents = function (e, type) {
          var event = this.getMap()._parseEvent(e, e.type);
          type = type || e.type;
          if (type === 'mousedown') {
              this._mousedownEvent = e;
          }
          if (type === 'mouseup') {
              this._mouseupEvent = e;
          }
          if (type === 'click' && this._mouseClickPositionIsChange()) {
              return;
          }
          if (type === 'touchstart') {
              this._touchstartTime = now();
          }
          this.fire(type, event);
          // Mobile device simulation click event
          if (type === 'touchend' && Browser$1.touch) {
              var clickTimeThreshold = this.getMap().options.clickTimeThreshold || 280;
              if (now() - this._touchstartTime < clickTimeThreshold) {
                  this._onDomEvents(e, 'click');
              }
          }
      };
      //@internal
      UIMarker.prototype._removeDOMEvents = function (dom) {
          off(dom, domEvents, this._onDomEvents);
      };
      //@internal
      UIMarker.prototype._mouseClickPositionIsChange = function () {
          var _a = this._mousedownEvent || {}, x1 = _a.x, y1 = _a.y;
          var _b = this._mouseupEvent || {}, x2 = _b.x, y2 = _b.y;
          return (x1 !== x2 || y1 !== y2);
      };
      /**
       * Get the connect points of panel for connector lines.
       * @private
       */
      //@internal
      UIMarker.prototype._getConnectPoints = function () {
          var map = this.getMap();
          var containerPoint = map.coordToContainerPoint(this.getCoordinates());
          var size = this.getSize(), width = size.width, height = size.height;
          var anchors = [
              //top center
              map.containerPointToCoordinate(containerPoint.add(-width / 2, 0)),
              //middle right
              map.containerPointToCoordinate(containerPoint.add(width / 2, 0)),
              //bottom center
              map.containerPointToCoordinate(containerPoint.add(0, height / 2)),
              //middle left
              map.containerPointToCoordinate(containerPoint.add(0, -height / 2))
          ];
          return anchors;
      };
      //@internal
      UIMarker.prototype._getViewPoint = function () {
          var alt = 0;
          if (this._owner) {
              var altitude = this.getAltitude();
              if (altitude > 0) {
                  alt = this._meterToPoint(this._coordinate, altitude);
              }
          }
          return this.getMap().coordToViewPoint(this._coordinate, undefined, alt)
              ._add(this.options['dx'], this.options['dy']);
      };
      //@internal
      UIMarker.prototype._getDefaultEvents = function () {
          return extend$2({}, _super.prototype._getDefaultEvents.call(this), { 'zooming zoomend': this.onZoomFilter });
      };
      //@internal
      UIMarker.prototype._setPosition = function () {
          //show/hide zoomFilter
          this.onZoomFilter();
          _super.prototype._setPosition.call(this);
      };
      UIMarker.prototype.onZoomFilter = function () {
          var dom = this.getDOM();
          if (!dom)
              return;
          if (!this.isVisible() && dom.style.display !== 'none') {
              dom.style.display = 'none';
          }
          else if (this.isVisible() && dom.style.display === 'none') {
              dom.style.display = '';
          }
      };
      UIMarker.prototype.isVisible = function () {
          var map = this.getMap();
          if (!map) {
              return false;
          }
          if (!this.options['visible']) {
              return false;
          }
          var zoom = map.getZoom();
          var _a = this.options, minZoom = _a.minZoom, maxZoom = _a.maxZoom;
          if (!isNil(minZoom) && zoom < minZoom || (!isNil(maxZoom) && zoom > maxZoom)) {
              return false;
          }
          var dom = this.getDOM();
          return dom && true;
      };
      UIMarker.prototype.isSupportZoomFilter = function () {
          return true;
      };
      return UIMarker;
  }(Handlerable(UIComponent)));
  UIMarker.mergeOptions(options$i);
  var EVENTS$2 = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';
  var UIMarkerDragHandler = /** @class */ (function (_super) {
      __extends(UIMarkerDragHandler, _super);
      function UIMarkerDragHandler(target) {
          return _super.call(this, target) || this;
      }
      UIMarkerDragHandler.prototype.addHooks = function () {
          this.target.on(EVENTS$2, this._startDrag, this);
      };
      UIMarkerDragHandler.prototype.removeHooks = function () {
          this.target.off(EVENTS$2, this._startDrag, this);
      };
      //@internal
      UIMarkerDragHandler.prototype._startDrag = function (param) {
          var domEvent = param['domEvent'];
          if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
              return;
          }
          if (this.isDragging()) {
              return;
          }
          this.target.on('click', this._endDrag, this);
          this._lastCoord = param['coordinate'];
          this._lastPoint = param['containerPoint'];
          this._prepareDragHandler();
          this._dragHandler.onMouseDown(param['domEvent']);
          /**
           * drag start event
           * @event ui.UIMarker#dragstart
           * @type {Object}
           * @property {String} type                    - dragstart
           * @property {UIMarker} target    - the uimarker fires event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          this.target.fire('dragstart', param);
      };
      //@internal
      UIMarkerDragHandler.prototype._prepareDragHandler = function () {
          this._dragHandler = new DragHandler(this.target.getDOM(), {
              'cancelOn': this._cancelOn.bind(this),
              'ignoreMouseleave': true
          });
          this._dragHandler.on('mousedown', this._onMouseDown, this);
          this._dragHandler.on('dragging', this._dragging, this);
          this._dragHandler.on('mouseup', this._endDrag, this);
          this._dragHandler.enable();
      };
      //@internal
      UIMarkerDragHandler.prototype._cancelOn = function (domEvent) {
          var target = domEvent.srcElement || domEvent.target, tagName = target.tagName.toLowerCase();
          if (tagName === 'button' ||
              tagName === 'input' ||
              tagName === 'select' ||
              tagName === 'option' ||
              tagName === 'textarea') {
              return true;
          }
          return false;
      };
      //@internal
      UIMarkerDragHandler.prototype._onMouseDown = function (param) {
          stopPropagation(param['domEvent']);
      };
      //@internal
      UIMarkerDragHandler.prototype._dragging = function (param) {
          var target = this.target, map = target.getMap(), eventParam = map._parseEvent(param['domEvent']), domEvent = eventParam['domEvent'];
          var touchEvent = domEvent;
          if (touchEvent.touches && touchEvent.touches.length > 1) {
              return;
          }
          if (!this._isDragging) {
              this._isDragging = true;
              return;
          }
          var coord = eventParam['coordinate'], point = eventParam['containerPoint'];
          if (!this._lastCoord) {
              this._lastCoord = coord;
          }
          if (!this._lastPoint) {
              this._lastPoint = point;
          }
          var coordOffset = coord.sub(this._lastCoord), pointOffset = point.sub(this._lastPoint);
          this._lastCoord = coord;
          this._lastPoint = point;
          this.target.setCoordinates(this.target.getCoordinates().add(coordOffset));
          eventParam['coordOffset'] = coordOffset;
          eventParam['pointOffset'] = pointOffset;
          /**
           * dragging event
           * @event ui.UIMarker#dragging
           * @type {Object}
           * @property {String} type                    - dragging
           * @property {UIMarker} target    - the uimarker fires event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          target.fire('dragging', eventParam);
      };
      //@internal
      UIMarkerDragHandler.prototype._endDrag = function (param) {
          var target = this.target, map = target.getMap();
          if (this._dragHandler) {
              target.off('click', this._endDrag, this);
              this._dragHandler.disable();
              delete this._dragHandler;
          }
          delete this._lastCoord;
          delete this._lastPoint;
          this._isDragging = false;
          if (!map) {
              return;
          }
          var eventParam = map._parseEvent(param['domEvent']);
          /**
           * dragend event
           * @event ui.UIMarker#dragend
           * @type {Object}
           * @property {String} type                    - dragend
           * @property {UIMarker} target    - the uimarker fires event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          if (target && target._mouseClickPositionIsChange && target._mouseClickPositionIsChange()) {
              target.fire('dragend', eventParam);
          }
      };
      UIMarkerDragHandler.prototype.isDragging = function () {
          if (!this._isDragging) {
              return false;
          }
          return true;
      };
      return UIMarkerDragHandler;
  }(Handler));
  UIMarker.addInitHook('addHandler', 'draggable', UIMarkerDragHandler);

  var PROPERTY_PATTERN = /\{ *([\w_]+) *\}/g;
  /**
   * @property {Object} options
   * @property {Boolean} [options.autoPan=true]  - set it to false if you don't want the map to do panning animation to fit the opened window.
   * @property {String} [options.autoCloseOn=null] - Auto close infowindow on map's events, e.g. "click contextmenu" will close infowindow with click or right click on map.
   * @property {String} [options.autoOpenOn='click']  - Auto open infowindow on owner's events, e.g. "click" will open infowindow with click or right click on window's owner.
   * @property {Number}  [options.width=auto]     - default width
   * @property {Number}  [options.minHeight=120] - minimun height
   * @property {Boolean} [options.custom=false]  - set it to true if you want a customized infowindow, customized html codes or a HTMLElement is set to content.
   * @property {String}  [options.title=null]    - title of the infowindow.
   * @property {String|HTMLElement}  options.content - content of the infowindow.
   * @property {Boolean}  [options.enableTemplate=false]  - whether open template . such as content:`homepage:{url},company name:{name}`.
   * @memberOf ui.InfoWindow
   * @instance
   */
  var options$h = {
      'containerClass': 'maptalks-msgBox',
      'autoPan': true,
      'autoCloseOn': null,
      'autoOpenOn': 'click',
      'width': 'auto',
      'minHeight': 120,
      'custom': false,
      'title': null,
      'content': null,
      'enableTemplate': false
  };
  var EMPTY_SIZE = new Size(0, 0);
  /**
   * @classdesc
   * Class for info window, a popup on the map to display any useful infomation you wanted.
   * @category ui
   * @extends ui.UIComponent
   * @param {Object} options - options defined in [InfoWindow]{@link InfoWindow#options}
   * @memberOf ui
   */
  var InfoWindow = /** @class */ (function (_super) {
      __extends(InfoWindow, _super);
      function InfoWindow() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      // TODO: obtain class in super
      //@internal
      InfoWindow.prototype._getClassName = function () {
          return 'InfoWindow';
      };
      /**
       * Adds the UI Component to a geometry or a map
       * @param {Geometry|Map} owner - geometry or map to addto.
       * @returns {UIComponent} this
       * @fires UIComponent#add
       */
      InfoWindow.prototype.addTo = function (owner) {
          if (owner instanceof Geometry) {
              if (owner.getInfoWindow() && owner.getInfoWindow() !== this) {
                  owner.removeInfoWindow();
              }
              owner._infoWindow = this;
          }
          return _super.prototype.addTo.call(this, owner);
      };
      /**
       * Set the content of the infowindow.
       * @param {String|HTMLElement} content - content of the infowindow.
       * return {InfoWindow} this
       * @fires InfoWindow#contentchange
       */
      InfoWindow.prototype.setContent = function (content) {
          var old = this.options['content'];
          this.options['content'] = content;
          /**
           * contentchange event.
           *
           * @event InfoWindow#contentchange
           * @type {Object}
           * @property {String} type - contentchange
           * @property {InfoWindow} target - InfoWindow
           * @property {String|HTMLElement} old      - old content
           * @property {String|HTMLElement} new      - new content
           */
          this.fire('contentchange', {
              'old': old,
              'new': content
          });
          if (this.isVisible()) {
              this.show(this._coordinate);
          }
          return this;
      };
      /**
       * Get content of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      InfoWindow.prototype.getContent = function () {
          return this.options['content'];
      };
      /**
       * Set the title of the infowindow.
       * @param {String|HTMLElement} title - title of the infowindow.
       * return {InfoWindow} this
       * @fires InfoWindow#titlechange
       */
      InfoWindow.prototype.setTitle = function (title) {
          var old = title;
          this.options['title'] = title;
          /**
           * titlechange event.
           *
           * @event InfoWindow#titlechange
           * @type {Object}
           * @property {String} type - titlechange
           * @property {InfoWindow} target - InfoWindow
           * @property {String} old      - old content
           * @property {String} new      - new content
           */
          this.fire('contentchange', {
              'old': old,
              'new': title
          });
          if (this.isVisible()) {
              this.show(this._coordinate);
          }
          return this;
      };
      /**
       * Get title of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      InfoWindow.prototype.getTitle = function () {
          return this.options['title'];
      };
      InfoWindow.prototype.buildOn = function () {
          var _this = this;
          var isFunc = isFunction(this.options['content']);
          var isStr = isString(this.options['content']);
          if (this.options['custom']) {
              var oldDom = this.getDOM();
              var newDom = void 0;
              this._bindDomEvents(oldDom, 'off');
              if (isStr || isFunc) {
                  var dom_1 = createEl('div');
                  if (isStr) {
                      dom_1.innerHTML = this.options['content'];
                      this._replaceTemplate(dom_1);
                  }
                  else {
                      //dymatic render dom content
                      this.options['content'].bind(this)(dom_1);
                  }
                  newDom = dom_1;
              }
              else {
                  this._replaceTemplate(this.options['content']);
                  newDom = this.options['content'];
              }
              this._bindDomEvents(newDom, 'on');
              this._appendCustomClass(newDom);
              return newDom;
          }
          this._bindDomEvents(this.getDOM(), 'off');
          var dom = createEl('div');
          if (this.options['containerClass']) {
              dom.className = this.options['containerClass'];
          }
          var width = this._getWindowWidth();
          dom.style.width = isNumber(width) ? width + 'px' : 'auto';
          dom.style.bottom = '0px'; // fix #657
          var content = '<em class="maptalks-ico"></em>';
          if (this.options['title']) {
              content += '<h2>' + this.options['title'] + '</h2>';
          }
          content += '<a href="javascript:void(0);" class="maptalks-close">×</a><div class="maptalks-msgContent"></div>';
          dom.innerHTML = content;
          //reslove title
          this._replaceTemplate(dom);
          var msgContent = dom.querySelector('.maptalks-msgContent');
          if (isStr || isFunc) {
              if (isStr) {
                  msgContent.innerHTML = this.options['content'];
              }
              else {
                  //dymatic render dom content
                  this.options['content'].bind(this)(msgContent);
              }
          }
          else {
              msgContent.appendChild(this.options['content']);
          }
          this._onCloseBtnClick = function (event) {
              if (!_this.options.eventsPropagation) {
                  preventDefault(event);
                  stopPropagation(event);
              }
              _this.hide();
          };
          var closeBtn = dom.querySelector('.maptalks-close');
          addDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
          //reslove content
          if (!isFunc) {
              this._replaceTemplate(msgContent);
          }
          this._bindDomEvents(dom, 'on');
          this._appendCustomClass(dom);
          return dom;
      };
      //@internal
      InfoWindow.prototype._replaceTemplate = function (dom) {
          var geo = this._owner;
          if (this.options['enableTemplate'] && geo && geo.getProperties && dom && dom.innerHTML) {
              var properties_1 = geo.getProperties() || {};
              if (isObject$1(properties_1)) {
                  var html = dom.innerHTML;
                  dom.innerHTML = html.replace(PROPERTY_PATTERN, function (str, key) {
                      return properties_1[key];
                  });
              }
          }
          return this;
      };
      /**
       * Gets InfoWindow's transform origin for animation transform
       * @protected
       * @return {Point} transform origin
       */
      InfoWindow.prototype.getTransformOrigin = function () {
          var size = this.getSize();
          return size.width / 2 + 'px bottom';
      };
      InfoWindow.prototype.getOffset = function () {
          var size = this.getSize();
          var o = new Point(-size['width'] / 2, 0);
          if (!this.options['custom']) {
              o._sub(4, 12);
          }
          else {
              o._sub(0, size['height']);
          }
          var owner = this.getOwner();
          if (owner instanceof Marker || owner instanceof MultiPoint) {
              var painter = void 0, markerSize = void 0;
              if (owner instanceof Marker) {
                  painter = owner._getPainter();
                  markerSize = owner.getSize();
              }
              else {
                  var children = owner.getGeometries();
                  if (!children || !children.length) {
                      return o;
                  }
                  painter = children[0]._getPainter();
                  markerSize = children[0].getSize();
              }
              if (!markerSize) {
                  markerSize = EMPTY_SIZE;
              }
              if (painter) {
                  var fixExtent = painter.getFixedExtent();
                  o._add(fixExtent.xmax - markerSize.width / 2, fixExtent.ymin);
              }
              else {
                  o._add(0, -markerSize.height);
              }
          }
          return o;
      };
      InfoWindow.prototype.show = function (coordinate) {
          if (!this.getMap()) {
              return this;
          }
          if (!this.getMap().options['enableInfoWindow']) {
              return this;
          }
          return _super.prototype.show.call(this, coordinate);
      };
      InfoWindow.prototype.getEvents = function () {
          if (!this.options['autoCloseOn']) {
              return null;
          }
          var events = {};
          events[this.options['autoCloseOn']] = this.hide;
          return events;
      };
      InfoWindow.prototype.getOwnerEvents = function () {
          var owner = this.getOwner();
          if (!this.options['autoOpenOn'] || !owner) {
              return null;
          }
          var events = {};
          events[this.options['autoOpenOn']] = this._onAutoOpen;
          return events;
      };
      InfoWindow.prototype.onRemove = function () {
          this._onDomMouseout();
          this.onDomRemove();
      };
      InfoWindow.prototype.onDomRemove = function () {
          if (this._onCloseBtnClick) {
              var dom = this.getDOM();
              var closeBtn = dom.childNodes[2];
              removeDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
              delete this._onCloseBtnClick;
          }
      };
      //@internal
      InfoWindow.prototype._onAutoOpen = function (e) {
          var _this = this;
          var owner = this.getOwner();
          setTimeout(function () {
              if (owner instanceof Marker || owner instanceof UIComponent) {
                  _this.show(owner.getCoordinates());
              }
              else if (owner instanceof MultiPoint) {
                  _this.show(owner.findClosest(e.coordinate));
              }
              else if ((owner instanceof LineString) || (owner instanceof MultiLineString)) {
                  if (_this.getMap().getScale() >= 8) {
                      e.coordinate = _this._rectifyMouseCoordinte(owner, e.coordinate);
                  }
                  _this.show(e.coordinate);
              }
              else {
                  _this.show(e.coordinate);
              }
          }, 1);
      };
      //@internal
      InfoWindow.prototype._rectifyMouseCoordinte = function (owner, mouseCoordinate) {
          var _this = this;
          if (owner instanceof LineString) {
              return this._rectifyLineStringMouseCoordinate(owner, mouseCoordinate).coordinate;
          }
          else if (owner instanceof MultiLineString) {
              return owner.getGeometries().map(function (lineString) {
                  return _this._rectifyLineStringMouseCoordinate(lineString, mouseCoordinate);
              }).sort(function (a, b) {
                  return a.dis - b.dis;
              })[0].coordinate;
          }
          // others
          return mouseCoordinate;
      };
      //@internal
      InfoWindow.prototype._rectifyLineStringMouseCoordinate = function (lineString, mouseCoordinate) {
          var map = this.getMap();
          var coordinates = lineString.getCoordinates() || [];
          var glRes = map.getGLRes();
          //coordinates to containerpoints
          var pts = coordinates.map(function (coordinate) {
              var renderPoints = map.coordToPointAtRes(coordinate, glRes);
              var altitude = coordinate.z || 0;
              return map._pointAtResToContainerPoint(renderPoints, glRes, altitude);
          });
          var mousePt = map.coordToContainerPoint(mouseCoordinate);
          var minDis = Infinity, coordinateIndex = -1;
          // Find the point with the shortest distance
          for (var i = 0, len = pts.length; i < len; i++) {
              var pt = pts[i];
              var dis = mousePt.distanceTo(pt);
              if (dis < minDis) {
                  minDis = dis;
                  coordinateIndex = i;
              }
          }
          var indexs = [coordinateIndex - 1, coordinateIndex, coordinateIndex + 1].filter(function (index) {
              return index >= 0 && index <= pts.length - 1;
          });
          var filterPts = indexs.map(function (index) {
              return pts[index];
          });
          var xys = [];
          var _a = map.getSize(), width = _a.width, height = _a.height;
          //Calculate all pixels in the field of view
          for (var i = 0, len = filterPts.length - 1; i < len; i++) {
              var coordinateIndex_1 = i;
              var pt1 = filterPts[i], pt2 = filterPts[i + 1];
              // Vertical line
              if (pt1.x === pt2.x) {
                  var miny = Math.max(0, Math.min(pt1.y, pt2.y));
                  var maxy = Math.min(height, Math.max(pt1.y, pt2.y));
                  for (var y_1 = miny; y_1 <= maxy; y_1++) {
                      xys.push({
                          point: new Point(pt1.x, y_1),
                          coordinateIndex: coordinateIndex_1
                      });
                  }
              }
              else {
                  var k = (pt2.y - pt1.y) / (pt2.x - pt1.x);
                  // y-y0=k(x-x0)
                  // y-pt1.y=k(x-pt1.x)
                  var minx = Math.max(0, Math.min(pt1.x, pt2.x));
                  var maxx = Math.min(width, Math.max(pt1.x, pt2.x));
                  for (var x_1 = minx; x_1 <= maxx; x_1++) {
                      var y_2 = k * (x_1 - pt1.x) + pt1.y;
                      xys.push({
                          point: new Point(x_1, y_2),
                          coordinateIndex: coordinateIndex_1
                      });
                  }
              }
          }
          var minPtDis = Infinity, ptIndex = -1, index = -1, containerPoint;
          // Find the point with the shortest distance
          for (var i = 0, len = xys.length; i < len; i++) {
              var _b = xys[i], point = _b.point, coordinateIndex_2 = _b.coordinateIndex;
              var dis = mousePt.distanceTo(point);
              if (dis < minPtDis) {
                  minPtDis = dis;
                  ptIndex = i;
                  index = coordinateIndex_2;
                  containerPoint = point;
              }
          }
          if (ptIndex < 0) {
              return {
                  dis: minPtDis,
                  coordinate: mouseCoordinate
              };
          }
          // const coordinate = map.containerPointToCoord(containerPoint);
          var p1 = filterPts[index], p2 = filterPts[index + 1];
          var distance = p1.distanceTo(p2);
          var d = containerPoint.distanceTo(p1);
          var percent = d / distance;
          var filterCoordinates = indexs.map(function (index) {
              return coordinates[index];
          });
          var c1 = filterCoordinates[index], c2 = filterCoordinates[index + 1];
          var x1 = c1.x, y1 = c1.y, z1 = c1.z || 0;
          var x2 = c2.x, y2 = c2.y, z2 = c2.z || 0;
          var dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;
          var x = x1 + dx * percent, y = y1 + dy * percent, z = z1 + dz * percent;
          return {
              dis: minPtDis,
              coordinate: new Coordinate(x, y, z)
          };
      };
      //@internal
      InfoWindow.prototype._getWindowWidth = function () {
          var defaultWidth = options$h.width;
          var width = this.options['width'];
          if (!width) {
              width = defaultWidth;
          }
          return width;
      };
      return InfoWindow;
  }(UIComponent));
  InfoWindow.mergeOptions(options$h);

  var HIDEDOMEVENTS = 'remove hide shapechange positionchange dragend animatestart';
  /**
   * @property {Object} options
   * @property {Number}  [options.width=0]     - default width
   * @property {Number}  [options.height=0]     - default height
   * @property {String}  [options.animation='fade']     - default fade, scale | fade,scale are an alternative to set
   * @property {String}  [options.cssName=maptalks-tooltip]    - tooltip's css class name
   * @property {Number}  [options.showTimeout=400]      - timeout to show tooltip
   * @memberOf ui.ToolTip
   * @instance
   */
  var options$g = {
      'width': 0,
      'height': 0,
      'animation': 'fade',
      'containerClass': 'maptalks-tooltip',
      'showTimeout': 400
  };
  /**
   * @classdesc
   * Class for tooltip, a tooltip used for showing some useful infomation attached to geometries on the map.
   * @category ui
   * @extends ui.UIComponent
   * @memberOf ui
   */
  var ToolTip = /** @class */ (function (_super) {
      __extends(ToolTip, _super);
      /**
       * @param {String} content         - content of tooltip
       * @param {Object} [options=null]  - options defined in [ToolTip]{@link ToolTip#options}
       */
      function ToolTip(content, options) {
          if (options === void 0) { options = {}; }
          var _this = _super.call(this, options) || this;
          _this._content = content;
          return _this;
      }
      // TODO:obtain class in super
      //@internal
      ToolTip.prototype._getClassName = function () {
          return 'ToolTip';
      };
      /**
       * Adds the UI Component to a geometry UIMarker Other graphic elements
       * @param {Geometry} owner - geometry to add.
       * @returns {UIComponent} this
       * @fires UIComponent#add
       */
      ToolTip.prototype.addTo = function (owner) {
          if (ToolTip.isSupport(owner)) {
              owner.on('mousemove', this.onMouseMove, this);
              owner.on('mouseout', this.onMouseOut, this);
              owner.on(HIDEDOMEVENTS, this.hideDom, this);
              return _super.prototype.addTo.call(this, owner);
          }
          else {
              throw new Error('Invalid geometry or UIMarker the tooltip is added to.');
          }
      };
      /**
       * set ToolTip's content's css class name.
       * @param {String} css class name - set for ToolTip's content.
       */
      ToolTip.prototype.setStyle = function (cssName) {
          this.options.containerClass = cssName;
          return this;
      };
      /**
       * get ToolTip's  content's css class name
       * @returns {String} css class name - set for ToolTip's content.
       */
      ToolTip.prototype.getStyle = function () {
          return this.options.containerClass;
      };
      /**
       * get the UI Component's content
       * @returns {String} tooltip's content
       */
      ToolTip.prototype.getContent = function () {
          return this._content;
      };
      ToolTip.prototype.buildOn = function () {
          var dom = createEl('div');
          var options = this.options || {};
          if (options.height) {
              dom.style.height = options.height + 'px';
          }
          if (options.width) {
              dom.style.width = options.width + 'px';
          }
          var cssName = options.containerClass || options.cssName;
          if (!cssName && options.height) {
              dom.style.lineHeight = options.height + 'px';
          }
          if (isFunction(this._content)) {
              //dymatic render dom content
              this._content.bind(this)(dom);
          }
          else {
              dom.innerHTML = "<div class=\"".concat(cssName, "\">").concat(this._content, "</div>");
          }
          this._appendCustomClass(dom);
          return dom;
      };
      ToolTip.prototype.onMouseOut = function () {
          clearTimeout(this._timeout);
          if (this.isVisible()) {
              this._removePrevDOM();
          }
          this._switchMapEvents('off');
      };
      ToolTip.prototype.onMouseMove = function (e) {
          var _this = this;
          clearTimeout(this._timeout);
          var map = this.getMap();
          if (!map) {
              return;
          }
          var coord = map.locateByPoint(e.coordinate, -5, 25);
          if (this.options['showTimeout'] === 0) {
              this.show(coord);
          }
          else {
              this._timeout = setTimeout(function () {
                  if (map) {
                      _this.show(coord);
                  }
              }, this.options['showTimeout']);
          }
      };
      /**
       * remove the tooltip, this method will be called by 'this.remove()'
       */
      ToolTip.prototype.onRemove = function () {
          clearTimeout(this._timeout);
          if (this._owner) {
              this._owner.off('mousemove', this.onMouseMove, this);
              this._owner.off('mouseout', this.onMouseOut, this);
              this._owner.off(HIDEDOMEVENTS, this.hideDom, this);
          }
      };
      ToolTip.prototype.hideDom = function () {
          this.hide();
      };
      ToolTip.prototype.onEvent = function () {
          _super.prototype.onEvent.call(this);
          this.hideDom();
          return this;
      };
      /**
       * override UIComponent method
       * ignore altitude calculation
       */
      //@internal
      ToolTip.prototype._getViewPoint = function () {
          return this.getMap().coordToViewPoint(this._coordinate, undefined, 0)
              ._add(this.options['dx'], this.options['dy']);
      };
      return ToolTip;
  }(UIComponent));
  ToolTip.mergeOptions(options$g);

  /**
   * @property {Object} options
   * @property {Boolean} [options.autoPan=false]  - set it to false if you don't want the map to do panning animation to fit the opened menu.
   * @property {Number}  [options.width=160]      - default width
   * @property {Number}  [options.maxHeight=0]    - default max-height
   * @property {String|HTMLElement} [options.custom=false]  - set it to true if you want a customized menu, customized html codes or a HTMLElement is set to items.
   * @property {Object[]|String|HTMLElement}  options.items   - html code or a html element is options.custom is true. Or a menu items array, containing: item objects, "-" as a splitor line
   * @memberOf ui.Menu
   * @instance
   */
  var defaultOptions = {
      'containerClass': 'maptalks-menu',
      'animation': null,
      'animationDelay': 10,
      'animationOnHide': false,
      'autoPan': false,
      'width': 160,
      'maxHeight': 0,
      'custom': false,
      'items': []
  };
  /**
   * @classdesc
   * Class for context menu, useful for interactions with right clicks on the map.
   * @category ui
   * @extends ui.UIComponent
   * @memberOf ui
   */
  var Menu = /** @class */ (function (_super) {
      __extends(Menu, _super);
      /**
       * Menu items is set to options.items or by setItems method. <br>
       * <br>
       * Normally items is a object array, containing: <br>
       * 1. item object: {'item': 'This is a menu text', 'click': function() {alert('oops! You clicked!');)}} <br>
       * 2. minus string "-", which will draw a splitor line on the menu. <br>
       * <br>
       * If options.custom is set to true, the menu is considered as a customized one. Then items is the customized html codes or HTMLElement. <br>
       * @param {Object} options - options defined in [ui.Menu]{@link ui.Menu#options}
       */
      function Menu(options) {
          return _super.call(this, options) || this;
      }
      // TODO: obtain class in super
      //@internal
      Menu.prototype._getClassName = function () {
          return 'Menu';
      };
      Menu.prototype.addTo = function (owner) {
          if (owner._menu && owner._menu !== this) {
              owner.removeMenu();
          }
          owner._menu = this;
          this._owner = owner;
          return UIComponent.prototype.addTo.apply(this, [owner]);
      };
      /**
       * Set the items of the menu.
       * @param {Object[]|String|HTMLElement} items - items of the menu
       * return {ui.Menu} this
       * @example
       * menu.setItems([
       *      //return false to prevent event propagation
       *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},
       *     '-',
       *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},
       *     {'item': 'About', 'click': function() {alert('About Clicked!')}}
       * ]);
       */
      Menu.prototype.setItems = function (items) {
          this.options['items'] = items;
          return this;
      };
      /**
       * Get items of  the menu.
       * @return {Object[]|String|HTMLElement} - items of the menu
       */
      Menu.prototype.getItems = function () {
          return this.options['items'] || [];
      };
      /**
       * Create the menu DOM.
       * @protected
       * @return {HTMLElement} menu's DOM
       */
      Menu.prototype.buildOn = function () {
          var dom;
          if (this.options['custom']) {
              if (isString(this.options['items'])) {
                  var container = createEl('div');
                  container.innerHTML = this.options['items'];
                  this._appendCustomClass(container);
                  dom = container;
              }
              else {
                  dom = this.options['items'];
              }
          }
          else {
              dom = createEl('div');
              if (this.options['containerClass']) {
                  addClass(dom, this.options['containerClass']);
              }
              dom.style.width = this._getMenuWidth() + 'px';
              /*const arrow = createEl('em');
              addClass(arrow, 'maptalks-ico');*/
              var menuItems = this._createMenuItemDom();
              // dom.appendChild(arrow);
              dom.appendChild(menuItems);
              on(dom, 'contextmenu', preventDefault);
              this._appendCustomClass(dom);
          }
          if (dom) {
              this._bindDomEvents(dom, 'off');
              this._bindDomEvents(dom, 'on');
          }
          return dom;
      };
      /**
       * Offset of the menu DOM to fit the click position.
       * @return {Point} offset
       * @private
       */
      Menu.prototype.getOffset = function () {
          if (!this.getMap()) {
              return null;
          }
          var mapSize = this.getMap().getSize(), p = this.getMap().viewPointToContainerPoint(this._getViewPoint()), size = this.getSize();
          var dx = 0, dy = 0;
          if (p.x + size['width'] > mapSize['width']) {
              dx = -size['width'];
          }
          if (p.y + size['height'] > mapSize['height']) {
              dy = -size['height'];
          }
          return new Point(dx, dy);
      };
      Menu.prototype.getTransformOrigin = function () {
          var p = this.getOffset()._multi(-1);
          return p.x + 'px ' + p.y + 'px';
      };
      Menu.prototype.getEvents = function () {
          return {
              '_zoomstart _zoomend _movestart _dblclick _click': this._removePrevDOM
          };
      };
      //@internal
      Menu.prototype._createMenuItemDom = function () {
          var me = this;
          var map = this.getMap();
          var ul = createEl('ul');
          addClass(ul, 'maptalks-menu-items');
          var items = this.getItems();
          function onMenuClick(index) {
              return function (e) {
                  var param = map._parseEvent(e, 'click');
                  param['target'] = me;
                  param['owner'] = me._owner;
                  param['index'] = index;
                  var result = this._callback(param);
                  if (result === false) {
                      return;
                  }
                  me.hide();
                  if (me._owner) {
                      me._owner.fire('closemenu');
                  }
              };
          }
          var item, itemDOM;
          for (var i = 0, len = items.length; i < len; i++) {
              item = items[i];
              if (item === '-' || item === '_') {
                  itemDOM = createEl('li');
                  addClass(itemDOM, 'maptalks-menu-splitter');
              }
              else {
                  itemDOM = createEl('li');
                  var itemTitle = item['item'];
                  if (isFunction(itemTitle)) {
                      itemTitle = itemTitle({
                          'owner': this._owner,
                          'index': i
                      });
                  }
                  itemDOM.innerHTML = itemTitle;
                  itemDOM._callback = item['click'];
                  on(itemDOM, 'click', (onMenuClick)(i));
              }
              ul.appendChild(itemDOM);
          }
          var maxHeight = this.options['maxHeight'] || 0;
          if (maxHeight > 0) {
              setStyle(ul, 'max-height: ' + maxHeight + 'px; overflow-y: auto;');
          }
          return ul;
      };
      //@internal
      Menu.prototype._getMenuWidth = function () {
          var defaultWidth = 160;
          var width = this.options['width'] || defaultWidth;
          return width;
      };
      return Menu;
  }(UIComponent));
  Menu.mergeOptions(defaultOptions);

  /**
   * Mixin of the context menu methods.
   * @mixin ui.Menuable
   */
  var Menuable = {
      /**
       * Set a context menu
       * @param {Object} options - menu options
       * @return {*} this
       * @example
       * foo.setMenu({
       *  'width'  : 160,
       *  'custom' : false,
       *  'items' : [
       *      //return false to prevent event propagation
       *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},
       *     '-',
       *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},
       *     {'item': 'About', 'click': function() {alert('About Clicked!')}}
       *    ]
       * });
       * @function ui.Menuable.setMenu
       */
      setMenu: function (options) {
          this._menuOptions = options;
          if (this._menu) {
              this._menu.setOptions(options);
          }
          else {
              this.on('contextmenu', this._defaultOpenMenu, this);
          }
          return this;
      },
      /**
      * get a context menu
      * @return {*} ui.Menu
      * @function ui.Menuable.getMenu
      */
      getMenu: function () {
          return this._menu;
      },
      /**
       * Open the context menu, default on the center of the geometry or map.
       * @param {Coordinate} [coordinate=null] - coordinate to open the context menu
       * @return {*} this
       * @function ui.Menuable.openMenu
       */
      openMenu: function (coordinate) {
          var map = (this instanceof Map$1) ? this : this.getMap();
          if (!coordinate) {
              coordinate = this.getCenter();
          }
          if (!this._menu) {
              if (this._menuOptions && map) {
                  this._bindMenu();
                  this._menu.show(coordinate);
              }
          }
          else {
              this._menu.show(coordinate);
          }
          /**
             * openmenu event
             *
             * @event Geometry#openmenu
             * @type {Object}
             * @property {String} type - openmenu
             * @property {Geometry} target - the geometry fires the event
             */
          /**
           * openmenu event
           *
           * @event Map#openmenu
           * @type {Object}
           * @property {String} type - openmenu
           * @property {Map} target - the Map fires the event
           */
          this.fire('openmenu', {
              coordinate: coordinate
          });
          return this;
      },
      /**
       * Set menu items to the context menu
       * @param {Object[]} items - menu items
       * @return {*} this
       * @function ui.Menuable.setMenuItems
       */
      setMenuItems: function (items) {
          if (!this._menuOptions) {
              this._menuOptions = {};
          }
          if (Array.isArray(items)) {
              this._menuOptions['custom'] = false;
          }
          this._menuOptions['items'] = items;
          this.setMenu(this._menuOptions);
          return this;
      },
      /**
       * Get the context menu items
       * @return {Object[]}
       * @function ui.Menuable.getMenuItems
       */
      getMenuItems: function () {
          if (this._menu) {
              return this._menu.getItems();
          }
          else if (this._menuOptions) {
              return this._menuOptions['items'] || [];
          }
          return [];
      },
      /**
       * Close the contexnt menu
       * @return {*} this
       * @function ui.Menuable.closeMenu
       */
      closeMenu: function () {
          if (this._menu) {
              this._menu.hide();
          }
          /**
         * closemenu event
         *
         * @event Geometry#closemenu
         * @type {Object}
         * @property {String} type - closemenu
         * @property {Geometry} target - the geometry fires the event
         */
          /**
           * closemenu event
           *
           * @event Map#closemenu
           * @type {Object}
           * @property {String} type - closemenu
           * @property {Map} target - the Map fires the event
           */
          this.fire('closemenu', {});
          return this;
      },
      /**
       * Remove the context menu
       * @return {*} this
       * @function ui.Menuable.removeMenu
       */
      removeMenu: function () {
          this.off('contextmenu', this._defaultOpenMenu, this);
          this._unbindMenu();
          delete this._menuOptions;
          /**
          * removemenu event
          *
          * @event Geometry#removemenu
          * @type {Object}
          * @property {String} type - removemenu
          * @property {Geometry} target - the geometry fires the event
          */
          /**
           * removemenu event
           *
           * @event Map#removemenu
           * @type {Object}
           * @property {String} type - removemenu
           * @property {Map} target - the Map fires the event
           */
          this.fire('removemenu', {});
          return this;
      },
      //@internal
      _bindMenu: function () {
          if (!this._menuOptions) {
              return this;
          }
          this._menu = new Menu(this._menuOptions);
          this._menu.addTo(this);
          return this;
      },
      //@internal
      _unbindMenu: function () {
          if (this._menu) {
              this.closeMenu();
              this._menu.remove();
              delete this._menu;
          }
          return this;
      },
      /**
       * If contextmenu is not listened, open the menu in default.<br>
       * Otherwise, do nothing here.
       * @param  {Object} param - event parameter
       * @return {Boolean} true | false to stop event propagation
       * @private
       */
      //@internal
      _defaultOpenMenu: function (param) {
          // 如果用户想自定义右键菜单，其不应该setMenu,既然其设置了说明就是想用默认的menu,应该根据是否设置了menu为参考依据而不是 contextmenu监听次数
          this.openMenu(param['coordinate']);
          return false;
      }
  };
  Map$1.include(Menuable);
  Geometry.include(Menuable);

  var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    InfoWindow: InfoWindow,
    Menu: Menu,
    Menuable: Menuable,
    ToolTip: ToolTip,
    UIComponent: UIComponent,
    UIMarker: UIMarker
  });

  /**
   * Base class for all the map controls, you can extend it to build your own customized Control.
   * It is abstract and not intended to be instantiated.
   * @category control
   * @memberOf control
   * @abstract
   * @extends Class
   * @mixes Eventable
   */
  var Control = /** @class */ (function (_super) {
      __extends(Control, _super);
      /**
       * Methods needs to implement:  <br>
       *  <br>
       * 1. Method to create UI's Dom element  <br>
       * function buildOn : HTMLElement  <br>
       *  <br>
       * 2. Optional, a callback when the control is added.  <br>
       * function onAdd : void  <br>
       * 3. Optional, a callback when the control is removed.  <br>
       * function onRemove : void  <br>
       *  <br>
       * @param  {Object} [options=null] configuration options
       */
      function Control(options) {
          if (options && options['position'] && !isString(options['position'])) {
              options['position'] = extend$2({}, options['position']);
          }
          return _super.call(this, options) || this;
      }
      //@internal
      Control.prototype._appendCustomClass = function (dom) {
          if (!dom) {
              console.warn('dom is null:', dom);
              return this;
          }
          if (this.options.cssName) {
              var cssName = this.options.cssName;
              if (!Array.isArray(cssName)) {
                  cssName = [cssName];
              }
              cssName.forEach(function (name) {
                  dom.classList.add(name);
              });
          }
          return this;
      };
      Control.prototype.onAdd = function () {
      };
      Control.prototype.onRemove = function () {
      };
      /**
       * Adds the control to a map.
       * @param {Map} map
       * @returns {control.Control} this
       * @fires control.Control#add
       */
      Control.prototype.addTo = function (map) {
          this.remove();
          if (!map.options['control']) {
              return this;
          }
          this._map = map;
          var controlContainer = map.getPanels().control;
          this.__ctrlContainer = createEl('div');
          setStyle(this.__ctrlContainer, 'position:absolute;overflow:visible;');
          // on(this.__ctrlContainer, 'mousedown mousemove click dblclick contextmenu', stopPropagation)
          this.update();
          controlContainer.appendChild(this.__ctrlContainer);
          if (this.onAdd) {
              this.onAdd();
          }
          /**
           * add event.
           *
           * @event control.Control#add
           * @type {Object}
           * @property {String} type - add
           * @property {control.Control} target - the control instance
           */
          this.fire('add', {
              'dom': controlContainer
          });
          return this;
      };
      /**
       * update control container
       * @return {control.Control} this
       */
      Control.prototype.update = function () {
          this.__ctrlContainer.innerHTML = '';
          this._controlDom = this.buildOn(this.getMap());
          if (this._controlDom) {
              this._updatePosition();
              this.__ctrlContainer.appendChild(this._controlDom);
          }
          return this;
      };
      /**
       * Get the map that the control is added to.
       * @return {Map}
       */
      Control.prototype.getMap = function () {
          return this._map;
      };
      /**
       * Get the position of the control
       * @return {Object}
       */
      Control.prototype.getPosition = function () {
          return extend$2({}, this._parse(this.options['position']));
      };
      /**
       * update the control's position
       * @param {String|Object} position - can be one of 'top-left', 'top-right', 'bottom-left', 'bottom-right' or a position object like {'top': 40,'left': 60}
       * @return {control.Control} this
       * @fires control.Control#positionchange
       */
      Control.prototype.setPosition = function (position) {
          if (isString(position)) {
              this.options['position'] = position;
          }
          else {
              this.options['position'] = extend$2({}, position);
          }
          this._updatePosition();
          return this;
      };
      /**
       * Get the container point of the control.
       * @return {Point}
       */
      Control.prototype.getContainerPoint = function () {
          var position = this.getPosition();
          var size = this.getMap().getSize();
          var x, y;
          if (!isNil(position['left'])) {
              x = parseInt(position['left'] + '');
          }
          else if (!isNil(position['right'])) {
              x = size['width'] - parseInt(position['right'] + '');
          }
          if (!isNil(position['top'])) {
              y = parseInt(position['top'] + '');
          }
          else if (!isNil(position['bottom'])) {
              y = size['height'] - parseInt(position['bottom'] + '');
          }
          return new Point(x, y);
      };
      /**
       * Get the control's container.
       * Container is a div element wrapping the control's dom and decides the control's position and display.
       * @return {HTMLElement}
       */
      Control.prototype.getContainer = function () {
          return this.__ctrlContainer;
      };
      /**
       * Get html dom element of the control
       * @return {HTMLElement}
       */
      Control.prototype.getDOM = function () {
          return this._controlDom;
      };
      /**
       * Show
       * @return {control.Control} this
       */
      Control.prototype.show = function () {
          this.__ctrlContainer.style.display = '';
          return this;
      };
      /**
       * Hide
       * @return {control.Control} this
       */
      Control.prototype.hide = function () {
          this.__ctrlContainer.style.display = 'none';
          return this;
      };
      /**
       * Whether the control is visible
       * @return {Boolean}
       */
      Control.prototype.isVisible = function () {
          return (this.__ctrlContainer && this.__ctrlContainer.style.display === '');
      };
      /**
       * Remove itself from the map
       * @return {control.Control} this
       * @fires control.Control#remove
       */
      Control.prototype.remove = function () {
          if (!this._map) {
              return this;
          }
          removeDomNode(this.__ctrlContainer);
          if (this.onRemove) {
              this.onRemove();
          }
          delete this._map;
          delete this.__ctrlContainer;
          delete this._controlDom;
          /**
           * remove event.
           *
           * @event control.Control#remove
           * @type {Object}
           * @property {String} type - remove
           * @property {control.Control} target - the control instance
           */
          this.fire('remove');
          return this;
      };
      //@internal
      Control.prototype._parse = function (position) {
          var p = position;
          if (isString(position)) {
              p = Control['positions'][p];
          }
          return p;
      };
      //@internal
      Control.prototype._updatePosition = function () {
          var position = this.getPosition();
          if (!position) {
              //default one
              position = {
                  'top': 20,
                  'left': 20
              };
          }
          for (var p in position) {
              if (position.hasOwnProperty(p)) {
                  var v = position[p] || 0;
                  if (isNumber(v)) {
                      v += 'px';
                  }
                  this.__ctrlContainer.style[p] = v;
              }
          }
          /**
           * Control's position update event.
           *
           * @event control.Control#positionchange
           * @type {Object}
           * @property {String} type - positionchange
           * @property {control.Control} target - the control instance
           * @property {Object} position - Position of the control, eg:{"top" : 100, "left" : 50}
           */
          this.fire('positionchange', {
              'position': extend$2({}, position)
          });
      };
      return Control;
  }(Eventable(Class)));
  Control.positions = {
      'top-left': {
          'top': 20,
          'left': 20
      },
      'top-right': {
          'top': 20,
          'right': 20
      },
      'bottom-left': {
          'bottom': 20,
          'left': 20
      },
      'bottom-right': {
          'bottom': 20,
          'right': 20
      }
  };
  Map$1.mergeOptions({
      'control': true
  });
  Map$1.include(/** @lends Map.prototype */ {
      /**
       * Add a control on the map.
       * @param {control.Control} control - contorl to add
       * @return {Map} this
       */
      addControl: function (control) {
          // if map container is a canvas, can't add control on it.
          if (this._containerDOM.getContext) {
              return this;
          }
          control.addTo(this);
          return this;
      },
      /**
       * Remove a control from the map.
       * @param {control.Control} control - control to remove
       * @return {Map} this
       */
      removeControl: function (control) {
          if (!control || control.getMap() !== this) {
              return this;
          }
          control.remove();
          return this;
      }
  });

  /**
   * @property {Object} options - options
   * @property {Object} [options.position='bottom-left'] - position of the control, this option defined in [Control.position]{@link Control#positions}.
   * @property {String} [options.content='Powered by <a href="http://maptalks.org" target="_blank">maptalks</a>']  - content of the attribution control, HTML format
   * @memberOf control.Attribution
   * @instance
   */
  var options$f = {
      'position': {
          'bottom': 0,
          'left': 0
      },
      'content': '<a href="http://maptalks.org" target="_blank">maptalks</a>'
  };
  var layerEvents = 'addlayer removelayer setbaselayer baselayerremove';
  /**
   * @classdesc
   * A control to allows to display attribution content in a small text box on the map.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var map = new maptalks.Map('map', {
   *    center: [-0.113049, 51.498568],
   *    zoom: 14,
   *    attribution: {
   *       content : 'my attribution',
   *       position : 'bottom-left'
   *    },
   *    baseLayer: new maptalks.TileLayer('base', {
   *        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
   *        subdomains: ['a','b','c','d'],
   *        attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
   *    })
   * });
   * map.addLayer(new maptalks.TileLayer('base', {
   *      urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
   *      subdomains: ['a','b','c','d'],
   *      attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
   * }));
   */
  var Attribution = /** @class */ (function (_super) {
      __extends(Attribution, _super);
      function Attribution() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Attribution.prototype.buildOn = function () {
          this._attributionContainer = createEl('div');
          this._attributionContainer.className = 'maptalks-attribution';
          this._appendCustomClass(this._attributionContainer);
          this._update();
          return this._attributionContainer;
      };
      Attribution.prototype.onAdd = function () {
          this.getMap().on(layerEvents, this._update, this);
      };
      Attribution.prototype.onRemove = function () {
          this.getMap().off(layerEvents, this._update, this);
      };
      //@internal
      Attribution.prototype._update = function () {
          var map = this.getMap();
          if (!map) {
              return;
          }
          var attributions = map
              ._getLayers(function (layer) { return !!layer.options['attribution']; })
              .reverse()
              .map(function (layer) { return layer.options['attribution']; });
          var content = this.options['content'] + (attributions.length > 0 ? ' - ' + attributions.join(', ') : '');
          this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + content + '</span>';
      };
      return Attribution;
  }(Control));
  Attribution.mergeOptions(options$f);
  Map$1.mergeOptions({
      'attribution': true
  });
  Map$1.addOnLoadHook(function () {
      var a = this.options['attribution'] || this.options['attributionControl'];
      if (a) {
          this.attributionControl = new Attribution(a);
          this.addControl(this.attributionControl);
      }
  });

  /**
   * @property {Object}   options - options
   * @property {String|Object}   [options.position="top-left"]  - position of the compass control.
   * @memberOf control.Compass
   * @instance
   * @example
   * var compassControl = new Compass({
   *     position : 'top-left',
   * }).addTo(map);
   */
  var options$e = {
      position: {
          'top': 120,
          'left': 20
      }
  };
  var Compass = /** @class */ (function (_super) {
      __extends(Compass, _super);
      function Compass() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Compass.prototype.buildOn = function (map) {
          var compass = this._getCompass();
          this._appendCustomClass(compass);
          this._compass = compass;
          this._registerDomEvents();
          map.on('resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange', this._rotateCompass, this);
          return compass;
      };
      Compass.prototype.onAdd = function () {
          this._rotateCompass();
      };
      //@internal
      Compass.prototype._getCompass = function () {
          var compass = createEl('div', 'maptalks-compass');
          return compass;
      };
      //@internal
      Compass.prototype._registerDomEvents = function () {
          on(this._compass, 'click', this._resetView, this);
      };
      //@internal
      Compass.prototype._rotateCompass = function () {
          var b = this.getMap().getBearing().toFixed(1);
          var bearing = parseFloat(b);
          if (bearing <= 180)
              bearing *= -1;
          if (bearing !== this._bearing) {
              this._bearing = bearing;
              setStyle(this._compass, "transform: rotate(".concat(this._bearing, "deg);"));
          }
      };
      Compass.prototype.onRemove = function () {
          this.getMap().off('resize moving moveend zooming zoomend rotate rotateend dragrotating dragrotateend viewchange', this._rotateCompass, this);
          delete this._compass;
          delete this._bearing;
      };
      //@internal
      Compass.prototype._resetView = function () {
          var view = { bearing: 0 };
          this.getMap().animateTo(view);
      };
      return Compass;
  }(Control));
  Compass.mergeOptions(options$e);
  Map$1.mergeOptions({
      'compassControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['compassControl']) {
          this.compassControl = new Compass(this.options['compassControl']);
          this.addControl(this.compassControl);
      }
  });

  /**
   * @property {Object} options - options
   * @property {Object} [options.position='top-right'] - position of the control
   * @property {Object} [options.baseTitle='Base Layers'] - title of the base layers
   * @property {Object} [options.overlayTitle='Layers'] - title of the overlay layers
   * @property {Object} [options.excludeLayers=[]] - ids of layers that don't display in layerswitcher
   * @property {Object} [options.containerClass=maptalks-layer-switcher] - layerswitcher's container div's CSS class
   *
   * @memberOf control.LayerSwitcher
   * @instance
   */
  var options$d = {
      'position': 'top-right',
      'baseTitle': 'Base Layers',
      'overlayTitle': 'Layers',
      'excludeLayers': [],
      'containerClass': 'maptalks-layer-switcher'
  };
  /**
   * @classdesc
   * A LayerSwitcher control for the map.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var LayerSwitcher = new LayerSwitcher({
   *     position : {'top': '0', 'right': '0'}
   * }).addTo(map);
  */
  var LayerSwitcher = /** @class */ (function (_super) {
      __extends(LayerSwitcher, _super);
      function LayerSwitcher() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @return {HTMLDOMElement}
       */
      LayerSwitcher.prototype.buildOn = function () {
          var container = this.container = createEl('div', this.options['containerClass']), panel = this.panel = createEl('div', 'panel'), button = this.button = createEl('button');
          container.appendChild(button);
          container.appendChild(panel);
          this._appendCustomClass(container);
          return container;
      };
      LayerSwitcher.prototype.onAdd = function () {
          on(this.button, 'mouseover', this._show, this);
          on(this.panel, 'mouseleave', this._hide, this);
          // on(this.getMap(), 'click', this._hide, this);
      };
      LayerSwitcher.prototype.onRemove = function () {
          if (this.panel) {
              off(this.button, 'mouseover', this._show);
              off(this.panel, 'mouseleave', this._hide);
              // off(this.getMap(), 'click', this._hide);
              removeDomNode(this.panel);
              removeDomNode(this.button);
              delete this.panel;
              delete this.button;
              delete this.container;
          }
      };
      //@internal
      LayerSwitcher.prototype._show = function () {
          if (!hasClass(this.container, 'shown')) {
              addClass(this.container, 'shown');
              this._createPanel();
          }
      };
      //@internal
      LayerSwitcher.prototype._hide = function (e) {
          if (!this.panel.contains(e.toElement || e.relatedTarget)) {
              setClass(this.container, this.options['containerClass']);
          }
      };
      //@internal
      LayerSwitcher.prototype._createPanel = function () {
          this.panel.innerHTML = '';
          var ul = createEl('ul');
          this.panel.appendChild(ul);
          this._renderLayers(this.getMap(), ul);
      };
      //@internal
      LayerSwitcher.prototype._renderLayers = function (map, elm) {
          var _this = this;
          var base = map.getBaseLayer(), layers = map.getLayers(), len = layers.length;
          if (base) {
              var baseLayers = base.layers || [base], li = createEl('li', 'group'), ul = createEl('ul'), label = createEl('label');
              label.innerHTML = this.options['baseTitle'];
              li.appendChild(label);
              for (var i = 0, len_1 = baseLayers.length; i < len_1; i++) {
                  var layer = baseLayers[i];
                  if (this._isExcluded(layer)) {
                      ul.appendChild(this._renderLayer(baseLayers[i], true));
                      li.appendChild(ul);
                      elm.appendChild(li);
                  }
              }
          }
          if (len) {
              var li = createEl('li', 'group'), ul = createEl('ul'), label = createEl('label'), input = createEl('input');
              //checkbox for select/cancel all overlaylayers
              input.type = 'checkbox';
              input.checked = true;
              label.innerHTML = this.options['overlayTitle'];
              li.appendChild(input);
              li.appendChild(label);
              var groupInputOnChange = function (e) {
                  var checked = e.target.checked;
                  var parentNode = e.target.parentNode;
                  if (!parentNode) {
                      return;
                  }
                  var ul = parentNode.getElementsByTagName('ul')[0];
                  if (!ul) {
                      return;
                  }
                  var parentLayerShow = function (node) {
                      var layer = node._layer;
                      if (layer) {
                          layer[checked ? 'show' : 'hide']();
                      }
                  };
                  var layerShow = function (li) {
                      var layer = li._layer, checkbox = li.childNodes[0];
                      if (checkbox) {
                          checkbox.checked = checked;
                      }
                      if (layer) {
                          layer[checked ? 'show' : 'hide']();
                      }
                  };
                  parentLayerShow(parentNode);
                  ul.childNodes.forEach(function (li) {
                      layerShow(li);
                      //检查其是否有子节点,such as :groupgllayer
                      var childUl = li.getElementsByTagName('ul')[0];
                      if (!childUl) {
                          return;
                      }
                      parentLayerShow(li);
                      childUl.childNodes.forEach(function (li) {
                          layerShow(li);
                      });
                  });
              };
              var _loop_1 = function (i) {
                  var layer = layers[i];
                  if (this_1._isExcluded(layer)) {
                      //such as :groupgllayer
                      if (layer.getLayers) {
                          var groupLi = createEl('li', 'group'), groupUl_1 = createEl('ul'), groupLabel = createEl('label'), groupInput_1 = createEl('input');
                          groupLabel.innerHTML = layer.getId();
                          groupInput_1.type = 'checkbox';
                          groupInput_1.checked = layer.isVisible();
                          groupInput_1.onchange = groupInputOnChange;
                          groupLi.appendChild(groupInput_1);
                          groupLi.appendChild(groupLabel);
                          groupLi.appendChild(groupUl_1);
                          groupLi._layer = layer;
                          ul.appendChild(groupLi);
                          var groupLayers = layer.getLayers() || [];
                          groupLayers.forEach(function (layer) {
                              groupUl_1.appendChild(_this._renderLayer(layer, false, groupInput_1.checked));
                          });
                      }
                      else {
                          ul.appendChild(this_1._renderLayer(layer));
                      }
                      //只要有一个子节点不选中，顶级节点就不选中
                      if (layer && !layer.isVisible()) {
                          input.checked = false;
                      }
                  }
              };
              var this_1 = this;
              for (var i = 0; i < len; i++) {
                  _loop_1(i);
              }
              li.appendChild(ul);
              elm.appendChild(li);
              input.onchange = groupInputOnChange;
          }
      };
      //@internal
      LayerSwitcher.prototype._isExcluded = function (layer) {
          var id = layer.getId(), excludeLayers = this.options['excludeLayers'];
          return !(excludeLayers.length && excludeLayers.indexOf(id) >= 0);
      };
      //@internal
      LayerSwitcher.prototype._renderLayer = function (layer, isBase, parentChecked) {
          var _this = this;
          if (parentChecked === void 0) { parentChecked = true; }
          var li = createEl('li', 'layer'), label = createEl('label'), input = createEl('input'), map = this.getMap();
          var visible = layer.options['visible'];
          layer.options['visible'] = true;
          var enabled = layer.isVisible();
          layer.options['visible'] = visible;
          li.className = 'layer';
          var radioInput = input;
          if (isBase) {
              radioInput.type = 'radio';
              radioInput.name = 'base';
          }
          else {
              radioInput.type = 'checkbox';
          }
          radioInput.checked = visible && enabled;
          //父节点没有选中，那么子节点一定不选中
          if (!parentChecked) {
              radioInput.checked = false;
          }
          if (!enabled) {
              radioInput.setAttribute('disabled', 'disabled');
          }
          radioInput.onchange = function (e) {
              if (e.target.type === 'radio') {
                  var baseLayer = map.getBaseLayer(), baseLayers = baseLayer.layers;
                  if (baseLayers) {
                      for (var i = 0, len = baseLayers.length; i < len; i++) {
                          var childLayer = baseLayers[i];
                          childLayer[childLayer === layer ? 'show' : 'hide']();
                      }
                  }
                  else if (!baseLayer.isVisible()) {
                      baseLayer.show();
                  }
                  map._fireEvent('setbaselayer');
              }
              else {
                  layer[e.target.checked ? 'show' : 'hide']();
              }
              _this.fire('layerchange', { target: layer });
          };
          li.appendChild(input);
          label.innerHTML = layer.getId();
          li.appendChild(label);
          li._layer = layer;
          return li;
      };
      return LayerSwitcher;
  }(Control));
  LayerSwitcher.mergeOptions(options$d);
  Map$1.mergeOptions({
      'layerSwitcherControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['layerSwitcherControl']) {
          this.layerSwitcherControl = new LayerSwitcher(this.options['layerSwitcherControl']);
          this.addControl(this.layerSwitcherControl);
      }
  });

  /**
   * @property {Object} options - options
   * @property {Object} [options.position='bottom-right'] - position of the control
   * @property {Number} [options.level=4]  - the zoom level of the overview
   * @property {Object} [options.maximize=true]  - whether to maximize overview when added
   * @property {Object} [options.size=[300, 200]  - size of the Control
   * @property {Object} [options.symbol={}] - symbol of the overview rectangle
   * @property {Object} [options.containerClass=maptalks-overview] - overview's container div's CSS class
   * @property {Object} [options.buttonClass=maptalks-overview-button] - overview's minimize/maximize button's CSS class
   *
   * @memberOf control.Overview
   * @instance
   */
  var options$c = {
      'level': 4,
      'position': {
          'right': 1,
          'bottom': 1
      },
      'size': [300, 200],
      'maximize': true,
      'symbol': {
          'lineWidth': 3,
          'lineColor': '#1bbc9b',
          'polygonFill': '#1bbc9b',
          'polygonOpacity': 0.4
      },
      'containerClass': 'maptalks-overview',
      'buttonClass': 'maptalks-overview-button'
  };
  /**
   * @classdesc
   * An overview control for the map.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var overview = new Overview({
   *     position: {'bottom': '0', 'right': '0'},
   *     size: [300, 200]
   * }).addTo(map);
   */
  var Overview = /** @class */ (function (_super) {
      __extends(Overview, _super);
      function Overview() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Overview.prototype.buildOn = function () {
          var size = this.options['size'];
          if (!this.options['maximize']) {
              size = [0, 0];
          }
          var container = createEl('div');
          this._appendCustomClass(container);
          var mapContainer = this.mapContainer = createEl('div');
          mapContainer.style.width = size[0] + 'px';
          mapContainer.style.height = size[1] + 'px';
          mapContainer.className = this.options['containerClass'];
          var button = this.button = createEl('div');
          button.className = this.options['buttonClass'];
          container.appendChild(mapContainer);
          container.appendChild(button);
          return container;
      };
      Overview.prototype.onAdd = function () {
          if (this.options['maximize']) {
              this._createOverview();
          }
          this.getMap().on('resize moving zooming rotate dragrotating viewchange', this._update, this)
              .on('setbaselayer', this._updateBaseLayer, this)
              .on('spatialreferencechange', this._updateSpatialReference, this);
          on(this.button, 'click', this._onButtonClick, this);
          this._updateButtonText();
      };
      Overview.prototype.onRemove = function () {
          this.getMap()
              .off('resize moving zooming rotate dragrotating viewchange', this._update, this)
              .off('setbaselayer', this._updateBaseLayer, this)
              .off('spatialreferencechange', this._updateSpatialReference, this);
          if (this._overview) {
              this._overview.remove();
              delete this._overview;
              delete this._perspective;
          }
          off(this.button, 'click', this._onButtonClick);
      };
      /**
       * Maximize overview control
       * @returns {control.Overview}
       */
      Overview.prototype.maxmize = function () {
          var size = this.options['size'];
          var dom = this.mapContainer;
          dom.style.width = size[0] + 'px';
          dom.style.height = size[1] + 'px';
          this._createOverview();
          return this;
      };
      /**
       * Minimize overview control
       * @returns {control.Overview}
       */
      Overview.prototype.minimize = function () {
          if (this._overview) {
              this._overview.remove();
          }
          delete this._overview;
          delete this._perspective;
          var dom = this.mapContainer;
          dom.style.width = 0 + 'px';
          dom.style.height = 0 + 'px';
          return this;
      };
      /**
       * Return overview's map object
       * @returns {Map}
       */
      Overview.prototype.getOverviewMap = function () {
          return this._overview;
      };
      //@internal
      Overview.prototype._onButtonClick = function () {
          if (!this._overview) {
              this.maxmize();
          }
          else {
              this.minimize();
          }
          this._updateButtonText();
      };
      //@internal
      Overview.prototype._updateButtonText = function () {
          if (this._overview) {
              this.button.innerHTML = '-';
          }
          else {
              this.button.innerHTML = '+';
          }
      };
      //@internal
      Overview.prototype._createOverview = function () {
          var map = this.getMap(), dom = this.mapContainer;
          var options = map.config();
          extend$2(options, {
              'center': map.getCenter(),
              'zoom': this._getOverviewZoom(),
              'zoomAnimationDuration': 150,
              'pitch': 0,
              'bearing': 0,
              'scrollWheelZoom': false,
              'checkSize': false,
              'doubleClickZoom': false,
              'touchZoom': false,
              'control': false,
              'draggable': false,
              'maxExtent': null
          });
          this._overview = new Map$1(dom, options);
          this._updateBaseLayer();
          this._perspective = new Polygon(this._getPerspectiveCoords(), {
              'draggable': true,
              'cursor': 'move',
              'symbol': this.options['symbol']
          })
              .on('dragend', this._onDragEnd, this);
          new VectorLayer('perspective_layer', this._perspective).addTo(this._overview);
          this.fire('load');
      };
      //@internal
      Overview.prototype._getOverviewZoom = function () {
          var map = this.getMap(), zoom = map.getZoom(), minZoom = map.getMinZoom(), level = this.options['level'];
          if (level > 0) {
              for (var i = level; i > 0; i--) {
                  if (zoom - i >= minZoom) {
                      return zoom - i;
                  }
              }
          }
          else {
              for (var i = level; i < 0; i++) {
                  if (zoom - i >= minZoom) {
                      return zoom - i;
                  }
              }
          }
          return zoom;
      };
      //@internal
      Overview.prototype._onDragEnd = function () {
          var center = this._perspective.getCenter();
          this._overview.setCenter(center);
          this.getMap().panTo(center);
      };
      //@internal
      Overview.prototype._getPerspectiveCoords = function () {
          var map = this.getMap();
          var projection = map.getProjection();
          return map.getContainerExtent().toArray().map(function (c) {
              if (projection) {
                  var prjCoord = map._containerPointToPrj(c);
                  map._fixPrjOnWorldWide(prjCoord);
                  return projection.unproject(prjCoord);
              }
              return map.containerPointToCoordinate(c);
          });
      };
      //@internal
      Overview.prototype._update = function () {
          if (!this._overview) {
              return;
          }
          // refresh map's dom position
          computeDomPosition(this._overview.getContainer());
          var coords = this._getPerspectiveCoords();
          this._perspective.setCoordinates(coords);
          this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom());
      };
      //@internal
      Overview.prototype._updateSpatialReference = function () {
          if (!this._overview) {
              return;
          }
          var map = this.getMap();
          var spatialRef = map.options['spatialReference'];
          this._overview.setSpatialReference(spatialRef);
      };
      //@internal
      Overview.prototype._updateBaseLayer = function () {
          if (!this._overview) {
              return;
          }
          var map = this.getMap(), baseLayer = map.getBaseLayer();
          if (!baseLayer) {
              this._overview.setBaseLayer(null);
              return;
          }
          var layers = baseLayer.layers;
          var showIndex = 0;
          if (layers) {
              for (var i = 0, l = layers.length; i < l; i++) {
                  var layer_1 = layers[i];
                  if (layer_1.isVisible()) {
                      showIndex = i;
                      break;
                  }
              }
          }
          var json = baseLayer.toJSON();
          var options = null;
          if (layers) {
              options = json.layers[showIndex].options;
              options.visible = true;
          }
          else {
              options = json.options;
          }
          this._overview.setMinZoom(options.minZoom || null)
              .setMaxZoom(options.maxZoom || null);
          delete options.minZoom;
          delete options.maxZoom;
          delete json.options.canvas;
          json.options.visible = true;
          json.options.renderer = 'canvas';
          var layer = Layer.fromJSON(json);
          for (var p in baseLayer) {
              if (isFunction(baseLayer[p]) && baseLayer.hasOwnProperty(p) && baseLayer[p] !== baseLayer.constructor.prototype[p]) {
                  layer[p] = baseLayer[p];
              }
          }
          this._overview.setBaseLayer(layer);
      };
      return Overview;
  }(Control));
  Overview.mergeOptions(options$c);
  Map$1.mergeOptions({
      'overviewControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['overviewControl']) {
          this.overviewControl = new Overview(this.options['overviewControl']);
          this.addControl(this.overviewControl);
      }
  });

  /**
   * @property {Object} options - options
   * @property {Object} [options.position='top-right']       - position of the control
   * @property {Boolean} [options.draggable=true]            - whether the panel can be dragged
   * @property {Boolean} [options.custom=false]              - whether the panel's content is customized .
   * @property {String|HTMLElement} options.content          - panel's content, can be a dom element or a string.
   * @property {Boolean} [options.closeButton=true]          - whether to display the close button on the panel.
   * @memberOf control.Panel
   * @instance
   */
  var options$b = {
      'position': 'top-right',
      'draggable': true,
      'custom': false,
      'content': '',
      'closeButton': true
  };
  /**
   * @classdesc
   * Class for panel controls.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var panel = new Panel({
   *     position : {'bottom': '0', 'right': '0'},
   *     draggable : true,
   *     custom : false,
   *     content : '<div class="map-panel">hello </div>',
   *     closeButton : true
   * }).addTo(map);
   */
  var Panel = /** @class */ (function (_super) {
      __extends(Panel, _super);
      function Panel() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Panel.prototype.buildOn = function () {
          var _this = this;
          var dom;
          if (this.options['custom']) {
              if (isString(this.options['content'])) {
                  dom = createEl('div');
                  dom.innerHTML = this.options['content'];
                  this._appendCustomClass(dom);
              }
              else {
                  dom = this.options['content'];
              }
          }
          else {
              dom = createEl('div', 'maptalks-panel');
              this._appendCustomClass(dom);
              if (this.options['closeButton']) {
                  var closeButton = createEl('a', 'maptalks-close');
                  closeButton.innerText = '×';
                  closeButton.href = 'javascript:;';
                  closeButton.onclick = function () {
                      dom.style.display = 'none';
                      _this.fire('close');
                  };
                  dom.appendChild(closeButton);
              }
              var panelContent = createEl('div', 'maptalks-panel-content');
              if (isString(this.options['content'])) {
                  panelContent.innerHTML = this.options['content'];
              }
              else {
                  panelContent.appendChild(this.options.content);
              }
              dom.appendChild(panelContent);
          }
          this.draggable = new DragHandler(dom, {
              'cancelOn': this._cancelOn.bind(this),
              'ignoreMouseleave': true
          });
          this.draggable.on('dragstart', this._onDragStart, this)
              .on('dragging', this._onDragging, this)
              .on('dragend', this._onDragEnd, this);
          if (this.options['draggable']) {
              this.draggable.enable();
          }
          return dom;
      };
      /**
       * update control container
       * @return {control.Panel} this
       */
      Panel.prototype.update = function () {
          if (this.draggable) {
              this.draggable.disable();
              delete this.draggable;
          }
          return Control.prototype.update.call(this);
      };
      /**
       * Set the content of the Panel.
       * @param {String|HTMLElement} content - content of the infowindow.
       * return {control.Panel} this
       * @fires Panel#contentchange
       */
      Panel.prototype.setContent = function (content) {
          var old = this.options['content'];
          this.options['content'] = content;
          /**
           * contentchange event.
           *
           * @event Panel#contentchange
           * @type {Object}
           * @property {String} type - contentchange
           * @property {control.Panel} target - Panel
           * @property {String|HTMLElement} old      - old content
           * @property {String|HTMLElement} new      - new content
           */
          this.fire('contentchange', {
              'old': old,
              'new': content
          });
          if (this.isVisible()) {
              this.update();
          }
          return this;
      };
      /**
       * Get content of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      Panel.prototype.getContent = function () {
          return this.options['content'];
      };
      //@internal
      Panel.prototype._cancelOn = function (domEvent) {
          var target = domEvent.srcElement || domEvent.target, tagName = target.tagName.toLowerCase();
          if (tagName === 'button' ||
              tagName === 'input' ||
              tagName === 'select' ||
              tagName === 'option' ||
              tagName === 'textarea') {
              return true;
          }
          return false;
      };
      //@internal
      Panel.prototype._onDragStart = function (param) {
          this._startPos = param['mousePos'];
          this._startPosition = extend$2({}, this.getPosition());
          /**
           * drag start event
           * @event control.Panel#dragstart
           * @type {Object}
           * @property {String} type        - dragstart
           * @property {UIMarker} target    - the panel control fires event
           * @property {Point} mousePos     - mouse position
           * @property {Event} domEvent     - dom event
           */
          this.fire('dragstart', param);
      };
      //@internal
      Panel.prototype._onDragging = function (param) {
          var pos = param['mousePos'];
          var offset = pos.sub(this._startPos);
          var startPosition = this._startPosition;
          var position = this.getPosition();
          if (!isNil(position['top'])) {
              position['top'] = parseInt(startPosition['top']) + offset.y;
          }
          if (!isNil(position['bottom'])) {
              position['bottom'] = parseInt(startPosition['bottom']) - offset.y;
          }
          if (!isNil(position['left'])) {
              position['left'] = parseInt(startPosition['left']) + offset.x;
          }
          if (!isNil(position['right'])) {
              position['right'] = parseInt(startPosition['right']) - offset.x;
          }
          this.setPosition(position);
          /**
           * dragging event
           * @event control.Panel#dragging
           * @type {Object}
           * @property {String} type        - dragging
           * @property {UIMarker} target    - the panel control fires event
           * @property {Point} mousePos     - mouse position
           * @property {Event} domEvent     - dom event
           */
          this.fire('dragging', param);
      };
      //@internal
      Panel.prototype._onDragEnd = function (param) {
          delete this._startPos;
          delete this._startPosition;
          /**
           * drag end event
           * @event control.Panel#dragend
           * @type {Object}
           * @property {String} type        - dragend
           * @property {UIMarker} target    - the panel control fires event
           * @property {Point} mousePos     - mouse position
           * @property {Event} domEvent     - dom event
           */
          this.fire('dragend', param);
      };
      /**
       * Get the connect points of panel for connector lines.
       * @private
       */
      //@internal
      Panel.prototype._getConnectPoints = function () {
          var map = this.getMap();
          var containerPoint = this.getContainerPoint();
          var dom = this.getDOM(), width = parseInt(dom.clientWidth + ''), height = parseInt(dom.clientHeight + '');
          var anchors = [
              //top center
              map.containerPointToCoordinate(containerPoint.add(width / 2, 0)),
              //middle right
              map.containerPointToCoordinate(containerPoint.add(width, height / 2)),
              //bottom center
              map.containerPointToCoordinate(containerPoint.add(width / 2, height)),
              //middle left
              map.containerPointToCoordinate(containerPoint.add(0, height / 2))
          ];
          return anchors;
      };
      return Panel;
  }(Control));
  Panel.mergeOptions(options$b);

  /**
   * @property {Object}   options - options
   * @property {String|Object}   [options.position="top-left"]  - position of the rest control.
   * @memberOf control.Reset
   * @instance
   * @example
   * var resetControl = new Reset({
   *     position : 'top-left',
   * }).addTo(map);
   */
  var options$a = {
      position: {
          'top': 156,
          'left': 20
      },
      view: null
  };
  var Reset = /** @class */ (function (_super) {
      __extends(Reset, _super);
      function Reset() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Reset.prototype.buildOn = function () {
          var reset = this._getReset();
          this._appendCustomClass(reset);
          this._reset = reset;
          this._registerDomEvents();
          return reset;
      };
      Reset.prototype.onAdd = function () {
          this._view = !this.options.view ? this.getMap().getView() : this.options.view;
      };
      Reset.prototype.setView = function (view) {
          this._view = view;
      };
      //@internal
      Reset.prototype._getReset = function () {
          var reset = createEl('div', 'maptalks-reset');
          return reset;
      };
      //@internal
      Reset.prototype._registerDomEvents = function () {
          on(this._reset, 'click', this._resetView, this);
      };
      Reset.prototype.onRemove = function () {
          delete this._reset;
          delete this._view;
      };
      //@internal
      Reset.prototype._resetView = function () {
          this.getMap().setView(this._view);
      };
      return Reset;
  }(Control));
  Reset.mergeOptions(options$a);
  Map$1.mergeOptions({
      'resetControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['resetControl']) {
          this.resetControl = new Reset(this.options['resetControl']);
          this.addControl(this.resetControl);
      }
  });

  /**
   * @property {Object} [options=null] - options
   * @property {String|Object}   [options.position="bottom-left"]  - position of the scale control.
   * @property {Number} [options.maxWidth=100]               - max width of the scale control.
   * @property {Boolean} [options.metric=true]               - Whether to show the metric scale line (m/km).
   * @property {Boolean} [options.imperial=false]            - Whether to show the imperial scale line (mi/ft).
   * @property {String|Object} [options.containerClass=null]           - scalControl's container div's CSS class
   * @instance
   * @memberOf control.Scale
   */
  var options$9 = {
      'position': 'bottom-left',
      'maxWidth': 100,
      'metric': true,
      'imperial': false,
      'containerClass': null
  };
  /**
   * @classdesc
   * Based on scale control of Leaflet, a simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var scale = new Scale({
   *     position : 'bottom-left',
   *     maxWidth : 160,
   *     metric : true,
   *     imperial : true,
   *     containerClass : null
   * }).addTo(map);
   */
  var EVENTS_TO_LISTEN = 'zoomend moving moveend';
  var Scale = /** @class */ (function (_super) {
      __extends(Scale, _super);
      function Scale() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Scale.prototype.buildOn = function (map) {
          this._map = map;
          this._scaleContainer = createEl('div', this.options['containerClass']);
          this._addScales();
          map.on(EVENTS_TO_LISTEN, this._update, this);
          if (this._map.isLoaded()) {
              this._update();
          }
          this._appendCustomClass(this._scaleContainer);
          return this._scaleContainer;
      };
      Scale.prototype.onRemove = function () {
          this.getMap().off(EVENTS_TO_LISTEN, this._update, this);
      };
      //@internal
      Scale.prototype._addScales = function () {
          var css = 'border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;' +
              'color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden' +
              ';-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);';
          if (this.options['metric']) {
              this._mScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
          }
          if (this.options['imperial']) {
              this._iScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
          }
      };
      //@internal
      Scale.prototype._update = function () {
          var map = this._map;
          var maxMeters = map.pixelToDistance(this.options['maxWidth'], 0);
          this._updateScales(maxMeters);
      };
      //@internal
      Scale.prototype._updateScales = function (maxMeters) {
          if (this.options['metric'] && maxMeters) {
              this._updateMetric(maxMeters);
          }
          if (this.options['imperial'] && maxMeters) {
              this._updateImperial(maxMeters);
          }
      };
      //@internal
      Scale.prototype._updateMetric = function (maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
          this._updateScale(this._mScale, label, meters / maxMeters);
      };
      //@internal
      Scale.prototype._updateImperial = function (maxMeters) {
          var maxFeet = maxMeters * 3.2808399;
          var maxMiles, miles, feet;
          if (maxFeet > 5280) {
              maxMiles = maxFeet / 5280;
              miles = this._getRoundNum(maxMiles);
              this._updateScale(this._iScale, miles + ' mile', miles / maxMiles);
          }
          else {
              feet = this._getRoundNum(maxFeet);
              this._updateScale(this._iScale, feet + ' feet', feet / maxFeet);
          }
      };
      //@internal
      Scale.prototype._updateScale = function (scale, text, ratio) {
          scale['style']['width'] = Math.round(this.options['maxWidth'] * ratio) + 'px';
          scale['innerHTML'] = text;
      };
      //@internal
      Scale.prototype._getRoundNum = function (num) {
          var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
          var d = num / pow10;
          d = d >= 10 ? 10 :
              d >= 5 ? 5 :
                  d >= 3 ? 3 :
                      d >= 2 ? 2 : 1;
          return pow10 * d;
      };
      return Scale;
  }(Control));
  Scale.mergeOptions(options$9);
  Map$1.mergeOptions({
      'scaleControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['scaleControl']) {
          this.scaleControl = new Scale(this.options['scaleControl']);
          this.addControl(this.scaleControl);
      }
  });

  /**
   * @property {Object}   options - options
   * @property {String|Object}   [options.position="top-right"]          - position of the toolbar control.
   * @property {Boolean}  [options.vertical=true]                        - Whether the toolbar is a vertical one.
   * @property {Boolean}  [options.reverseMenu=false]                    - Whether to reverse direction of drop menu.
   * @property {Object[]} options.items                                  - items on the toolbar. 'item':content of button,support HTML.'height': height in pixels,'click':click function,'children': displayed menus by hovering
   * @memberOf control.Toolbar
   * @instance
   */
  var options$8 = {
      'height': 28,
      'vertical': false,
      'position': 'top-right',
      'reverseMenu': false,
      'items': []
      //default buttons
  };
  /**
   * @classdesc
   * A toolbar control of the map.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var toolbar = new Toolbar({
   *     position : 'top-right',
   *     items: [
   *          {
   *            item: 'item1',
   *            click: function () {
   *              alert('item1 clicked');
   *            }
   *          },
   *          {
   *            item: 'item2',
   *            click: function () {
   *              alert('item2 clicked');
   *            }
   *          }
   *      ]
   * }).addTo(map);
   */
  var Toolbar = /** @class */ (function (_super) {
      __extends(Toolbar, _super);
      function Toolbar() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Toolbar.prototype.buildOn = function (map) {
          this._map = map;
          var dom = createEl('div');
          var ul = createEl('ul', 'maptalks-toolbar-hx');
          dom.appendChild(ul);
          if (this.options['vertical']) {
              addClass(dom, 'maptalks-toolbar-vertical');
          }
          else {
              addClass(dom, 'maptalks-toolbar-horizonal');
          }
          var me = this;
          function onButtonClick(fn, index, childIndex, targetDom) {
              var item = me._getItems()[index];
              return function (e) {
                  stopPropagation(e);
                  return fn({
                      'target': item,
                      'index': index,
                      'childIndex': childIndex,
                      'dom': targetDom
                  });
              };
          }
          var items = this.options['items'];
          if (isArrayHasData(items)) {
              for (var i = 0, len = items.length; i < len; i++) {
                  var item = items[i];
                  var li = createEl('li');
                  if (this.options['height'] !== 28) {
                      li.style.lineHeight = this.options['height'] + 'px';
                  }
                  li.style.height = this.options['height'] + 'px';
                  li.style.cursor = 'pointer';
                  if (isHTML(item['item'])) {
                      li.style.textAlign = 'center';
                      var itemSize = measureDom('div', item['item']);
                      //vertical-middle
                      li.innerHTML = '<div style="margin-top:' + (this.options['height'] - itemSize['height']) / 2 + 'px;">' + item['item'] + '</div>';
                  }
                  else {
                      li.innerHTML = item['item'];
                  }
                  if (item['click']) {
                      on(li, 'click', (onButtonClick)(item['click'], i, null, li));
                  }
                  if (isArrayHasData(item['children'])) {
                      var dropMenu = this._createDropMenu(i);
                      li.appendChild(dropMenu);
                      li._menu = dropMenu;
                      on(li, 'mouseover', function () {
                          this._menu.style.display = '';
                      });
                      on(li, 'mouseout', function () {
                          this._menu.style.display = 'none';
                      });
                  }
                  ul.appendChild(li);
              }
          }
          this._appendCustomClass(dom);
          return dom;
      };
      //@internal
      Toolbar.prototype._createDropMenu = function (index) {
          var me = this;
          function onButtonClick(fn, index, childIndex) {
              var item = me._getItems()[index]['children'][childIndex];
              return function (e) {
                  stopPropagation(e);
                  return fn({
                      'target': item,
                      'index': index,
                      'childIndex': childIndex
                  });
              };
          }
          var menuDom = createEl('div', 'maptalks-dropMenu'), items = this._getItems(), len = items.length, menuUL = createEl('ul'), children = items[index]['children'];
          if (index === len - 1 && children) {
              menuDom.style.cssText = 'right: 0px;';
              menuUL.style.cssText = 'right: 0px;position: absolute;';
              if (this.options['reverseMenu']) {
                  menuUL.style.bottom = 0 + '';
              }
          }
          menuDom.appendChild(createEl('em', 'maptalks-ico'));
          var liWidth = 0;
          for (var i = 0, l = children.length; i < l; i++) {
              var size = stringLength(children[i]['item'], '12px');
              if (size.width > liWidth) {
                  liWidth = size.width;
              }
          }
          for (var i = 0, l = children.length; i < l; i++) {
              var child = children[i];
              var li = createEl('li');
              li.innerHTML = '<a href="javascript:;">' + child['item'] + '</a>';
              li.style.cursor = 'pointer';
              li.style.width = (liWidth + 24) + 'px'; // 20 for text-intent
              on(li.childNodes[0], 'click', (onButtonClick)(child['click'], index, i));
              menuUL.appendChild(li);
          }
          if (this.options['vertical']) {
              var width = liWidth < 95 ? 95 : liWidth;
              if (this.options['reverseMenu']) {
                  menuDom.style.right = -(width + 10 * 2 + 2) + 'px';
              }
              else {
                  menuDom.style.left = -(width + 10 * 2 + 2) + 'px'; // 10: padding in .maptalks-toolbar-vertical li
              }
          }
          else if (this.options['reverseMenu']) {
              menuDom.style.bottom = '28px';
          }
          else {
              menuDom.style.top = '29px';
          }
          menuDom.appendChild(menuUL);
          menuDom.style.display = 'none';
          return menuDom;
      };
      //@internal
      Toolbar.prototype._getItems = function () {
          return this.options['items'] || [];
      };
      return Toolbar;
  }(Control));
  Toolbar.mergeOptions(options$8);

  // import DragHandler from '../handler/Drag';
  /**
   * @property {Object}   options - options
   * @property {String|Object}   [options.position="top-left"]  - position of the zoom control.
   * @property {Boolean}  [options.zoomLevel=true]                      - Whether to display the text box of zoom level
   * @memberOf control.Zoom
   * @instance
   */
  var options$7 = {
      'position': 'top-left',
      // 'slider': true,
      'zoomLevel': true,
      'seamless': false
  };
  // const UNIT = 10;
  /**
   * @classdesc
   * A zoom control with buttons to zoomin/zoomout and a slider indicator for the zoom level.
   * @category control
   * @extends control.Control
   * @memberOf control
   * @example
   * var zoomControl = new Zoom({
   *     position : 'top-left',
   *     slider : true,
   *     zoomLevel : false
   * }).addTo(map);
   */
  var Zoom = /** @class */ (function (_super) {
      __extends(Zoom, _super);
      function Zoom() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      Zoom.prototype.buildOn = function (map) {
          var options = this.options;
          var dom = createEl('div', 'maptalks-zoom');
          this._appendCustomClass(dom);
          if (options['zoomLevel']) {
              var levelWrapper = createEl('span', 'maptalks-zoom-zoomlevel');
              var levelDOM = createEl('span', 'maptalks-zoom-zoomlevel-text');
              levelWrapper.appendChild(levelDOM);
              dom.appendChild(levelWrapper);
              this._levelDOM = levelDOM;
          }
          var zoomDOM = createEl('div', 'maptalks-zoom-slider');
          var zoomInButton = createEl('a', 'maptalks-zoom-zoomin');
          zoomInButton.href = 'javascript:;';
          zoomDOM.appendChild(zoomInButton);
          this._zoomInButton = zoomInButton;
          // if (options['slider']) {
          //     const box = createEl('div', 'maptalks-zoom-slider-box');
          //     const ruler = createEl('div', 'maptalks-zoom-slider-ruler');
          //     const reading = createEl('span', 'maptalks-zoom-slider-reading');
          //     const dot = createEl('span', 'maptalks-zoom-slider-dot');
          //     ruler.appendChild(reading);
          //     box.appendChild(ruler);
          //     box.appendChild(dot);
          //     zoomDOM.appendChild(box);
          //     this._sliderBox = box;
          //     this._sliderRuler = ruler;
          //     this._sliderReading = reading;
          //     this._sliderDot = dot;
          // }
          var zoomOutButton = createEl('a', 'maptalks-zoom-zoomout');
          zoomOutButton.href = 'javascript:;';
          zoomDOM.appendChild(zoomOutButton);
          this._zoomOutButton = zoomOutButton;
          dom.appendChild(zoomDOM);
          map.on('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);
          this._update();
          this._registerDomEvents();
          return dom;
      };
      Zoom.prototype.onRemove = function () {
          this.getMap().off('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);
          // if (this._zoomInButton) {
          //     off(this._zoomInButton, 'click', this._onZoomInClick, this);
          // }
          // if (this._zoomOutButton) {
          //     off(this._zoomOutButton, 'click', this._onZoomOutClick, this);
          // }
          // if (this._sliderRuler) {
          //     off(this._sliderRuler, 'click', this._onClickRuler, this);
          //     this.dotDragger.disable();
          //     delete this.dotDragger;
          // }
      };
      //@internal
      Zoom.prototype._update = function () {
          // const map = this.getMap();
          // if (this._sliderBox) {
          //     const totalRange = (map.getMaxZoom() - map.getMinZoom()) * UNIT;
          //     this._sliderBox.style.height = totalRange + 16 + 'px';
          //     this._sliderRuler.style.height = totalRange + 8 + 'px';
          //     this._sliderRuler.style.cursor = 'pointer';
          //     const zoomRange = (map.getMaxZoom() - map.getZoom()) * UNIT;
          //     //this._sliderReading.style.height = (map.getZoom() - map.getMinZoom()) * UNIT + 'px';
          //     this._sliderReading.style.height = (map.getZoom() - map.getMinZoom() + 1) * UNIT + 'px';
          //     this._sliderDot.style.top = zoomRange + 'px';
          // }
          this._updateText();
      };
      //@internal
      Zoom.prototype._updateText = function () {
          if (this._levelDOM) {
              var map = this.getMap();
              var zoom = map.getZoom();
              if (!isInteger(zoom)) {
                  zoom = Math.floor(zoom * 10) / 10;
              }
              this._levelDOM.innerHTML = zoom + '';
          }
      };
      //@internal
      Zoom.prototype._registerDomEvents = function () {
          if (this._zoomInButton) {
              on(this._zoomInButton, 'click', this._onZoomInClick, this);
          }
          if (this._zoomOutButton) {
              on(this._zoomOutButton, 'click', this._onZoomOutClick, this);
          }
          // if (this._sliderRuler) {
          //     on(this._sliderRuler, 'click', this._onClickRuler, this);
          //     this.dotDragger = new DragHandler(this._sliderDot, {
          //         'ignoreMouseleave' : true
          //     });
          //     this.dotDragger.on('dragstart', this._onDotDragstart, this)
          //         .on('dragging dragend', this._onDotDrag, this)
          //         .enable();
          // }
      };
      //@internal
      Zoom.prototype._onZoomInClick = function (e) {
          preventDefault(e);
          this.getMap().zoomIn();
      };
      //@internal
      Zoom.prototype._onZoomOutClick = function (e) {
          preventDefault(e);
          this.getMap().zoomOut();
      };
      return Zoom;
  }(Control));
  Zoom.mergeOptions(options$7);
  Map$1.mergeOptions({
      'zoomControl': false
  });
  Map$1.addOnLoadHook(function () {
      if (this.options['zoomControl']) {
          this.zoomControl = new Zoom(this.options['zoomControl']);
          this.addControl(this.zoomControl);
      }
  });

  var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Attribution: Attribution,
    Compass: Compass,
    Control: Control,
    LayerSwitcher: LayerSwitcher,
    Overview: Overview,
    Panel: Panel,
    Reset: Reset,
    Scale: Scale,
    Toolbar: Toolbar,
    Zoom: Zoom
  });

  /**
   * @classdesc
   * A class internally used by tile layer helps to descibe tile system used by different tile services.<br>
   *
   * @class
   * @category layer
   * @example
   * var ts = new TileSystem([1, -1, -20037508.34, 20037508.34]);
   */
  var TileSystem = /** @class */ (function () {
      /**
       * Similar with [transformation]{@link Transformation}, it contains 4 numbers: sx, sy, ox, oy.<br>
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}
       * @param sx the order of X-axis tile index, 1 means right is larger and -1 means the reverse, left is larger;
       * @param sy the order of Y-axis tile index, 1 means bottom is larger and -1 means the reverse, top is larger;
       * @param ox x of the origin point of the world's projected coordinate system
       * @param oy y of the origin point of the world's projected coordinate system
       */
      function TileSystem(sx, sy, ox, oy) {
          if (Array.isArray(sx)) {
              this.scale = {
                  x: sx[0],
                  y: sx[1]
              };
              this.origin = {
                  x: sx[2],
                  y: sx[3]
              };
          }
          else {
              this.scale = {
                  x: sx,
                  y: sy
              };
              this.origin = {
                  x: ox,
                  y: oy
              };
          }
      }
      /**
       * Get the default tile system's code for the projection.
       * @param projection      - a projection object
       * @return tile system code
       */
      TileSystem.getDefault = function (projection) {
          var code = projection['code'].toLowerCase();
          if (code === 'baidu') {
              return 'baidu';
          }
          else if (code === 'EPSG:4326'.toLowerCase() || code === 'EPSG:4490'.toLowerCase()) {
              return 'tms-global-geodetic';
          }
          else if (code === 'identity') {
              return [1, -1, 0, 0];
          }
          else {
              return 'web-mercator';
          }
      };
      return TileSystem;
  }());
  var semiCircum = 6378137 * Math.PI;
  extend$2(TileSystem, /** @lends TileSystem */ {
      /**
       * The most common used tile system, used by google maps, bing maps and amap, soso maps in China.
       * @see {@link https://en.wikipedia.org/wiki/Web_Mercator}
       * @constant
       * @static
       */
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      'web-mercator': new TileSystem([1, -1, -semiCircum, semiCircum]),
      /**
       * Predefined tile system for TMS tile system, A tile system published by [OSGEO]{@link http://www.osgeo.org/}. <br>
       * Also used by mapbox's [mbtiles]{@link https://github.com/mapbox/mbtiles-spec} specification.
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}
       * @constant
       * @static
       */
      'tms-global-mercator': new TileSystem([1, 1, -semiCircum, -semiCircum]),
      /**
       * Another tile system published by [OSGEO]{@link http://www.osgeo.org/}, based on EPSG:4326 SRS.
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic}
       * @constant
       * @static
       */
      'tms-global-geodetic': new TileSystem([1, 1, -180, -90]),
      /**
       * Tile system used by [baidu]{@link http://map.baidu.com}
       * @constant
       * @static
       */
      'baidu': new TileSystem([1, 1, 0, 0])
  });

  /* eslint-disable @typescript-eslint/ban-ts-comment */
  /**
   * Tile config for tile layers, an utilities class for tile layers to render tiles
   * @class
   * @category layer
   * @private
   */
  var TileConfig = /** @class */ (function () {
      /**
       * @param tileSystem  - tileSystem
       * @param fullExtent      - fullExtent of the tile layer
       * @param tileSize          - tile size
       */
      function TileConfig(map, tileSystem, fullExtent, tileSize) {
          this.map = map;
          this.tileSize = tileSize;
          this.fullExtent = fullExtent;
          this.prepareTileInfo(tileSystem, fullExtent);
          this._xScale = fullExtent['right'] >= fullExtent['left'] ? 1 : -1;
          this._yScale = fullExtent['top'] >= fullExtent['bottom'] ? 1 : -1;
          var glRes = map.getGLRes();
          this._pointOrigin = map._prjToPointAtRes(new Point(this.tileSystem['origin']), glRes);
          this._glRes = glRes;
      }
      TileConfig.prototype.prepareTileInfo = function (tileSystem, fullExtent) {
          if (isString(tileSystem)) {
              tileSystem = TileSystem[tileSystem.toLowerCase()];
          }
          else if (Array.isArray(tileSystem)) {
              tileSystem = new TileSystem(tileSystem);
          }
          if (!tileSystem) {
              throw new Error('Invalid TileSystem');
          }
          this.tileSystem = tileSystem;
          //自动计算transformation
          var a = fullExtent['right'] > fullExtent['left'] ? 1 : -1, b = fullExtent['top'] > fullExtent['bottom'] ? -1 : 1, c = tileSystem['origin']['x'], d = tileSystem['origin']['y'];
          this.transformation = new Transformation([a, b, c, d]);
      };
      /**
       * Get index of point's tile
       * @param point - transformed point, this.transformation.transform(pCoord)
       * @param res  - current resolution
       * @return       tile index
       */
      //@internal
      TileConfig.prototype._getTileNum = function (point, res) {
          var tileSystem = this.tileSystem, tileSize = this['tileSize'], delta = 1E-7;
          var tileX = Math.floor(delta * tileSystem['scale']['x'] + point.x / (tileSize['width'] * res));
          var tileY = Math.ceil(delta * tileSystem['scale']['y'] + point.y / (tileSize['height'] * res));
          return {
              'x': tileSystem['scale']['x'] * tileX,
              'y': tileSystem['scale']['y'] * tileY
          };
      };
      /**
       * Get tile index and offset from tile's northwest
       * @param pCoord   - projected coordinate
       * @param res - current resolution
       * @return   tile index and offset
       */
      TileConfig.prototype.getTileIndex = function (pCoord, res, repeatWorld) {
          var tileSystem = this.tileSystem;
          // tileSize = this['tileSize'];
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          var point = this.transformation.transform(pCoord, 1);
          var tileIndex = this._getTileNum(point, res);
          // const tileLeft = tileIndex['x'] * tileSize['width'];
          // const tileTop = tileIndex['y'] * tileSize['height'];
          // const offsetLeft = point.x / res - tileSystem['scale']['x'] * tileLeft;
          // const offsetTop = point.y / res + tileSystem['scale']['y'] * tileTop;
          //如果x方向为左大右小
          if (tileSystem['scale']['x'] < 0) {
              tileIndex['x'] -= 1;
          }
          //如果y方向上大下小
          if (tileSystem['scale']['y'] > 0) {
              tileIndex['y'] -= 1;
          }
          //有可能tileIndex超出世界范围
          return this.getNeighorTileIndex(tileIndex['x'], tileIndex['y'], 0, 0, res, repeatWorld);
      };
      /**
       * Get neibor's tile index
       * @param tileX
       * @param tileY
       * @param offsetX
       * @param offsetY
       * @param zoomLevel
       * @return  tile's neighbor index
       */
      TileConfig.prototype.getNeighorTileIndex = function (tileX, tileY, offsetX, offsetY, res, repeatWorld) {
          var tileSystem = this.tileSystem;
          var x = (tileX + tileSystem['scale']['x'] * offsetX);
          var y = (tileY - tileSystem['scale']['y'] * offsetY);
          var out = false;
          var idx = x;
          var idy = y;
          var ext = this._getTileFullIndex(res);
          if (repeatWorld) {
              if (repeatWorld === true || repeatWorld === 'x') {
                  //caculate tile index to request in url in repeated world.
                  if (ext['xmax'] === ext['xmin']) {
                      x = ext['xmin'];
                  }
                  else if (x < ext['xmin']) {
                      x = ext['xmax'] - (ext['xmin'] - x) % (ext['xmax'] - ext['xmin']);
                      if (x === ext['xmax']) {
                          x = ext['xmin'];
                      }
                  }
                  else if (x >= ext['xmax']) {
                      x = ext['xmin'] + (x - ext['xmin']) % (ext['xmax'] - ext['xmin']);
                  }
              }
              if (repeatWorld === true || repeatWorld === 'y') {
                  if (ext['ymax'] === ext['ymin']) {
                      y = ext['ymin'];
                  }
                  else if (y >= ext['ymax']) {
                      y = ext['ymin'] + (y - ext['ymin']) % (ext['ymax'] - ext['ymin']);
                  }
                  else if (y < ext['ymin']) {
                      y = ext['ymax'] - (ext['ymin'] - y) % (ext['ymax'] - ext['ymin']);
                      if (y === ext['ymax']) {
                          y = ext['ymin'];
                      }
                  }
              }
          }
          if (x < ext['xmin'] || x > ext['xmax'] || y > ext['ymax'] || y < ext['ymin']) {
              out = true;
          }
          return {
              // tile index to request in url
              'x': x,
              'y': y,
              // real tile index
              'idx': idx,
              'idy': idy,
              out: out
          };
      };
      //@internal
      TileConfig.prototype._getTileFullIndex = function (res) {
          if (!this._tileFullIndex) {
              this._tileFullIndex = {};
          }
          if (this._tileFullIndex[res]) {
              return this._tileFullIndex[res];
          }
          var ext = this.fullExtent;
          var transformation = this.transformation;
          var nwIndex = this._getTileNum(transformation.transform(new Coordinate(ext['left'], ext['top']), 1), res);
          var seIndex = this._getTileNum(transformation.transform(new Coordinate(ext['right'], ext['bottom']), 1), res);
          var tileSystem = this.tileSystem;
          //如果x方向为左大右小
          if (tileSystem['scale']['x'] < 0) {
              nwIndex.x -= 1;
              seIndex.x -= 1;
          }
          //如果y方向上大下小
          if (tileSystem['scale']['y'] > 0) {
              nwIndex.y -= 1;
              seIndex.y -= 1;
          }
          this._tileFullIndex[res] = new Extent(nwIndex, seIndex, null);
          return this._tileFullIndex[res];
      };
      /**
       * Get tile's north west's projected coordinate
       * @param tileX
       * @param tileY
       * @param res
       * @return
       */
      TileConfig.prototype.getTilePrjNW = function (tileX, tileY, res, out) {
          var tileSystem = this.tileSystem;
          var tileSize = this['tileSize'];
          var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * res * tileSize['height'];
          var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * res * tileSize['width'];
          if (out) {
              out.set(x, y);
              return out;
          }
          return new Coordinate(x, y);
      };
      TileConfig.prototype.getTilePointNW = function (tileX, tileY, res, out) {
          // res = res / this._glRes;
          var scale = this._glRes / res;
          var tileSystem = this.tileSystem;
          var tileSize = this['tileSize'];
          var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * tileSize['height'];
          var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * tileSize['width'];
          if (out) {
              out.set(x, y);
              return out;
          }
          return new Point(x, y);
      };
      /**
       * Get tile's south east's projected coordinate
       * @param tileX
       * @param tileY
       * @param res
       * @return
       */
      TileConfig.prototype.getTilePrjSE = function (tileX, tileY, res, out) {
          var tileSystem = this.tileSystem;
          var tileSize = this['tileSize'];
          var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * res * tileSize['height'];
          var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * res * tileSize['width'];
          if (out) {
              out.set(x, y);
              return out;
          }
          return new Coordinate(x, y);
      };
      TileConfig.prototype.getTilePointSE = function (tileX, tileY, res, out) {
          var scale = this._glRes / res;
          var tileSystem = this.tileSystem;
          var tileSize = this['tileSize'];
          var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * tileSize['height'];
          var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * tileSize['width'];
          if (out) {
              out.set(x, y);
              return out;
          }
          return new Point(x, y);
      };
      /**
       * Get tile's projected extent
       * @param tileX
       * @param tileY
       * @param res
       * @return
       */
      TileConfig.prototype.getTilePrjExtent = function (tileX, tileY, res) {
          var nw = this.getTilePrjNW(tileX, tileY, res), se = this.getTilePrjSE(tileX, tileY, res);
          return new Extent(nw, se);
      };
      return TileConfig;
  }());

  /*!
  * Contains code from THREE.js
  * MIT License
  * https://github.com/mrdoob/three.js
  */

  var planes = [];
  for (var i = 0; i < 6; i++) {
      planes[i] = [];
  }

  var p = [];

  function intersectsBox(matrix, box, mask) {
      setPlanes(matrix);
      for (var i = 0; i < 6; i++) {
          var plane = planes[i];
          // corner at max distance
          p[0] = plane[0] > 0 ? box[1][0] : box[0][0];
          p[1] = plane[1] > 0 ? box[1][1] : box[0][1];
          p[2] = plane[2] > 0 ? box[1][2] : box[0][2];

          if (distanceToPoint(plane, p) < 0) {
              return false;
          }
      }

      return true;
  }

  function setPlanes(m) {
      var me = m;
      var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

      //right
      setComponents(planes[0], me3 - me0, me7 - me4, me11 - me8, me15 - me12);
      //left
      setComponents(planes[1], me3 + me0, me7 + me4, me11 + me8, me15 + me12);
      //bottom
      setComponents(planes[2], me3 + me1, me7 + me5, me11 + me9, me15 + me13);
      //top
      setComponents(planes[3], me3 - me1, me7 - me5, me11 - me9, me15 - me13);
      //z-far
      setComponents(planes[4], me3 - me2, me7 - me6, me11 - me10, me15 - me14);
      //z-near
      setComponents(planes[5], me3 + me2, me7 + me6, me11 + me10, me15 + me14);
  }

  var normalLength = 1.0 / 6;
  function setComponents(out, x, y, z, w) {
      out[0] = x * normalLength;
      out[1] = y * normalLength;
      out[2] = z * normalLength;
      out[3] = w * normalLength;
      return out;
  }

  function distanceToPoint(plane, p) {
      return plane[0] * p[0] + plane[1] * p[1] + plane[2] * p[2] + plane[3];
  }

  var DEFAULT_MAXERROR = 1;
  var TEMP_POINT$3 = new Point(0, 0);
  var MAX_ROOT_NODES = 32;
  var isSetAvailable = typeof Set !== 'undefined';
  var TileHashset = /** @class */ (function () {
      function TileHashset() {
          this._table = isSetAvailable ? new Set() : {};
      }
      TileHashset.prototype.add = function (key) {
          if (isSetAvailable) {
              this._table.add(key);
          }
          else {
              this._table[key] = true;
          }
      };
      TileHashset.prototype.has = function (key) {
          if (isSetAvailable) {
              return this._table.has(key);
          }
          else {
              return this._table[key];
          }
      };
      TileHashset.prototype.reset = function () {
          if (isSetAvailable) {
              this._table.clear();
          }
          else {
              this._table = {};
          }
      };
      return TileHashset;
  }());
  /**
   * @property              options                     - TileLayer's options
   * @property     options.urlTemplate         - url templates
   * @property   [options.subdomains=null]   - subdomains to replace '{s}' in urlTemplate
   * @property              [options.spatialReference=null] - TileLayer's spatial reference
   * @property            [options.tileSize=[256, 256]] - size of the tile image, [width, height]
   * @property   [options.offset=[0, 0]]       - overall tile offset, [dx, dy], useful for tile sources from difference coordinate systems, e.g. (wgs84 and gcj02)
   * @property            [options.tileSystem=null]     - tile system number arrays
   * @property              [options.maxAvailableZoom=null] - Maximum zoom level for which tiles are available. Data from tiles at the maxAvailableZoom are used when displaying the map at higher zoom levels.
   * @property             [options.repeatWorld=true]  - tiles will be loaded repeatedly outside the world.
   * @property             [options.background=true]   - whether to draw a background during or after interacting, true by default
   * @property    [options.placeholder=false]    - a placeholder image to replace loading tile, can be a function with a parameter of the tile canvas
   * @property              [options.fragmentShader=null]  - custom fragment shader, replace <a href="https://github.com/maptalks/maptalks.js/blob/master/src/renderer/layer/tilelayer/TileLayerGLRenderer.js#L8">the default fragment shader</a>
   * @property              [options.crossOrigin=null]    - tile image's corssOrigin
   * @property             [options.fadeAnimation=true]  - fade animation when loading tiles
   * @property              [options.fadeDuration=167]    - fading animation duration in ms, default is 167 (10 frames)
   * @property             [options.debug=false]         - if set to true, tiles will have borders and a title of its coordinates.
   * @property              [options.renderer=gl]         - TileLayer's renderer, canvas or gl. gl tiles requires image CORS that canvas doesn't. canvas tiles can't pitch.
   * @property              [options.maxCacheSize=256]    - maximum number of tiles to cache
   * @property             [options.cascadeTiles=true]      - draw cascaded tiles of different zooms to reduce tiles
   * @property              [options.zoomOffset=0]           - offset from map's zoom to tile's zoom
   * @property              [options.tileRetryCount=0]       - retry count of tiles
   * @property              [options.errorUrl=null]       - image to replace when encountering error on loading tile image
   * @property              [options.customTags=null]    - custom tag values in urlTemplate, e.g. { foo: 'bar' } for http://path/to/{z}/{x}/{y}?foo={foo}
   * @property             [options.decodeImageInWorker=false]  - decode image in worker, for better performance if the server support
   * @property              [options.token=null]       - token to replace {token} in template http://foo/bar/{z}/{x}/{y}?token={token}
   * @property              [options.fetchOptions=object]       - fetch params,such as fetchOptions: { 'headers': { 'accept': '' } }, about accept value more info https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation/List_of_default_Accept_values
   * @property             [options.awareOfTerrain=true]       - if the tile layer is aware of terrain.
   * @property             [options.bufferPixel=0.5]       - tile buffer size,the unit is pixel
   * @property             [options.depthMask=true]       - mask to decide whether to write depth buffe
   * @memberOf TileLayer
   * @instance
   */
  var options$6 = {
      'urlTemplate': null,
      'subdomains': null,
      'errorUrl': null,
      'repeatWorld': true,
      'background': true,
      'loadingLimitOnInteracting': 3,
      'loadingLimit': 0,
      'tileRetryCount': 0,
      'placeholder': false,
      'crossOrigin': null,
      'tileSize': [256, 256],
      'offset': [0, 0],
      'tileSystem': null,
      'fadeAnimation': !IS_NODE,
      'fadeDuration': (1000 / 60 * 10),
      'debug': false,
      'spatialReference': null,
      'maxCacheSize': 256,
      'renderer': (function () {
          return Browser$1.webgl ? 'gl' : 'canvas';
      })(),
      'clipByPitch': true,
      'maxAvailableZoom': null,
      'cascadeTiles': true,
      'zoomOffset': 0,
      'pyramidMode': 1,
      'decodeImageInWorker': false,
      'tileLimitPerFrame': 0,
      'tileStackStartDepth': 7,
      'tileStackDepth': 6,
      'awareOfTerrain': true,
      'bufferPixel': 0.5,
      'mipmapTexture': true,
      'depthMask': true,
      'currentTilesFirst': true,
      'forceRenderOnMoving': true
  };
  var URL_PATTERN = /\{ *([\w_]+) *\}/g;
  // const MAX_VISIBLE_SIZE = 5;
  var TEMP_POINT0 = new Point(0, 0);
  var TEMP_POINT1$1 = new Point(0, 0);
  var TEMP_POINT2$1 = new Point(0, 0);
  var TEMP_POINT3 = new Point(0, 0);
  var TEMP_POINT4 = new Point(0, 0);
  var TEMP_POINT6 = new Point(0, 0);
  // const TEMP_POINT_EXTENT = new PointExtent();
  var TILE_BOX = [[0, 0, 0], [0, 0, 0]];
  var TILE_MIN = [0, 0, 0];
  var TILE_MAX = [0, 0, 0];
  var ARR3 = [0, 0, 0];
  /**
   * A layer used to display tiled map services, such as [google maps](http://maps.google.com), [open street maps](http://www.osm.org)
   * @category layer
   * @example
   *  new TileLayer("tile",{
          urlTemplate : 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
          subdomains:['a','b','c']
      })
   */
  var TileLayer = /** @class */ (function (_super) {
      __extends(TileLayer, _super);
      /**
       *
       * @param id - tile layer's id
       * @param options - options defined in TileLayerOptionsType
       */
      function TileLayer(id, options) {
          return _super.call(this, id, options) || this;
      }
      /**
       * Reproduce a TileLayer from layer's profile JSON.
       * @param layerJSON - layer's profile JSON
       * @return
       * @static
       * @protected
       * @function
       */
      TileLayer.fromJSON = function (layerJSON) {
          if (!layerJSON || layerJSON['type'] !== 'TileLayer') {
              return null;
          }
          return new TileLayer(layerJSON['id'], layerJSON['options']);
      };
      /**
       * force Reload tilelayer.
       * Note that this method will clear all cached tiles and reload them. It shouldn't be called frequently for performance reason.

       * @return this
       */
      TileLayer.prototype.forceReload = function () {
          this.fire('forcereloadstart');
          this.clear();
          this.load();
          this.fire('forcereloadend');
          return this;
      };
      /**
       * Get tile size of the tile layer
       * @return
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayer.prototype.getTileSize = function (id) {
          if (this._tileSize) {
              return this._tileSize;
          }
          var size = this.options['tileSize'];
          if (isNumber(size)) {
              size = [size, size];
          }
          this._tileSize = new Size(size);
          return this._tileSize;
      };
      TileLayer.prototype.getTiles = function (z, parentLayer) {
          var _this = this;
          this._coordCache = {};
          var result;
          if (this._isPyramidMode()) {
              result = this._getPyramidTiles(z, parentLayer);
          }
          else {
              result = this._getCascadeTiles(z, parentLayer);
          }
          if (!this._maskGeoJSON) {
              return result;
          }
          var tileGrids = result.tileGrids || [];
          var count = 0;
          //filter tiles by mask
          tileGrids.forEach(function (tileGrid) {
              var tiles = tileGrid.tiles || [];
              tileGrid.tiles = tiles.filter(function (tile) {
                  return _this._tileInMask(tile);
              });
              count += tileGrid.tiles.length;
              var parentIds = tileGrid.tiles.map(function (tile) {
                  return tile.parent;
              });
              tileGrid.parents = tileGrid.parents.filter(function (parent) {
                  return parentIds.indexOf(parent.id) > -1;
              });
          });
          result.count = count;
          return result;
      };
      //@internal
      TileLayer.prototype._isPyramidMode = function () {
          var sr = this.getSpatialReference();
          return !this._disablePyramid && !this._hasOwnSR && this.options['pyramidMode'] && sr && sr.isPyramid();
      };
      //@internal
      TileLayer.prototype._getTileFullExtent = function () {
          if (this._tileFullExtent) {
              return this._tileFullExtent;
          }
          var sr = this.getSpatialReference();
          var fullExtent = sr.getFullExtent();
          var res = sr.getResolution(0);
          var map = this.getMap();
          this._tileFullExtent = fullExtent.convertTo(function (c) { return map._prjToPointAtRes(c, res, TEMP_POINT$3); });
          return this._tileFullExtent;
      };
      //@internal
      TileLayer.prototype._getRootNodes = function (offset0) {
          var map = this.getMap();
          if (this._rootNodes) {
              var _a = this._rootNodes, tiles_1 = _a.tiles, mapWidth = _a.mapWidth, mapHeight = _a.mapHeight;
              if (map.width !== mapWidth || map.height !== mapHeight) {
                  var error_1 = this._getRootError();
                  for (var i = 0; i < tiles_1.length; i++) {
                      tiles_1[i].error = error_1;
                  }
                  this._rootNodes.mapWidth = map.width;
                  this._rootNodes.mapHeight = map.height;
              }
              for (var i = 0; i < tiles_1.length; i++) {
                  tiles_1[i].offset[0] = offset0[0];
                  tiles_1[i].offset[1] = offset0[1];
              }
              return this._rootNodes;
          }
          var sr = this.getSpatialReference();
          var res = sr.getResolution(0);
          var tileConfig = this._getTileConfig();
          var fullExtent = sr.getFullExtent();
          var _b = tileConfig.tileSystem, origin = _b.origin, scale = _b.scale;
          var extent000 = tileConfig.getTilePrjExtent(0, 0, res);
          var w = extent000.getWidth();
          var h = extent000.getHeight();
          var delta = 1E-5;
          var left = Math.abs((origin.x - fullExtent.left) / w);
          left = Math.ceil(left - delta);
          var right = Math.abs((fullExtent.right - origin.x) / w);
          right = Math.ceil(right - delta);
          var top = Math.ceil(Math.abs(fullExtent.top - origin.y) / h);
          top = Math.ceil(top - delta);
          var bottom = Math.ceil(Math.abs(fullExtent.bottom - origin.y) / h);
          bottom = Math.ceil(bottom - delta);
          if ((right + left) * (bottom + top) > MAX_ROOT_NODES) {
              return {
                  status: 0,
                  error: 'Too many root nodes'
              };
          }
          var error = this._getRootError();
          var tiles = [];
          var z = 0;
          for (var i = -left; i < right; i++) {
              for (var j = -top; j < bottom; j++) {
                  var y = scale.y < 0 ? j : -(j + 1);
                  tiles.push(this.createTileNode(i, y, z, i, y, res, error));
              }
          }
          this._rootNodes = {
              status: 1,
              tiles: tiles,
              mapWidth: map.width,
              mapHeight: map.height
          };
          return this._getRootNodes(offset0);
      };
      TileLayer.prototype.createTileNode = function (x, y, z, idx, idy, res, error, parentId, extent2d, tileId) {
          var map = this.getMap();
          var zoomOffset = this.options['zoomOffset'];
          if (!extent2d) {
              var tileConfig = this._getTileConfig();
              extent2d = tileConfig.getTilePrjExtent(x, y, res).convertTo(function (c) { return map._prjToPointAtRes(c, res, TEMP_POINT$3); });
          }
          var offset = this._getTileOffset(z);
          var url = this.getTileUrl(x, y, z + zoomOffset);
          return {
              parent: parentId,
              layer: this.getId(),
              x: x,
              y: y,
              z: z,
              idx: idx,
              idy: idy,
              res: res,
              extent2d: extent2d,
              id: tileId || this._getTileId(x, y, z),
              url: formatResourceUrl(url),
              offset: offset,
              error: error,
              children: []
          };
      };
      //@internal
      TileLayer.prototype._getRootError = function () {
          var map = this.getMap();
          var fov = toRadian(map.getFov());
          var aspectRatio = map.width / map.height;
          // @ts-ignore
          var cameraZ = map.cameraPosition[2];
          var heightZ = cameraZ * Math.tan(0.5 * fov);
          var widthZ = heightZ * aspectRatio;
          // 相机到容器右上角，斜对角线的距离
          var diagonalZ = Math.sqrt(cameraZ * cameraZ + heightZ * heightZ + widthZ * widthZ);
          // @ts-ignore
          var fov0 = map._getFovZ(0);
          var error = fov0 * (diagonalZ / cameraZ);
          var sr = this.getSpatialReference();
          var res = sr.getResolution(0);
          return error * res / map.getResolution(0);
      };
      //@internal
      TileLayer.prototype._getPyramidTiles = function (z, layer) {
          var map = this.getMap();
          if (isNaN(+z)) {
              z = this._getTileZoom(map.getZoom());
          }
          var sr = this.getSpatialReference();
          var maxZoom = Math.min(z, this.getMaxZoom(), this.getMaxAvailableZoom() || Infinity);
          // @ts-ignore
          var projectionView = map.projViewMatrix;
          var fullExtent = this._getTileFullExtent();
          var offset0 = this._getTileOffset(0);
          var queue;
          if (this.options['repeatWorld']) {
              var mapContainerExtent = map.getContainerExtent();
              var mapExtent2D = this._convertToExtent2d(mapContainerExtent);
              var scale = sr.getResolution(0) / map.getResolution();
              if (!mapExtent2D.within(fullExtent.copy()._scale(scale))) {
                  var pitch = map.getPitch();
                  var cascadePitch1 = map.options['cascadePitches'][1];
                  var visualHeight1 = Math.floor(map._getVisualHeight(cascadePitch1));
                  var visualContainerExtent = pitch <= cascadePitch1 ? mapContainerExtent : new PointExtent(0, map.height - visualHeight1, map.width, map.height);
                  this._visitedTiles = new TileHashset();
                  var tileGrid = this._getTiles(0 - this.options['zoomOffset'], visualContainerExtent, 2, layer && layer.getRenderer(), true);
                  var error_2 = this._getRootError() * Math.pow(2, this.options['zoomOffset']);
                  tileGrid.tiles.forEach(function (t) {
                      t.error = error_2;
                  });
                  queue = tileGrid.tiles;
              }
              else {
                  var rootNodes = this._getRootNodes(offset0);
                  if (rootNodes.status !== 1) {
                      console.warn(rootNodes.error);
                      this._disablePyramid = true;
                      return this.getTiles(z, layer);
                  }
                  queue = __spreadArray([], __read(rootNodes.tiles), false);
              }
          }
          else {
              var rootNodes = this._getRootNodes(offset0);
              if (rootNodes.status !== 1) {
                  console.warn(rootNodes.error);
                  this._disablePyramid = true;
                  return this.getTiles(z, layer);
              }
              queue = __spreadArray([], __read(rootNodes.tiles), false);
          }
          var glRes = map.getGLRes();
          var offsets = {
              0: offset0
          };
          var extent = new PointExtent();
          var tiles = [];
          var parents = [];
          while (queue.length > 0) {
              var node = queue.pop();
              if (node.z === maxZoom) {
                  extent._combine(node.extent2d);
                  tiles.push(node);
                  continue;
              }
              if (!offsets[node.z + 1]) {
                  offsets[node.z + 1] = this._getTileOffset(node.z + 1);
              }
              this._splitNode(node, projectionView, queue, tiles, extent, maxZoom, offsets[node.z + 1], layer && layer.getRenderer(), glRes);
              if (this.isParentTile(z, maxZoom, node)) {
                  parents.push(node);
              }
          }
          parents.sort(sortingTiles);
          return {
              tileGrids: [
                  {
                      extent: extent,
                      count: tiles.length,
                      tiles: tiles,
                      parents: parents,
                      offset: [0, 0],
                      zoom: z
                  }
              ],
              count: tiles.length
          };
      };
      TileLayer.prototype.isParentTile = function (z, maxZoom, tile) {
          var stackMinZoom = Math.max(this.getMinZoom(), z - this.options['tileStackStartDepth']);
          var stackMaxZoom = Math.min(maxZoom, stackMinZoom + this.options['tileStackDepth']);
          return tile.z >= stackMinZoom && tile.z < stackMaxZoom;
      };
      //@internal
      TileLayer.prototype._splitNode = function (node, projectionView, queue, tiles, gridExtent, maxZoom, offset, parentRenderer, glRes) {
          var z = node.z + 1;
          var sr = this.getSpatialReference();
          var idx = node.idx, idy = node.idy;
          var renderer = parentRenderer || this.getRenderer();
          var hasCurrentIn = false;
          var children = [];
          var res = sr.getResolution(z);
          var glScale = res / glRes;
          for (var i = 0; i < 4; i++) {
              var dx = (i % 2);
              var dy = (i >> 1);
              var childIdx = (idx << 1) + dx;
              var childIdy = (idy << 1) + dy;
              // const tileId = this._getTileId(childIdx, childIdy, z);
              if (!node.children) {
                  node.children = [];
              }
              var tileId = node.children[i];
              if (!tileId) {
                  tileId = this._getTileId(childIdx, childIdy, z);
                  node.children[i] = tileId;
              }
              var cached = renderer.isTileCachedOrLoading(tileId);
              var childNode = cached && cached.info;
              if (!childNode) {
                  if (!this.tileInfoCache) {
                      this.tileInfoCache = new LRUCache(this.options['maxCacheSize'] * 4);
                  }
                  childNode = this.tileInfoCache.get(tileId);
                  if (!childNode) {
                      childNode = this._createChildNode(node, dx, dy, offset, tileId);
                  }
              }
              childNode.error = node.error / 2;
              childNode.offset[0] = offset[0];
              childNode.offset[1] = offset[1];
              var visible = this._isTileVisible(childNode, projectionView, glScale, maxZoom, offset);
              if (visible === 1) {
                  hasCurrentIn = true;
              }
              else if (visible === -1) {
                  continue;
              }
              else if (visible === 0 && z !== maxZoom) {
                  // 任意子瓦片的error低于maxError，则添加父级瓦片，不再遍历子瓦片
                  tiles.push(node);
                  gridExtent._combine(node.extent2d);
                  return;
              }
              children.push(childNode);
          }
          if (z === maxZoom) {
              if (hasCurrentIn) {
                  queue.push.apply(queue, __spreadArray([], __read(children), false));
              }
              else {
                  tiles.push(node);
                  gridExtent._combine(node.extent2d);
              }
          }
          else {
              queue.push.apply(queue, __spreadArray([], __read(children), false));
          }
      };
      //@internal
      TileLayer.prototype._createChildNode = function (node, dx, dy, offset, tileId) {
          // const zoomOffset = this.options['zoomOffset'];
          var x = node.x, y = node.y, idx = node.idx, idy = node.idy, extent2d = node.extent2d;
          var z = node.z + 1;
          var childX = (x << 1) + dx;
          var childY = (y << 1) + dy;
          var childIdx = (idx << 1) + dx;
          var childIdy = (idy << 1) + dy;
          var childScale = 2;
          var width = extent2d.getWidth() / 2 * childScale;
          var height = extent2d.getHeight() / 2 * childScale;
          var minx = extent2d.xmin * childScale;
          var maxy = extent2d.ymax * childScale;
          var miny = extent2d.ymin * childScale;
          var tileSystem = this._getTileConfig().tileSystem;
          var scaleY = tileSystem.scale.y;
          tileId = tileId || this._getTileId(childIdx, childIdy, z);
          var extent;
          if (scaleY < 0) {
              var nwx = minx + dx * width;
              var nwy = maxy - dy * height;
              // extent2d 是 node.z 级别上的 extent
              extent = new PointExtent(nwx, nwy - height, nwx + width, nwy);
          }
          else {
              var swx = minx + dx * width;
              var swy = miny + dy * height;
              extent = new PointExtent(swx, swy, swx + width, swy + height);
          }
          var childNode = this.createTileNode(childX, childY, z, childIdx, childIdy, node.res / 2, node.error / 2, node.id, extent, tileId);
          this.tileInfoCache.add(tileId, childNode);
          return childNode;
      };
      //@internal
      TileLayer.prototype._isTileVisible = function (node, projectionView, glScale, maxZoom, offset) {
          if (node.z === 0) {
              return 1;
          }
          if (!this._isTileInFrustum(node, projectionView, glScale, offset) /* || this._isTileTooSmall(node, projectionView, glScale, maxZoom, offset)*/) {
              return -1;
          }
          var maxError = this.options['maxError'];
          if (isNil(maxError)) {
              maxError = DEFAULT_MAXERROR;
          }
          var error = this._getScreenSpaceError(node, glScale, maxZoom, offset);
          return error >= maxError ? 1 : 0;
      };
      // _isTileTooSmall(node, projectionView, glScale, maxZoom, offset) {
      //     if (Math.abs(node.z - maxZoom) <= 3) {
      //         return false;
      //     }
      //     const { xmin, ymin, xmax, ymax } = node.extent2d;
      //     TILE_MIN[0] = (xmin - offset[0]) * glScale;
      //     TILE_MIN[1] = (ymin - offset[1]) * glScale;
      //     TILE_MAX[0] = (xmax - offset[0]) * glScale;
      //     TILE_MAX[1] = (ymax - offset[1]) * glScale;
      //     const ndcMin = applyMatrix(TILE_MIN, TILE_MIN, projectionView);
      //     const ndcMax = applyMatrix(TILE_MAX, TILE_MAX, projectionView);
      //     const map = this.getMap();
      //     const w2 = map.width / 2, h2 = map.height / 2;
      //     const cp0 = this._toCP(ndcMin, w2, h2);
      //     const cp1 = this._toCP(ndcMax, w2, h2);
      //     const vh = map.height - map._getVisualHeight(map.getPitch());
      //     if (cp0[1] <= vh && cp1[1] <= vh) {
      //         this._tooSmall++;
      //         return true;
      //     }
      //     const t = [ndcMin[0] - ndcMax[0], ndcMin[1] - ndcMax[1]];
      //     const w = Math.abs((t[0] * w2) + w2);
      //     const h = Math.abs(-(t[1] * h2) + h2);
      //     // const w = map.width / 2 * (ndcMin[0] - ndcMax[0]);
      //     // const h = map.height / 2 * (ndcMin[1] - ndcMax[1]);
      //     if (w <= 5 || h <= 5) {
      //         this._tooSmall++;
      //     }
      //     return w <= 5 || h <= 5;
      // }
      // _toCP(t, w2, h2) {
      //     const w = (t[0] * w2) + w2;
      //     const h = -(t[1] * h2) + h2;
      //     return [w, h];
      // }
      //@internal
      TileLayer.prototype._isTileInFrustum = function (node, projectionView, glScale, offset) {
          if (!this._zScale) {
              var map = this.getMap();
              var glRes = map.getGLRes();
              this._zScale = map.altitudeToPoint(100, glRes) / 100;
          }
          var renderer = this.getRenderer();
          var _a = node.extent2d, xmin = _a.xmin, ymin = _a.ymin, xmax = _a.xmax, ymax = _a.ymax;
          if (node.offset && !isFunction(this.options.offset)) {
              var _b = __read(node.offset, 2), x = _b[0], y = _b[1];
              xmin += x;
              xmax += x;
              ymin += y;
              ymax += y;
          }
          TILE_BOX[0][0] = (xmin - offset[0]) * glScale;
          TILE_BOX[0][1] = (ymin - offset[1]) * glScale;
          var minAltitude = node.minAltitude || renderer && renderer.avgMinAltitude || 0;
          TILE_BOX[0][2] = minAltitude * this._zScale;
          TILE_BOX[1][0] = (xmax - offset[0]) * glScale;
          TILE_BOX[1][1] = (ymax - offset[1]) * glScale;
          var maxAltitude = node.maxAltitude || renderer && renderer.avgMaxAltitude || 0;
          TILE_BOX[1][2] = maxAltitude * this._zScale;
          return intersectsBox(projectionView, TILE_BOX);
      };
      /**
       * Compute tile's SSE
       * from Cesium
       * 与cesium不同的是，我们用boundingVolume顶面的四个顶点中的最小值作为distanceToCamera
       */
      //@internal
      TileLayer.prototype._getScreenSpaceError = function (node, glScale, maxZoom, offset) {
          // const fovDenominator = this._fovDenominator;
          var geometricError = node.error;
          var map = this.getMap();
          var _a = node.extent2d, xmin = _a.xmin, ymin = _a.ymin, xmax = _a.xmax, ymax = _a.ymax;
          TILE_MIN[0] = (xmin - offset[0]) * glScale;
          TILE_MIN[1] = (ymin - offset[1]) * glScale;
          TILE_MAX[0] = (xmax - offset[0]) * glScale;
          TILE_MAX[1] = (ymax - offset[1]) * glScale;
          // @ts-ignore
          var distanceToCamera = distanceToRect(TILE_MIN, TILE_MAX, map.cameraPosition);
          var distance = Math.max(Math.abs(distanceToCamera), 1E-7);
          // const r = Math.abs(node.z - maxZoom) === 0 ? 1.3 : Math.abs(node.z - maxZoom) <= 1 ? 1 : 0.505;
          var gap = Math.abs(node.z - maxZoom);
          var r;
          // 地图容器高度小于1000时，因为影响到camera高度，原有的error乘数会让低级别瓦片优先级太高，造成瓦片缺失
          // 所以在高度<1000像素时，乘数重置为1
          if (map.height < 1000) {
              r = 1;
          }
          else {
              r = gap <= 1 ? 1 : gap <= 2 ? 0.7 : 0.605;
          }
          // const r = 1;
          var error = geometricError * r / distance;
          var pitch = this.getMap().getPitch();
          if (pitch <= 60) {
              return error * 1.45;
          }
          return error;
      };
      /**
       * Get tiles at zoom z (or current zoom)
       * @param z - zoom
       * @return tile descriptors
       */
      //@internal
      TileLayer.prototype._getCascadeTiles = function (z, parentLayer) {
          var map = this.getMap();
          var pitch = map.getPitch();
          var parentRenderer = parentLayer && parentLayer.getRenderer();
          var mapExtent = map.getContainerExtent();
          var tileGrids = [];
          var count = 0;
          var minZoom = this.getMinZoom();
          var cascadePitch0 = map.options['cascadePitches'][0];
          var cascadePitch1 = map.options['cascadePitches'][1];
          var visualHeight1 = Math.floor(map._getVisualHeight(cascadePitch1));
          var tileZoom = isNil(z) ? this._getTileZoom(map.getZoom()) : z;
          this._visitedTiles = new TileHashset();
          if (!isNil(z) ||
              !this.options['cascadeTiles'] ||
              pitch <= cascadePitch0 ||
              !isNil(minZoom) && tileZoom <= minZoom) {
              var containerExtent = pitch <= cascadePitch1 ? mapExtent : new PointExtent(0, map.height - visualHeight1, map.width, map.height);
              var currentTiles_1 = this._getTiles(tileZoom, containerExtent, 2, parentRenderer);
              if (currentTiles_1) {
                  count += currentTiles_1.tiles.length;
                  tileGrids.push(currentTiles_1);
              }
              return {
                  tileGrids: tileGrids,
                  count: count
              };
          }
          var visualHeight0 = Math.floor(map._getVisualHeight(cascadePitch0));
          var extent0 = new PointExtent(0, map.height - visualHeight0, map.width, map.height);
          var currentTiles = this._getTiles(tileZoom, extent0, 0, parentRenderer);
          count += currentTiles ? currentTiles.tiles.length : 0;
          tileGrids.push(currentTiles);
          var cascadeHeight = extent0.ymin;
          var d = map.getSpatialReference().getZoomDirection();
          var cascadeLevels = d;
          var cascadeTiles1;
          if (pitch > cascadePitch1) {
              if (tileZoom - cascadeLevels <= minZoom) {
                  cascadeLevels = 0;
              }
              var extent1 = new PointExtent(0, map.height - visualHeight1, map.width, cascadeHeight);
              cascadeTiles1 = this._getTiles(tileZoom - cascadeLevels, extent1, 1, parentRenderer);
              count += cascadeTiles1 ? cascadeTiles1.tiles.length : 0;
              cascadeHeight = extent1.ymin;
              cascadeLevels += 4 * d;
              tileGrids.push(cascadeTiles1);
          }
          var cascadeTiles2;
          if (tileZoom - cascadeLevels >= minZoom) {
              var extent2 = new PointExtent(0, mapExtent.ymin, map.width, cascadeHeight);
              cascadeTiles2 = this._getTiles(tileZoom - cascadeLevels, extent2, 2, parentRenderer);
              count += cascadeTiles2 ? cascadeTiles2.tiles.length : 0;
              tileGrids.push(cascadeTiles2);
          }
          if (cascadeTiles1 && cascadeTiles2) {
              tileGrids[1] = cascadeTiles2;
              tileGrids[2] = cascadeTiles1;
          }
          // console.log(currentTiles && currentTiles.tiles.length, cascadeTiles1 && cascadeTiles1.tiles.length, cascadeTiles2 && cascadeTiles2.tiles.length);
          return {
              tileGrids: tileGrids,
              count: count
          };
      };
      /**
       * Get tile's url
       * @param x
       * @param y
       * @param z
       * @returns url
       */
      TileLayer.prototype.getTileUrl = function (x, y, z) {
          var urlTemplate = this.options['urlTemplate'];
          var domain = '';
          if (this.options['subdomains']) {
              var subdomains = this.options['subdomains'];
              if (isArrayHasData(subdomains)) {
                  var length_1 = subdomains.length;
                  var s = (x + y) % length_1;
                  if (s < 0) {
                      s = 0;
                  }
                  domain = subdomains[s];
              }
          }
          if (isFunction(urlTemplate)) {
              return urlTemplate(x, y, z, domain);
          }
          var data = {
              'x': x,
              'y': y,
              'z': z,
              's': domain
          };
          // @ts-ignore
          if (this.options.token) {
              // @ts-ignore
              data.token = this.options.token;
          }
          // @ts-ignore
          if (this.options.customTags) {
              // @ts-ignore
              extend$2(data, this.options.customTags);
          }
          return urlTemplate.replace(URL_PATTERN, function (str, key) {
              var value = data[key];
              if (value === undefined) {
                  throw new Error('No value provided for variable ' + str);
              }
              else if (typeof value === 'function') {
                  value = value(data);
              }
              return value;
          });
      };
      /**
       * Clear the layer
       * @return this
       */
      TileLayer.prototype.clear = function () {
          if (this._renderer) {
              this._renderer.clear();
          }
          if (this.tileInfoCache) {
              this.tileInfoCache.reset();
          }
          /**
           * clear event, fired when tile layer is cleared.
           *
           * @event TileLayer#clear
           * @type {Object}
           * @property {String} type - clear
           * @property {TileLayer} target - tile layer
           */
          this.fire('clear');
          return this;
      };
      /**
       * Export the tile layer's profile json. <br>
       * Layer's profile is a snapshot of the layer in JSON format. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return layer's profile JSON
       */
      TileLayer.prototype.toJSON = function () {
          var profile = {
              'type': this.getJSONType(),
              'id': this.getId(),
              'options': this.config()
          };
          return profile;
      };
      /**
       * Get tilelayer's spatial reference.
       * @returns spatial reference
       */
      TileLayer.prototype.getSpatialReference = function () {
          var map = this.getMap();
          if (map && (!this.options['spatialReference'] || SpatialReference.equals(this.options['spatialReference'], map.options['spatialReference']))) {
              return map.getSpatialReference();
          }
          if (this._sr) {
              return this._sr;
          }
          var config = this.options['spatialReference'];
          if (isString(config)) {
              config = SpatialReference.getPreset(config);
              if (!config) {
                  throw new Error("Unsupported spatial reference: ".concat(this.options['spatialReference'], ", possible values: ").concat(SpatialReference.getAllPresets().join()));
              }
          }
          this._sr = new SpatialReference(config);
          this._srMinZoom = this._sr.getMinZoom();
          this._srMaxZoom = this._sr.getMaxZoom();
          this._hasOwnSR = this._sr.toJSON().projection !== map.getSpatialReference().toJSON().projection;
          return this._sr;
      };
      TileLayer.prototype.getMinZoom = function () {
          var minZoom = this.options['minZoom'] || 0;
          var sr = this.getSpatialReference();
          if (sr !== this.getMap().getSpatialReference()) {
              return Math.max(minZoom, this._srMinZoom);
          }
          return minZoom;
      };
      TileLayer.prototype.getMaxZoom = function () {
          var sr = this.getSpatialReference();
          if (sr !== this.getMap().getSpatialReference()) {
              return Math.min(_super.prototype.getMaxZoom.call(this), this._srMaxZoom);
          }
          return _super.prototype.getMaxZoom.call(this);
      };
      //@internal
      TileLayer.prototype._getTileZoom = function (zoom) {
          if (!this._hasOwnSR) {
              var res0 = this.getMap().getResolution(zoom);
              var res1 = this.getSpatialReference().getResolution(zoom);
              var dz = Math.log(res1 / res0) * Math.LOG2E; // polyfill of Math.log2
              zoom += dz;
          }
          var maxZoom = this.getMaxAvailableZoom();
          if (!isNil(maxZoom) && zoom > maxZoom) {
              zoom = maxZoom;
          }
          if (!isInteger(zoom)) {
              zoom = Math.round(zoom);
          }
          zoom = Math.max(0, zoom);
          return zoom;
      };
      /**
       * Get tileLayer's max available zoom, either options['maxAvailableZoom'] or spatialReference's maxZoom
       *
       * @returns
       **/
      TileLayer.prototype.getMaxAvailableZoom = function () {
          var sr = this.getSpatialReference();
          return this.options['maxAvailableZoom'] || sr && sr.getMaxZoom();
      };
      //@internal
      TileLayer.prototype._getTiles = function (tileZoom, containerExtent, cascadeLevel, parentRenderer, ignoreMinZoom) {
          // rendWhenReady = false;
          var map = this.getMap();
          var z = tileZoom;
          // @ts-ignore
          var frustumMatrix = map.projViewMatrix;
          var canSplitTile = map.getResolution(tileZoom) / map.getResolution(tileZoom - 1) === 0.5;
          if (cascadeLevel < 2) {
              if (cascadeLevel === 0 && canSplitTile) {
                  // cascadeLevel为0时，查询父级瓦片，再对父级瓦片split
                  z -= 1;
              }
              // @ts-ignore
              frustumMatrix = cascadeLevel === 0 ? map.cascadeFrustumMatrix0 : cascadeLevel === 1 ? map.cascadeFrustumMatrix1 : map.projViewMatrix;
          }
          var zoom = z + this.options['zoomOffset'];
          var offset = this._getTileOffset(z), hasOffset = offset[0] || offset[1];
          var emptyGrid = {
              'zoom': z,
              'extent': null,
              'offset': offset,
              'tiles': []
          };
          if (zoom < 0) {
              return emptyGrid;
          }
          if (!map || !this.isVisible() || !map.width || !map.height) {
              return emptyGrid;
          }
          if (!ignoreMinZoom) {
              var minZoom = this.getMinZoom(), maxZoom = this.getMaxZoom();
              if (!isNil(minZoom) && z < minZoom ||
                  !isNil(maxZoom) && z > maxZoom) {
                  return emptyGrid;
              }
          }
          var tileConfig = this._getTileConfig();
          if (!tileConfig) {
              return emptyGrid;
          }
          //$$$
          var tileOffsets = {
              zoom: offset
          };
          var sr = this.getSpatialReference();
          var res = sr.getResolution(z);
          // const glScale = res / map.getGLRes();
          var glScale;
          if (this._hasOwnSR) {
              glScale = map.getGLScale(z);
          }
          else {
              glScale = res / map.getGLRes();
          }
          var repeatWorld = !this._hasOwnSR && this.options['repeatWorld'];
          var extent2d = this._convertToExtent2d(containerExtent);
          // const innerExtent2D = this._getInnerExtent(z, containerExtent, extent2d)._add(offset);
          // extent2d._add(offset);
          var maskExtent = this._getMask2DExtent();
          if (maskExtent) {
              var intersection = maskExtent.intersection(extent2d);
              if (!intersection) {
                  return emptyGrid;
              }
              // @ts-ignore
              containerExtent = intersection.convertTo(function (c) { return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT$3); });
          }
          //Get description of center tile including left and top offset
          var prjCenter = map._containerPointToPrj(containerExtent.getCenter(), TEMP_POINT0);
          var centerPoint = map._prjToPoint(prjCenter, z, TEMP_POINT1$1);
          var c;
          if (hasOffset) {
              c = this._project(map._pointToPrj(centerPoint._add(offset), z, TEMP_POINT1$1), TEMP_POINT1$1);
          }
          else {
              c = this._project(prjCenter, TEMP_POINT1$1);
          }
          var extentScale = map.getGLScale() / map.getGLScale(z);
          TEMP_POINT2$1.x = extent2d.xmin * extentScale;
          TEMP_POINT2$1.y = extent2d.ymax * extentScale;
          TEMP_POINT3.x = extent2d.xmax * extentScale;
          TEMP_POINT3.y = extent2d.ymin * extentScale;
          var pmin = this._project(map._pointToPrj(TEMP_POINT2$1._add(offset), z, TEMP_POINT2$1), TEMP_POINT2$1);
          var pmax = this._project(map._pointToPrj(TEMP_POINT3._add(offset), z, TEMP_POINT3), TEMP_POINT3);
          var centerTile = tileConfig.getTileIndex(c, res, repeatWorld);
          var ltTile = tileConfig.getTileIndex(pmin, res, repeatWorld);
          var rbTile = tileConfig.getTileIndex(pmax, res, repeatWorld);
          // Number of tiles around the center tile
          var top = Math.ceil(Math.abs(centerTile.idy - ltTile.idy)), left = Math.ceil(Math.abs(centerTile.idx - ltTile.idx)), bottom = Math.ceil(Math.abs(centerTile.idy - rbTile.idy)), right = Math.ceil(Math.abs(centerTile.idx - rbTile.idx));
          var allCount = (top + bottom + 1) * (left + right + 1);
          var tileSize = this.getTileSize();
          var renderer = this.getRenderer() || parentRenderer, scale = this._getTileConfig().tileSystem.scale;
          var tiles = [], extent = new PointExtent();
          var tilePoint = new Point(0, 0);
          for (var i = -top; i <= bottom; i++) {
              var j = -left;
              var leftVisitEnd = -Infinity;
              var rightVisitEnd = false;
              while (j >= leftVisitEnd && j <= right) {
                  var idx = tileConfig.getNeighorTileIndex(centerTile.idx, centerTile.idy, j, i, res, repeatWorld);
                  if (leftVisitEnd === -Infinity) {
                      //从左往右遍历中
                      j++;
                  }
                  else {
                      //从右往左遍历中
                      j--;
                  }
                  var tileId = this._getTileId(idx.idx, idx.idy, z);
                  if (idx.out || this._visitedTiles && this._visitedTiles.has(tileId)) {
                      continue;
                  }
                  //unique id of the tile
                  var tileInfo = renderer && renderer.isTileCachedOrLoading(tileId);
                  if (tileInfo) {
                      tileInfo = tileInfo.info;
                  }
                  var p = void 0;
                  if (tileInfo) {
                      var extent2d_1 = tileInfo.extent2d;
                      tilePoint.set(extent2d_1.xmin, extent2d_1.ymax);
                      p = tilePoint;
                  }
                  else if (!this._hasOwnSR) {
                      p = tileConfig.getTilePointNW(idx.x, idx.y, res);
                      // const pnw = tileConfig.getTilePrjNW(idx.x, idx.y, res);
                      // p = map._prjToPoint(this._unproject(pnw, TEMP_POINT3), z);
                  }
                  else {
                      var pnw = tileConfig.getTilePrjNW(idx.x, idx.y, res);
                      p = map._prjToPoint(this._unproject(pnw, TEMP_POINT3), z);
                  }
                  var width = void 0, height = void 0;
                  if (!this._hasOwnSR) {
                      width = tileSize.width;
                      height = tileSize.height;
                  }
                  else {
                      var pp = void 0;
                      if (!this._hasOwnSR) {
                          pp = tileConfig.getTilePointSE(idx.x, idx.y, res);
                      }
                      else {
                          var pse = tileConfig.getTilePrjSE(idx.x, idx.y, res);
                          pp = map._prjToPoint(this._unproject(pse, TEMP_POINT3), z, TEMP_POINT3);
                      }
                      width = Math.ceil(Math.abs(pp.x - p.x));
                      height = Math.ceil(Math.abs(pp.y - p.y));
                  }
                  var dx = scale.x * (idx.idx - idx.x) * width, dy = scale.y * (idx.idy - idx.y) * height;
                  if (!tileInfo && (dx || dy)) {
                      p._add(dx, dy);
                  }
                  var tileExtent = tileInfo && tileInfo.extent2d || new PointExtent(p.x, p.y - height, p.x + width, p.y);
                  // if (hasOffset) {
                  //     tileExtent.set(p.x, p.y - height, p.x + width, p.y);
                  // }
                  if (allCount <= 4 || rightVisitEnd || this._isTileInExtent(frustumMatrix, tileExtent, offset, glScale)) {
                      var tileRes = this._hasOwnSR ? map._getResolution(z) : res;
                      if (this._visitedTiles && cascadeLevel === 0) {
                          this._visitedTiles.add(tileId);
                      }
                      if (canSplitTile && cascadeLevel === 0) {
                          this._splitTiles(frustumMatrix, tiles, renderer, idx, z + 1, tileRes, tileExtent, dx, dy, tileOffsets);
                          extent._combine(tileExtent);
                      }
                      else {
                          if (!tileInfo) {
                              tileInfo = this.createTileNode(idx.x, idx.y, z, idx.idx, idx.idy, tileRes, 0, null, tileExtent, tileId);
                          }
                          else {
                              tileInfo.offset[0] = offset[0];
                              tileInfo.offset[1] = offset[1];
                          }
                          tiles.push(tileInfo);
                          extent._combine(tileExtent);
                      }
                      if (leftVisitEnd === -Infinity) {
                          //从左往右第一次遇到可视的瓦片，改为从右往左遍历
                          leftVisitEnd = j;
                          j = right; // - Math.max(j - -left - 4, 0);
                          // rightVisitEnd = true;
                      }
                      else if (!rightVisitEnd) {
                          //从右往左第一次遇到可视瓦片，之后的瓦片全部可视
                          rightVisitEnd = true;
                      }
                  }
              }
          }
          if (tiles.length) {
              //sort tiles according to tile's distance to center
              var center_1 = map._containerPointToPoint(containerExtent.getCenter(), z, TEMP_POINT$3)._add(offset);
              var point0_1 = new Point(0, 0);
              var point1_1 = new Point(0, 0);
              tiles.sort(function (a, b) {
                  point0_1.set((a.extent2d.xmin + a.extent2d.xmax) / 2, (a.extent2d.ymin + a.extent2d.ymax) / 2);
                  point1_1.set((b.extent2d.xmin + b.extent2d.xmax) / 2, (b.extent2d.ymin + b.extent2d.ymax) / 2);
                  return point0_1.distanceTo(center_1) - point1_1.distanceTo(center_1);
              });
          }
          return {
              'offset': offset,
              'zoom': tileZoom,
              'extent': extent,
              'tiles': tiles
          };
      };
      //@internal
      TileLayer.prototype._convertToExtent2d = function (containerExtent) {
          var _this = this;
          var map = this.getMap();
          return containerExtent.convertTo(function (c) {
              var result;
              if (c.y > 0 && c.y < map.height) {
                  var key = (c.x === 0 ? 0 : 1) + c.y;
                  if (!_this._coordCache[key]) {
                      _this._coordCache[key] = map._containerPointToPoint(c);
                  }
                  result = _this._coordCache[key];
              }
              result = map._containerPointToPoint(c, undefined, TEMP_POINT$3);
              return result;
          });
      };
      //@internal
      TileLayer.prototype._splitTiles = function (frustumMatrix, tiles, renderer, tileIdx, z, res, tileExtent, dx, dy, tileOffsets) {
          // const hasOffset = offset[0] || offset[1];
          var yOrder = this._getTileConfig().tileSystem.scale.y;
          var glScale = this.getMap().getGLScale(z);
          //yOrder < 0，用左上角，大于0时，用左下角
          var corner = TEMP_POINT4.set(tileExtent.xmin * 2, yOrder < 0 ? tileExtent.ymax * 2 : tileExtent.ymin * 2);
          var w = tileExtent.getWidth();
          var h = tileExtent.getHeight();
          var idx = tileIdx.idx * 2;
          var idy = tileIdx.idy * 2;
          var x = tileIdx.x * 2;
          var y = tileIdx.y * 2;
          var tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, res, 0, 0, w, h, corner, glScale, tileOffsets);
          if (tile)
              tiles.push(tile);
          tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, res, 0, 1, w, h, corner, glScale, tileOffsets);
          if (tile)
              tiles.push(tile);
          tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, res, 1, 0, w, h, corner, glScale, tileOffsets);
          if (tile)
              tiles.push(tile);
          tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, res, 1, 1, w, h, corner, glScale, tileOffsets);
          if (tile)
              tiles.push(tile);
      };
      //@internal
      TileLayer.prototype._checkAndAddTile = function (frustumMatrix, renderer, idx, idy, x, y, z, res, i, j, w, h, corner, glScale, tileOffsets) {
          var tileId = this._getTileId(idx + i, idy + j, z);
          if (this._visitedTiles && this._visitedTiles.has(tileId)) {
              return null;
          }
          var offset = tileOffsets[z];
          if (!offset) {
              offset = tileOffsets[z] = this._getTileOffset(z);
          }
          var yOrder = this._getTileConfig().tileSystem.scale.y;
          var childExtent = new PointExtent(corner.x + i * w, corner.y + yOrder * j * h, corner.x + (i + 1) * w, corner.y + yOrder * (j + 1) * h);
          if ( /*!rightVisitEnd && */!this._isSplittedTileInExtent(frustumMatrix, childExtent, offset, glScale)) {
              return null;
          }
          var childRes = res / 2;
          var tileCache = renderer && renderer.isTileCachedOrLoading(tileId);
          var tileInfo;
          if (!tileCache) {
              //reserve point caculated by tileConfig
              //so add offset because we have p._sub(offset) and p._add(dx, dy) if hasOffset
              tileInfo = this.createTileNode(x + i, y + j, z, idx + i, idx + y, childRes, 0, null, childExtent, tileId);
          }
          else {
              tileInfo = tileCache.info;
          }
          return tileInfo;
      };
      //@internal
      TileLayer.prototype._getTileOffset = function () {
          var params = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              params[_i] = arguments[_i];
          }
          // offset result can't be cached, as it varies with map's center.
          var offset = this.options['offset'];
          if (isFunction(offset)) {
              offset = offset.call.apply(offset, __spreadArray([this], __read(params), false));
          }
          if (isNumber(offset)) {
              offset = [offset, offset];
          }
          return offset || [0, 0];
      };
      TileLayer.prototype.getTileId = function (x, y, zoom, id) {
          return this._getTileId(x, y, zoom, id);
      };
      //@internal
      TileLayer.prototype._getTileId = function (x, y, zoom, id) {
          //id is to mark GroupTileLayer's child layers
          return "".concat(id || this.getId(), "_").concat(x, "_").concat(y, "_").concat(zoom);
      };
      //@internal
      TileLayer.prototype._project = function (pcoord, out) {
          if (this._hasOwnSR) {
              var map = this.getMap();
              var mapProjection = map.getProjection();
              var projection = this.getSpatialReference().getProjection();
              return projection.project(mapProjection.unproject(pcoord, out), out);
          }
          else {
              return pcoord;
          }
      };
      //@internal
      TileLayer.prototype._unproject = function (pcoord, out) {
          if (this._hasOwnSR) {
              var map = this.getMap();
              var sr = this.getSpatialReference();
              var mapProjection = map.getProjection();
              var projection = sr.getProjection();
              return mapProjection.project(projection.unproject(pcoord, out), out);
          }
          else {
              return pcoord;
          }
      };
      /**
       * initialize [tileConfig]{@link TileConfig} for the tilelayer
       * @private
       */
      //@internal
      TileLayer.prototype._initTileConfig = function () {
          var map = this.getMap(), tileSize = this.getTileSize();
          var sr = this.getSpatialReference();
          var projection = sr.getProjection(), fullExtent = sr.getFullExtent();
          // @ts-ignore
          this._defaultTileConfig = new TileConfig(map, TileSystem.getDefault(projection), fullExtent, tileSize);
          if (this.options.hasOwnProperty('tileSystem')) {
              // @ts-ignore
              this._tileConfig = new TileConfig(map, this.options['tileSystem'], fullExtent, tileSize);
          }
          //inherit baselayer's tileconfig
          // if (map && !this._tileConfig &&
          //     mapSr === sr &&
          //     map.getBaseLayer() &&
          //     map.getBaseLayer() !== this &&
          //     map.getBaseLayer()._getTileConfig &&
          //     map.getBaseLayer().getSpatialReference() === mapSr) {
          //     const base = map.getBaseLayer()._getTileConfig();
          //     this._tileConfig = new TileConfig(map, base.tileSystem, base.fullExtent, tileSize);
          // }
          delete this._rootNodes;
          delete this._tileFullExtent;
          delete this._disablePyramid;
      };
      //@internal
      TileLayer.prototype._getTileConfig = function () {
          if (!this._defaultTileConfig) {
              this._initTileConfig();
          }
          return this._tileConfig || this._defaultTileConfig;
      };
      //@internal
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayer.prototype._bindMap = function (args) {
          this._onSpatialReferenceChange();
          // eslint-disable-next-line prefer-rest-params
          return _super.prototype._bindMap.apply(this, arguments);
      };
      //@internal
      TileLayer.prototype._isTileInExtent = function (frustumMatrix, tileExtent, offset, glScale) {
          var map = this.getMap();
          var matrix;
          if (frustumMatrix !== map.projViewMatrix) {
              var tileCenter = tileExtent.getCenter(TEMP_POINT6)._sub(offset[0], offset[1])._multi(glScale);
              set(ARR3, tileCenter.x, tileCenter.y, 0);
              var ndc = transformMat4(ARR3, ARR3, map.projViewMatrix);
              //地图中心下方的瓦片与 map.projViewMatrix 比较
              //地图中心上方的瓦片与 map.cascadeFrustumMatrix 比较
              matrix = ndc[1] < 0 ? map.projViewMatrix : frustumMatrix;
          }
          else {
              matrix = map.projViewMatrix;
          }
          TILE_BOX[0][0] = (tileExtent.xmin - offset[0]) * glScale;
          TILE_BOX[0][1] = (tileExtent.ymin - offset[1]) * glScale;
          TILE_BOX[1][0] = (tileExtent.xmax - offset[0]) * glScale;
          TILE_BOX[1][1] = (tileExtent.ymax - offset[1]) * glScale;
          return intersectsBox(matrix, TILE_BOX);
      };
      //@internal
      TileLayer.prototype._isSplittedTileInExtent = function (frustumMatrix, tileExtent, offset, glScale) {
          var map = this.getMap();
          TILE_BOX[0][0] = (tileExtent.xmin - offset[0]) * glScale;
          TILE_BOX[0][1] = (tileExtent.ymin - offset[1]) * glScale;
          TILE_BOX[1][0] = (tileExtent.xmax - offset[0]) * glScale;
          TILE_BOX[1][1] = (tileExtent.ymax - offset[1]) * glScale;
          return intersectsBox(map.projViewMatrix, TILE_BOX);
      };
      TileLayer.prototype.getEvents = function () {
          return {
              'spatialreferencechange': this._onSpatialReferenceChange
          };
      };
      //@internal
      TileLayer.prototype._onSpatialReferenceChange = function () {
          delete this._tileConfig;
          delete this._defaultTileConfig;
          delete this._sr;
          delete this._srMinZoom;
          delete this._hasOwnSR;
          delete this._rootNodes;
          if (this.tileInfoCache) {
              this.tileInfoCache.reset();
          }
          var renderer = this.getRenderer();
          if (renderer) {
              renderer.clear();
          }
      };
      /**
       * Get layer's polygonOffset count
       * @return
       */
      TileLayer.prototype.getPolygonOffsetCount = function () {
          return 2;
      };
      /**
       * Get layer's base polygon offset
       * @return
       */
      TileLayer.prototype.getPolygonOffset = function () {
          return this._polygonOffset || 0;
      };
      /**
       * Set layer's base polygon offset, called by GroupGLLayer
       * @param offset polygon offset
       * @return
       */
      TileLayer.prototype.setPolygonOffset = function (offset) {
          this._polygonOffset = offset;
          return this;
      };
      TileLayer.prototype.getRenderer = function () {
          return _super.prototype.getRenderer.call(this);
      };
      //@internal
      TileLayer.prototype._getTileBBox = function (tile) {
          var map = this.getMap();
          if (!map) {
              return;
          }
          var extent2d = tile.extent2d;
          if (!extent2d) {
              return;
          }
          var res = tile.res;
          var xmin = extent2d.xmin, ymin = extent2d.ymin, xmax = extent2d.xmax, ymax = extent2d.ymax;
          var pmin = new Point(xmin, ymin), pmax = new Point(xmax, ymax);
          var min = map.pointAtResToCoordinate(pmin, res, TEMP_POINT0), max = map.pointAtResToCoordinate(pmax, res, TEMP_POINT1$1);
          return [min.x, min.y, max.x, max.y];
      };
      //@internal
      TileLayer.prototype._tileInMask = function (tile) {
          var mask = this.getMask();
          if (!mask) {
              return true;
          }
          var maskType = mask.type;
          if (!maskType || maskType.indexOf('Polygon') === -1) {
              return true;
          }
          var maskGeoJSON = this._maskGeoJSON;
          if (!maskGeoJSON || !maskGeoJSON.geometry) {
              return true;
          }
          var _a = maskGeoJSON.geometry, coordinates = _a.coordinates, type = _a.type;
          if (!coordinates || !type) {
              return true;
          }
          if (type.indexOf('Polygon') === -1) {
              return true;
          }
          if (!maskGeoJSON.bbox) {
              var extent = mask.getExtent();
              if (!extent) {
                  return true;
              }
              maskGeoJSON.bbox = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];
          }
          var tileBBOX = this._getTileBBox(tile);
          if (!tileBBOX) {
              return true;
          }
          return bboxInMask(tileBBOX, this._maskGeoJSON);
      };
      return TileLayer;
  }(Layer));
  TileLayer.registerJSONType('TileLayer');
  TileLayer.mergeOptions(options$6);
  //https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
  // function pnpoly(nvert, vertx, verty, testx, testy) {
  //     let i, j, c = 0;
  //     for (i = 0, j = nvert - 1; i < nvert; j = i++) {
  //         if (((verty[i] > testy) !== (verty[j] > testy)) &&
  //            (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i])) {
  //             c = !c;
  //         }
  //     }
  //     return c;
  // }
  function distanceToRect(min, max, xyz) {
      var dx = Math.max(min[0] - xyz[0], 0, xyz[0] - max[0]);
      var dy = Math.max(min[1] - xyz[1], 0, xyz[1] - max[1]);
      var dz = Math.max(min[2] - xyz[2], 0, xyz[2] - max[2]);
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
  }
  function sortingTiles(t0, t1) {
      return t0.z - t1.z;
  }

  var options$5 = {
      urlTemplate: '',
      'maxCacheSize': 1024
  };
  var DEFAULT_TILESIZE = new Size(256, 256);
  var EVENTS$1 = 'show hide remove setzindex forcereloadstart';
  function checkLayers(tileLayers) {
      if (!Array.isArray(tileLayers)) {
          tileLayers = [tileLayers];
      }
      return tileLayers;
  }
  /**
   * @classdesc
   * A layer used to display a group of tile layers. <br>
   * Its performance is better than add TileLayers seperately and it can help prevent limits of active webgl contexts: <br>
   * "WARNING: Too many active WebGL contexts. Oldest context will be lost"
   * @category layer
   * @extends TileLayer
   * @param {String|Number} id - tile layer's id
   * @param {TileLayer[]} layers  - TileLayers to add
   * @param {Object} [options=null] - options defined in [TileLayer]{@link TileLayer#options}
   * @example
   * new GroupTileLayer("group-tiles",[
      new maptalks.WMSTileLayer('wms', {
        'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',
        'crs' : 'EPSG:3857',
        'layers' : 'ne:ne',
        'styles' : '',
        'version' : '1.3.0',
        'format': 'image/png',
        'transparent' : true,
        'uppercase' : true
      }),
      new maptalks.TileLayer('tile2',{
        urlTemplate: 'http://korona.geog.uni-heidelberg.de/tiles/adminb/x={x}&y={y}&z={z}'
      })
    ])
   */
  var GroupTileLayer = /** @class */ (function (_super) {
      __extends(GroupTileLayer, _super);
      /**
       * @param id    - layer's id
       * @param layers  - TileLayers to add
       * @param [options=null]          - construct options
       * @param [options.*=null]             - options defined in [TileLayer]{@link TileLayer#options}
       */
      function GroupTileLayer(id, layers, options) {
          var _this = _super.call(this, id, options) || this;
          _this.layers = layers || [];
          _this._checkChildren();
          _this.layerMap = {};
          _this._groupChildren = [];
          return _this;
      }
      /**
       * Reproduce a GroupTileLayer from layer's profile JSON.
       * @param layerJSON - layer's profile JSON
       * @return
       * @static
       * @private
       * @function
       */
      GroupTileLayer.fromJSON = function (layerJSON) {
          if (!layerJSON || layerJSON['type'] !== 'GroupTileLayer') {
              return null;
          }
          var layers = layerJSON['layers'].map(function (json) { return Layer.fromJSON(json); });
          return new GroupTileLayer(layerJSON['id'], layers, layerJSON['options']);
      };
      /**
       * Get children TileLayer
       */
      GroupTileLayer.prototype.getLayers = function () {
          return this.layers;
      };
      /**
       * add tilelayers
       * @param tileLayers
       */
      GroupTileLayer.prototype.addLayer = function (tileLayers) {
          var _this = this;
          if (tileLayers === void 0) { tileLayers = []; }
          tileLayers = checkLayers(tileLayers);
          var len = this.layers.length;
          tileLayers.forEach(function (tileLayer) {
              if (!(tileLayer instanceof TileLayer)) {
                  return;
              }
              if (_this.layers.indexOf(tileLayer) === -1 && !_this.layerMap[tileLayer.getId()]) {
                  _this.layers.push(tileLayer);
              }
          });
          //layers change
          if (len !== this.layers.length) {
              this._sortLayers();
              this._refresh();
              this._renderLayers();
          }
          return this;
      };
      /**
       * remove tilelayers
       * @param tileLayers
       */
      GroupTileLayer.prototype.removeLayer = function (tileLayers) {
          var _this = this;
          if (tileLayers === void 0) { tileLayers = []; }
          tileLayers = checkLayers(tileLayers);
          var len = this.layers.length;
          tileLayers.forEach(function (tileLayer) {
              if (!(tileLayer instanceof TileLayer)) {
                  //if tilelayer is id
                  tileLayer = _this.layerMap[tileLayer];
              }
              if (!(tileLayer instanceof TileLayer)) {
                  return;
              }
              var index = _this.layers.indexOf(tileLayer);
              if (index >= 0) {
                  _this.layers.splice(index, 1);
                  tileLayer._doRemove();
                  tileLayer.off(EVENTS$1, _this._onLayerShowHide, _this);
              }
          });
          //layers change
          if (len !== this.layers.length) {
              this._refresh();
              this._renderLayers();
          }
          return this;
      };
      /**
     * clear tilelayers
     */
      GroupTileLayer.prototype.clearLayers = function () {
          var _this = this;
          this.layers.forEach(function (layer) {
              layer._doRemove();
              layer.off(EVENTS$1, _this._onLayerShowHide, _this);
          });
          this.layers = [];
          this._refresh();
          this._renderLayers();
          return this;
      };
      /**
       * Export the GroupTileLayer's profile json. <br>
       * Layer's profile is a snapshot of the layer in JSON format. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return layer's profile JSON
       */
      GroupTileLayer.prototype.toJSON = function () {
          var profile = {
              'type': this.getJSONType(),
              'id': this.getId(),
              'layers': this.layers.map(function (layer) { return layer.toJSON(); }),
              'options': this.config()
          };
          return profile;
      };
      GroupTileLayer.prototype.getTileSize = function (id) {
          var layer = this.getLayer(id);
          if (!layer) {
              return DEFAULT_TILESIZE;
          }
          return layer.getTileSize();
      };
      /**
       * Get tiles at zoom (or current zoom)
       * @param z
       * @returns tiles
       */
      GroupTileLayer.prototype.getTiles = function (z, parentLayer) {
          var layers = this.layers;
          var tiles = [];
          var count = 0;
          for (var i = 0, l = layers.length; i < l; i++) {
              var layer = layers[i];
              if (!layer || !layer.options['visible'] || !layer.isVisible() || !layer.getMap()) {
                  continue;
              }
              var childGrid = layer.getTiles(z, parentLayer || this);
              if (!childGrid || childGrid.count === 0) {
                  continue;
              }
              count += childGrid.count;
              pushIn(tiles, childGrid.tileGrids);
          }
          return {
              count: count,
              tileGrids: tiles
          };
      };
      GroupTileLayer.prototype.onAdd = function () {
          this._sortLayers();
          this._refresh();
          _super.prototype.onAdd.call(this);
      };
      GroupTileLayer.prototype.onRemove = function () {
          var _this = this;
          this.layers.forEach(function (layer) {
              layer._doRemove();
              layer.off(EVENTS$1, _this._onLayerShowHide, _this);
          });
          this.layerMap = {};
          this._groupChildren = [];
          _super.prototype.onRemove.call(this);
      };
      GroupTileLayer.prototype.getLayer = function (id) {
          return this.getChildLayer(id);
      };
      GroupTileLayer.prototype.getChildLayer = function (id) {
          var layer = this.layerMap[id];
          if (layer) {
              return layer;
          }
          for (var i = 0; i < this._groupChildren.length; i++) {
              var child = this._groupChildren[i].getChildLayer(id);
              if (child) {
                  return child;
              }
          }
          return null;
      };
      //@internal
      GroupTileLayer.prototype._removeChildTileCache = function (layer) {
          if (!layer) {
              return this;
          }
          var renderer = this.getRenderer();
          if (!renderer) {
              return this;
          }
          var cache;
          var id = layer.getId();
          var validateCache = function () {
              return cache && cache.info && cache.info.layer === id;
          };
          //clear LRU
          if (renderer.tileCache) {
              var keys = renderer.tileCache.keys();
              keys.forEach(function (key) {
                  cache = renderer.tileCache.get(key);
                  if (validateCache()) {
                      renderer.tileCache.remove(key);
                  }
              });
          }
          //clear tilesInView cache
          var tilesInView = renderer.tilesInView || {};
          for (var key in tilesInView) {
              cache = tilesInView[key];
              if (validateCache()) {
                  delete tilesInView[key];
              }
          }
          //cancel image load
          var tilesLoading = renderer.tilesLoading || {};
          for (var key in tilesLoading) {
              cache = tilesLoading[key];
              if (validateCache()) {
                  renderer.abortTileLoading(cache.image, cache.info);
              }
          }
          return this;
      };
      //@internal
      GroupTileLayer.prototype._onLayerShowHide = function (e) {
          var _a = e || {}, type = _a.type, target = _a.target;
          //listen tilelayer.remove() method fix #1629
          if (type === 'remove' && target) {
              this.layers.splice(this.layers.indexOf(target), 1);
              target._doRemove();
              target.off(EVENTS$1, this._onLayerShowHide, this);
              this._refresh();
          }
          else if (type === 'setzindex') {
              this._sortLayers();
          }
          else if (type === 'forcereloadstart') {
              this._removeChildTileCache(target);
          }
          this._renderLayers();
      };
      // render all layers
      //@internal
      GroupTileLayer.prototype._renderLayers = function () {
          var renderer = this.getRenderer();
          if (renderer) {
              renderer.setToRedraw();
          }
          return this;
      };
      // reset layerMap,_groupChildren,listen tilelayers events
      //@internal
      GroupTileLayer.prototype._refresh = function () {
          var _this = this;
          var map = this.getMap();
          this._groupChildren = [];
          this.layerMap = {};
          this.layers.forEach(function (layer) {
              _this.layerMap[layer.getId()] = layer;
              // @ts-ignore
              if (layer.getChildLayer) {
                  _this._groupChildren.push(layer);
              }
              if (!layer.getMap()) {
                  layer._bindMap(map);
              }
              //remove old event handler
              layer.off(EVENTS$1, _this._onLayerShowHide, _this);
              layer.on(EVENTS$1, _this._onLayerShowHide, _this);
          });
          return this;
      };
      GroupTileLayer.prototype.isVisible = function () {
          if (!_super.prototype.isVisible.call(this)) {
              return false;
          }
          var children = this.layers;
          for (var i = 0, l = children.length; i < l; i++) {
              if (children[i].isVisible()) {
                  return true;
              }
          }
          return false;
      };
      //@internal
      GroupTileLayer.prototype._checkChildren = function () {
          var _this = this;
          var ids = {};
          this.layers.forEach(function (layer) {
              var layerId = layer.getId();
              if (ids[layerId]) {
                  throw new Error("Duplicate child layer id (".concat(layerId, ") in the GroupTileLayer (").concat(_this.getId(), ")"));
              }
              else {
                  ids[layerId] = 1;
              }
          });
      };
      //@internal
      GroupTileLayer.prototype._sortLayers = function () {
          this.layers.sort(function (a, b) {
              return a.options.zIndex - b.options.zIndex;
          });
      };
      return GroupTileLayer;
  }(TileLayer));
  GroupTileLayer.registerJSONType('GroupTileLayer');
  GroupTileLayer.mergeOptions(options$5);

  /**
   * @property options                     - TileLayer's options
   * @property [options.service=WMS]       - WMS Service
   * @property options.layers              - Comma-separated list of WMS layers to show.
   * @property [options.styles='']         - Comma-separated list of WMS styles.
   * @property [options.format=image/jpeg] - WMS image format (use `'image/png'` for layers with transparency).
   * @property [options.transparent=false] - Is the tile transparent
   * @property [options.version=1.1.1]     - Version of the WMS service to use
   * @property [options.crs=null]          - Coordinate Reference System to use for the WMS requests, defaults to map CRS. Don't change this if you're not sure what it means.
   * @property [options.uppercase=false]   - If `true`, WMS request parameter keys will be uppercase.
   * @property [options.detectRetina=false]   - If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
   * @memberOf WMSTileLayer
   * @instance
   */
  var options$4 = {
      urlTemplate: '',
      crs: null,
      uppercase: false,
      detectRetina: false
  };
  var defaultWmsParams = {
      service: 'WMS',
      request: 'GetMap',
      layers: '',
      styles: '',
      format: 'image/jpeg',
      transparent: false,
      version: '1.1.1'
  };
  var wmsExcludeParams;
  /**
   * @classdesc
   * Used to display [WMS]{https://en.wikipedia.org/wiki/Web_Map_Service} services as tile layers on the map. Extends [TileLayer]{@link TileLayer}.
   * Implemented based on Leaflet's TileLayer.WMS.
   * @category layer
   * @extends TileLayer
   * @param id - tile layer's id
   * @param - options defined in [WMSTileLayer]{@link TileLayer#options}
   * @example
   * var layer = new maptalks.WMSTileLayer('wms', {
   *     'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',
   *     'crs' : 'EPSG:3857',
   *     'layers' : 'ne:ne',
   *     'styles' : '',
   *     'version' : '1.3.0',
   *     'format': 'image/png',
   *     'transparent' : true,
   *     'uppercase' : true
   * });
   */
  var WMSTileLayer = /** @class */ (function (_super) {
      __extends(WMSTileLayer, _super);
      function WMSTileLayer(id, options) {
          var _this = _super.call(this, id) || this;
          if (!wmsExcludeParams) {
              wmsExcludeParams = extend$2({}, _this.options);
          }
          _this.wmsParams = extend$2({}, defaultWmsParams);
          _this.setOptions(options);
          _this.setZIndex(options.zIndex);
          if (!Browser$1.proxy) {
              _this._optionsHook(options);
          }
          return _this;
      }
      //in Hook,Reset wmsParams
      //@internal
      WMSTileLayer.prototype._optionsHook = function (options) {
          if (options === void 0) { options = {}; }
          for (var p in options) {
              //clear tilesize cache
              if (p === 'tileSize') {
                  this._tileSize = null;
              }
              if (!(p in wmsExcludeParams)) {
                  this.wmsParams[p] = options[p];
              }
          }
          var tileSize = this.getTileSize();
          this.wmsParams.width = tileSize.width;
          this.wmsParams.height = tileSize.height;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          return this;
      };
      WMSTileLayer.prototype.onAdd = function () {
          var dpr = this.getMap().getDevicePixelRatio();
          var r = options$4.detectRetina ? dpr : 1;
          this.wmsParams.width *= r;
          this.wmsParams.height *= r;
          // @ts-ignore
          var crs = this.options.crs || this.getMap().getProjection().code;
          var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
          this.wmsParams[projectionKey] = crs;
          _super.prototype.onAdd.call(this);
      };
      WMSTileLayer.prototype.getTileUrl = function (x, y, z) {
          var res = this.getSpatialReference().getResolution(z), tileConfig = this._getTileConfig(), tileExtent = tileConfig.getTilePrjExtent(x, y, res);
          var max = tileExtent.getMax(), min = tileExtent.getMin();
          var bbox = (this._wmsVersion >= 1.3 && (this.wmsParams.crs === 'EPSG:4326' || this.wmsParams.crs === 'EPSG:4490') ?
              [min.y, min.x, max.y, max.x] :
              [min.x, min.y, max.x, max.y]).join(',');
          var url = _super.prototype.getTileUrl.call(this, x, y, z);
          return url +
              // @ts-ignore
              getParamString(this.wmsParams, url, this.options.uppercase) +
              // @ts-ignore
              (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
      };
      /**
       * Export the WMSTileLayer's json. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return layer's JSON
       */
      WMSTileLayer.prototype.toJSON = function () {
          return {
              'type': 'WMSTileLayer',
              'id': this.getId(),
              'options': this.config()
          };
      };
      /**
       * Reproduce a WMSTileLayer from layer's JSON.
       * @param layerJSON - layer's JSON
       * @return a WMSTileLayer instance
       * @static
       * @private
       * @function
       */
      WMSTileLayer.fromJSON = function (layerJSON) {
          if (!layerJSON || layerJSON['type'] !== 'WMSTileLayer') {
              return null;
          }
          return new WMSTileLayer(layerJSON['id'], layerJSON['options']);
      };
      return WMSTileLayer;
  }(TileLayer));
  WMSTileLayer.registerJSONType('WMSTileLayer');
  WMSTileLayer.mergeOptions(options$4);
  // From Leaflet
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)
  function getParamString(obj, existingUrl, uppercase) {
      var params = [];
      for (var i in obj) {
          params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
      }
      return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
  }

  /**
   * @classdesc
   * @ignore
   * @category layer
   * @extends TileLayer
   * @param id - tile layer's id
   * @param - options defined in [CanvasTileLayer]{@link TileLayer#options}
   * @example
   * var layer = new CanvasTileLayer("tile");
   * layer.drawTile = ()
   */
  var CanvasTileLayer = /** @class */ (function (_super) {
      __extends(CanvasTileLayer, _super);
      function CanvasTileLayer(id, options) {
          var _this = _super.call(this, id, options) || this;
          if (!_this.options.hasOwnProperty('forceRenderOnMoving')) {
              // force not to forceRenderOnMoving
              _this.options['forceRenderOnMoving'] = false;
          }
          return _this;
      }
      /**
       * The interface method to draw on canvsa tile
       * @param canvas  canvas to draw on
       * @param options current options
       * @param options current options
       */
      CanvasTileLayer.prototype.drawTile = function ( /*canvas, options*/) {
      };
      /**
       * Export the CanvasTileLayer's json. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return layer's JSON
       */
      CanvasTileLayer.prototype.toJSON = function () {
          return {
              'type': 'CanvasTileLayer',
              'id': this.getId(),
              'options': this.config()
          };
      };
      /**
       * Reproduce a CanvasTileLayer from layer's JSON.
       * @param layerJSON - layer's JSON
       * @static
       * @private
       * @function
       */
      CanvasTileLayer.fromJSON = function (layerJSON) {
          if (!layerJSON || layerJSON['type'] !== 'CanvasTileLayer') {
              return null;
          }
          return new CanvasTileLayer(layerJSON['id'], layerJSON['options']);
      };
      return CanvasTileLayer;
  }(TileLayer));
  CanvasTileLayer.registerJSONType('CanvasTileLayer');

  function createGLContext(canvas, options) {
      var attributes = {
          'alpha': true,
          'stencil': true,
          'preserveDrawingBuffer': true,
          'antialias': false
      };
      var names = ['webgl', 'experimental-webgl'];
      var context = null;
      /* eslint-disable no-empty */
      for (var i = 0; i < names.length; ++i) {
          try {
              context = canvas.getContext(names[i], options || attributes);
          }
          catch (e) { }
          if (context) {
              break;
          }
      }
      return context;
      /* eslint-enable no-empty */
  }
  /**
  * Create a shader object
  * @param gl GL context
  * @param type the type of the shader object to be created
  * @param source shader program (string)
  * @return created shader object, or null if the creation has failed.
  * @private
  */
  function compileShader(gl, type, source) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
          var error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Error('Failed to compile shader: ' + error);
      }
      return shader;
  }
  /**
   * Create the linked program object
   * @param gl WebGL2RenderingContext
   * @param vert a vertex shader program (string)
   * @param frag a fragment shader program (string)
   * @return created program object, or null if the creation has failed
   * @private
   */
  function createProgram(gl, vert, frag) {
      var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vert);
      var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, frag);
      if (!vertexShader || !fragmentShader) {
          return null;
      }
      var program = gl.createProgram();
      if (!program) {
          return null;
      }
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      return { program: program, vertexShader: vertexShader, fragmentShader: fragmentShader };
  }
  /**
   * Enable vertex attributes
   * @param gl WebGL2RenderingContext
   * @param attributes [[name, stride, type], [name, stride, type]...]
   * @example
   * rendererr.enableVertexAttrib([
   *  ['a_position', 3, 'FLOAT'],
   *  ['a_normal', 3, 'FLOAT']
   * ]);
   * @private
   */
  function enableVertexAttrib(gl, program, attributes) {
      if (Array.isArray(attributes[0])) {
          var FSIZE = Float32Array.BYTES_PER_ELEMENT;
          var STRIDE = 0;
          for (var i = 0; i < attributes.length; i++) {
              STRIDE += (attributes[i][1] || 0);
          }
          var offset = 0;
          for (var i = 0; i < attributes.length; i++) {
              var attr = gl.getAttribLocation(program, attributes[i][0]);
              if (attr < 0) {
                  throw new Error('Failed to get the storage location of ' + attributes[i][0]);
              }
              gl.vertexAttribPointer(attr, attributes[i][1], gl[attributes[i][2] || 'FLOAT'], false, FSIZE * STRIDE, FSIZE * offset);
              offset += (attributes[i][1] || 0);
              gl.enableVertexAttribArray(attr);
          }
      }
      else {
          var attr = gl.getAttribLocation(program, attributes[0]);
          gl.vertexAttribPointer(attr, attributes[1], gl[attributes[2] || 'FLOAT'], false, 0, 0);
          gl.enableVertexAttribArray(attr);
      }
  }
  var DEPTH_FUNC_CONSTANTS = {
      'never': 0x0200,
      '<': 0x0201,
      '=': 0x0202,
      '<=': 0x0203,
      '>': 0x0204,
      '!=': 0x0205,
      '>=': 0x0206,
      'always': 0x0207
  };
  function getDepthFunc(v) {
      return DEPTH_FUNC_CONSTANTS[v];
  }

  // used to debug tiles
  var DEFAULT_BASE_COLOR = [1, 1, 1, 1];
  var TEMP_FLOAT32ARRAY = new Float32Array(8);
  var TEMP_INT16ARRAY = new Int16Array(8);
  var shaders = {
      'vertexShader': "\n        attribute vec2 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 0., 1.);\n\n            v_texCoord = a_texCoord;\n        }\n    ",
      // fragment shader, can be replaced by layer.options.fragmentShader
      'fragmentShader': "\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug_line;\n        uniform vec4 u_base_color;\n        uniform float u_alpha_test;\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug_line == 1.) {\n                gl_FragColor = vec4(0., 1., 0., 1.);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n            gl_FragColor *= u_base_color;\n            if (gl_FragColor.a < u_alpha_test) {\n                discard;\n            }\n        }\n    "
  };
  //reusable temporary variables
  var v2 = ['', 0], v3 = [0, 0, 0], arr16 = new Array(16);
  var DEBUG_POINT = new Point(20, 20);
  /**
   * A mixin providing image support in WebGL env
   * @mixin ImageGLRenderable
   * @protected
   */
  var ImageGLRenderable = function (Base) {
      var renderable = /** @class */ (function (_super) {
          __extends(class_1, _super);
          function class_1() {
              var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
              // webgl point for layerAltitude
              //@internal
              _this._layerAlt = 0;
              //@internal
              _this._layerAltitude = 0;
              return _this;
          }
          /**
           * 绘制图片数据
           *
           * @english
           * Draw an image at x, y at map's gl zoom
           * @param image
           * @param x x at map's gl zoom
           * @param y y at map's gl zoom
           * @param w width at map's gl zoom
           * @param h height at map's gl zoom
           * @param scale scale at map's gl zoom
           * @param opacity
           * @param debugInfo
           * @param baseColor
           */
          class_1.prototype.drawGLImage = function (image, x, y, w, h, scale, opacity, debugInfo, baseColor) {
              if (this.gl.program !== this.program) {
                  this.useProgram(this.program);
              }
              var gl = this.gl;
              this.loadTexture(image);
              var inGroup = this.canvas.gl && this.canvas.gl.wrap;
              if (inGroup) {
                  var layerOpacity = this.layer && this.layer.options['opacity'];
                  if (isNil(layerOpacity)) {
                      layerOpacity = 1;
                  }
                  opacity *= layerOpacity;
              }
              v3[0] = x || 0;
              v3[1] = y || 0;
              v3[2] = 0;
              var layer = this.layer;
              if (layer) {
                  var altitude = layer.options.altitude;
                  var altIsNumber = isNumber(altitude);
                  if (!altIsNumber) {
                      this._layerAlt = 0;
                  }
                  //update _layerAlt cache
                  if (this._layerAltitude !== altitude && altIsNumber) {
                      var map = layer.getMap();
                      if (map) {
                          var z = map.altitudeToPoint(altitude, map.getGLRes());
                          this._layerAltitude = altitude;
                          this._layerAlt = z;
                      }
                  }
              }
              v3[2] = this._layerAlt || 0;
              var uMatrix = identity$1(arr16);
              translate(uMatrix, uMatrix, v3);
              scale$1(uMatrix, uMatrix, [scale, scale, 1]);
              multiply(uMatrix, this.getMap().projViewMatrix, uMatrix);
              gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
              gl.uniform1f(this.program['u_opacity'], opacity);
              gl.uniform1f(this.program['u_debug_line'], 0);
              gl.uniform4fv(this.program['u_base_color'], baseColor || DEFAULT_BASE_COLOR);
              gl.uniform1f(this.program['u_alpha_test'], this.layer.options['alphaTest'] || 0);
              var glBuffer = image.glBuffer;
              if (glBuffer && (glBuffer.width !== w || glBuffer.height !== h)) {
                  this.saveImageBuffer(glBuffer);
                  delete image.glBuffer;
              }
              if (!image.glBuffer) {
                  image.glBuffer = this.bufferTileData(0, 0, w, h);
              }
              else {
                  gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
              }
              v2[0] = 'a_position';
              v2[1] = 2;
              v2[2] = image.glBuffer.type;
              this.enableVertexAttrib(v2); // ['a_position', 3]
              gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
              v2[0] = 'a_texCoord';
              v2[1] = 2;
              v2[2] = 'UNSIGNED_BYTE';
              this.enableVertexAttrib(v2);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              if (debugInfo) {
                  this.drawDebug(uMatrix, 0, 0, w, h, debugInfo);
              }
          };
          /**
           * 绘制 debug 信息，包括边线和行列号
           * @param uMatrix
           * @param x
           * @param y
           * @param w
           * @param h
           * @param debugInfo
           */
          class_1.prototype.drawDebug = function (uMatrix, x, y, w, h, debugInfo) {
              var gl = this.gl;
              gl.disable(gl.DEPTH_TEST);
              gl.bindBuffer(gl.ARRAY_BUFFER, this._debugBuffer);
              this.enableVertexAttrib(['a_position', 2, 'FLOAT']);
              gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                  x, y,
                  x + w, y,
                  x + w, y - h,
                  x, y - h,
                  x, y
              ]), gl.DYNAMIC_DRAW);
              gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
              gl.uniform1f(this.program['u_opacity'], 1);
              gl.uniform1f(this.program['u_debug_line'], 1);
              gl.uniform4fv(this.program['u_base_color'], DEFAULT_BASE_COLOR);
              gl.uniform1f(this.program['u_alpha_test'], this.layer.options['alphaTest'] || 0);
              gl.drawArrays(gl.LINE_STRIP, 0, 5);
              //draw debug info
              var canvas = this._debugInfoCanvas;
              if (!canvas) {
                  var dpr = this.getMap().getDevicePixelRatio() > 1 ? 2 : 1;
                  canvas = this._debugInfoCanvas = document.createElement('canvas');
                  canvas.width = 256 * dpr;
                  canvas.height = 32 * dpr;
                  var ctx_1 = canvas.getContext('2d');
                  ctx_1.font = '20px monospace';
                  ctx_1.scale(dpr, dpr);
              }
              var ctx = canvas.getContext('2d');
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              var color = this.layer.options['debugOutline'];
              Canvas.fillText(ctx, debugInfo, DEBUG_POINT, color);
              this.loadTexture(canvas);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
              w = 256;
              var x1 = x;
              var x2 = x + w;
              var y1 = y - h + 32;
              var y2 = y - h;
              gl.bufferData(gl.ARRAY_BUFFER, this.set8(x1, y1, x1, y2, x2, y1, x2, y2), gl.DYNAMIC_DRAW);
              gl.uniform1f(this.program['u_debug_line'], 0);
              gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
              this.enableVertexAttrib(['a_texCoord', 2, 'UNSIGNED_BYTE']);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              gl.enable(gl.DEPTH_TEST);
          };
          /**
           * 构建瓦片顶点数据
           * @param x
           * @param y
           * @param w
           * @param h
           * @param buffer
           */
          class_1.prototype.bufferTileData = function (x, y, w, h, buffer) {
              var x1 = x;
              var x2 = x + w;
              var y1 = y;
              var y2 = y - h;
              var data;
              if (isInteger(x1) && isInteger(x2) && isInteger(y1) && isInteger(y2)) {
                  data = this.set8Int(x1, y1, x1, y2, x2, y1, x2, y2);
              }
              else {
                  data = this.set8(x1, y1, x1, y2, x2, y1, x2, y2);
              }
              var glBuffer = this.loadImageBuffer(data, buffer);
              glBuffer.width = w;
              glBuffer.height = h;
              glBuffer.type = data instanceof Int16Array ? 'SHORT' : 'FLOAT';
              return glBuffer;
          };
          /**
           * 对于需要两个 canvas 来绘制的图层我们需要重新创建一个 canvas
           * @english
           * Create another GL canvas to draw gl images
           * For layer renderer that needs 2 seperate canvases for 2d and gl
           */
          class_1.prototype.createCanvas2 = function () {
              this.canvas2 = Canvas.createCanvas(this.canvas.width, this.canvas.height);
          };
          /**
           * 创建 webgl 实例，优先使用 canvas2
           * @english
           * Get webgl context(this.gl). It prefers canvas2, and will change to this.canvas if canvas2 is not created
           */
          class_1.prototype.createGLContext = function () {
              if (this.canvas.gl && this.canvas.gl.wrap) {
                  this.gl = this.canvas.gl.wrap();
              }
              else {
                  this.gl = createGLContext(this.canvas2 || this.canvas, this.layer.options['glOptions']);
              }
              var gl = this.gl;
              gl.clearColor(0.0, 0.0, 0.0, 0.0);
              gl.enable(gl.DEPTH_TEST);
              gl.enable(gl.STENCIL_TEST);
              gl.enable(gl.BLEND);
              gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              this.program = this.createProgram(shaders['vertexShader'], this.layer.options['fragmentShader'] || shaders['fragmentShader']);
              this._debugBuffer = this.createBuffer();
              this.useProgram(this.program);
              // input texture vec data
              this.texBuffer = this.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
              this.enableVertexAttrib(['a_texCoord', 2, 'UNSIGNED_BYTE']);
              gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array([
                  0.0, 0.0,
                  0.0, 1.0,
                  1.0, 0.0,
                  1.0, 1.0
              ]), gl.STATIC_DRAW);
              this.enableSampler('u_image');
              // Enable texture unit 0
              gl.activeTexture(gl['TEXTURE0']);
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
          };
          /**
           * Resize GL canvas with renderer's 2D canvas
           */
          class_1.prototype.resizeGLCanvas = function () {
              if (this.gl) {
                  this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
              }
              if (!this.canvas2) {
                  return;
              }
              if (this.canvas2.width !== this.canvas.width || this.canvas2.height !== this.canvas.height) {
                  this.canvas2.width = this.canvas.width;
                  this.canvas2.height = this.canvas.height;
              }
          };
          /**
           * Clear gl canvas
           */
          class_1.prototype.clearGLCanvas = function () {
              if (this.gl) {
                  this.gl.clearStencil(0xFF);
                  this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);
              }
              if (!this.gl.wrap) {
                  this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
              }
          };
          class_1.prototype.disposeImage = function (image) {
              if (!image) {
                  return;
              }
              if (image.texture) {
                  this.saveTexture(image.texture);
              }
              if (image.glBuffer) {
                  this.saveImageBuffer(image.glBuffer);
              }
              delete image.texture;
              delete image.glBuffer;
          };
          //@internal
          class_1.prototype._createTexture = function (image) {
              var gl = this.gl;
              var texture = this.getTexture() || gl.createTexture(); // Create a texture object
              // Bind the texture object to the target
              gl.bindTexture(gl.TEXTURE_2D, texture);
              // from mapbox-gl-js
              // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              var genMipmap = this.layer.options['mipmapTexture'];
              if (genMipmap && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height))) {
                  image = resize(image);
              }
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
              if (genMipmap) {
                  gl.generateMipmap(gl.TEXTURE_2D);
              }
              return texture;
          };
          /**
           * Get a texture from cache or create one if cache is empty
           */
          class_1.prototype.getTexture = function () {
              if (!this._textures) {
                  this._textures = [];
              }
              var textures = this._textures;
              return textures && textures.length > 0 ? textures.pop() : null;
          };
          /**
           * Save a texture to the cache
           */
          class_1.prototype.saveTexture = function (texture) {
              this._textures.push(texture);
          };
          /**
           * Load image into a text and bind it with WebGLContext
           * @param image
           */
          class_1.prototype.loadTexture = function (image) {
              var map = this.getMap();
              var gl = this.gl;
              var texture = image.texture; // Create a texture object
              if (!texture) {
                  texture = this._createTexture(image);
                  image.texture = texture;
              }
              gl.bindTexture(gl.TEXTURE_2D, texture);
              var genMipmap = this.layer.options['mipmapTexture'];
              if (genMipmap) {
                  if (map.isMoving() && map.getRenderer().isViewChanged()) {
                      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                  }
                  else {
                      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                  }
              }
              return texture;
          };
          /**
           * Get a texture from cache or create one if cache is empty
           */
          class_1.prototype.getImageBuffer = function () {
              if (!this._imageBuffers) {
                  this._imageBuffers = [];
              }
              var imageBuffers = this._imageBuffers;
              return imageBuffers && imageBuffers.length > 0 ? imageBuffers.pop() : null;
          };
          /**
           * Save a texture to the cache
           * @param buffer
           */
          class_1.prototype.saveImageBuffer = function (buffer) {
              if (!this._imageBuffers) {
                  this._imageBuffers = [];
              }
              this._imageBuffers.push(buffer);
          };
          /**
           * Load image into a text and bind it with WebGLContext
           * @returns
           */
          class_1.prototype.loadImageBuffer = function (data, glBuffer) {
              var gl = this.gl;
              // Create a buffer object
              var buffer = glBuffer || this.createImageBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
              gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
              return buffer;
          };
          class_1.prototype.createImageBuffer = function () {
              return this.getImageBuffer() || this.createBuffer();
          };
          /**
           * remove all the resources and remove gl canvas
           */
          class_1.prototype.removeGLCanvas = function () {
              // release resources
              var gl = this.gl;
              if (!gl) {
                  return;
              }
              if (this._debugBuffer) {
                  gl.deleteBuffer(this._debugBuffer);
                  delete this._debugBuffer;
              }
              if (this._buffers) {
                  this._buffers.forEach(function (b) {
                      gl.deleteBuffer(b);
                  });
                  delete this._buffers;
              }
              if (this._textures) {
                  this._textures.forEach(function (t) { return gl.deleteTexture(t); });
                  delete this._textures;
              }
              if (this._debugInfoCanvas) {
                  var texture = this._debugInfoCanvas.texture;
                  if (texture) {
                      gl.deleteTexture(texture);
                  }
                  delete this._debugInfoCanvas.texture;
                  delete this._debugInfoCanvas;
              }
              var program = gl.program;
              gl.deleteShader(program.fragmentShader);
              gl.deleteShader(program.vertexShader);
              gl.deleteProgram(program);
              delete this.gl;
              delete this.canvas2;
          };
          //----------------------- webgl utils unlike to change ---------------------------------
          /**
           * Create a WebGL buffer
           * @returns {WebGLBuffer}
           */
          class_1.prototype.createBuffer = function () {
              var gl = this.gl;
              // Create the buffer object
              var buffer = gl.createBuffer();
              if (!buffer) {
                  throw new Error('Failed to create the buffer object');
              }
              if (!this._buffers) {
                  this._buffers = [];
              }
              this._buffers.push(buffer);
              return buffer;
          };
          /**
           * Enable vertex attributes
           * @params attributes
           * @example
           * rendererr.enableVertexAttrib(['a_position', 3, 'FLOAT']);
           */
          class_1.prototype.enableVertexAttrib = function (attributes) {
              enableVertexAttrib(this.gl, this.gl.program, attributes);
          };
          /**
           * Create the linked program object
           * @param vert a vertex shader program (string)
           * @param frag a fragment shader program (string)
           * @return created program object, or null if the creation has failed
           */
          class_1.prototype.createProgram = function (vert, frag) {
              var gl = this.gl;
              var _a = createProgram(gl, vert, frag), program = _a.program, vertexShader = _a.vertexShader, fragmentShader = _a.fragmentShader;
              var numUniforms = gl.getProgramParameter(program, 0x8B86);
              var activeUniforms = [];
              for (var i = 0; i < numUniforms; ++i) {
                  var info = gl.getActiveUniform(program, i);
                  activeUniforms.push(info.name);
              }
              program.vertexShader = vertexShader;
              program.fragmentShader = fragmentShader;
              this._initUniforms(program, activeUniforms);
              return program;
          };
          /**
           * use the given program
           * @param {WebGLProgram} program
           */
          class_1.prototype.useProgram = function (program) {
              var gl = this.gl;
              gl.useProgram(program);
              gl.program = program;
              return this;
          };
          /**
           * 启用纹理采样器
           * Enable a sampler, and set texture
           * @param sampler
           * @param texIdx id
           */
          class_1.prototype.enableSampler = function (sampler, texIdx) {
              var gl = this.gl;
              var uSampler = this._getUniform(gl.program, sampler);
              if (!texIdx) {
                  texIdx = 0;
              }
              // Set the texture unit to the sampler
              gl.uniform1i(uSampler, texIdx);
              return uSampler;
          };
          //@internal
          class_1.prototype._initUniforms = function (program, uniforms) {
              for (var i = 0; i < uniforms.length; i++) {
                  var name_1 = uniforms[i];
                  var uniform = uniforms[i];
                  var b = name_1.indexOf('[');
                  if (b >= 0) {
                      name_1 = name_1.substring(0, b);
                      if (!IS_NODE) {
                          // In browser, remove [0] from uniforma declaration
                          uniform = uniform.substring(0, b);
                      }
                  }
                  program[name_1] = this._getUniform(program, uniform);
              }
          };
          //@internal
          class_1.prototype._getUniform = function (program, uniformName) {
              var gl = this.gl;
              var uniform = gl.getUniformLocation(program, uniformName);
              if (!uniform) {
                  throw new Error('Failed to get the storage location of ' + uniformName);
              }
              return uniform;
          };
          class_1.prototype.set8 = function (a0, a1, a2, a3, a4, a5, a6, a7) {
              var out = TEMP_FLOAT32ARRAY;
              out[0] = a0;
              out[1] = a1;
              out[2] = a2;
              out[3] = a3;
              out[4] = a4;
              out[5] = a5;
              out[6] = a6;
              out[7] = a7;
              return out;
          };
          class_1.prototype.set8Int = function (a0, a1, a2, a3, a4, a5, a6, a7) {
              var out = TEMP_INT16ARRAY;
              out[0] = a0;
              out[1] = a1;
              out[2] = a2;
              out[3] = a3;
              out[4] = a4;
              out[5] = a5;
              out[6] = a6;
              out[7] = a7;
              return out;
          };
          return class_1;
      }(Base));
      return renderable;
  };
  function resize(image) {
      if (isPowerOfTwo(image.width) && isPowerOfTwo(image.height)) {
          return image;
      }
      var width = image.width;
      var height = image.height;
      if (!isPowerOfTwo(width)) {
          width = ceilPowerOfTwo(width);
      }
      if (!isPowerOfTwo(height)) {
          height = ceilPowerOfTwo(height);
      }
      var canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      var ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(image, 0, 0, width, height);
      return canvas;
  }
  function isPowerOfTwo(value) {
      return (value & (value - 1)) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }

  /**
   * 配置参数
   *
   * @english
   * @property options                     - ImageLayer's options
   * @property options.crossOrigin=null    - image's corssOrigin
   * @property options.renderer=gl         - ImageLayer's renderer, canvas or gl. gl tiles requires image CORS that canvas doesn't. canvas tiles can't pitch.
   * @property options.alphaTest=0         - only for gl renderer, pixels alpha <= alphaTest will be discarded
   * @property options.depthMask=true      - only for gl renderer, whether to write into depth buffer
   * @property options.depthFunc=String    - only for gl renderer, depth function, available values: never,<, =, <=, >, !=, >=, always
   * @memberOf ImageLayer
   * @instance
   */
  var options$3 = {
      renderer: Browser$1.webgl ? 'gl' : 'canvas',
      crossOrigin: null,
      alphaTest: false,
      depthMask: true,
      depthFunc: '<='
  };
  var TEMP_POINT$2 = new Point(0, 0);
  /**
   * images layer,可指定图像地理位置及透明的
   *
   * @english
   * @classdesc
   * A layer used to display images, you can specify each image's geographic extent and opacity
   * @category layer
   * @extends Layer
   * @param id - tile layer's id
   * @param images=null - images
   * @param options=null - options defined in [ImageLayer]{@link ImageLayer#options}
   * @example
   * new ImageLayer("images", [{
          url : 'http://example.com/foo.png',
          extent: [xmin, ymin, xmax, ymax],
          opacity : 1
      }])
   */
  var ImageLayer = /** @class */ (function (_super) {
      __extends(ImageLayer, _super);
      function ImageLayer(id, images, options) {
          var _this = this;
          if (images && !Array.isArray(images) && !images.url) {
              options = images;
              images = null;
          }
          _this = _super.call(this, id, options) || this;
          _this._images = images;
          return _this;
      }
      ImageLayer.prototype.onAdd = function () {
          this._prepareImages(this._images);
      };
      /**
       * 设置图像并重新绘制
       *
       * @english
       * Set images and redraw
       * @param images - new images
       * @return this
       */
      ImageLayer.prototype.setImages = function (images) {
          this._images = images;
          this._prepareImages(images);
          return this;
      };
      /**
       * 获取图像
       *
       * @english
       * Get images
       * @return
       */
      ImageLayer.prototype.getImages = function () {
          return this._images;
      };
      //@internal
      ImageLayer.prototype._prepareImages = function (images) {
          images = images || [];
          if (!Array.isArray(images)) {
              images = [images];
          }
          var map = this.getMap();
          var glRes = map.getGLRes();
          this._imageData = images.map(function (img) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore 需/src/geo/Extent.js -> ts 并支持只传一个参数
              var extent = new Extent(img.extent);
              return extend$2({}, img, {
                  extent: extent,
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-ignore 需/src/geo/Extent.js -> ts 并支持少传out参数
                  extent2d: extent.convertTo(function (c) { return map.coordToPointAtRes(c, glRes); })
              });
          });
          this._images = images;
          var renderer = this.getRenderer();
          if (renderer) {
              renderer.refreshImages();
          }
      };
      ImageLayer.prototype.getRenderer = function () {
          return _super.prototype.getRenderer.call(this);
      };
      return ImageLayer;
  }(Layer));
  ImageLayer.mergeOptions(options$3);
  var EMPTY_ARRAY$1 = [];
  var ImageLayerCanvasRenderer = /** @class */ (function (_super) {
      __extends(ImageLayerCanvasRenderer, _super);
      function ImageLayerCanvasRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ImageLayerCanvasRenderer.prototype.isDrawable = function () {
          if (this.getMap().getPitch()) {
              if (console) {
                  console.warn('ImageLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
              }
              return false;
          }
          return true;
      };
      ImageLayerCanvasRenderer.prototype.checkResources = function () {
          var _this = this;
          if (this._imageLoaded) {
              return EMPTY_ARRAY$1;
          }
          var layer = this.layer;
          var urls = layer._imageData.map(function (img) { return [img.url, null, null]; });
          if (this.resources) {
              var unloaded_1 = [];
              var resources_1 = new ResourceCache();
              urls.forEach(function (url) {
                  if (_this.resources.isResourceLoaded(url)) {
                      var img = _this.resources.getImage(url);
                      resources_1.addResource(url, img);
                  }
                  else {
                      unloaded_1.push(url);
                  }
              });
              this.resources.forEach(function (url, res) {
                  if (!resources_1.isResourceLoaded(url)) {
                      _this.retireImage(res.image);
                  }
              });
              this.resources = resources_1;
              urls = unloaded_1;
          }
          this._imageLoaded = true;
          return urls;
      };
      ImageLayerCanvasRenderer.prototype.retireImage = function (image) {
          var img = image;
          if (img.close) {
              img.close();
          }
      };
      ImageLayerCanvasRenderer.prototype.refreshImages = function () {
          this._imageLoaded = false;
          this.setToRedraw();
      };
      ImageLayerCanvasRenderer.prototype.draw = function (timestamp, context) {
          if (!this.isDrawable()) {
              return;
          }
          this.prepareCanvas();
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          this._painted = false;
          this._drawImages(timestamp, context);
          this.completeRender();
      };
      //@internal
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      ImageLayerCanvasRenderer.prototype._drawImages = function (timestamp, context) {
          var imgData = this.layer._imageData;
          var map = this.getMap();
          var mapExtent = map.get2DExtentAtRes(map.getGLRes());
          if (imgData && imgData.length) {
              for (var i = 0; i < imgData.length; i++) {
                  var extent = imgData[i].extent2d;
                  var image = this.resources && this.resources.getImage(imgData[i].url);
                  if (image && mapExtent.intersects(extent)) {
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-ignore
                      this._painted = true;
                      this._drawImage(image, extent, imgData[i].opacity || 1);
                  }
              }
          }
      };
      //@internal
      ImageLayerCanvasRenderer.prototype._drawImage = function (image, extent, opacity) {
          var globalAlpha = 0;
          var ctx = this.context;
          if (opacity < 1) {
              globalAlpha = ctx.globalAlpha;
              ctx.globalAlpha = opacity;
          }
          var map = this.getMap();
          var nw = TEMP_POINT$2.set(extent.xmin, extent.ymax);
          var point = map._pointAtResToContainerPoint(nw, map.getGLRes());
          var x = point.x, y = point.y;
          var bearing = map.getBearing();
          if (bearing) {
              ctx.save();
              ctx.translate(x, y);
              if (bearing) {
                  ctx.rotate(-bearing * Math.PI / 180);
              }
              x = y = 0;
          }
          var scale = map.getGLScale();
          ctx.drawImage(image, x, y, extent.getWidth() / scale, extent.getHeight() / scale);
          if (bearing) {
              ctx.restore();
          }
          if (globalAlpha) {
              ctx.globalAlpha = globalAlpha;
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      ImageLayerCanvasRenderer.prototype.drawOnInteracting = function (event, timestamp, context) {
          this.draw();
      };
      return ImageLayerCanvasRenderer;
  }(CanvasRenderer$1));
  var ImageLayerGLRenderer = /** @class */ (function (_super) {
      __extends(ImageLayerGLRenderer, _super);
      function ImageLayerGLRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ImageLayerGLRenderer.prototype.drawOnInteracting = function (event, timestamp, context) {
          this.draw(timestamp, context);
      };
      //@internal
      ImageLayerGLRenderer.prototype._prepareGLContext = function () {
          var gl = this.gl;
          if (gl) {
              gl.disable(gl.STENCIL_TEST);
              gl.disable(gl.POLYGON_OFFSET_FILL);
              gl.enable(gl.DEPTH_TEST);
              gl.enable(gl.BLEND);
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
              gl.depthFunc(getDepthFunc(this.layer.options['depthFunc']));
              var depthMask = !!this.layer.options['depthMask'];
              gl.depthMask(depthMask);
          }
      };
      //@internal
      ImageLayerGLRenderer.prototype._drawImages = function (timestamp, parentContext) {
          var gl = this.gl;
          if (parentContext && parentContext.renderTarget) {
              var fbo = parentContext.renderTarget.fbo;
              if (fbo) {
                  var framebuffer = parentContext.renderTarget.getFramebuffer(fbo);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              }
          }
          this._prepareGLContext();
          _super.prototype._drawImages.call(this);
          if (parentContext && parentContext.renderTarget) {
              var fbo = parentContext.renderTarget.fbo;
              if (fbo) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              }
          }
      };
      //override to set to always drawable
      ImageLayerGLRenderer.prototype.isDrawable = function () {
          return true;
      };
      //@internal
      ImageLayerGLRenderer.prototype._drawImage = function (image, extent, opacity) {
          this.drawGLImage(image, extent.xmin, extent.ymax, extent.getWidth(), extent.getHeight(), 1, opacity);
      };
      ImageLayerGLRenderer.prototype.createContext = function () {
          this.createGLContext();
      };
      ImageLayerGLRenderer.prototype.resizeCanvas = function (canvasSize) {
          if (!this.canvas) {
              return;
          }
          _super.prototype.resizeCanvas.call(this, canvasSize);
          this.resizeGLCanvas();
      };
      ImageLayerGLRenderer.prototype.clearCanvas = function () {
          if (!this.canvas) {
              return;
          }
          _super.prototype.clearCanvas.call(this);
          this.clearGLCanvas();
      };
      ImageLayerGLRenderer.prototype.retireImage = function (image) {
          var img = image;
          if (img.close) {
              img.close();
          }
          this.disposeImage(image);
      };
      ImageLayerGLRenderer.prototype.onRemove = function () {
          this.removeGLCanvas();
          _super.prototype.onRemove.call(this);
      };
      return ImageLayerGLRenderer;
  }(ImageGLRenderable(ImageLayerCanvasRenderer)));
  ImageLayer.registerRenderer('canvas', ImageLayerCanvasRenderer);
  ImageLayer.registerRenderer('gl', ImageLayerGLRenderer);
  var depthFuncEnum;
  (function (depthFuncEnum) {
      depthFuncEnum[depthFuncEnum["never"] = 0] = "never";
      depthFuncEnum[depthFuncEnum["<"] = 1] = "<";
      depthFuncEnum[depthFuncEnum["="] = 2] = "=";
      depthFuncEnum[depthFuncEnum["<="] = 3] = "<=";
      depthFuncEnum[depthFuncEnum[" >"] = 4] = " >";
      depthFuncEnum[depthFuncEnum["!="] = 5] = "!=";
      depthFuncEnum[depthFuncEnum[">="] = 6] = ">=";
      depthFuncEnum[depthFuncEnum["always"] = 7] = "always";
  })(depthFuncEnum || (depthFuncEnum = {}));

  var CanvasLayerRenderer = /** @class */ (function (_super) {
      __extends(CanvasLayerRenderer, _super);
      function CanvasLayerRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasLayerRenderer.prototype.getPrepareParams = function () {
          return [];
      };
      CanvasLayerRenderer.prototype.getDrawParams = function () {
          return [];
      };
      CanvasLayerRenderer.prototype.onCanvasCreate = function () {
          if (this.canvas && this.layer.options['doubleBuffer']) {
              this.buffer = Canvas.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass);
          }
      };
      CanvasLayerRenderer.prototype.needToRedraw = function () {
          if (this.layer.options['animation']) {
              return true;
          }
          var map = this.getMap();
          if (map.isInteracting() && !this.layer.drawOnInteracting) {
              return false;
          }
          return _super.prototype.needToRedraw.call(this);
      };
      CanvasLayerRenderer.prototype.draw = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          this.prepareCanvas();
          this.prepareDrawContext();
          this._drawLayer.apply(this, __spreadArray([], __read(args), false));
      };
      CanvasLayerRenderer.prototype.drawOnInteracting = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          this._drawLayerOnInteracting.apply(this, __spreadArray([], __read(args), false));
      };
      CanvasLayerRenderer.prototype.getCanvasImage = function () {
          var canvasImg = _super.prototype.getCanvasImage.call(this);
          if (canvasImg && canvasImg.image && this.layer.options['doubleBuffer']) {
              var canvas = canvasImg.image;
              if (this.buffer.width !== canvas.width || this.buffer.height !== canvas.height) {
                  this.buffer.width = canvas.width;
                  this.buffer.height = canvas.height;
              }
              var bufferContext = this.buffer.getContext('2d');
              var prevent = this.layer.doubleBuffer(bufferContext, this.context);
              if (prevent === undefined || prevent) {
                  Canvas.image(bufferContext, canvas, 0, 0);
                  canvasImg.image = this.buffer;
              }
          }
          return canvasImg;
      };
      CanvasLayerRenderer.prototype.remove = function () {
          delete this._drawContext;
          return _super.prototype.remove.call(this);
      };
      CanvasLayerRenderer.prototype.onZoomStart = function (param) {
          this.layer.onZoomStart(param);
          _super.prototype.onZoomStart.call(this, param);
      };
      CanvasLayerRenderer.prototype.onZooming = function (param) {
          this.layer.onZooming(param);
          _super.prototype.onZooming.call(this, param);
      };
      CanvasLayerRenderer.prototype.onZoomEnd = function (param) {
          this.layer.onZoomEnd(param);
          _super.prototype.onZoomEnd.call(this, param);
      };
      CanvasLayerRenderer.prototype.onMoveStart = function (param) {
          this.layer.onMoveStart(param);
          _super.prototype.onMoveStart.call(this, param);
      };
      CanvasLayerRenderer.prototype.onMoving = function (param) {
          this.layer.onMoving(param);
          _super.prototype.onMoving.call(this, param);
      };
      CanvasLayerRenderer.prototype.onMoveEnd = function (param) {
          this.layer.onMoveEnd(param);
          _super.prototype.onMoveEnd.call(this, param);
      };
      CanvasLayerRenderer.prototype.onResize = function (param) {
          this.layer.onResize(param);
          _super.prototype.onResize.call(this, param);
      };
      CanvasLayerRenderer.prototype.prepareDrawContext = function () {
          var _a;
          if (!this._predrawed) {
              var params = ensureParams(this.getPrepareParams());
              this._drawContext = (_a = this.layer).prepareToDraw.apply(_a, __spreadArray([this.context], __read(params), false));
              if (!this._drawContext) {
                  this._drawContext = [];
              }
              if (!Array.isArray(this._drawContext)) {
                  this._drawContext = [this._drawContext];
              }
              this._predrawed = true;
          }
      };
      //@internal
      CanvasLayerRenderer.prototype._prepareDrawParams = function () {
          if (!this.getMap()) {
              return null;
          }
          var view = this.getViewExtent();
          if (view['maskExtent'] && !view['extent'].intersects(view['maskExtent'])) {
              this.completeRender();
              return null;
          }
          var args = [this.context, view];
          var params = ensureParams(this.getDrawParams());
          return __spreadArray(__spreadArray(__spreadArray([], __read(args), false), __read(params), false), __read(this._drawContext), false);
      };
      //@internal
      CanvasLayerRenderer.prototype._drawLayer = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var params = this._prepareDrawParams();
          if (!params) {
              return;
          }
          // eslint-disable-next-line prefer-spread
          this.layer.draw.apply(this.layer, params.concat(args));
          this.completeRender();
      };
      //@internal
      CanvasLayerRenderer.prototype._drawLayerOnInteracting = function () {
          var _a;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (!this.layer.drawOnInteracting) {
              return;
          }
          var params = this._prepareDrawParams();
          if (!params) {
              return;
          }
          (_a = this.layer).drawOnInteracting.apply(_a, __spreadArray(__spreadArray([], __read(params), false), __read(args), false));
          this.completeRender();
      };
      return CanvasLayerRenderer;
  }(CanvasRenderer$1));
  function ensureParams(params) {
      if (!params) {
          params = [];
      }
      if (!Array.isArray(params)) {
          params = [params];
      }
      return params;
  }

  /**
   * @property options                       - configuration options
   * @property options.doubleBuffer=false    - layer is rendered with doubleBuffer
   * @property options.animation=false       - if the layer is an animated layer
   * @property fps=1000 / 16                 - animation fps
   * @memberOf CanvasLayer
   * @instance
   */
  var options$2 = {
      'doubleBuffer': false,
      'animation': false
  };
  /**
   * 一个带有HTML5 2D canvas的layer
   * CanvasLayer为canvas操作提供了一些接口方法
   * 你可以直接使用CanvasLayer,但不能通过JSON序列化/反序列化实现CanvasLayer
   * 更推荐使用子类扩展CanvasLayer，并在子类中实现canvas绘画
   *
   * @english
   * A layer with a HTML5 2D canvas context.<br>
   * CanvasLayer provides some interface methods for canvas context operations. <br>
   * You can use it directly, but can't serialize/deserialize a CanvasLayer with JSON in this way. <br>
   * It is more recommended to extend it with a subclass and implement canvas paintings inside the subclass.
   * @example
   *  var layer = new CanvasLayer('canvas');
   *
   *  layer.prepareToDraw = function (context) {
   *      var size = map.getSize();
   *      return [size.width, size.height]
   *  };
   *
   *  layer.draw = function (context, width, height) {
   *      context.fillStyle = "#f00";
   *      context.fillRect(0, 0, w, h);
   *  };
   *  layer.addTo(map);
   * @category layer
   * @extends Layer
   * @param {String|Number} id - layer's id
   * @param {Object} options - options defined in [options]{@link CanvasLayer#options}
   */
  var CanvasLayer = /** @class */ (function (_super) {
      __extends(CanvasLayer, _super);
      function CanvasLayer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasLayer.prototype.isCanvasRender = function () {
          return true;
      };
      /**
       * 准备画布的接口函数
       *
       * @engilsh
       * An optional interface function called only once before the first draw, useful for preparing your canvas operations.
       * @param  {CanvasRenderingContext2D } context - CanvasRenderingContext2D of the layer canvas.
       * @return {Object[]} objects that will be passed to function draw(context, ..) as parameters.
       */
      CanvasLayer.prototype.prepareToDraw = function () { };
      /**
       * 绘制something的接口函数
       *
       * @engilsh
       * The required interface function to draw things on the layer canvas.
       * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.
       * @param  {*} params.. - parameters returned by function prepareToDraw(context).
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      CanvasLayer.prototype.draw = function () {
      };
      /**
       * map交互绘制接口
       * 默认情况调用draw()
       * 如果你知道如何提升绘制性能可以重新此方法
       *
       * @english
       * An optional interface function to draw while map is interacting.
       * By default, it will call draw method instead.
       * You can override this method if you are clear with what to draw when interacting to improve performance.
       * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.
       * @param  {*} params.. - parameters returned by function prepareToDraw(context).
       */
      // drawOnInteracting() {
      //     return this.draw.apply(this, arguments);
      // }
      /**
       * 重绘
       *
       * @english
       * Redraw the layer
       * @return this
       */
      CanvasLayer.prototype.redraw = function () {
          if (this._getRenderer()) {
              this._getRenderer().setToRedraw();
          }
          return this;
      };
      /**
       * 播放
       *
       * @english
       * Start animation
       * @return this
       */
      CanvasLayer.prototype.play = function () {
          this.config('animation', true);
          return this;
      };
      /**
       * 暂停
       *
       * @english
       * Pause the animation
       * @return this
       */
      CanvasLayer.prototype.pause = function () {
          this.config('animation', false);
          return this;
      };
      /**
       * 是否正在播放
       *
       * @english
       * If the animation is playing
       * @return
       */
      CanvasLayer.prototype.isPlaying = function () {
          return this.options['animation'];
      };
      /**
       * 清空画布
       *
       * @engilsh
       * Clear layer's canvas
       * @return this
       */
      CanvasLayer.prototype.clearCanvas = function () {
          if (this._getRenderer()) {
              this._getRenderer().clearCanvas();
          }
          return this;
      };
      /**
       * 要求map不触发任何事件下重绘canvas
       *
       * @engilsh
       * Ask the map to redraw the layer canvas without firing any event.
       * @return this
       */
      CanvasLayer.prototype.requestMapToRender = function () {
          var renderer = this._getRenderer();
          if (renderer && renderer.requestMapToRender) {
              renderer.requestMapToRender();
          }
          return this;
      };
      /**
       * 要求map触发layerload事件重绘canvas
       *
       * @engilsh
       * Ask the map to redraw the layer canvas and fire layerload event
       * @return this
       */
      CanvasLayer.prototype.completeRender = function () {
          if (this._getRenderer()) {
              this._getRenderer().completeRender();
          }
          return this;
      };
      /**
       * canvas创建完成后的回调函数
       *
       * @english
       * Callback function when layer's canvas is created. <br>
       * Override it to do anything needed.
       */
      CanvasLayer.prototype.onCanvasCreate = function () {
          return this;
      };
      /**
       * map zoomstart事件回调
       *
       * @engilsh
       * The event callback for map's zoomstart event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onZoomStart = function () { };
      /**
       * map zooming事件回调
       *
       * @engilsh
       * The event callback for map's zooming event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onZooming = function () { };
      /**
       * map zoomend事件回调
       *
       * @engilsh
       * The event callback for map's zoomend event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onZoomEnd = function () { };
      /**
       * map movestart事件回调
       *
       * @engilsh
       * The event callback for map's movestart event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onMoveStart = function () { };
      /**
       * map moving事件回调
       *
       * @engilsh
       * The event callback for map's moving event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onMoving = function () { };
      /**
       * map moveend事件回调
       *
       * @engilsh
       * The event callback for map's moveend event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onMoveEnd = function () { };
      /**
       * map resize事件回调
       *
       * @engilsh
       * The event callback for map's resize event.
       * @param  {Object} param - event parameter
       */
      CanvasLayer.prototype.onResize = function () { };
      /**
       * double buffer的回调函数
       * 默认情况下just draws and return，如果你需要在绘制之前处理canvas，可以重写改函数
       *
       * @engilsh
       * The callback function to double buffer. <br>
       * In default, it just draws and return, and you can override it if you need to process the canvas image before drawn.
       * @param  {CanvasRenderingContext2D} bufferContext CanvasRenderingContext2D of double buffer of the layer canvas.
       * @param  {CanvasRenderingContext2D} context CanvasRenderingContext2D of the layer canvas.
       */
      CanvasLayer.prototype.doubleBuffer = function (bufferContext /*, context?:CanvasRenderingContext2D*/) {
          bufferContext.clearRect(0, 0, bufferContext.canvas.width, bufferContext.canvas.height);
          return this;
      };
      //@internal
      CanvasLayer.prototype._getRenderer = function () {
          return _super.prototype._getRenderer.call(this);
      };
      return CanvasLayer;
  }(Layer));
  CanvasLayer.mergeOptions(options$2);
  CanvasLayer.registerRenderer('canvas', CanvasLayerRenderer);

  var TEMP_POINT$1 = new Point(0, 0);
  /**
   * @property {Object} options                  - configuration options
   * @property {Boolean} [options.animation=true]       - if the layer is an animated layer
   * @memberOf ParticleLayer
   * @instance
   */
  var options$1 = {
      'animation': true
  };
  /**
   * 粒子图层
   * 提供了一些渲染粒子的接口方法。
   * 你可以直接使用它，但不能以这种方式用JSON序列化/反序列化一个 particelayer
   * 更建议使用子类来扩展它
   *
   * @english
   * @classdesc
   * A layer to draw particles. <br>
   * ParticleLayer provides some interface methods to render particles. <br>
   * You can use it directly, but can't serialize/deserialize a ParticleLayer with JSON in this way. <br>
   * It is more recommended to extend it with a subclass.
   * @example
   * import { ParticleLayer } from 'maptalks';
   * var layer = new ParticleLayer('particle');
   *
   * layer.getParticles = function (t) {
   *     return particles[t];
   * };
   * layer.addTo(map);
   * @category layer
   * @extends CanvasLayer
   * @param {String} id - layer's id
   * @param {Object} [options=null] - options defined in [options]{@link ParticleLayer#options}
   */
  var ParticleLayer = /** @class */ (function (_super) {
      __extends(ParticleLayer, _super);
      function ParticleLayer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * 获取t时刻的例子位置
       *
       * @english
       * Interface method to get particles's position at time t.
       * @param t - current time in milliseconds
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      ParticleLayer.prototype.getParticles = function (t) {
      };
      ParticleLayer.prototype.draw = function (context, view) {
          var points = this.getParticles(now());
          if (!points || points.length === 0) {
              var renderer = this._getRenderer();
              if (renderer) {
                  this._getRenderer()._shouldClear = true;
              }
              return;
          }
          var map = this.getMap();
          var extent = view.extent;
          if (view.maskExtent) {
              extent = view.extent.intersection(view.maskExtent);
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore 当前 map 接口中目前没有_pointToContainerPoint方法
          extent = extent.convertTo(function (c) { return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT$1); });
          var e = 2 * Math.PI;
          for (var i = 0, l = points.length; i < l; i++) {
              var pos = points[i].point;
              if (extent.contains(pos)) {
                  var color = points[i].color || this.options['lineColor'] || '#fff', r = points[i].r;
                  if (context.fillStyle !== color) {
                      context.fillStyle = color;
                  }
                  if (r <= 2) {
                      context.fillRect(pos.x - r / 2, pos.y - r / 2, r, r);
                  }
                  else {
                      context.beginPath();
                      context.arc(pos.x, pos.y, r / 2, 0, e);
                      context.fill();
                  }
              }
          }
          this._fillCanvas(context);
      };
      //@internal
      ParticleLayer.prototype._fillCanvas = function (context) {
          var g = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';
          var trail = this.options['trail'] || 30;
          context.fillStyle = 'rgba(0, 0, 0, ' + (1 / trail) + ')';
          context.fillRect(0, 0, context.canvas.width, context.canvas.height);
          context.globalCompositeOperation = g;
      };
      return ParticleLayer;
  }(CanvasLayer));
  ParticleLayer.mergeOptions(options$1);
  ParticleLayer.registerRenderer('canvas', /** @class */ (function (_super) {
      __extends(class_1, _super);
      function class_1() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      class_1.prototype.draw = function () {
          if (!this.canvas || !this.layer.options['animation'] || this._shouldClear) {
              this.prepareCanvas();
              this._shouldClear = false;
          }
          this.prepareDrawContext();
          this._drawLayer();
      };
      class_1.prototype.drawOnInteracting = function () {
          this.draw();
          this._shouldClear = false;
      };
      class_1.prototype.onSkipDrawOnInteracting = function () {
          this._shouldClear = true;
      };
      return class_1;
  }(CanvasLayerRenderer)));

  var resources = new ResourceCache();
  var prevX, prevY;
  var EditHandle = /** @class */ (function (_super) {
      __extends(EditHandle, _super);
      function EditHandle(target, map, options) {
          var _this = _super.call(this, options) || this;
          _this.target = target;
          target.once('remove', _this.delete, _this);
          var symbol = _this.options['symbol'];
          var lineWidth = symbol['markerLineWidth'] || 1;
          _this.w = symbol['markerWidth'] + lineWidth;
          _this.h = symbol['markerHeight'] + lineWidth;
          _this.opacity = isNil(symbol['opacity']) ? 1 : symbol['opacity'];
          _this.map = map;
          _this.events = options.events;
          _this._fetchImage();
          _this.addTo(map);
          return _this;
      }
      EditHandle.prototype.getCursor = function () {
          return this.options['cursor'] || 'default';
      };
      //@internal
      EditHandle.prototype._fetchImage = function () {
          var map = this.map;
          var symbol = this.options.symbol;
          var markerFile = symbol.markerFile;
          this.url = markerFile || getSymbolHash(symbol);
          var img = resources.getImage(this.url);
          if (!img) {
              var w = this.w;
              var h = this.h;
              if (markerFile) {
                  img = new Image();
                  img.onload = function () {
                      var renderer = map.getRenderer();
                      if (renderer) {
                          renderer.setToRedraw();
                      }
                  };
                  img.src = this.url;
              }
              else {
                  var canvas = document.createElement('canvas');
                  canvas.width = w;
                  canvas.height = h;
                  var ctx = canvas.getContext('2d');
                  // vector marker
                  // 不同的vector，point不同
                  img = drawVectorMarker(ctx, { x: w / 2, y: h / 2 }, symbol, resources);
              }
              resources.addResource([this.url, w, h], img);
          }
          resources.login(this.url);
          this._img = img;
      };
      EditHandle.prototype.setContainerPoint = function (cp) {
          this._point = cp;
          this._point._sub(this.w / 2, this.h / 2);
      };
      EditHandle.prototype.getContainerPoint = function () {
          return this._point.add(this.w / 2, this.h / 2);
      };
      EditHandle.prototype.offset = function (p) {
          // dragging
          this._point._add(p);
      };
      EditHandle.prototype.render = function (ctx) {
          if (!this._img) {
              return false;
          }
          var symbol = this.options['symbol'];
          var dx = symbol['markerDx'] || 0;
          var dy = symbol['markerDy'] || 0;
          var map = this.map;
          var _a = this._point, x = _a.x, y = _a.y;
          var w = this.w;
          var h = this.h;
          if (x + w > 0 && x < map.width && y + h > 0 && y < map.height) {
              var dpr = map.getDevicePixelRatio();
              ctx.globalAlpha = this.opacity;
              ctx.drawImage(this._img, Math.round((x + dx) * dpr), Math.round((y + dy) * dpr), Math.round(w * dpr), Math.round(h * dpr));
              return true;
          }
          return false;
      };
      EditHandle.prototype.delete = function () {
          if (this.map) {
              var renderer = this.map.getRenderer();
              if (renderer) {
                  renderer.removeTopElement(this);
              }
          }
          resources.logout(this.url);
          if (this._dragger) {
              this._dragger.disable();
              delete this._dragger;
          }
          delete this.map;
      };
      EditHandle.prototype.hitTest = function (p) {
          var symbol = this.options['symbol'];
          var dx = symbol['markerDx'] || 0;
          var dy = symbol['markerDy'] || 0;
          var w = this.w;
          var h = this.h;
          var x = this._point.x + dx;
          var y = this._point.y + dy;
          return p.x >= x && p.x <= x + w && p.y >= y && p.y <= y + h;
      };
      EditHandle.prototype.addTo = function (map) {
          this.map = map;
          var renderer = map.getRenderer();
          renderer.addTopElement(this);
      };
      EditHandle.prototype.onEvent = function (e) {
          this.fire(e.type, e);
      };
      EditHandle.prototype.mousedown = function (e) {
          var map = e.target;
          var cursor = this.options['cursor'];
          if (cursor) {
              map.setCursor(cursor);
          }
          this.onDragstart(e);
      };
      EditHandle.prototype.onDragstart = function (e) {
          var containerPoint = e.containerPoint, map = e.target;
          var dom = map.getPanels().mapWrapper || map.getContainer();
          var dragHandler = this._dragger = new DragHandler(dom);
          dragHandler.on('dragging', this.onDragging, this)
              .on('mouseup', this.onDragend, this)
              .enable();
          dragHandler.onMouseDown(e['domEvent']);
          prevX = containerPoint.x;
          prevY = containerPoint.y;
          this.fire('dragstart', {
              containerPoint: containerPoint
          });
      };
      EditHandle.prototype.onDragging = function (e) {
          if (!this._dragger) {
              return;
          }
          var activeMap = this.map;
          var containerPoint = getEventContainerPoint(e.domEvent, activeMap.getContainer());
          var offset = {
              x: containerPoint.x - prevX,
              y: containerPoint.y - prevY,
          };
          var prevCoord = activeMap.containerPointToCoord(new Point(prevX, prevY));
          var currentCoord = activeMap.containerPointToCoord(containerPoint);
          prevX = containerPoint.x;
          prevY = containerPoint.y;
          this.offset(offset);
          this.fire('dragging', {
              containerPoint: containerPoint,
              coordOffset: currentCoord._sub(prevCoord)
          });
      };
      EditHandle.prototype.onDragend = function (e) {
          if (!this._dragger) {
              return;
          }
          var map = this.map;
          map.resetCursor();
          var containerPoint = getEventContainerPoint(e.domEvent, map.getContainer());
          var offset = {
              x: containerPoint.x - prevX,
              y: containerPoint.y - prevY,
          };
          this.offset(offset);
          this._dragger.disable();
          delete this._dragger;
          this.fire('dragend', {
              containerPoint: containerPoint
          });
      };
      EditHandle.prototype.needCollision = function () {
          var target = this.target;
          return target && target.options && target.options.collision;
      };
      EditHandle.prototype.getRenderBBOX = function (dpr) {
          var _a = this, target = _a.target, map = _a.map;
          if (!target || !target.options || !map) {
              return null;
          }
          var symbol = this.options['symbol'];
          var dx = symbol['markerDx'] || 0;
          var dy = symbol['markerDy'] || 0;
          var _b = this._point, x = _b.x, y = _b.y;
          var w = this.w;
          var h = this.h;
          dpr = dpr || map.getDevicePixelRatio();
          this.bbox = this.bbox || getDefaultBBOX();
          var x1 = Math.round((x + dx) * dpr);
          var y1 = Math.round((y + dy) * dpr);
          var width = Math.round(w * dpr);
          var height = Math.round(h * dpr);
          this.bbox[0] = x1;
          this.bbox[1] = y1;
          this.bbox[2] = x1 + width;
          this.bbox[3] = y1 + height;
          var options = target.options;
          var collisionBufferSize = options.collisionBufferSize || 0;
          bufferBBOX(this.bbox, collisionBufferSize);
          return this.bbox;
      };
      EditHandle.prototype.setZIndex = function (zIndex) {
          this.options.zIndex = zIndex;
      };
      return EditHandle;
  }(Eventable(Class)));

  var EditOutline = /** @class */ (function () {
      function EditOutline(target, map, options) {
          this.target = target;
          target.once('remove', this.delete, this);
          this.map = map;
          this.options = options;
          this.addTo(map);
      }
      EditOutline.prototype.setPoints = function (points) {
          this.points = points;
          var allX = points.map(function (p) { return p.x; });
          var allY = points.map(function (p) { return p.y; });
          this.xmin = Math.min.apply(Math, __spreadArray([], __read(allX), false));
          this.xmax = Math.max.apply(Math, __spreadArray([], __read(allX), false));
          this.ymin = Math.min.apply(Math, __spreadArray([], __read(allY), false));
          this.ymax = Math.max.apply(Math, __spreadArray([], __read(allY), false));
      };
      EditOutline.prototype.hitTest = function () {
          return false;
      };
      EditOutline.prototype.render = function (ctx) {
          var map = this.map;
          if (this.xmax <= 0 || this.xmin >= map.width ||
              this.ymax <= 0 || this.ymin >= map.height) {
              return;
          }
          var dpr = map.getDevicePixelRatio();
          // make line thiner
          var padding = 0.5;
          function c(v) {
              return Math.round(v) * dpr + padding;
          }
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#000';
          ctx.globalAlpha = 1;
          ctx.beginPath();
          var points = this.points;
          ctx.moveTo(c(points[0].x), c(points[0].y));
          for (var i = 1; i < this.points.length; i++) {
              ctx.lineTo(c(points[i].x), c(points[i].y));
          }
          ctx.closePath();
          ctx.stroke();
      };
      EditOutline.prototype.addTo = function (map) {
          this.map = map;
          var renderer = map.getRenderer();
          renderer.addTopElement(this);
      };
      EditOutline.prototype.delete = function () {
          if (this.map) {
              var renderer = this.map.getRenderer();
              if (renderer) {
                  renderer.removeTopElement(this);
              }
          }
      };
      return EditOutline;
  }());

  var EDIT_STAGE_LAYER_PREFIX = INTERNAL_LAYER_PREFIX + '_edit_stage_';
  function createHandleSymbol(markerType, opacity) {
      return {
          'markerType': markerType,
          'markerFill': '#fff',
          'markerLineColor': '#000',
          'markerLineWidth': 2,
          'markerWidth': 10,
          'markerHeight': 10,
          'opacity': opacity
      };
  }
  var options = {
      //fix outline's aspect ratio when resizing
      'fixAspectRatio': false,
      // geometry's symbol when editing
      'symbol': null,
      'removeVertexOn': 'contextmenu',
      //symbols of edit handles
      'centerHandleSymbol': createHandleSymbol('ellipse', 1),
      'vertexHandleSymbol': createHandleSymbol('square', 1),
      'newVertexHandleSymbol': createHandleSymbol('square', 0.4),
      'collision': false,
      'collisionBufferSize': 0,
      'vertexZIndex': 0,
      'newVertexZIndex': 0
  };
  /**
   * 内部使用的几何图形编辑器
   * @english
   * Geometry editor used internally for geometry editing.
   * @category geometry
   * @protected
   * @extends Class
   * @mixes Eventable
   */
  var GeometryEditor = /** @class */ (function (_super) {
      __extends(GeometryEditor, _super);
      /**
       * @param {Geometry} geometry geometry to edit
       * @param {Object} [opts=null] options
       * @param {Object} [opts.symbol=null] symbol of being edited.
       */
      function GeometryEditor(geometry, opts) {
          var _this = _super.call(this, opts) || this;
          _this._geometry = geometry;
          if (!_this._geometry) {
              return _this;
          }
          return _this;
      }
      /**
       * 获取地图对象
       * @english
       * Get map
       * @return {Map} map
       */
      GeometryEditor.prototype.getMap = function () {
          return this._geometry.getMap();
      };
      /**
       * 准备编辑
       * @english
       * Prepare to edit
       */
      GeometryEditor.prototype.prepare = function () {
          var map = this.getMap();
          if (!map) {
              return;
          }
          map.on('drawtopstart', this._refresh, this);
          /**
           * reserve the original symbol
           */
          if (this.options['symbol']) {
              this._originalSymbol = this._geometry.getSymbol();
              this._geometry.setSymbol(this.options['symbol']);
          }
          this._prepareEditStageLayer();
      };
      //@internal
      GeometryEditor.prototype._prepareEditStageLayer = function () {
          var layer = this._geometry.getLayer();
          if (layer.options['renderer'] !== 'canvas') {
              // doesn't need shadow if it's webgl or gpu renderer
              return;
          }
          var map = this.getMap();
          var uid = UID();
          var shadowId = EDIT_STAGE_LAYER_PREFIX + uid + '_shadow';
          this._shadowLayer = map.getLayer(shadowId);
          if (!this._shadowLayer) {
              var LayerType = layer.constructor;
              this._shadowLayer = new LayerType(shadowId);
              map.addLayer(this._shadowLayer);
          }
      };
      /**
       * 开始编辑
       * @english
       * Start to edit
       */
      GeometryEditor.prototype.start = function () {
          if (!this._geometry || !this._geometry.getMap() || this._geometry.editing) {
              return;
          }
          this.editing = true;
          this.prepare();
          var geometry = this._geometry;
          var shadow;
          var layer = this._geometry.getLayer();
          var needShadow = layer.options['renderer'] === 'canvas';
          this._geometryDraggble = geometry.options['draggable'];
          if (needShadow) {
              geometry.config('draggable', false);
              //edits are applied to a shadow of geometry to improve performance.
              shadow = geometry.copy();
              shadow.setSymbol(geometry._getInternalSymbol());
              //geometry copy没有将event复制到新建的geometry,对于编辑这个功能会存在一些问题
              //原geometry上可能绑定了其它监听其click/dragging的事件,在编辑时就无法响应了.
              shadow.copyEventListeners(geometry);
              if (geometry._getParent()) {
                  shadow.copyEventListeners(geometry._getParent());
              }
              shadow._setEventTarget(geometry);
              //drag shadow by center handle instead.
              shadow.setId(null).config({
                  'draggable': false
              });
              this._shadow = shadow;
              geometry.hide();
          }
          else if (geometry instanceof Marker) {
              geometry.config('draggable', true);
          }
          this._switchGeometryEvents('on');
          if (geometry instanceof Marker ||
              geometry instanceof Circle ||
              geometry instanceof Rectangle ||
              geometry instanceof Ellipse) {
              //ouline has to be added before shadow to let shadow on top of it, otherwise shadow's events will be overrided by outline
              this._createOrRefreshOutline();
          }
          if (this._shadowLayer) {
              this._shadowLayer.bringToFront().addGeometry(shadow);
          }
          if (!(geometry instanceof Marker)) {
              this._createCenterHandle();
          }
          else if (shadow) {
              shadow.config('draggable', true);
              shadow.on('dragend', this._onMarkerDragEnd, this);
          }
          if ((geometry instanceof Marker) && this.options['resize'] !== false) {
              this.createMarkerEditor();
          }
          else if (geometry instanceof Circle) {
              this.createCircleEditor();
          }
          else if (geometry instanceof Rectangle) {
              this.createEllipseOrRectEditor();
          }
          else if (geometry instanceof Ellipse) {
              this.createEllipseOrRectEditor();
          }
          else if (geometry instanceof Sector) ;
          else if ((geometry instanceof Polygon) ||
              (geometry instanceof LineString)) {
              this.createPolygonEditor();
          }
      };
      /**
       * 停止编辑
       * @english
       * Stop editing
       */
      GeometryEditor.prototype.stop = function () {
          delete this._history;
          delete this._historyPointer;
          delete this._editOutline;
          this._switchGeometryEvents('off');
          var map = this.getMap();
          if (!map) {
              this.fire('remove');
              return;
          }
          this._geometry.config('draggable', this._geometryDraggble);
          if (this._shadow) {
              delete this._shadow;
              delete this._geometryDraggble;
              this._geometry.show();
          }
          if (this._shadowLayer) {
              this._shadowLayer.remove();
              delete this._shadowLayer;
          }
          this._refreshHooks = [];
          if (this.options['symbol']) {
              this._geometry.setSymbol(this._originalSymbol);
              delete this._originalSymbol;
          }
          this.editing = false;
          this.fire('remove');
      };
      /**
       * 编辑器是否在编辑
       * @english
       * Whether the editor is editing
       * @return {Boolean}
       */
      GeometryEditor.prototype.isEditing = function () {
          if (isNil(this.editing)) {
              return false;
          }
          return this.editing;
      };
      //@internal
      GeometryEditor.prototype._getGeometryEvents = function () {
          return {
              'symbolchange': this._onGeoSymbolChange,
              // prevent _exeAndReset when dragging geometry in gl layers
              'dragstart': this._onDragStart,
              'dragend': this._onDragEnd,
              'positionchange shapechange': this._exeAndReset,
          };
      };
      //@internal
      GeometryEditor.prototype._switchGeometryEvents = function (oper) {
          if (this._geometry) {
              var events = this._getGeometryEvents();
              for (var p in events) {
                  this._geometry[oper](p, events[p], this);
              }
          }
      };
      //@internal
      GeometryEditor.prototype._onGeoSymbolChange = function (param) {
          if (this._shadow) {
              this._shadow.setSymbol(param.target._getInternalSymbol());
          }
      };
      //@internal
      GeometryEditor.prototype._onMarkerDragEnd = function () {
          this._update('setCoordinates', this._shadow.getCoordinates().toArray());
      };
      /**
       * 创建几何图形的矩形轮廓
       * @english
       * create rectangle outline of the geometry
       * @private
       */
      //@internal
      GeometryEditor.prototype._createOrRefreshOutline = function () {
          var geometry = this._geometry;
          var outline = this._editOutline;
          if (!outline) {
              this._editOutline = new EditOutline(this, this.getMap());
              this._addRefreshHook(this._createOrRefreshOutline);
          }
          var points = this._editOutline.points;
          if (geometry instanceof Marker) {
              this._editOutline.setPoints(geometry.getContainerExtent().toArray(points));
          }
          else {
              var map_1 = this.getMap();
              var extent = geometry._getPrjExtent();
              points = extent.toArray(points);
              points.forEach(function (c) { return map_1.prjToContainerPoint(c, null, c); });
              this._editOutline.setPoints(points);
          }
          return outline;
      };
      //@internal
      GeometryEditor.prototype._createCenterHandle = function () {
          var _this = this;
          var map = this.getMap();
          var symbol = this.options['centerHandleSymbol'];
          var shadow;
          var cointainerPoint = map.coordToContainerPoint(this._geometry.getCenter());
          var handle = this.createHandle(cointainerPoint, {
              'symbol': symbol,
              'cursor': 'move',
              onDown: function () {
                  if (_this._shadow) {
                      shadow = _this._shadow.copy();
                      var symbol_1 = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
                      shadow.setSymbol(symbol_1).addTo(_this._geometry.getLayer());
                  }
              },
              onMove: function (param) {
                  var offset = param['coordOffset'];
                  if (shadow) {
                      shadow.translate(offset);
                  }
                  else {
                      _this._geometry.translate(offset);
                  }
              },
              onUp: function () {
                  if (shadow) {
                      var shadowFirst = shadow.getFirstCoordinate();
                      var first = _this._geometry.getFirstCoordinate();
                      var offset = shadowFirst.sub(first);
                      _this._update('translate', offset);
                      shadow.remove();
                  }
              }
          });
          this._addRefreshHook(function () {
              var center = _this._geometry.getCenter();
              handle.setContainerPoint(map.coordToContainerPoint(center));
          });
      };
      //@internal
      GeometryEditor.prototype._createHandleInstance = function (containerPoint, opts) {
          var map = this.getMap();
          var symbol = loadFunctionTypes(opts['symbol'], function () {
              return [
                  map.getZoom(),
                  {
                      '{bearing}': map.getBearing(),
                      '{pitch}': map.getPitch(),
                      '{zoom}': map.getZoom()
                  }
              ];
          });
          var removeVertexOn = this.options['removeVertexOn'];
          var handle = new EditHandle(this, map, { symbol: symbol, cursor: opts['cursor'], events: removeVertexOn });
          handle.setContainerPoint(containerPoint);
          return handle;
      };
      GeometryEditor.prototype.createHandle = function (containerPoint, opts) {
          if (!opts) {
              opts = {};
          }
          var handle = this._createHandleInstance(containerPoint, opts);
          var me = this;
          function onHandleDragstart(param) {
              this._updating = true;
              if (opts.onDown) {
                  opts.onDown.call(me, param['containerPoint'], param);
                  /**
                   * 更改几何图形启动事件，在拖动以更改几何图形时激发
                   * @english
                   * change geometry shape start event, fired when drag to change geometry shape.
                   *
                   * @event Geometry#handledragstart
                   * @type {Object}
                   * @property {String} type - handledragstart
                   * @property {Geometry} target - the geometry fires the event
                   */
                  this._geometry.fire('handledragstart');
              }
              return false;
          }
          function onHandleDragging(param) {
              me._hideContext();
              if (opts.onMove) {
                  opts.onMove.call(me, param);
                  /**
                   * 更改几何图形事件，在拖动以更改几何图形时激发
                   * @english
                   * changing geometry shape event, fired when dragging to change geometry shape.
                   *
                   * @event Geometry#handledragging
                   * @type {Object}
                   * @property {String} type - handledragging
                   * @property {Geometry} target - the geometry fires the event
                   */
                  this._geometry.fire('handledragging');
              }
              return false;
          }
          function onHandleDragEnd(ev) {
              if (opts.onUp) {
                  //run mouseup code for handle delete etc
                  opts.onUp.call(me, ev);
                  /**
                   * changed geometry shape event, fired when drag end to change geometry shape.
                   *
                   * @event Geometry#handledragend
                   * @type {Object}
                   * @property {String} type - handledragend
                   * @property {Geometry} target - the geometry fires the event
                   */
                  this._geometry.fire('handledragend');
              }
              this._updating = false;
              return false;
          }
          handle.on('dragstart', onHandleDragstart, this);
          handle.on('dragging', onHandleDragging, this);
          handle.on('dragend', onHandleDragEnd, this);
          //拖动移图
          if (opts.onRefresh) {
              handle.refresh = opts.onRefresh;
          }
          return handle;
      };
      /**
       * 为几何图形创建可以调整大小的事件
       * @english
       * create resize handles for geometry that can resize.
       * @param {Array} blackList handle indexes that doesn't display, to prevent change a geometry's coordinates
       * @param {fn} onHandleMove callback
       * @private
       */
      //@internal
      GeometryEditor.prototype._createResizeHandles = function (blackList, onHandleMove, onHandleUp) {
          var _this = this;
          //cursor styles.
          var cursors = [
              'nw-resize', 'n-resize', 'ne-resize',
              'w-resize', 'e-resize',
              'sw-resize', 's-resize', 'se-resize'
          ];
          //defines dragOnAxis of resize handle
          var axis = [
              null, 'y', null,
              'x', 'x',
              null, 'y', null
          ];
          var geometry = this._geometry;
          //marker做特殊处理，利用像素求锚点
          var isMarker = geometry instanceof Marker;
          function getResizeAnchors() {
              if (isMarker) {
                  var ext_1 = geometry.getContainerExtent();
                  return [
                      // ext.getMin(),
                      new Point(ext_1['xmin'], ext_1['ymin']),
                      new Point((ext_1['xmax'] + ext_1['xmin']) / 2, ext_1['ymin']),
                      new Point(ext_1['xmax'], ext_1['ymin']),
                      new Point(ext_1['xmin'], (ext_1['ymin'] + ext_1['ymax']) / 2),
                      new Point(ext_1['xmax'], (ext_1['ymin'] + ext_1['ymax']) / 2),
                      new Point(ext_1['xmin'], ext_1['ymax']),
                      new Point((ext_1['xmax'] + ext_1['xmin']) / 2, ext_1['ymax']),
                      new Point(ext_1['xmax'], ext_1['ymax'])
                  ];
              }
              var ext = geometry._getPrjExtent();
              return [
                  // ext.getMin(),
                  new Point(ext['xmin'], ext['ymax']),
                  new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymax']),
                  new Point(ext['xmax'], ext['ymax']),
                  new Point(ext['xmin'], (ext['ymax'] + ext['ymin']) / 2),
                  new Point(ext['xmax'], (ext['ymax'] + ext['ymin']) / 2),
                  new Point(ext['xmin'], ext['ymin']),
                  new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymin']),
                  new Point(ext['xmax'], ext['ymin']),
              ];
          }
          if (!blackList) {
              blackList = [];
          }
          var me = this;
          var resizeHandles = [], anchorIndexes = {}, map = this.getMap(), handleSymbol = this.options['vertexHandleSymbol'];
          var fnLocateHandles = function () {
              var anchors = getResizeAnchors();
              var _loop_1 = function (i) {
                  //ignore anchors in blacklist
                  if (Array.isArray(blackList)) {
                      var isBlack = blackList.some(function (ele) { return ele === i; });
                      if (isBlack) {
                          return "continue";
                      }
                  }
                  var anchor = anchors[i], point = isMarker ? anchor : map.prjToContainerPoint(anchor);
                  if (resizeHandles.length < (anchors.length - blackList.length)) {
                      var handle = _this.createHandle(point, {
                          'symbol': handleSymbol,
                          'cursor': cursors[i],
                          'axis': axis[i],
                          onMove: (function (_index) {
                              return function (e) {
                                  me._updating = true;
                                  onHandleMove(e.containerPoint, _index);
                                  geometry.fire('resizing');
                              };
                          })(i),
                          onUp: function () {
                              me._updating = false;
                              onHandleUp();
                          }
                      });
                      // handle.setId(i);
                      anchorIndexes[i] = resizeHandles.length;
                      resizeHandles.push(handle);
                  }
                  else {
                      resizeHandles[anchorIndexes[i]].setContainerPoint(point);
                  }
              };
              for (var i = 0; i < anchors.length; i++) {
                  _loop_1(i);
              }
          };
          fnLocateHandles();
          //refresh hooks to refresh handles' coordinates
          this._addRefreshHook(fnLocateHandles);
          return resizeHandles;
      };
      /**
       * 创建标记编辑器
       * @english
       * Create marker editor
       * @private
       */
      GeometryEditor.prototype.createMarkerEditor = function () {
          var _this = this;
          var geometryToEdit = this._shadow || this._geometry, map = this.getMap();
          if (!geometryToEdit._canEdit()) {
              if (console) {
                  console.warn('A marker can\'t be resized with symbol:', geometryToEdit.getSymbol());
              }
              return;
          }
          if (!this._history) {
              this._recordHistory(getUpdates());
          }
          //only image marker and vector marker can be edited now.
          var symbol = geometryToEdit._getInternalSymbol();
          var dxdy = new Point(0, 0);
          if (isNumber(symbol['markerDx'])) {
              dxdy.x = symbol['markerDx'];
          }
          if (isNumber(symbol['markerDy'])) {
              dxdy.y = symbol['markerDy'];
          }
          var blackList = null;
          var verticalAnchor = 'middle';
          var horizontalAnchor = 'middle';
          if (VectorMarkerSymbolizer.test(symbol)) {
              var type = symbol['markerType'];
              if (type === 'pin' || type === 'pie' || type === 'bar') {
                  //as these types of markers' anchor stands on its bottom
                  blackList = [5, 6, 7];
                  verticalAnchor = 'bottom';
              }
              else if (type === 'rectangle') {
                  blackList = [0, 1, 2, 3, 5];
                  verticalAnchor = 'top';
                  horizontalAnchor = 'left';
              }
          }
          else if (ImageMarkerSymbolizer.test(symbol) ||
              VectorPathMarkerSymbolizer.test(symbol)) {
              verticalAnchor = 'bottom';
              blackList = [5, 6, 7];
          }
          //defines what can be resized by the handle
          //0: resize width; 1: resize height; 2: resize both width and height.
          var resizeAbilities = [
              2, 1, 2,
              0, 0,
              2, 1, 2
          ];
          var aspectRatio;
          if (this.options['fixAspectRatio']) {
              var size = geometryToEdit.getSize();
              aspectRatio = size.width / size.height;
          }
          var resizeHandles = this._createResizeHandles(blackList, function (containerPoint, i) {
              if (blackList && blackList.indexOf(i) >= 0) {
                  //need to change marker's coordinates
                  var newCoordinates = map.containerPointToCoordinate(containerPoint.sub(dxdy));
                  var coordinates = geometryToEdit.getCoordinates();
                  newCoordinates.x = coordinates.x;
                  geometryToEdit.setCoordinates(newCoordinates);
                  _this._updateCoordFromShadow(true);
                  // geometryToEdit.setCoordinates(newCoordinates);
                  //coordinates changed, and use mirror handle instead to caculate width and height
                  var mirrorHandle = resizeHandles[resizeHandles.length - 1 - i];
                  var mirror = mirrorHandle.getContainerPoint();
                  containerPoint = mirror;
              }
              //caculate width and height
              var viewCenter = map.coordToContainerPoint(geometryToEdit.getCoordinates()).add(dxdy), symbol = geometryToEdit._getInternalSymbol();
              var wh = containerPoint.sub(viewCenter);
              if (verticalAnchor === 'bottom' && containerPoint.y > viewCenter.y) {
                  wh.y = 0;
              }
              //if this marker's anchor is on its bottom, height doesn't need to multiply by 2.
              var vr = verticalAnchor === 'middle' ? 2 : 1;
              var hr = horizontalAnchor === 'left' ? 1 : 2;
              var width = Math.abs(wh.x) * hr, height = Math.abs(wh.y) * vr;
              if (aspectRatio) {
                  width = Math.max(width, height * aspectRatio);
                  height = width / aspectRatio;
              }
              var ability = resizeAbilities[i];
              if (!(geometryToEdit instanceof TextBox)) {
                  if (aspectRatio || ability === 0 || ability === 2) {
                      symbol['markerWidth'] = Math.min(width, _this._geometry.options['maxMarkerWidth'] || Infinity);
                  }
                  if (aspectRatio || ability === 1 || ability === 2) {
                      symbol['markerHeight'] = Math.min(height, _this._geometry.options['maxMarkerHeight'] || Infinity);
                  }
                  geometryToEdit.setSymbol(symbol);
                  if (geometryToEdit !== _this._geometry) {
                      _this._geometry.setSymbol(symbol);
                  }
              }
              else {
                  if (aspectRatio || ability === 0 || ability === 2) {
                      geometryToEdit.setWidth(width);
                      if (geometryToEdit !== _this._geometry) {
                          _this._geometry.setWidth(width);
                      }
                  }
                  if (aspectRatio || ability === 1 || ability === 2) {
                      geometryToEdit.setHeight(height);
                      if (geometryToEdit !== _this._geometry) {
                          _this._geometry.setHeight(height);
                      }
                  }
              }
          }, function () {
              _this._update(getUpdates());
          });
          function getUpdates() {
              var updates = [
                  ['setCoordinates', geometryToEdit.getCoordinates().toArray()]
              ];
              if (geometryToEdit instanceof TextBox) {
                  updates.push(['setWidth', geometryToEdit.getWidth()]);
                  updates.push(['setHeight', geometryToEdit.getHeight()]);
              }
              else {
                  updates.push(['setSymbol', geometryToEdit.getSymbol()]);
              }
              return updates;
          }
      };
      /**
       * 创建圆形编辑器
       * @english
       * Create circle editor
       * @private
       */
      GeometryEditor.prototype.createCircleEditor = function () {
          var _this = this;
          var geo = this._shadow || this._geometry;
          var map = this.getMap();
          if (!this._history) {
              this._recordHistory([
                  ['setCoordinates', geo.getCoordinates().toArray()],
                  ['setRadius', geo.getRadius()]
              ]);
          }
          this._createResizeHandles(null, function (handleContainerPoint) {
              var center = geo.getCenter();
              var mouseCoordinate = map.containerPointToCoord(handleContainerPoint);
              var wline = new LineString([[center.x, center.y], [mouseCoordinate.x, center.y]]);
              var hline = new LineString([[center.x, center.y], [center.x, mouseCoordinate.y]]);
              var r = Math.max(map.computeGeometryLength(wline), map.computeGeometryLength(hline));
              geo.setRadius(r);
              if (geo !== _this._geometry) {
                  _this._geometry.setRadius(r);
              }
          }, function () {
              _this._update('setRadius', geo.getRadius());
          });
      };
      /**
       * 创建椭圆或者矩形编辑器
       * @english
       * editor of ellipse or rectangle
       * @private
       */
      GeometryEditor.prototype.createEllipseOrRectEditor = function () {
          var _this = this;
          //defines what can be resized by the handle
          //0: resize width; 1: resize height; 2: resize both width and height.
          var resizeAbilities = [
              2, 1, 2,
              0, 0,
              2, 1, 2
          ];
          var geometryToEdit = this._shadow || this._geometry;
          if (!this._history) {
              this._recordHistory(getUpdates());
          }
          var map = this.getMap();
          var isRect = this._geometry instanceof Rectangle;
          var aspectRatio;
          if (this.options['fixAspectRatio']) {
              aspectRatio = geometryToEdit.getWidth() / geometryToEdit.getHeight();
          }
          var resizeHandles = this._createResizeHandles(null, function (mouseContainerPoint, i) {
              //ratio of width and height
              var r = isRect ? 1 : 2;
              var pointSub, w, h;
              var handle = resizeHandles[i];
              var targetPoint = handle.getContainerPoint(); //mouseContainerPoint;
              var ability = resizeAbilities[i];
              if (isRect) {
                  var mirror = resizeHandles[7 - i];
                  var mirrorContainerPoint = mirror.getContainerPoint();
                  pointSub = targetPoint.sub(mirrorContainerPoint);
                  var absSub = pointSub.abs();
                  w = map.pixelToDistance(absSub.x, 0);
                  h = map.pixelToDistance(0, absSub.y);
                  var size = geometryToEdit.getSize();
                  var geoCoord = geometryToEdit.getCoordinates();
                  var width = geometryToEdit.getWidth();
                  var height = geometryToEdit.getHeight();
                  var mouseCoordinate = map.containerPointToCoord(mouseContainerPoint);
                  var mirrorCoordinate = map.containerPointToCoord(mirrorContainerPoint);
                  var wline = new LineString([[mirrorCoordinate.x, mirrorCoordinate.y], [mouseCoordinate.x, mirrorCoordinate.y]]);
                  var hline = new LineString([[mirrorCoordinate.x, mirrorCoordinate.y], [mirrorCoordinate.x, mouseCoordinate.y]]);
                  //fix distance cal error
                  w = map.computeGeometryLength(wline);
                  h = map.computeGeometryLength(hline);
                  if (ability === 0) {
                      // changing width
                      // -  -  -
                      // 0     0
                      // -  -  -
                      // Rectangle's northwest's y is (y - height / 2)
                      if (aspectRatio) {
                          // update rectangle's height with aspect ratio
                          absSub.y = absSub.x / aspectRatio;
                          size.height = Math.abs(absSub.y);
                          h = w / aspectRatio;
                      }
                      targetPoint.y = mirrorContainerPoint.y - size.height / 2;
                      mouseCoordinate.y = geoCoord.y;
                      if (i === 4) {
                          mouseCoordinate.x = Math.min(mouseCoordinate.x, geoCoord.x);
                      }
                      else {
                          // use locate instead of containerPoint to fix precision problem
                          var mirrorCoord = map.locate(geoCoord, width, 0);
                          mouseCoordinate.x = map.locate(new Coordinate(mirrorCoord.x, mouseCoordinate.y), -w, 0).x;
                      }
                  }
                  else if (ability === 1) {
                      // changing height
                      // -  1  -
                      // |     |
                      // -  1  -
                      // Rectangle's northwest's x is (x - width / 2)
                      if (aspectRatio) {
                          // update rectangle's width with aspect ratio
                          absSub.x = absSub.y * aspectRatio;
                          size.width = Math.abs(absSub.x);
                          w = h * aspectRatio;
                      }
                      targetPoint.x = mirrorContainerPoint.x - size.width / 2;
                      mouseCoordinate.x = geoCoord.x;
                      mouseCoordinate.y = Math.max(mouseCoordinate.y, mirrorCoordinate.y);
                  }
                  else {
                      // corner handles, relocate the target point according to aspect ratio.
                      if (aspectRatio) {
                          if (w > h * aspectRatio) {
                              h = w / aspectRatio;
                              targetPoint.y = mirrorContainerPoint.y + absSub.x * sign(pointSub.y) / aspectRatio;
                          }
                          else {
                              w = h * aspectRatio;
                              targetPoint.x = mirrorContainerPoint.x + absSub.y * sign(pointSub.x) * aspectRatio;
                          }
                      }
                      // anchor at northwest and south west
                      if (i === 0 || i === 5) {
                          // use locate instead of containerPoint to fix precision problem
                          var mirrorCoord = i === 0 ? map.locate(geoCoord, width, 0) : map.locate(geoCoord, width, -height);
                          mouseCoordinate.x = map.locate(new Coordinate(mirrorCoord.x, mouseCoordinate.y), -w, 0).x;
                      }
                      else {
                          mouseCoordinate.x = Math.min(mouseCoordinate.x, mirrorCoordinate.x);
                      }
                      mouseCoordinate.y = Math.max(mouseCoordinate.y, mirrorCoordinate.y);
                  }
                  //change rectangle's coordinates
                  // const newCoordinates = map.viewPointToCoordinate(new Point(Math.min(targetPoint.x, mirrorContainerPoint.x), Math.min(targetPoint.y, mirrorContainerPoint.y)));
                  geometryToEdit.setCoordinates(mouseCoordinate);
                  _this._updateCoordFromShadow(true);
                  // geometryToEdit.setCoordinates(newCoordinates);
              }
              else {
                  // const viewCenter = map.coordToViewPoint(geometryToEdit.getCenter());
                  // pointSub = viewCenter.sub(targetPoint)._abs();
                  // w = map.pixelToDistance(pointSub.x, 0);
                  // h = map.pixelToDistance(0, pointSub.y);
                  // if (aspectRatio) {
                  //     w = Math.max(w, h * aspectRatio);
                  //     h = w / aspectRatio;
                  // }
                  var center = geometryToEdit.getCenter();
                  var mouseCoordinate = map.containerPointToCoord(targetPoint);
                  var wline = new LineString([[center.x, center.y], [mouseCoordinate.x, center.y]]);
                  var hline = new LineString([[center.x, center.y], [center.x, mouseCoordinate.y]]);
                  w = map.computeGeometryLength(wline);
                  h = map.computeGeometryLength(hline);
                  if (aspectRatio) {
                      w = Math.max(w, h * aspectRatio);
                      h = w / aspectRatio;
                  }
              }
              if (aspectRatio || ability === 0 || ability === 2) {
                  geometryToEdit.setWidth(w * r);
                  if (geometryToEdit !== _this._geometry) {
                      _this._geometry.setWidth(w * r);
                  }
              }
              if (aspectRatio || ability === 1 || ability === 2) {
                  geometryToEdit.setHeight(h * r);
                  if (geometryToEdit !== _this._geometry) {
                      _this._geometry.setHeight(h * r);
                  }
              }
          }, function () {
              _this._update(getUpdates());
          });
          function getUpdates() {
              return [
                  ['setCoordinates', geometryToEdit.getCoordinates().toArray()],
                  ['setWidth', geometryToEdit.getWidth()],
                  ['setHeight', geometryToEdit.getHeight()]
              ];
          }
      };
      /**
       * 创建多边形编辑器
       * @english
       * Editor for polygon
       * @private
       */
      GeometryEditor.prototype.createPolygonEditor = function () {
          var map = this.getMap(), geoToEdit = this._shadow || this._geometry, me = this;
          if (!this._history) {
              this._recordHistory('setCoordinates', Coordinate.toNumberArrays(geoToEdit.getCoordinates()));
          }
          var verticeLimit = geoToEdit instanceof Polygon ? 3 : 2;
          var propertyOfVertexIndex = 'maptalks--editor-vertex-index';
          var _a = this.options, vertexZIndex = _a.vertexZIndex, newVertexZIndex = _a.newVertexZIndex;
          //{ ringIndex:ring }
          var vertexHandles = { 0: [] }, newVertexHandles = { 0: [] };
          //大面积调用这个方法是非常耗时的
          function getVertexCoordinates(ringIndex) {
              if (ringIndex === void 0) { ringIndex = 0; }
              if (geoToEdit instanceof Polygon) {
                  var coordinates = geoToEdit.getCoordinates()[ringIndex] || [];
                  return coordinates.slice(0, coordinates.length - 1);
              }
              else {
                  return geoToEdit.getCoordinates();
              }
          }
          function getVertexPrjCoordinates(ringIndex) {
              if (ringIndex === void 0) { ringIndex = 0; }
              if (ringIndex === 0) {
                  return geoToEdit._getPrjCoordinates();
              }
              return geoToEdit._getPrjHoles()[ringIndex - 1];
          }
          function onVertexAddOrRemove() {
              //restore index property of each handles.
              for (var ringIndex in vertexHandles) {
                  for (var i = vertexHandles[ringIndex].length - 1; i >= 0; i--) {
                      vertexHandles[ringIndex][i][propertyOfVertexIndex] = i;
                  }
                  for (var i = newVertexHandles[ringIndex].length - 1; i >= 0; i--) {
                      newVertexHandles[ringIndex][i][propertyOfVertexIndex] = i;
                  }
              }
              me._updateCoordFromShadow();
          }
          function removeVertex(param) {
              me._updating = true;
              var handle = param['target'], index = handle[propertyOfVertexIndex];
              var ringIndex = isNumber(handle._ringIndex) ? handle._ringIndex : 0;
              var prjCoordinates = getVertexPrjCoordinates(ringIndex);
              if (prjCoordinates.length <= verticeLimit) {
                  return;
              }
              var isEnd = (geoToEdit instanceof LineString) && (index === 0 || index === prjCoordinates.length - 1);
              prjCoordinates.splice(index, 1);
              if (ringIndex > 0) {
                  //update hole prj
                  geoToEdit._prjHoles[ringIndex - 1] = prjCoordinates;
              }
              else {
                  //update shell prj
                  geoToEdit._setPrjCoordinates(prjCoordinates);
              }
              geoToEdit._updateCache();
              //remove vertex handle
              vertexHandles[ringIndex].splice(index, 1)[0].delete();
              //remove two neighbor "new vertex" handles
              if (index < newVertexHandles[ringIndex].length) {
                  newVertexHandles[ringIndex].splice(index, 1)[0].delete();
              }
              var nextIndex;
              if (index === 0) {
                  nextIndex = newVertexHandles[ringIndex].length - 1;
              }
              else {
                  nextIndex = index - 1;
              }
              newVertexHandles[ringIndex].splice(nextIndex, 1)[0].delete();
              if (!isEnd) {
                  //add a new "new vertex" handle.
                  newVertexHandles[ringIndex].splice(nextIndex, 0, createNewVertexHandle.call(me, nextIndex, ringIndex));
              }
              if (ringIndex > 0) {
                  var coordiantes = geoToEdit.getCoordinates();
                  //fix hole Vertex delete
                  var ring = coordiantes[ringIndex];
                  if (ring && Array.isArray(ring) && ring.length > 1) {
                      ring.splice(index, 1);
                      //update shadow coordinates
                      if (geoToEdit !== this._geometry) {
                          geoToEdit.setCoordinates(coordiantes);
                      }
                  }
              }
              onVertexAddOrRemove();
              me._updating = false;
              /**
               * changed geometry shape event, fired when edit control vertex  remove
               *
               * @event Geometry#handleremove
               * @type {Object}
               * @property {String} type - handleremove
               * @property {Geometry} target - the geometry fires the event
               */
              me._geometry.fire('handleremove', Object.assign({}, param, { coordinate: map.containerPointToCoordinate(param.containerPoint), vertex: param.target }));
          }
          function moveVertexHandle(handleConatainerPoint, index, ringIndex) {
              if (ringIndex === void 0) { ringIndex = 0; }
              //for adsorption effect
              var snapTo = me._geometry.snapTo;
              if (snapTo && isFunction(snapTo)) {
                  handleConatainerPoint = me._geometry.snapTo(handleConatainerPoint) || handleConatainerPoint;
              }
              var vertice = getVertexPrjCoordinates(ringIndex);
              var nVertex = map._containerPointToPrj(handleConatainerPoint.sub(getDxDy()));
              var pVertex = vertice[index];
              pVertex.x = nVertex.x;
              pVertex.y = nVertex.y;
              geoToEdit._updateCache();
              geoToEdit.onShapeChanged();
              me._updateCoordFromShadow(true);
              var nextIndex;
              if (index === 0) {
                  nextIndex = newVertexHandles[ringIndex].length - 1;
              }
              else {
                  nextIndex = index - 1;
              }
              //refresh two neighbor "new vertex" handles.
              if (newVertexHandles[ringIndex][index]) {
                  newVertexHandles[ringIndex][index].refresh();
              }
              if (newVertexHandles[ringIndex][nextIndex]) {
                  newVertexHandles[ringIndex][nextIndex].refresh();
              }
          }
          var hanldeDxdy = new Point(0, 0);
          function getDxDy() {
              var compiledSymbol = geoToEdit._getCompiledSymbol();
              hanldeDxdy.x = compiledSymbol.lineDx || 0;
              hanldeDxdy.y = compiledSymbol.lineDy || 0;
              return hanldeDxdy;
          }
          function createVertexHandle(index, ringIndex, ringCoordinates) {
              if (ringIndex === void 0) { ringIndex = 0; }
              //not get geometry coordiantes when ringCoordinates is not null
              //每个vertex都去获取geometry的coordinates太耗时了，应该所有vertex都复用传进来的ringCoordinates
              var vertex = (ringCoordinates || getVertexCoordinates(ringIndex))[index];
              var handle = me.createHandle(map.coordToContainerPoint(vertex)._add(getDxDy()), {
                  'symbol': me.options['vertexHandleSymbol'],
                  'cursor': 'pointer',
                  'axis': null,
                  onMove: function () {
                      moveVertexHandle(handle.getContainerPoint(), handle[propertyOfVertexIndex], ringIndex);
                  },
                  onRefresh: function (rIndex, ringCoordinates) {
                      vertex = (ringCoordinates || getVertexCoordinates(ringIndex))[handle[propertyOfVertexIndex]];
                      var containerPoint = map.coordToContainerPoint(vertex);
                      handle.setContainerPoint(containerPoint._add(getDxDy()));
                  },
                  onUp: function () {
                      me._updateCoordFromShadow();
                  },
                  onDown: function (param, e) {
                      if (e && e.domEvent && e.domEvent.button === 2) {
                          return;
                      }
                  }
              });
              handle[propertyOfVertexIndex] = index;
              handle._ringIndex = ringIndex;
              handle.on(me.options['removeVertexOn'], removeVertex);
              handle.setZIndex(vertexZIndex);
              return handle;
          }
          var pauseRefresh = false;
          function createNewVertexHandle(index, ringIndex, ringCoordinates) {
              if (ringIndex === void 0) { ringIndex = 0; }
              var vertexCoordinates = ringCoordinates || getVertexCoordinates(ringIndex);
              var nextVertex;
              if (index + 1 >= vertexCoordinates.length) {
                  nextVertex = vertexCoordinates[0];
              }
              else {
                  nextVertex = vertexCoordinates[index + 1];
              }
              var vertex = vertexCoordinates[index].add(nextVertex).multi(1 / 2);
              var handle = me.createHandle(vertex, {
                  'symbol': me.options['newVertexHandleSymbol'],
                  'cursor': 'pointer',
                  'axis': null,
                  onDown: function (param, e) {
                      if (e && e.domEvent && e.domEvent.button === 2) {
                          return;
                      }
                      var prjCoordinates = getVertexPrjCoordinates(ringIndex);
                      var vertexIndex = handle[propertyOfVertexIndex];
                      //add a new vertex
                      var cp = handle.getContainerPoint();
                      var pVertex = map._containerPointToPrj(cp);
                      //update shadow's vertice
                      prjCoordinates.splice(vertexIndex + 1, 0, pVertex);
                      if (ringIndex > 0) {
                          //update hole
                          geoToEdit._prjHoles[ringIndex - 1] = prjCoordinates;
                      }
                      else {
                          geoToEdit._setPrjCoordinates(prjCoordinates);
                      }
                      geoToEdit._updateCache();
                      handle.opacity = 1;
                      //add two "new vertex" handles
                      newVertexHandles[ringIndex].splice(vertexIndex, 0, createNewVertexHandle.call(me, vertexIndex, ringIndex), createNewVertexHandle.call(me, vertexIndex + 1, ringIndex));
                      pauseRefresh = true;
                  },
                  onMove: function () {
                      moveVertexHandle(handle.getContainerPoint(), handle[propertyOfVertexIndex] + 1, ringIndex);
                  },
                  onUp: function (e) {
                      if (e && e.domEvent && e.domEvent.button === 2) {
                          pauseRefresh = false;
                          return;
                      }
                      var vertexIndex = handle[propertyOfVertexIndex];
                      //remove this handle
                      removeFromArray(handle, newVertexHandles[ringIndex]);
                      handle.delete();
                      //add a new vertex handle
                      vertexHandles[ringIndex].splice(vertexIndex + 1, 0, createVertexHandle.call(me, vertexIndex + 1, ringIndex));
                      onVertexAddOrRemove();
                      me._updateCoordFromShadow();
                      pauseRefresh = false;
                  },
                  onRefresh: function (rIndex, ringCoordinates) {
                      vertexCoordinates = ringCoordinates || getVertexCoordinates(rIndex);
                      var vertexIndex = handle[propertyOfVertexIndex];
                      var nextIndex;
                      if (vertexIndex === vertexCoordinates.length - 1) {
                          nextIndex = 0;
                      }
                      else {
                          nextIndex = vertexIndex + 1;
                      }
                      var refreshVertex = vertexCoordinates[vertexIndex].add(vertexCoordinates[nextIndex]).multi(1 / 2);
                      var containerPoint = map.coordToContainerPoint(refreshVertex);
                      handle.setContainerPoint(containerPoint._add(getDxDy()));
                  }
              });
              handle[propertyOfVertexIndex] = index;
              handle.setZIndex(newVertexZIndex);
              return handle;
          }
          if (geoToEdit instanceof Polygon) {
              var rings = geoToEdit.getHoles().length + 1;
              for (var ringIndex = 0; ringIndex < rings; ringIndex++) {
                  vertexHandles[ringIndex] = [];
                  newVertexHandles[ringIndex] = [];
                  var vertexCoordinates = getVertexCoordinates(ringIndex);
                  for (var i = 0, len = vertexCoordinates.length; i < len; i++) {
                      //reuse vertexCoordinates
                      vertexHandles[ringIndex].push(createVertexHandle.call(this, i, ringIndex, vertexCoordinates));
                      if (i < len - 1) {
                          //reuse vertexCoordinates
                          newVertexHandles[ringIndex].push(createNewVertexHandle.call(this, i, ringIndex, vertexCoordinates));
                      }
                  }
                  //1 more vertex handle for polygon
                  newVertexHandles[ringIndex].push(createNewVertexHandle.call(this, vertexCoordinates.length - 1, ringIndex, vertexCoordinates));
              }
          }
          else {
              var ringIndex = 0;
              var vertexCoordinates = getVertexCoordinates(ringIndex);
              for (var i = 0, len = vertexCoordinates.length; i < len; i++) {
                  vertexHandles[ringIndex].push(createVertexHandle.call(this, i, ringIndex, vertexCoordinates));
                  if (i < len - 1) {
                      newVertexHandles[ringIndex].push(createNewVertexHandle.call(this, i, ringIndex, vertexCoordinates));
                  }
              }
              if (newVertexHandles[ringIndex].length && geoToEdit.getCoordinates().length === 2) {
                  newVertexHandles[ringIndex][0].options.symbol['markerDx'] = 12;
              }
          }
          var renderer = map.getRenderer();
          if (renderer) {
              renderer.sortTopElements();
          }
          this._addRefreshHook(function () {
              if (pauseRefresh) {
                  return;
              }
              for (var ringIndex in newVertexHandles) {
                  var ringCoordinates = getVertexCoordinates(ringIndex);
                  for (var i = newVertexHandles[ringIndex].length - 1; i >= 0; i--) {
                      //reuse ringCoordinates
                      newVertexHandles[ringIndex][i].refresh(ringIndex, ringCoordinates);
                  }
              }
              if (newVertexHandles[0].length && geoToEdit instanceof LineString) {
                  if (geoToEdit.getCoordinates().length === 2) {
                      newVertexHandles[0][0].options.symbol['markerDx'] = 12;
                  }
                  else if (geoToEdit.getCoordinates().length > 2) {
                      newVertexHandles[0][0].options.symbol['markerDx'] = 0;
                  }
              }
              for (var ringIndex in vertexHandles) {
                  var ringCoordinates = getVertexCoordinates(ringIndex);
                  for (var i = vertexHandles[ringIndex].length - 1; i >= 0; i--) {
                      //reuse ringCoordinates
                      vertexHandles[ringIndex][i].refresh(ringIndex, ringCoordinates);
                  }
              }
          });
      };
      //@internal
      GeometryEditor.prototype._refresh = function () {
          if (this._refreshHooks) {
              for (var i = this._refreshHooks.length - 1; i >= 0; i--) {
                  this._refreshHooks[i].call(this);
              }
          }
      };
      //@internal
      GeometryEditor.prototype._hideContext = function () {
          if (this._geometry) {
              this._geometry.closeMenu();
              this._geometry.closeInfoWindow();
          }
      };
      //@internal
      GeometryEditor.prototype._addRefreshHook = function (fn) {
          if (!fn) {
              return;
          }
          if (!this._refreshHooks) {
              this._refreshHooks = [];
          }
          this._refreshHooks.push(fn);
      };
      //@internal
      GeometryEditor.prototype._update = function (method) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          this._exeHistory([method, args]);
          this._recordHistory.apply(this, __spreadArray([method], __read(args), false));
      };
      //@internal
      GeometryEditor.prototype._updateCoordFromShadow = function (ignoreRecord) {
          var geoToEdit = this._shadow || this._geometry;
          var coords = geoToEdit.getCoordinates();
          var geo = this._geometry;
          var updating = this._updating;
          this._updating = true;
          geo.setCoordinates(coords);
          if (!ignoreRecord) {
              this._recordHistory('setCoordinates', Coordinate.toNumberArrays(geo.getCoordinates()));
          }
          this._updating = updating;
      };
      //@internal
      GeometryEditor.prototype._recordHistory = function (method) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          if (!this._history) {
              this._history = [];
              this._historyPointer = 0;
          }
          if (this._history.length) {
              var lastOperation = this._history[this._history.length - 1];
              if (lastOperation[0] === method && JSON.stringify(lastOperation[1]) === JSON.stringify(args)) {
                  return;
              }
          }
          if (this._historyPointer < this._history.length - 1) {
              // remove old 'next views'
              this._history.splice(this._historyPointer + 1);
          }
          this._history.push([method, args]);
          this._historyPointer = this._history.length - 1;
          /**
           * 编辑记录事件，在发生编辑并正在记录时激发
           * @english
           * edit record event, fired when an edit happend and being recorded
           *
           * @event Geometry#editrecord
           * @type {Object}
           * @property {String} type - editrecord
           * @property {Geometry} target - the geometry fires the event
           */
          this._geometry.fire('editrecord');
      };
      GeometryEditor.prototype.cancel = function () {
          if (!this._history || this._historyPointer === 0) {
              return this;
          }
          this._historyPointer = 0;
          var record = this._history[0];
          this._exeAndReset(record);
          return this;
      };
      /**
       * 获取视图历史记录中的上一个地图视图
       * @english
       * Get previous map view in view history
       * @return {Object} map view
       */
      GeometryEditor.prototype.undo = function () {
          if (!this._history || this._historyPointer === 0) {
              return this;
          }
          var record = this._history[--this._historyPointer];
          this._exeAndReset(record);
          return this;
      };
      /**
       * 获取视图历史记录中的下一个地图视图
       * @english
       * Get next view in view history
       * @return {Object} map view
       */
      GeometryEditor.prototype.redo = function () {
          if (!this._history || this._historyPointer === this._history.length - 1) {
              return this;
          }
          var record = this._history[++this._historyPointer];
          this._exeAndReset(record);
          return this;
      };
      //@internal
      GeometryEditor.prototype._exeAndReset = function (record) {
          if (this._updating) {
              return;
          }
          this._exeHistory(record);
          var history = this._history, pointer = this._historyPointer;
          this.stop();
          this._history = history;
          this._historyPointer = pointer;
          this.start();
      };
      //@internal
      GeometryEditor.prototype._onDragStart = function () {
          this._updating = true;
      };
      //@internal
      GeometryEditor.prototype._onDragEnd = function () {
          this._updating = false;
      };
      //@internal
      GeometryEditor.prototype._exeHistory = function (record) {
          var _a, _b;
          if (!Array.isArray(record)) {
              return;
          }
          var updating = this._updating;
          this._updating = true;
          var geoToEdit = this._shadow || this._geometry;
          var geo = this._geometry;
          if (Array.isArray(record[0])) {
              record[0].forEach(function (o) {
                  var _a, _b;
                  var m = o[0], args = o.slice(1);
                  (_a = geoToEdit[m]).call.apply(_a, __spreadArray([geoToEdit], __read(args), false));
                  if (geoToEdit !== geo) {
                      (_b = geo[m]).call.apply(_b, __spreadArray([geo], __read(args), false));
                  }
              });
          }
          else {
              (_a = geoToEdit[record[0]]).call.apply(_a, __spreadArray([geoToEdit], __read(record[1]), false));
              if (geoToEdit !== geo) {
                  (_b = geo[record[0]]).call.apply(_b, __spreadArray([geo], __read(record[1]), false));
              }
          }
          this._updating = updating;
      };
      return GeometryEditor;
  }(Eventable(Class)));
  GeometryEditor.mergeOptions(options);

  /**
   * Mixin methods for text editing.
   * @mixin TextEditable
   */
  var TextEditable = {
      /**
       * 开始编辑文本，每当点击地图时，编辑将自动结束
       * @english
       * Start to edit the text, editing will be ended automatically whenever map is clicked.
       *
       * @return {TextMarker} this
       * @fires TextMarker#edittextstart
       */
      startEditText: function () {
          if (!this.getMap()) {
              return this;
          }
          this._recordVisible();
          this.hide();
          this.endEditText();
          this._prepareEditor();
          /**
           * edittextstart when starting to edit text content
           * @event TextMarker#edittextstart
           * @type {Object}
           * @property {String} type - edittextstart
           * @property {TextMarker} target - fires the event
           */
          this._fireEvent('edittextstart');
          return this;
      },
      /**
       * 结束编辑
       * @english
       * End text edit.
       *
       * @return {TextMarker} this
       * @fires TextMarker#edittextend
       */
      endEditText: function () {
          if (this._textEditor) {
              var html = this._textEditor.innerHTML;
              html = html.replace(/<p>/ig, '').replace(/<\/p>/ig, '<br/>');
              this._textEditor.innerHTML = html;
              // trim enter chars in the end of text for IE
              var content = this._textEditor.innerText.replace(/[\r\n]+$/gi, '');
              this.setContent(content);
              off(this._textEditor, 'mousedown dblclick', stopPropagation);
              this.getMap().off('mousedown', this.endEditText, this);
              this._editUIMarker.remove();
              delete this._editUIMarker;
              this._textEditor.onkeyup = null;
              delete this._textEditor;
              this._recoveryVisible();
              this.show();
              /**
               * edittextend when ended editing text content
               * @event TextMarker#edittextend
               * @type {Object}
               * @property {String} type - edittextend
               * @property {TextMarker} target - textMarker fires the event
               */
              this._fireEvent('edittextend');
          }
          return this;
      },
      /**
       * 是否正在编辑文本
       * @english
       * Whether the text is being edited.
       *
       * @return {Boolean}
       */
      isEditingText: function () {
          if (this._textEditor) {
              return true;
          }
          return false;
      },
      /**
       * 获取正在编辑的文本对象
       * @english
       * Get the text editor which is an [ui.UIMarker]{@link ui.UIMarker}
       * @return {ui.UIMarker} text editor
       */
      getTextEditor: function () {
          return this._editUIMarker;
      },
      //@internal
      _prepareEditor: function () {
          var map = this.getMap();
          var editContainer = this._createEditor();
          this._textEditor = editContainer;
          map.on('mousedown', this.endEditText, this);
          var offset = this._getEditorOffset();
          this._editUIMarker = new UIMarker(this.getCoordinates(), {
              'animation': null,
              'content': editContainer,
              'dx': offset.dx,
              'dy': offset.dy
          })
              .addTo(map);
          this._setCursorToLast(this._textEditor);
      },
      //@internal
      _getEditorOffset: function () {
          var symbol = this._getInternalSymbol() || {};
          var dx = 0, dy = 0;
          var textAlign = symbol['textHorizontalAlignment'];
          if (textAlign === 'middle' || isNil(textAlign)) {
              dx = (symbol['textDx'] || 0) - 2;
              dy = (symbol['textDy'] || 0) - 2;
          }
          else {
              dx = (symbol['markerDx'] || 0) - 2;
              dy = (symbol['markerDy'] || 0) - 2;
          }
          return {
              'dx': dx,
              'dy': dy
          };
      },
      //@internal
      _createEditor: function () {
          var content = this.getContent();
          var labelSize = this.getSize(), symbol = this._getInternalSymbol() || {}, width = labelSize.width, textColor = symbol['textFill'] || '#000000', textSize = symbol['textSize'] || 12, height = labelSize.height, lineColor = symbol['markerLineColor'] || '#000', fill = symbol['markerFill'] || '#3398CC', spacing = symbol['textLineSpacing'] || 0;
          var editor = createEl('div');
          // @ts-expect-error todo
          editor.contentEditable = true;
          editor.style.cssText = "background:".concat(fill, "; border:1px solid ").concat(lineColor, ";\n            color:").concat(textColor, ";font-size:").concat(textSize, "px;width:").concat(width - 2, "px;height:").concat(height - 2, "px;margin: auto;\n            line-height:").concat(textSize + spacing, "px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;");
          editor.innerText = content;
          on(editor, 'mousedown dblclick', stopPropagation);
          editor.onkeyup = function (event) {
              var h = editor.style.height || 0;
              if (event.keyCode === 13) {
                  editor.style.height = (parseInt(h) + textSize / 2) + 'px';
              }
          };
          return editor;
      },
      //@internal
      _setCursorToLast: function (obj) {
          var range;
          if (window.getSelection) {
              obj.focus();
              range = window.getSelection();
              range.selectAllChildren(obj);
              range.collapseToEnd();
              // @ts-expect-error todo待确认document
          }
          else if (document.selection) {
              // @ts-expect-error todo待确认document
              range = document.selection.createRange();
              range.moveToElementText(obj);
              range.collapse(false);
              range.select();
          }
      }
  };
  TextMarker.include(TextEditable);

  Geometry.include(/** @lends Geometry.prototype */ {
      /**
       * 几何体动画
       * @english
       * Animate the geometry
       *
       * @param  {Object}   styles          - styles to animate
       * @param  {Object}   [options=null]  - animation options
       * @param  {NUmber}   [options.duration=1000]      - duration
       * @param  {Number}   [options.startTime=null]  - time to start animation in ms
       * @param  {String}   [options.easing=linear]   - animation easing: in, out, inAndOut, linear, upAndDown
       * @param  {Boolean}  [options.repeat=false]      - repeat animation
       * @param  {Function} [step=null]  - step function during animation, animation frame as the parameter
       * @return {animation.Player} animation player
       * @example
       * var player = marker.animate({
       *     'symbol': {
       *         'markerHeight': 82
       *      }
       * }, {
       *     'duration': 2000
       * }, function (frame) {
       *     if (frame.state.playState === 'finished') {
       *         console.log('animation finished');
       *     }
       * });
       * player.pause();
       */
      animate: function (styles, options, step) {
          var _this = this;
          if (this._animPlayer) {
              this._animPlayer.finish();
          }
          if (isFunction(options)) {
              step = options;
          }
          if (!options) {
              options = {};
          }
          var map = this.getMap(), projection = this._getProjection(), stylesToAnimate = this._prepareAnimationStyles(styles);
          var preTranslate;
          var isFocusing = options['focus'];
          delete this._animationStarted;
          // geometry.animate can be called without map
          if (map) {
              // merge geometry animation framing into map's frame loop
              var renderer_1 = map._getRenderer();
              var framer = function (fn) {
                  renderer_1.callInNextFrame(fn);
              };
              options['framer'] = framer;
          }
          if (!projection && isFocusing) {
              console.error(GEOMETRY_NOT_FIND_PROJECTION);
              return;
          }
          var player = Animation.animate(stylesToAnimate, options, function (frame) {
              if (map && map.isRemoved()) {
                  player.finish();
                  return;
              }
              if (map && !_this._animationStarted && isFocusing) {
                  map.onMoveStart();
              }
              var styles = frame.styles;
              for (var p in styles) {
                  if (p !== 'symbol' && p !== 'translate' && styles.hasOwnProperty(p)) {
                      var fnName = 'set' + p[0].toUpperCase() + p.slice(1);
                      _this[fnName](styles[p]);
                  }
              }
              var translate = styles['translate'];
              if (translate) {
                  var toTranslate = translate;
                  if (preTranslate) {
                      toTranslate = translate.sub(preTranslate);
                  }
                  preTranslate = translate;
                  _this.translate(toTranslate);
              }
              var dSymbol = styles['symbol'];
              if (dSymbol) {
                  var symbol = _this.getSymbol() || {};
                  _this.setSymbol(extendSymbol(symbol, dSymbol));
              }
              if (map && isFocusing) {
                  var pcenter = projection.project(_this.getCenter());
                  map._setPrjCenter(pcenter);
                  var e = map._parseEventFromCoord(projection.unproject(pcenter));
                  if (player.playState !== 'running') {
                      map.onMoveEnd(e);
                  }
                  else {
                      map.onMoving(e);
                  }
              }
              _this._fireAnimateEvent(player.playState);
              if (step) {
                  step(frame);
              }
          }, this);
          this._animPlayer = player;
          return this._animPlayer.play();
      },
      /**
       * 为动画准备样式
       * @english
       * Prepare styles for animation
       * @return {Object} styles
       * @private
       */
      //@internal
      _prepareAnimationStyles: function (styles) {
          var symbol = this._getInternalSymbol();
          var stylesToAnimate = {};
          for (var p in styles) {
              if (styles.hasOwnProperty(p)) {
                  var v = styles[p];
                  if (p !== 'translate' && p !== 'symbol') {
                      //this.getRadius() / this.getWidth(), etc.
                      var fnName = 'get' + p[0].toUpperCase() + p.substring(1);
                      var current = this[fnName]();
                      stylesToAnimate[p] = [current, v];
                  }
                  else if (p === 'symbol') {
                      var symbolToAnimate = void 0;
                      if (Array.isArray(styles['symbol'])) {
                          if (!Array.isArray(symbol)) {
                              throw new Error('geometry\'symbol isn\'t a composite symbol, while the symbol in styles is.');
                          }
                          symbolToAnimate = [];
                          var symbolInStyles = styles['symbol'];
                          for (var i = 0; i < symbolInStyles.length; i++) {
                              if (!symbolInStyles[i]) {
                                  symbolToAnimate.push(null);
                                  continue;
                              }
                              var a = {};
                              for (var sp in symbolInStyles[i]) {
                                  if (symbolInStyles[i].hasOwnProperty(sp)) {
                                      a[sp] = [symbol[i][sp], symbolInStyles[i][sp]];
                                  }
                              }
                              symbolToAnimate.push(a);
                          }
                      }
                      else {
                          if (Array.isArray(symbol)) {
                              throw new Error('geometry\'symbol is a composite symbol, while the symbol in styles isn\'t.');
                          }
                          symbolToAnimate = {};
                          for (var sp in v) {
                              if (v.hasOwnProperty(sp)) {
                                  symbolToAnimate[sp] = [symbol[sp], v[sp]];
                              }
                          }
                      }
                      stylesToAnimate['symbol'] = symbolToAnimate;
                  }
                  else if (p === 'translate') {
                      stylesToAnimate['translate'] = new Coordinate(v);
                  }
              }
          }
          return stylesToAnimate;
      },
      /**
       * 绑定动画事件
       * @english
       * Bind animation events
       * @param {string} playState
       */
      //@internal
      _fireAnimateEvent: function (playState) {
          if (playState === 'finished') {
              delete this._animationStarted;
              /**
               * fired when geometry's animation ended.
               *
               * @event Geometry#animateend
               * @type {Object}
               * @property {String} type - animateend
               * @property {Geometry} target - the geometry fires the event
               */
              this._fireEvent('animateend');
          }
          else if (playState === 'running') {
              if (this._animationStarted) {
                  /**
                   * fired when geometry is animating.
                   *
                   * @event Geometry#animating
                   * @type {Object}
                   * @property {String} type - animating
                   * @property {Geometry} target - the geometry fires the event
                   */
                  this._fireEvent('animating');
              }
              else {
                  /**
                   * fired when geometry's animation start.
                   *
                   * @event Geometry#animatestart
                   * @type {Object}
                   * @property {String} type - animatestart
                   * @property {Geometry} target - the geometry fires the event
                   */
                  this._fireEvent('animatestart');
                  this._animationStarted = true;
              }
          }
      }
  });

  var DRAG_STAGE_LAYER_ID = INTERNAL_LAYER_PREFIX + '_drag_stage';
  var EVENTS = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';
  /**
   * 几何图形的拖动处理程序
   * @english
   * Drag handler for geometries.
   * @category handler
   * @extends Handler
   * @ignore
   */
  var GeometryDragHandler = /** @class */ (function (_super) {
      __extends(GeometryDragHandler, _super);
      /**
       * @param  {Geometry} target geometry target to drag
       */
      function GeometryDragHandler(target) {
          return _super.call(this, target) || this;
      }
      GeometryDragHandler.prototype.addHooks = function () {
          this.target.on(EVENTS, this._startDrag, this);
      };
      GeometryDragHandler.prototype.removeHooks = function () {
          this._endDrag();
          this.target.off(EVENTS, this._startDrag, this);
          delete this.container;
      };
      //@internal
      GeometryDragHandler.prototype._prepareDragHandler = function () {
          this._dragHandler = new DragHandler(this.container);
          this._dragHandler.on('dragging', this._dragging, this)
              .on('mouseup', this._endDrag, this)
              .enable();
      };
      //@internal
      GeometryDragHandler.prototype._prepareShadow = function () {
          var _this = this;
          var target = this.target;
          var needShadow = target.getLayer().options['renderer'] === 'canvas';
          if (!needShadow) {
              return;
          }
          if (!target.options.dragShadow) {
              return;
          }
          this._prepareDragStageLayer();
          if (this._shadow) {
              this._shadow.remove();
          }
          var shadow = this._shadow = target.copy();
          if (shadow.getGeometries) {
              var shadows = shadow.getGeometries();
              var geos_1 = target.getGeometries();
              shadows.forEach(function (g, i) {
                  _this._updateShadowSymbol(g, geos_1[i]);
              });
          }
          else {
              this._updateShadowSymbol(shadow, target);
          }
          shadow.setId(null);
          this._prepareShadowConnectors();
      };
      //@internal
      GeometryDragHandler.prototype._updateShadowSymbol = function (shadow, target) {
          shadow.setSymbol(target._getInternalSymbol());
          if (target.options['dragShadow']) {
              var symbol = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
              shadow.setSymbol(symbol);
          }
      };
      //@internal
      GeometryDragHandler.prototype._prepareShadowConnectors = function () {
          //copy connectors
          var target = this.target;
          var shadow = this._shadow;
          var resources = this._dragStageLayer._getRenderer().resources;
          var shadowConnectors = [];
          if (ConnectorLine._hasConnectors(target)) {
              var connectors = ConnectorLine._getConnectors(target);
              for (var i = 0, l = connectors.length; i < l; i++) {
                  var targetConn = connectors[i];
                  var connOptions = targetConn.config(), connSymbol = targetConn._getInternalSymbol();
                  connOptions['symbol'] = lowerSymbolOpacity(connSymbol, 0.5);
                  var conn = void 0;
                  if (targetConn.getConnectSource() === target) {
                      conn = new targetConn.constructor(shadow, targetConn.getConnectTarget(), connOptions);
                  }
                  else {
                      conn = new targetConn.constructor(targetConn.getConnectSource(), shadow, connOptions);
                  }
                  shadowConnectors.push(conn);
                  if (targetConn.getLayer() && targetConn.getLayer()._getRenderer()) {
                      resources.merge(targetConn.getLayer()._getRenderer().resources);
                  }
              }
          }
          this._shadowConnectors = shadowConnectors;
          shadowConnectors.push(shadow);
          this._dragStageLayer.bringToFront().addGeometry(shadowConnectors);
      };
      //@internal
      GeometryDragHandler.prototype._onTargetUpdated = function () {
          if (this._shadow) {
              this._shadow.setSymbol(this.target._getSymbol());
          }
      };
      //@internal
      GeometryDragHandler.prototype._prepareDragStageLayer = function () {
          var map = this.target.getMap(), layer = this.target.getLayer();
          this._dragStageLayer = map.getLayer(DRAG_STAGE_LAYER_ID);
          if (!this._dragStageLayer) {
              this._dragStageLayer = new VectorLayer(DRAG_STAGE_LAYER_ID, {
                  enableAltitude: layer.options['enableAltitude'],
                  altitudeProperty: layer.options['altitudeProperty']
              });
              map.addLayer(this._dragStageLayer);
          }
          //copy resources to avoid repeat resource loading.
          var resources = new ResourceCache();
          resources.merge(layer._getRenderer().resources);
          this._dragStageLayer._getRenderer().resources = resources;
      };
      //@internal
      GeometryDragHandler.prototype._startDrag = function (param) {
          var map = this.target.getMap();
          if (!map) {
              return;
          }
          var parent = this.target._getParent();
          if (parent) {
              return;
          }
          if (this.isDragging()) {
              return;
          }
          var domEvent = param['domEvent'];
          if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
              return;
          }
          this.container = map.getPanels().mapWrapper || map.getContainer();
          this.target.on('click', this._endDrag, this);
          this._lastCoord = this._correctCoord(param['coordinate']);
          this._lastPoint = param['containerPoint'];
          this._prepareDragHandler();
          this._dragHandler.onMouseDown(param['domEvent']);
          on(this.container, 'mouseleave', this._endDrag, this);
          this._startParam = param;
          this._moved = false;
          return;
      };
      //@internal
      GeometryDragHandler.prototype._dragging = function (param) {
          var target = this.target;
          var map = target.getMap();
          if (map._isEventOutMap(param['domEvent'])) {
              return;
          }
          var e = map._parseEvent(param['domEvent']);
          var domEvent = e['domEvent'];
          if (domEvent.touches && domEvent.touches.length > 1) {
              return;
          }
          var visualHeight = map._getVisualHeight(map.options['maxVisualPitch']);
          if (e.containerPoint.y < map.height - visualHeight) {
              return;
          }
          if (!this._moved) {
              this._moved = true;
              target.on('symbolchange', this._onTargetUpdated, this);
              this._isDragging = true;
              this._prepareShadow();
              if (this._shadow) {
                  if (!target.options['dragShadow']) {
                      target.hide();
                  }
                  this._shadow._fireEvent('dragstart', e);
              }
              /**
               * 拖拽开始事件
               * @english
               * drag start event
               * @event Geometry#dragstart
               * @type {Object}
               * @property {String} type           - dragstart
               * @property {Geometry} target       - the geometry fires event
               * @property {Coordinate} coordinate - coordinate of the event
               * @property {Point} containerPoint  - container point of the event
               * @property {Point} viewPoint       - view point of the event
               * @property {Event} domEvent                 - dom event
               */
              this.target._fireEvent('dragstart', this._startParam || e);
              delete this._startParam;
              return;
          }
          var geo = this._shadow || target;
          var axis = geo.options['dragOnAxis'], dragOnScreenAxis = geo.options['dragOnScreenAxis'], point = e['containerPoint'];
          var coord = e['coordinate'];
          this._lastPoint = this._lastPoint || point;
          this._lastCoord = this._lastCoord || coord;
          // drag direction is ScreenCoordinates,The direction of the drag has nothing to do with the map rotation(bearing)
          if (dragOnScreenAxis) {
              if (axis === 'x') {
                  point.y = this._lastPoint.y;
              }
              else if (axis === 'y') {
                  point.x = this._lastPoint.x;
              }
              coord = map.containerPointToCoord(point);
          }
          else {
              coord = this._correctCoord(coord);
          }
          var pointOffset = point.sub(this._lastPoint);
          var coordOffset = coord.sub(this._lastCoord);
          if (!dragOnScreenAxis) {
              if (axis === 'x') {
                  pointOffset.y = coordOffset.y = 0;
              }
              else if (axis === 'y') {
                  pointOffset.x = coordOffset.x = 0;
              }
          }
          this._lastPoint = point;
          this._lastCoord = coord;
          var isPoint = !geo.getGeometries && geo.isPoint;
          isPoint ? geo.setCoordinates(coord) : geo.translate(coordOffset);
          if (geo !== target && !target.options['dragShadow']) {
              isPoint ? target.setCoordinates(coord) : target.translate(coordOffset);
          }
          e['coordOffset'] = coordOffset;
          e['pointOffset'] = pointOffset;
          geo._fireEvent('dragging', e);
          /**
           * 正在拖拽事件
           * @english
           * dragging event
           * @event Geometry#dragging
           * @type {Object}
           * @property {String} type                    - dragging
           * @property {Geometry} target       - the geometry fires event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */
          if (geo !== target) {
              target._fireEvent('dragging', e);
          }
      };
      //@internal
      GeometryDragHandler.prototype._endDrag = function (param) {
          if (this._dragHandler) {
              this._dragHandler.disable();
              delete this._dragHandler;
          }
          if (this.container) {
              // @ts-expect-error todo 待补充off参数类型
              off(this.container, 'mouseleave', this._endDrag);
          }
          if (!this.target) {
              return;
          }
          var target = this.target;
          target.off('click', this._endDrag, this);
          target.off('symbolchange', this._onTargetUpdated, this);
          delete this._lastCoord;
          delete this._lastPoint;
          this._isDragging = false;
          var map = target.getMap();
          if (this.enabled() && map) {
              var e = map._parseEvent(param ? param['domEvent'] : null);
              this._updateTargetAndRemoveShadow(e);
              if (this._moved) {
                  /**
                   * 拖拽结束事件
                   * @english
                   * dragend event
                   * @event Geometry#dragend
                   * @type {Object}
                   * @property {String} type                    - dragend
                   * @property {Geometry} target       - the geometry fires event
                   * @property {Coordinate} coordinate - coordinate of the event
                   * @property {Point} containerPoint  - container point of the event
                   * @property {Point} viewPoint       - view point of the event
                   * @property {Event} domEvent                 - dom event
                   */
                  target._fireEvent('dragend', e);
              }
          }
      };
      GeometryDragHandler.prototype.isDragging = function () {
          if (!this._isDragging) {
              return false;
          }
          return true;
      };
      //@internal
      GeometryDragHandler.prototype._updateTargetAndRemoveShadow = function (eventParam) {
          if (!this._shadow) {
              return;
          }
          var target = this.target, map = target.getMap();
          if (!target.options['dragShadow']) {
              target.show();
          }
          var shadow = this._shadow;
          if (shadow) {
              if (target.options['dragShadow']) {
                  var shadowFirst = shadow.getFirstCoordinate();
                  var first = target.getFirstCoordinate();
                  var offset = shadowFirst.sub(first);
                  target.translate(offset);
              }
              shadow._fireEvent('dragend', eventParam);
              shadow.remove();
              delete this._shadow;
          }
          if (this._shadowConnectors) {
              map.getLayer(DRAG_STAGE_LAYER_ID).removeGeometry(this._shadowConnectors);
              delete this._shadowConnectors;
          }
          if (this._dragStageLayer) {
              this._dragStageLayer._getRenderer().resources = new ResourceCache();
              this._dragStageLayer.remove();
          }
      };
      //find correct coordinate for coordOffset if geometry has altitude
      //@internal
      GeometryDragHandler.prototype._correctCoord = function (coord) {
          var map = this.target.getMap();
          if (!map.getPitch()) {
              return coord;
          }
          var target = this.target;
          if (!target.getMinAltitude()) {
              return coord;
          }
          var alt = (target.getMinAltitude() + target.getMaxAltitude()) / 2;
          return map.locateByPoint(coord, 0, -alt);
      };
      return GeometryDragHandler;
  }(Handler));
  Geometry.mergeOptions({
      'draggable': false,
      'dragShadow': true,
      'dragOnAxis': null,
      'dragOnScreenAxis': false
  });
  Geometry.addInitHook('addHandler', 'draggable', GeometryDragHandler);
  Geometry.include(/** @lends Geometry.prototype */ {
      /**
       * 是否正在拖到几何体
       * @english
       * Whether the geometry is being dragged.
       * @reutrn {Boolean}
       */
      isDragging: function () {
          if (this._getParent()) {
              return this._getParent().isDragging();
          }
          if (this['draggable']) {
              return this['draggable'].isDragging();
          }
          return false;
      }
  });

  Geometry.include(/** @lends Geometry.prototype */ {
      /**
       * 开始编辑
       * @english
       * Start to edit
       * @param {Object} [options=null]        - edit options
       * @param {Object} [options.symbol=null] - symbol for the geometry during editing
       * @param {Object} [options.fixAspectRatio=false]    - fix outline's aspect ratio when resizing
       * @param {Object} [options.centerHandleSymbol=null] - symbol of center handle
       * @param {Object} [options.vertexHandleSymbol=null] - symbol of vertex handle
       * @param {Object} [options.newVertexHandleSymbol=null] - symbol of new vertex handle
       * @param {Object} [options.removeVertexOn=contextmenu] - event to remove a vertex from line or polygon, contextmenu by default
       * @return {Geometry} this
       */
      startEdit: function (opts) {
          var map = this.getMap();
          if (!map || !this.options['editable']) {
              return this;
          }
          if (this._editor) {
              this.endEdit();
          }
          this._recordVisible();
          this._editor = new GeometryEditor(this, opts);
          this._editor.start();
          /**
           * start edit event
           *
           * @event Geometry#editstart
           * @type {Object}
           * @property {String} type - editstart
           * @property {Geometry} target - the geometry fires the event
           */
          if (!this._getParent()) {
              this.fire('editstart');
          }
          map.getRenderer().setToRedraw();
          return this;
      },
      /**
       * 结束编辑
       * @english
       * End editing.
       * @return {Geometry} this
       */
      endEdit: function () {
          if (this._editor) {
              this._editor.stop();
              delete this._editor;
              this._recoveryVisible();
              /**
               * end edit event
               *
               * @event Geometry#editend
               * @type {Object}
               * @property {String} type - editend
               * @property {Geometry} target - the geometry fires the event
               */
              if (!this._getParent()) {
                  this.fire('editend');
              }
              var map = this.getMap();
              if (map) {
                  map.getRenderer().setToRedraw();
              }
          }
          return this;
      },
      /**
       * 重新编辑
       * @english
       * Redo the edit
       * @return {Geometry} this
       */
      redoEdit: function () {
          if (!this.isEditing()) {
              return this;
          }
          this._editor.redo();
          /**
           * redo edit event
           *
           * @event Geometry#redoedit
           * @type {Object}
           * @property {String} type - redoedit
           * @property {Geometry} target - the geometry fires the event
           */
          if (!this._getParent()) {
              this.fire('redoedit');
          }
          return this;
      },
      /**
       * 撤销编辑
       * @english
       * Undo the edit
       * @return {Geometry} this
       */
      undoEdit: function () {
          if (!this.isEditing()) {
              return this;
          }
          this._editor.undo();
          /**
           * undo edit event
           *
           * @event Geometry#undoedit
           * @type {Object}
           * @property {String} type - undoedit
           * @property {Geometry} target - the geometry fires the event
           */
          if (!this._getParent()) {
              this.fire('undoedit');
          }
          return this;
      },
      /**
       * 取消编辑
       * @english
       * cancel the edit
       * @return {Geometry} this
       */
      cancelEdit: function () {
          if (!this.isEditing()) {
              return this;
          }
          this._recoveryVisible();
          this._editor.cancel();
          /**
           * cancel edit event
           *
           * @event Geometry#canceledit
           * @type {Object}
           * @property {String} type - canceledit
           * @property {Geometry} target - the geometry fires the event
           */
          if (!this._getParent()) {
              this.fire('canceledit');
          }
          return this;
      },
      /**
       * 是否正在编辑几何图形
       * @english
       * Whether the geometry is being edited.
       * @return {boolean}
       */
      isEditing: function () {
          if (this._editor) {
              return this._editor.isEditing();
          }
          return false;
      }
  });

  Geometry.include(/** @lends Geometry.prototype */ {
      /**
       * 所有事件的事件处理程序
       * @english
       * The event handler for all the events.
       * @param  {Event} event - dom event
       * @private
       */
      //@internal
      _onEvent: function (event, type) {
          var map = this.getMap();
          if (!map) {
              return;
          }
          var eventType = type || this._getEventTypeToFire(event);
          if (eventType === 'contextmenu' && this.listens('contextmenu')) {
              stopPropagation(event);
              preventDefault(event);
          }
          var params = map._getEventParams(event);
          if (isNumber(this._pickGeometryIndex)) {
              params.pickGeometryIndex = this._pickGeometryIndex;
              // delete this._pickGeometryIndex;
          }
          this._fireEvent(eventType, params);
      },
      /**
       * 获取事件类型
       * @english
       * Get the eventType of domEvent
       * @param {any} domEvent
       * @returns
       */
      //@internal
      _getEventTypeToFire: function (domEvent) {
          // let eventType = domEvent.type;
          // //change event type to contextmenu
          // if (eventType === 'click' || eventType === 'mousedown') {
          //     if (domEvent.button === 2) {
          //         eventType = 'contextmenu';
          //     }
          // }
          return domEvent.type;
      },
      /**
       * 生成事件参数
       * @english
       * Generate event parameters
       * @param  {Event} event - dom event
       * @return {Object}
       * @private
       */
      // _getEventParams(e: any): Object {
      //     const map = this.getMap();
      //     const eventParam = {
      //         'domEvent': e
      //     };
      //     const actual = e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
      //     if (actual) {
      //         const containerPoint = getEventContainerPoint(actual, map.getContainer());
      //         eventParam['coordinate'] = map.containerPointToCoordinate(containerPoint);
      //         eventParam['containerPoint'] = containerPoint;
      //         eventParam['viewPoint'] = map.containerPointToViewPoint(containerPoint);
      //         eventParam['point2d'] = map._containerPointToPoint(containerPoint);
      //     }
      //     return eventParam;
      // }
  });

  Geometry.include(/** @lends Geometry.prototype */ {
      /**
       * 给几何体设置信息窗口
       * @english
       * Set an InfoWindow to the geometry
       * @param {Object} options - construct [options]{@link ui.InfoWindow#options} for the InfoWindow
       * @return {Geometry} this
       * @example
       * geometry.setInfoWindow({
       *     title    : 'This is a title',
       *     content  : '<div style="color:#f00">This is content of the InfoWindow</div>'
       * });
       */
      setInfoWindow: function (options) {
          this.removeInfoWindow();
          if (options instanceof InfoWindow) {
              this._infoWindow = options;
              this._infoWinOptions = extend$2({}, this._infoWindow.options);
              this._infoWindow.addTo(this);
              return this;
          }
          this._infoWinOptions = extend$2({}, options);
          if (this._infoWindow) {
              this._infoWindow.setOptions(options);
          }
          else if (this.getMap()) {
              this._bindInfoWindow();
          }
          return this;
      },
      /**
       * 获取InfoWindow实例
       * @english
       * Get the InfoWindow instance.
       * @return {ui.InfoWindow}
       */
      getInfoWindow: function () {
          if (!this._infoWindow) {
              return null;
          }
          return this._infoWindow;
      },
      /**
       * 打开信息窗口，默认位于几何图形的中心。
       * @english
       * Open the InfoWindow, default on the center of the geometry.
       * @param  {Coordinate} [coordinate=null] - coordinate to open the InfoWindow
       * @return {Geometry} this
       */
      openInfoWindow: function (coordinate) {
          if (!this.getMap()) {
              return this;
          }
          if (!coordinate) {
              coordinate = this.getCenter();
          }
          if (!this._infoWindow) {
              if (this._infoWinOptions && this.getMap()) {
                  this._bindInfoWindow();
                  this._infoWindow.show(coordinate);
              }
          }
          else {
              this._infoWindow.show(coordinate);
          }
          return this;
      },
      /**
       * 关闭信息窗口
       * @english
       * Close the InfoWindow
       * @return {Geometry} this
       */
      closeInfoWindow: function () {
          if (this._infoWindow) {
              this._infoWindow.hide();
          }
          return this;
      },
      /**
       * 移除信息窗口
       * @english
       * Remove the InfoWindow
       * @return {Geometry} this
       */
      removeInfoWindow: function () {
          this._unbindInfoWindow();
          delete this._infoWinOptions;
          delete this._infoWindow;
          return this;
      },
      /**
       * 给几何体绑定信息窗口
       * @english
       * Bing InfoWindow to Geometry
       * @returns {Geometry} this
       */
      //@internal
      _bindInfoWindow: function () {
          var options = this._infoWinOptions;
          if (!options) {
              return this;
          }
          this._infoWindow = new InfoWindow(options);
          this._infoWindow.addTo(this);
          return this;
      },
      /**
       * 解绑几何体窗口
       * @english
       * Unbind InfoWindow
       * @returns {Geometry} this
       */
      //@internal
      _unbindInfoWindow: function () {
          if (this._infoWindow) {
              this.closeInfoWindow();
              this._infoWindow.remove();
              delete this._infoWindow;
          }
          return this;
      }
  });

  Geometry.fromJSON = function (json) {
      if (Array.isArray(json)) {
          var result = [];
          for (var i = 0, len = json.length; i < len; i++) {
              var c = Geometry.fromJSON(json[i]);
              if (Array.isArray(json)) {
                  result = result.concat(c);
              }
              else {
                  result.push(c);
              }
          }
          return result;
      }
      if (json && !json['feature']) {
          return GeoJSON.toGeometry(json);
      }
      var geometry;
      if (json['subType']) {
          geometry = Geometry.getJSONClass(json['subType']).fromJSON(json);
          if (!isNil(json['feature']['id'])) {
              geometry.setId(json['feature']['id']);
          }
      }
      else {
          //feature可能是GeometryCollection，里面可能包含Circle等
          geometry = GeoJSON.toGeometry(json['feature']);
          if (json['options']) {
              geometry.config(json['options']);
          }
      }
      if (json['symbol']) {
          geometry.setSymbol(json['symbol']);
      }
      if (json['infoWindow']) {
          geometry.setInfoWindow(json['infoWindow']);
      }
      return geometry;
  };

  var TILE_POINT$1 = new Point(0, 0);
  var TEMP_POINT = new Point(0, 0);
  var TEMP_POINT1 = new Point(0, 0);
  var TEMP_POINT2 = new Point(0, 0);
  var EMPTY_ARRAY = [];
  var TileWorkerConnection = /** @class */ (function (_super) {
      __extends(TileWorkerConnection, _super);
      function TileWorkerConnection() {
          return _super.call(this, imageFetchWorkerKey) || this;
      }
      TileWorkerConnection.prototype.checkUrl = function (url) {
          if (!url || !isString(url)) {
              return url;
          }
          //The URL is processed. Here, only the relative protocol is processed
          return getAbsoluteURL(url);
      };
      // eslint-disable-next-line @typescript-eslint/ban-types
      TileWorkerConnection.prototype.fetchImage = function (url, workerId, cb, fetchOptions) {
          url = this.checkUrl(url);
          var data = {
              url: url,
              fetchOptions: fetchOptions
          };
          this.send(data, EMPTY_ARRAY, cb, workerId);
      };
      return TileWorkerConnection;
  }(Actor));
  /**
   * 基于 `HTML5 Canvas2D` 的渲染器类，用于瓦片图层
   *
   * @english
   * Renderer class based on HTML5 Canvas2D for TileLayers
   * @class
   * @protected
   * @group renderer
   * @extends {renderer.CanvasRenderer}
   */
  var TileLayerCanvasRenderer = /** @class */ (function (_super) {
      __extends(TileLayerCanvasRenderer, _super);
      /**
       *
       * @param {TileLayer} layer - TileLayer to render
       */
      function TileLayerCanvasRenderer(layer) {
          var _this = _super.call(this, layer) || this;
          _this.tilesInView = {};
          _this.tilesLoading = {};
          _this._parentTiles = [];
          _this._childTiles = [];
          _this._tileQueue = [];
          _this._tileQueueIds = new Set();
          var tileSize = layer.getTileSize().width;
          _this.tileCache = new LRUCache(layer.options['maxCacheSize'] * tileSize / 512 * tileSize / 512, function (tile) {
              _this.deleteTile(tile);
          });
          if (Browser$1.decodeImageInWorker && _this.layer.options['decodeImageInWorker'] && (layer.options['renderer'] === 'gl' || !Browser$1.safari && !Browser$1.iosWeixin)) {
              _this._tileImageWorkerConn = new TileWorkerConnection();
          }
          _this._compareTiles = compareTiles.bind(_this);
          return _this;
      }
      TileLayerCanvasRenderer.prototype.getCurrentTileZoom = function () {
          return this._tileZoom;
      };
      TileLayerCanvasRenderer.prototype.draw = function (timestamp, context) {
          var map = this.getMap();
          if (!this.isDrawable()) {
              return;
          }
          var mask2DExtent = this.prepareCanvas();
          if (mask2DExtent) {
              if (!mask2DExtent.intersects(this.canvasExtent2D)) {
                  this.completeRender();
                  return;
              }
          }
          if (this._renderTimestamp !== timestamp) {
              // maptalks/issues#10
              // 如果consumeTileQueue方法在每个renderMode都会调用，但多边形只在fxaa mode下才会绘制。
              // 导致可能出现consumeTileQueue在fxaa阶段后调用，之后的阶段就不再绘制。
              // 改为consumeTileQueue只在finalRender时调用即解决问题
              this._consumeTileQueue();
              this._computeAvgTileAltitude();
              this._renderTimestamp = timestamp;
          }
          var currentTiles;
          var hasFreshTiles = false;
          var frameTiles = this._frameTiles;
          if (frameTiles && timestamp === frameTiles.timestamp) {
              if (frameTiles.empty) {
                  return;
              }
              currentTiles = frameTiles;
          }
          else {
              currentTiles = this._getTilesInCurrentFrame();
              if (!currentTiles) {
                  this._frameTiles = { empty: true, timestamp: timestamp };
                  this.completeRender();
                  return;
              }
              hasFreshTiles = true;
              this._frameTiles = currentTiles;
              this._frameTiles.timestamp = timestamp;
              if (currentTiles.loadingCount) {
                  this.loadTileQueue(currentTiles.tileQueue);
              }
          }
          var tiles = currentTiles.tiles, childTiles = currentTiles.childTiles, parentTiles = currentTiles.parentTiles, placeholders = currentTiles.placeholders, loading = currentTiles.loading, loadingCount = currentTiles.loadingCount, missedTiles = currentTiles.missedTiles, incompleteTiles = currentTiles.incompleteTiles;
          this._drawTiles(tiles, parentTiles, childTiles, placeholders, context, missedTiles, incompleteTiles);
          if (!loadingCount) {
              if (!loading) {
                  //redraw to remove parent tiles if any left in last paint
                  if (!map.isAnimating() && (this._parentTiles.length || this._childTiles.length)) {
                      this._parentTiles = [];
                      this._childTiles = [];
                      this.setToRedraw();
                  }
                  this.completeRender();
              }
          }
          if (hasFreshTiles) {
              this.retireTiles();
          }
      };
      TileLayerCanvasRenderer.prototype.getTileGridsInCurrentFrame = function () {
          return this._frameTileGrids;
      };
      TileLayerCanvasRenderer.prototype.getCurrentTimestamp = function () {
          return this._renderTimestamp || 0;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._getTilesInCurrentFrame = function () {
          var map = this.getMap();
          var layer = this.layer;
          var terrainTileMode = layer._isPyramidMode() && layer.options['terrainTileMode'];
          var tileGrids = layer.getTiles();
          this._frameTileGrids = tileGrids;
          tileGrids = tileGrids.tileGrids;
          if (!tileGrids || !tileGrids.length) {
              return null;
          }
          var count = tileGrids.reduce(function (acc, curr) { return acc + (curr && curr.tiles && curr.tiles.length || 0); }, 0);
          if (count >= (this.tileCache.max / 2)) {
              this.tileCache.setMaxSize(count * 2 + 1);
          }
          var loadingCount = 0;
          var loading = false;
          var checkedTiles = {};
          var tiles = [], parentTiles = [], parentKeys = {}, childTiles = [], childKeys = {}, placeholders = [], placeholderKeys = {};
          //visit all the tiles
          var tileQueue = {};
          var preLoadingCount = this.markTiles();
          var loadingLimit = this._getLoadLimit();
          var l = tileGrids.length;
          // !this._terrainHelper can't be deleted as parent tiles are part of terrain skin, maptalks/issues#608
          var isFirstRender = this._tileZoom === undefined && layer.options['currentTilesFirst'] && !this._terrainHelper;
          // main tile grid is the last one (draws on top)
          this._tileZoom = tileGrids[0]['zoom'];
          // let dirtyParentTiles = null;
          var missingTiles = null;
          var incompleteTiles = null;
          if (terrainTileMode) {
              // dirtyParentTiles = new Set();
              missingTiles = [];
              incompleteTiles = new Map();
          }
          for (var i = 0; i < l; i++) {
              var tileGrid = tileGrids[i];
              var gridTiles = tileGrid['tiles'];
              var parents = tileGrid['parents'] || EMPTY_ARRAY;
              var parentCount = parents.length;
              var allTiles = isFirstRender ? gridTiles : parents.concat(gridTiles);
              var placeholder = void 0;
              if (allTiles.length) {
                  placeholder = this._generatePlaceHolder(allTiles[0].res);
              }
              for (var j = 0, l_1 = allTiles.length; j < l_1; j++) {
                  var tile = allTiles[j];
                  var tileId = tile.id;
                  var isParentTile = j < parentCount;
                  //load tile in cache at first if it has.
                  var tileLoading = false;
                  var tilesCount = tiles.length;
                  if (this._isLoadingTile(tileId)) {
                      tileLoading = loading = true;
                      this.markCurrent(this.tilesLoading[tileId], true);
                  }
                  else {
                      var cached = this.getCachedTile(tile, isParentTile);
                      if (cached) {
                          if (!isParentTile) {
                              if (cached.image && this.isTileFadingIn(cached.image)) {
                                  tileLoading = loading = true;
                                  this.setToRedraw();
                              }
                              if (this.isTileComplete(cached)) {
                                  tiles.push(cached);
                              }
                              else {
                                  tileLoading = true;
                                  if (terrainTileMode) {
                                      incompleteTiles.set(tileId, cached);
                                  }
                              }
                          }
                      }
                      else {
                          tileLoading = loading = true;
                          var hitLimit = loadingLimit && (loadingCount + preLoadingCount[0]) > loadingLimit;
                          if (!this._tileQueueIds.has(tile.id) && !hitLimit && (!map.isInteracting() || (map.isMoving() || map.isRotating()))) {
                              loadingCount++;
                              var key = tileId;
                              tileQueue[key] = tile;
                          }
                      }
                  }
                  if (terrainTileMode && !isParentTile) {
                      if (tiles.length === tilesCount) {
                          missingTiles.push(tile);
                      }
                      else {
                          checkedTiles[tile.id] = 1;
                          // if (tile.parent) {
                          //     dirtyParentTiles.add(tile.parent);
                          // }
                      }
                  }
                  if (terrainTileMode)
                      continue;
                  if (isParentTile)
                      continue;
                  if (!tileLoading)
                      continue;
                  if (checkedTiles[tileId])
                      continue;
                  checkedTiles[tileId] = 1;
                  if (placeholder && !placeholderKeys[tileId]) {
                      //tell gl renderer not to bind gl buffer with image
                      tile.cache = false;
                      placeholders.push({
                          image: placeholder,
                          info: tile
                      });
                      placeholderKeys[tileId] = 1;
                  }
                  var children = this._findChildTiles(tile);
                  if (children.length) {
                      children.forEach(function (c) {
                          if (!childKeys[c.info.id]) {
                              childTiles.push(c);
                              childKeys[c.info.id] = 1;
                          }
                      });
                  }
                  // (children.length !== 4) means it's not complete, we still need a parent tile
                  if (!children.length || children.length !== 4) {
                      var parentTile = this._findParentTile(tile);
                      if (parentTile) {
                          var parentId = parentTile.info.id;
                          if (parentKeys[parentId] === undefined) {
                              parentKeys[parentId] = parentTiles.length;
                              parentTiles.push(parentTile);
                          } /* else {
                              //replace with parentTile of above tiles
                              parentTiles[parentKeys[parentId]] = parentTile;
                          } */
                      }
                  }
              }
          }
          // 遍历 missingTiles ，
          var missedTiles = [];
          if (terrainTileMode) {
              for (var i = 0; i < missingTiles.length; i++) {
                  var tile = missingTiles[i].info ? missingTiles[i].info : missingTiles[i];
                  if (!tile.parent || checkedTiles[tile.id]) {
                      continue;
                  }
                  var _a = this._findChildTiles(tile), children = _a.tiles, childMissedTiles = _a.missedTiles;
                  if (children.length) {
                      pushIn(tiles, children);
                      pushIn(missedTiles, childMissedTiles);
                      continue;
                  }
                  else if (incompleteTiles.has(tile.id)) {
                      tiles.push(incompleteTiles.get(tile.id));
                      incompleteTiles.delete(tile.id);
                      continue;
                  }
                  checkedTiles[tile.id] = 1;
                  missedTiles.push(tile);
                  // continue;
                  // // 以下是瓦片合并的优化，但一方面优化效果并不明显，且让渲染逻辑变得复杂，故暂时放弃
                  // if (dirtyParentTiles.has(tile.parent) || tile.z < this._tileZoom) {
                  //     // 如果sibling tile已经被加载过，或者是远处的上级瓦片，则直接加入missedTiles
                  //     checkedTiles[tile.id] = 1;
                  //     missedTiles.push(tile);
                  // } else {
                  //     // 遍历当前级别瓦片，如果四个sibling tile都没有加载，则把parentTile加入到missedTiles，减少要处理的瓦片数量
                  //     let parentTile = parentKeys[tile.parent];
                  //     if (parentTile || parentTile === null) {
                  //         // parentTile已被处理过
                  //         // 1. parentTile存在，则parentTile已经被加入到missedTile，作为parentTile的儿子瓦片的tile可以忽略
                  //         // 2. parentTile不存在，则把当前瓦片加入到missedTile
                  //         if (parentTile === null) {
                  //             checkedTiles[tile.id] = 1;
                  //             missedTiles.push(tile);
                  //         }
                  //         continue;
                  //     }
                  //     // 只查询上一级的parentTile
                  //     parentTile = this._findParentTile(tile, 1) || undefined;
                  //     if (parentTile && parentTile.image) {
                  //         // 父级瓦片存在，则把parentTile放入到tiles列表直接绘制
                  //         tiles.push(parentTile);
                  //         parentKeys[tile.parent] = parentTile;
                  //     } else {
                  //         const parentTileInfo = layer.tileInfoCache.get(tile.parent);
                  //         // 根据parentTileInfo是否存在，选择把parentTileInfo或者tile加入到missedTiles
                  //         if (parentTileInfo) {
                  //             if (!checkedTiles[parentTileInfo.id]) {
                  //                 checkedTiles[parentTileInfo.id] = 1;
                  //                 missedTiles.push(parentTileInfo);
                  //             }
                  //             parentKeys[tile.parent] = parentTileInfo;
                  //         } else {
                  //             checkedTiles[tile.id] = 1;
                  //             missedTiles.push(tile);
                  //             parentKeys[tile.parent] = null;
                  //         }
                  //     }
                  // }
              }
          }
          this.tileCache.shrink();
          // if (parentTiles.length) {
          //     childTiles.length = 0;
          //     this._childTiles.length = 0;
          // }
          return {
              childTiles: childTiles,
              missedTiles: missedTiles,
              parentTiles: parentTiles,
              tiles: tiles,
              incompleteTiles: incompleteTiles && Array.from(incompleteTiles.values()),
              placeholders: placeholders,
              loading: loading,
              loadingCount: loadingCount,
              tileQueue: tileQueue
          };
      };
      TileLayerCanvasRenderer.prototype.removeTileCache = function (tileId) {
          delete this.tilesInView[tileId];
          this.tileCache.remove(tileId);
      };
      TileLayerCanvasRenderer.prototype.isTileCachedOrLoading = function (tileId) {
          return this.tileCache.get(tileId) || this.tilesInView[tileId] || this.tilesLoading[tileId];
      };
      TileLayerCanvasRenderer.prototype.isTileCached = function (tileId) {
          return !!(this.tileCache.get(tileId) || this.tilesInView[tileId]);
      };
      TileLayerCanvasRenderer.prototype.isTileFadingIn = function (tileImage) {
          return this._getTileFadingOpacity(tileImage) < 1;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._drawTiles = function (tiles, parentTiles, childTiles, placeholders, parentContext, missedTiles, incompleteTiles) {
          var _this = this;
          if (parentTiles.length) {
              //closer the latter (to draw on top)
              // parentTiles.sort((t1, t2) => Math.abs(t2.info.z - this._tileZoom) - Math.abs(t1.info.z - this._tileZoom));
              parentTiles.sort(this._compareTiles);
              this._parentTiles = parentTiles;
          }
          if (childTiles.length) {
              this._childTiles = childTiles;
              this._childTiles.sort(this._compareTiles);
          }
          var drawBackground = true;
          var backgroundTimestamp = this.canvas._parentTileTimestamp;
          if (this.layer.constructor === TileLayer || this.layer.constructor === WMSTileLayer) {
              // background tiles are only painted once for TileLayer and WMSTileLayer per frame.
              if (this._renderTimestamp === backgroundTimestamp) {
                  drawBackground = false;
              }
              else {
                  this.canvas._parentTileTimestamp = this._renderTimestamp;
              }
          }
          // todo 当为 gl 模式时实例应为 TileLayerGLRenderer
          var renderInGL = this.layer.options.renderer === 'gl' && (!this.isGL || this.isGL());
          var context = { tiles: tiles, parentTiles: this._parentTiles, childTiles: this._childTiles, parentContext: parentContext };
          this.onDrawTileStart(context, parentContext);
          if (drawBackground && this.layer.options['opacity'] === 1) {
              this.layer._silentConfig = true;
              var fadingAnimation = this.layer.options['fadeAnimation'];
              this.layer.options['fadeAnimation'] = false;
              if (renderInGL) {
                  this._drawChildTiles(childTiles, parentContext);
                  this._drawParentTiles(this._parentTiles, parentContext);
              }
              else {
                  this._drawParentTiles(this._parentTiles, parentContext);
                  this._drawChildTiles(childTiles, parentContext);
              }
              this.layer.options['fadeAnimation'] = fadingAnimation;
              this.layer._silentConfig = false;
          }
          this.drawingCurrentTiles = true;
          tiles.sort(this._compareTiles);
          for (var i = 0, l = tiles.length; i < l; i++) {
              this._drawTileAndCache(tiles[i], parentContext);
          }
          delete this.drawingCurrentTiles;
          if (drawBackground && this.layer.options['opacity'] < 1) {
              this.layer._silentConfig = true;
              var fadingAnimation = this.layer.options['fadeAnimation'];
              this.layer.options['fadeAnimation'] = false;
              if (renderInGL) {
                  this._drawChildTiles(childTiles, parentContext);
                  this._drawParentTiles(this._parentTiles, parentContext);
              }
              else {
                  this._drawParentTiles(this._parentTiles, parentContext);
                  this._drawChildTiles(childTiles, parentContext);
              }
              this.layer.options['fadeAnimation'] = fadingAnimation;
              this.layer._silentConfig = false;
          }
          placeholders.forEach(function (t) { return _this._drawTile(t.info, t.image, parentContext); });
          this.onDrawTileEnd(context, parentContext);
      };
      //@internal
      TileLayerCanvasRenderer.prototype._drawChildTiles = function (childTiles, parentContext) {
          var _this = this;
          // _hasOwnSR 时，瓦片之间会有重叠，会产生z-fighting，所以背景瓦片要后绘制
          this.drawingChildTiles = true;
          childTiles.forEach(function (t) { return _this._drawTile(t.info, t.image, parentContext); });
          delete this.drawingChildTiles;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._drawParentTiles = function (parentTiles, parentContext) {
          var _this = this;
          this.drawingParentTiles = true;
          this._parentTiles.forEach(function (t) { return _this._drawTile(t.info, t.image, parentContext); });
          delete this.drawingParentTiles;
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayerCanvasRenderer.prototype.onDrawTileStart = function (context, parentContext) { };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayerCanvasRenderer.prototype.onDrawTileEnd = function (context, parentContext) { };
      //@internal
      TileLayerCanvasRenderer.prototype._drawTile = function (info, image, parentContext) {
          if (image) {
              this.drawTile(info, image, parentContext);
          }
      };
      //@internal
      TileLayerCanvasRenderer.prototype._drawTileAndCache = function (tile, parentContext) {
          if (this.isValidCachedTile(tile)) {
              this.tilesInView[tile.info.id] = tile;
          }
          this._drawTile(tile.info, tile.image, parentContext);
      };
      TileLayerCanvasRenderer.prototype.drawOnInteracting = function (event, timestamp, context) {
          this.draw(timestamp, context);
      };
      TileLayerCanvasRenderer.prototype.needToRedraw = function () {
          var map = this.getMap();
          if (this._tileQueue.length) {
              return true;
          }
          if (map.getPitch()) {
              return _super.prototype.needToRedraw.call(this);
          }
          if (map.isRotating() || map.isZooming()) {
              return true;
          }
          if (map.isMoving()) {
              return !!this.layer.options['forceRenderOnMoving'];
          }
          return _super.prototype.needToRedraw.call(this);
      };
      TileLayerCanvasRenderer.prototype.hitDetect = function () {
          return false;
      };
      /**
       * @private
       * limit tile number to load when map is interacting
       */
      //@internal
      TileLayerCanvasRenderer.prototype._getLoadLimit = function () {
          if (this.getMap().isInteracting()) {
              return this.layer.options['loadingLimitOnInteracting'];
          }
          return this.layer.options['loadingLimit'] || 0;
      };
      TileLayerCanvasRenderer.prototype.isDrawable = function () {
          if (this.getMap().getPitch()) {
              if (console) {
                  console.warn('TileLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
              }
              this.clear();
              return false;
          }
          return true;
      };
      TileLayerCanvasRenderer.prototype.clear = function () {
          this.retireTiles(true);
          this.tileCache.reset();
          this.tilesInView = {};
          this.tilesLoading = {};
          this._tileQueue = [];
          this._tileQueueIds.clear();
          this._parentTiles = [];
          this._childTiles = [];
          _super.prototype.clear.call(this);
      };
      //@internal
      TileLayerCanvasRenderer.prototype._isLoadingTile = function (tileId) {
          return !!this.tilesLoading[tileId];
      };
      TileLayerCanvasRenderer.prototype.clipCanvas = function (context) {
          // const mask = this.layer.getMask();
          // if (!mask) {
          //     return this._clipByPitch(context);
          // }
          return _super.prototype.clipCanvas.call(this, context);
      };
      // clip canvas to avoid rough edge of tiles
      //@internal
      TileLayerCanvasRenderer.prototype._clipByPitch = function (ctx) {
          var map = this.getMap();
          if (map.getPitch() <= map.options['maxVisualPitch']) {
              return false;
          }
          if (!this.layer.options['clipByPitch']) {
              return false;
          }
          var clipExtent = map.getContainerExtent();
          var r = map.getDevicePixelRatio();
          ctx.save();
          ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
          ctx.beginPath();
          ctx.rect(0, Math.ceil(clipExtent.ymin) * r, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(clipExtent.getHeight()) * r);
          ctx.stroke();
          ctx.clip();
          return true;
      };
      TileLayerCanvasRenderer.prototype.loadTileQueue = function (tileQueue) {
          for (var p in tileQueue) {
              if (tileQueue.hasOwnProperty(p)) {
                  var tile = tileQueue[p];
                  var tileImage = this.loadTile(tile);
                  if (tileImage.loadTime === undefined) {
                      // tile image's loading may not be async
                      this.tilesLoading[tile['id']] = {
                          image: tileImage,
                          current: true,
                          info: tile
                      };
                  }
              }
          }
      };
      TileLayerCanvasRenderer.prototype.loadTile = function (tile) {
          var _this = this;
          var tileImage = {};
          // fixme: 无相关定义，是否实现？
          // @ts-expect-error todo
          if (this.loadTileBitmap) {
              var onLoad = function (bitmap) {
                  _this.onTileLoad(bitmap, tile);
              };
              var onError = function (error, image) {
                  _this.onTileError(image, tile, error);
              };
              // @ts-expect-error todo
              this.loadTileBitmap(tile['url'], tile, onLoad, onError);
          }
          else if (this._tileImageWorkerConn && this.loadTileImage === this.constructor.prototype.loadTileImage) {
              this._fetchImage(tileImage, tile);
          }
          else {
              var tileSize = this.layer.getTileSize(tile.layer);
              tileImage = new Image();
              // @ts-expect-error todo
              tileImage.width = tileSize['width'];
              // @ts-expect-error todo
              tileImage.height = tileSize['height'];
              tileImage.onload = this.onTileLoad.bind(this, tileImage, tile);
              tileImage.onerror = this.onTileError.bind(this, tileImage, tile);
              this.loadTileImage(tileImage, tile['url']);
          }
          return tileImage;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._fetchImage = function (image, tile) {
          var _this = this;
          if (image instanceof Image) {
              image.src = tile.url;
          }
          else {
              var x = tile.x, y = tile.y;
              var workerId = Math.abs(x + y) % this._tileImageWorkerConn.workers.length;
              this._tileImageWorkerConn.fetchImage(tile.url, workerId, function (err, data) {
                  if (err) {
                      _this.onTileError(image, tile, err);
                  }
                  else {
                      getImageBitMap(data, function (bitmap) {
                          _this.onTileLoad(bitmap, tile);
                      });
                  }
              }, this.layer.options['fetchOptions'] || {
                  referrer: document.location.href,
                  headers: { accept: 'image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8' }
              });
          }
      };
      TileLayerCanvasRenderer.prototype.loadTileImage = function (tileImage, url) {
          var crossOrigin = this.layer.options['crossOrigin'];
          if (!isNil(crossOrigin)) {
              tileImage.crossOrigin = crossOrigin;
          }
          return loadImage(tileImage, [url]);
      };
      TileLayerCanvasRenderer.prototype.abortTileLoading = function (tileImage, tileInfo) {
          if (tileInfo && tileInfo.id !== undefined) {
              this.removeTileLoading(tileInfo);
          }
          if (!tileImage)
              return;
          if (tileImage instanceof Image) {
              tileImage.onload = falseFn;
              tileImage.onerror = falseFn;
              tileImage.src = emptyImageUrl;
          }
      };
      TileLayerCanvasRenderer.prototype.onTileLoad = function (tileImage, tileInfo) {
          this.removeTileLoading(tileInfo);
          this._tileQueue.push({ tileInfo: tileInfo, tileData: tileImage });
          this._tileQueueIds.add(tileInfo.id);
          this.setToRedraw();
      };
      TileLayerCanvasRenderer.prototype.removeTileLoading = function (tileInfo) {
          delete this.tilesLoading[tileInfo.id];
          // need to setToRedraw to let tiles blocked by loadingLimit continue to load
          this.setToRedraw();
      };
      //@internal
      TileLayerCanvasRenderer.prototype._consumeTileQueue = function () {
          var count = 0;
          var limit = this.layer.options['tileLimitPerFrame'];
          var queue = this._tileQueue;
          /* eslint-disable no-unmodified-loop-condition */
          while (queue.length && (limit <= 0 || count < limit)) {
              var _a = queue.shift(), tileData = _a.tileData, tileInfo = _a.tileInfo;
              if (!this._tileQueueIds.has(tileInfo.id)) {
                  continue;
              }
              this._tileQueueIds.delete(tileInfo.id);
              if (!this.checkTileInQueue(tileData, tileInfo)) {
                  continue;
              }
              this.consumeTile(tileData, tileInfo);
              count++;
          }
          /* eslint-enable no-unmodified-loop-condition */
      };
      //@internal
      TileLayerCanvasRenderer.prototype._computeAvgTileAltitude = function () {
          var sumMin = 0;
          var sumMax = 0;
          var count = 0;
          for (var p in this.tilesInView) {
              var info = this.tilesInView[p] && this.tilesInView[p].info;
              if (info) {
                  sumMin += info.minAltitude || 0;
                  sumMax += info.maxAltitude || 0;
                  count++;
              }
          }
          this.avgMinAltitude = sumMin / count;
          this.avgMaxAltitude = sumMax / count;
      };
      // Parameters tileImage and tileInfo are required in VectorTileLayerRenderer
      TileLayerCanvasRenderer.prototype.checkTileInQueue = function (tileImage, tileInfo) {
          return true;
      };
      TileLayerCanvasRenderer.prototype.consumeTile = function (tileImage, tileInfo) {
          if (!this.layer) {
              return;
          }
          if (!this.tilesInView) {
              // removed
              return;
          }
          var e = { tile: tileInfo, tileImage: tileImage };
          // let user update tileImage in listener if needed
          tileImage = e.tileImage;
          this.resetTileLoadTime(tileImage);
          this.removeTileLoading(tileInfo);
          this._addTileToCache(tileInfo, tileImage);
          /**
           * tileload event, fired when tile is loaded.
           *
           * @event TileLayer#tileload
           * @type {Object}
           * @property {String} type - tileload
           * @property {TileLayer} target - tile layer
           * @property {Object} tileInfo - tile info
           * @property {Image} tileImage - tile image
           */
          this.layer.fire('tileload', e);
          this.setToRedraw();
      };
      TileLayerCanvasRenderer.prototype.resetTileLoadTime = function (tileImage) {
          // loadTime = 0 means a tile from onTileError
          if (tileImage.loadTime !== 0) {
              tileImage.loadTime = now();
          }
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayerCanvasRenderer.prototype.onTileError = function (tileImage, tileInfo, error) {
          if (!this.layer) {
              return;
          }
          tileImage.onerrorTick = tileImage.onerrorTick || 0;
          var tileRetryCount = this.layer.options['tileRetryCount'];
          if (tileRetryCount > tileImage.onerrorTick) {
              tileImage.onerrorTick++;
              this._fetchImage(tileImage, tileInfo);
              this.removeTileLoading(tileInfo);
              return;
          }
          var errorUrl = this.layer.options['errorUrl'];
          if (errorUrl) {
              if ((tileImage instanceof Image) && tileImage.src !== errorUrl) {
                  tileImage.src = errorUrl;
                  this.removeTileLoading(tileInfo);
                  return;
              }
              else {
                  tileImage = new Image();
                  tileImage.src = errorUrl;
              }
          }
          this.abortTileLoading(tileImage, tileInfo);
          tileImage.loadTime = 0;
          this.removeTileLoading(tileInfo);
          this._addTileToCache(tileInfo, tileImage);
          this.setToRedraw();
          /**
           * tileerror event, fired when tile loading has error.
           *
           * @event TileLayer#tileerror
           * @type {Object}
           * @property {String} type - tileerror
           * @property {TileLayer} target - tile layer
           * @property {Object} tileInfo - tile info
           */
          this.layer.fire('tileerror', { tile: tileInfo });
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      TileLayerCanvasRenderer.prototype.drawTile = function (tileInfo, tileImage, parentContext) {
          if (!tileImage || !this.getMap()) {
              return;
          }
          var extent2d = tileInfo.extent2d, offset = tileInfo.offset;
          var point = TILE_POINT$1.set(extent2d.xmin - offset[0], extent2d.ymax - offset[1]), tileZoom = tileInfo.z, tileId = tileInfo.id;
          var map = this.getMap(), zoom = map.getZoom(), ctx = this.context, cp = map._pointAtResToContainerPoint(point, tileInfo.res, 0, TEMP_POINT), bearing = map.getBearing(), transformed = bearing || zoom !== tileZoom;
          var opacity = this.getTileOpacity(tileImage, tileInfo);
          var alpha = ctx.globalAlpha;
          if (opacity < 1) {
              ctx.globalAlpha = opacity;
          }
          if (!transformed) {
              cp._round();
          }
          var x = cp.x, y = cp.y;
          var w = tileInfo.extent2d.xmax - tileInfo.extent2d.xmin;
          var h = tileInfo.extent2d.ymax - tileInfo.extent2d.ymin;
          var layer = this.layer;
          var bufferPixel = (layer ? layer.options.bufferPixel : 0);
          if (transformed) {
              ctx.save();
              ctx.translate(x, y);
              if (bearing) {
                  ctx.rotate(-bearing * Math.PI / 180);
              }
              w += bufferPixel;
              h += bufferPixel;
              var res = map._getResolution();
              if (res !== tileInfo.res) {
                  var scale = tileInfo.res / res;
                  ctx.scale(scale, scale);
              }
              x = y = 0;
          }
          Canvas.image(ctx, tileImage, x, y, w, h);
          if (this.layer.options['debug']) {
              var color = this.layer.options['debugOutline'];
              ctx.save();
              ctx.strokeStyle = color;
              ctx.fillStyle = color;
              // ctx.strokeWidth = 10;
              // ctx.lineWidth = 10
              ctx.font = '20px monospace';
              var point_1 = new Point(x, y);
              Canvas.rectangle(ctx, point_1, { width: w, height: h }, 1, 0);
              Canvas.fillText(ctx, this.getDebugInfo(tileId), point_1._add(32, h - 14), color);
              Canvas.drawCross(ctx, x + w / 2, y + h / 2, 2, color);
              ctx.restore();
          }
          if (transformed) {
              ctx.restore();
          }
          if (ctx.globalAlpha !== alpha) {
              ctx.globalAlpha = alpha;
          }
          this.setCanvasUpdated();
      };
      TileLayerCanvasRenderer.prototype.getDebugInfo = function (tileId) {
          var xyz = tileId.split('_');
          var length = xyz.length;
          return xyz[length - 3] + '/' + xyz[length - 2] + '/' + xyz[length - 1];
      };
      TileLayerCanvasRenderer.prototype.findChildTiles = function (info) {
          return this._findChildTiles(info);
      };
      //@internal
      TileLayerCanvasRenderer.prototype._findChildTiles = function (info) {
          var layer = this._getLayerOfTile(info.layer);
          var terrainTileMode = layer && layer.options['terrainTileMode'] && layer._isPyramidMode();
          if (!layer || !layer.options['background'] && !terrainTileMode || info.z > this.layer.getMaxZoom()) {
              return EMPTY_ARRAY;
          }
          var map = this.getMap();
          var children = [];
          if (layer._isPyramidMode()) {
              if (!terrainTileMode) {
                  // a faster one
                  var layer_1 = this._getLayerOfTile(info.layer);
                  var zoomDiff_1 = 2;
                  var cx_1 = info.x * 2;
                  var cy_1 = info.y * 2;
                  var cz_1 = info.z + 1;
                  var queue = [];
                  for (var j = 0; j < 2; j++) {
                      for (var jj = 0; jj < 2; jj++) {
                          queue.push(cx_1 + j, cy_1 + jj, cz_1);
                      }
                  }
                  while (queue.length) {
                      var z = queue.pop();
                      var y = queue.pop();
                      var x = queue.pop();
                      var id = layer_1._getTileId(x, y, z, info.layer);
                      var canVisit = z + 1 <= info.z + zoomDiff_1;
                      var tile = this.tileCache.getAndRemove(id);
                      if (tile) {
                          if (this.isValidCachedTile(tile)) {
                              children.push(tile);
                              this.tileCache.add(id, tile);
                          }
                          else if (canVisit) {
                              for (var j = 0; j < 2; j++) {
                                  for (var jj = 0; jj < 2; jj++) {
                                      queue.push(x * 2 + j, y * 2 + jj, z + 1);
                                  }
                              }
                          }
                      }
                      else if (canVisit) {
                          for (var j = 0; j < 2; j++) {
                              for (var jj = 0; jj < 2; jj++) {
                                  queue.push(x * 2 + j, y * 2 + jj, z + 1);
                              }
                          }
                      }
                  }
                  return children;
              }
              var missedTiles = void 0;
              if (terrainTileMode) {
                  missedTiles = [];
              }
              // const zoomDiff = 2;
              var cx = info.x * 2;
              var cy = info.y * 2;
              var cz = info.z + 1;
              // const queue = [];
              // for the sake of performance, we only traverse next 2 levels of children tiles
              var candidates = [];
              for (var i = 0; i < 2; i++) {
                  for (var ii = 0; ii < 2; ii++) {
                      var x = cx + i;
                      var y = cy + ii;
                      var z = cz;
                      var id = layer._getTileId(x, y, z, info.layer);
                      var tile = this.tileCache.getAndRemove(id);
                      if (tile && this.isValidCachedTile(tile)) {
                          children.push(tile);
                          this.tileCache.add(id, tile);
                          candidates.push(null);
                      }
                      else {
                          // 缺少offset
                          candidates.push(id);
                      }
                  }
              }
              // children.length等于4时，说明4个一级子瓦片都放入了children中
              if (children.length < 4) {
                  var index = 0;
                  for (var i = 0; i < 2; i++) {
                      for (var ii = 0; ii < 2; ii++) {
                          var id = candidates[index++];
                          if (!id) {
                              continue;
                          }
                          var x = cx + i;
                          var y = cy + ii;
                          var z = cz;
                          var childrenCount = children.length;
                          var childCandidates = [];
                          for (var j = 0; j < 2; j++) {
                              for (var jj = 0; jj < 2; jj++) {
                                  var xx = x * 2 + j;
                                  var yy = y * 2 + jj;
                                  var zz = z + 1;
                                  var id_1 = layer._getTileId(xx, yy, zz, info.layer);
                                  var childTile = this.tileCache.getAndRemove(id_1);
                                  if (childTile && this.isValidCachedTile(childTile)) {
                                      children.push(childTile);
                                      this.tileCache.add(id_1, childTile);
                                      childCandidates.push(null);
                                  }
                                  else {
                                      childCandidates.push(id_1);
                                  }
                              }
                          }
                          if (!terrainTileMode) {
                              continue;
                          }
                          if (children.length - childrenCount < 4) {
                              var childTileInfo = layer.tileInfoCache.get(id) || layer._createChildNode(info, i, ii, [0, 0], id);
                              if (children.length - childrenCount === 0) {
                                  // 四个二级子瓦片都没有被缓存，直接将当前的一级子瓦片tileInfo放入missedTiles
                                  missedTiles.push(childTileInfo);
                              }
                              else {
                                  // 四个二级子瓦片有被缓存的，将没有被缓存的tileInfo加入missedTiles
                                  var index_1 = 0;
                                  for (var j = 0; j < 2; j++) {
                                      for (var jj = 0; jj < 2; jj++) {
                                          var id_2 = childCandidates[index_1++];
                                          if (!id_2) {
                                              // 这个二级子瓦片已经被加入到了children
                                              continue;
                                          }
                                          var grandsonTileInfo = this.layer.tileInfoCache.get(id_2) || layer._createChildNode(childTileInfo, j, jj, [0, 0], id_2);
                                          missedTiles.push(grandsonTileInfo);
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
              return terrainTileMode ? { tiles: children, missedTiles: missedTiles } : children;
          }
          var zoomDiff = 1;
          var res = info.res;
          var min = info.extent2d.getMin(), max = info.extent2d.getMax(), pmin = layer._project(map._pointToPrjAtRes(min, res, TEMP_POINT1), TEMP_POINT1), pmax = layer._project(map._pointToPrjAtRes(max, res, TEMP_POINT2), TEMP_POINT2);
          for (var i = 1; i < zoomDiff; i++) {
              this._findChildTilesAt(children, pmin, pmax, layer, info.z + i);
          }
          return children;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._findChildTilesAt = function (children, pmin, pmax, layer, childZoom) {
          var layerId = layer.getId(), res = layer.getSpatialReference().getResolution(childZoom);
          if (!res) {
              return;
          }
          var dmin = layer._getTileConfig().getTileIndex(pmin, res), dmax = layer._getTileConfig().getTileIndex(pmax, res);
          var sx = Math.min(dmin.idx, dmax.idx), ex = Math.max(dmin.idx, dmax.idx);
          var sy = Math.min(dmin.idy, dmax.idy), ey = Math.max(dmin.idy, dmax.idy);
          var id, tile;
          for (var i = sx; i < ex; i++) {
              for (var ii = sy; ii < ey; ii++) {
                  id = layer._getTileId(i, ii, childZoom, layerId);
                  tile = this.tileCache.getAndRemove(id);
                  if (tile) {
                      if (this.isValidCachedTile(tile)) {
                          children.push(tile);
                          this.tileCache.add(id, tile);
                      }
                  }
              }
          }
      };
      TileLayerCanvasRenderer.prototype.findParentTile = function (info, targetDiff) {
          return this._findParentTile(info, targetDiff);
      };
      //@internal
      TileLayerCanvasRenderer.prototype._findParentTile = function (info, targetDiff) {
          var map = this.getMap(), layer = this._getLayerOfTile(info.layer);
          if (!layer || !layer.options['background'] && !layer.options['terrainTileMode']) {
              return null;
          }
          var minZoom = layer.getMinZoom();
          var zoomDiff = targetDiff || info.z - minZoom;
          if (layer._isPyramidMode()) {
              var endZoom = info.z - zoomDiff;
              for (var z = info.z - 1; z >= endZoom; z--) {
                  var diff = info.z - z;
                  var scale = Math.pow(2, diff);
                  var x = Math.floor(info.x / scale);
                  var y = Math.floor(info.y / scale);
                  var id = void 0;
                  if (z === info.z - 1) {
                      id = info.parent;
                  }
                  else {
                      id = layer._getTileId(x, y, z, info.layer);
                  }
                  var tile = this.tileCache.getAndRemove(id);
                  if (tile) {
                      if (this.isValidCachedTile(tile)) {
                          this.tileCache.add(id, tile);
                          return tile;
                      }
                  }
              }
              return null;
          }
          var sr = layer.getSpatialReference();
          // const zoomOffset = layer.options['zoomOffset'];
          var d = sr.getZoomDirection();
          var res = info.res;
          var center = info.extent2d.getCenter(), prj = layer._project(map._pointToPrjAtRes(center, res));
          for (var diff = 1; diff <= zoomDiff; diff++) {
              var z = info.z - d * diff;
              var res_1 = sr.getResolution(z);
              if (!res_1)
                  continue;
              var tileIndex = layer._getTileConfig().getTileIndex(prj, res_1);
              var id = layer._getTileId(tileIndex.x, tileIndex.y, z, info.layer);
              var tile = this.tileCache.getAndRemove(id);
              if (tile) {
                  this.tileCache.add(id, tile);
                  return tile;
              }
          }
          return null;
      };
      TileLayerCanvasRenderer.prototype.isValidCachedTile = function (tile) {
          return !!tile.image;
      };
      TileLayerCanvasRenderer.prototype.isTileComplete = function (tile) {
          return true;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._getLayerOfTile = function (layerId) {
          return this.layer.getChildLayer ? this.layer.getChildLayer(layerId) : this.layer;
      };
      TileLayerCanvasRenderer.prototype.getCachedTile = function (tile, isParent) {
          var tileId = tile.id;
          var tilesInView = this.tilesInView;
          var cached = this.tileCache.getAndRemove(tileId);
          if (cached) {
              if (!isParent) {
                  tilesInView[tileId] = cached;
              }
              var tilesLoading = this.tilesLoading;
              if (tilesLoading && tilesLoading[tileId]) {
                  this.markCurrent(tilesLoading[tileId], false);
                  var _a = tilesLoading[tileId], image = _a.image, info = _a.info;
                  this.abortTileLoading(image, info);
                  delete tilesLoading[tileId];
              }
          }
          else {
              cached = tilesInView[tileId];
          }
          if (cached) {
              cached.current = true;
              if (this.isValidCachedTile(cached)) {
                  this.tileCache.add(tileId, cached);
              }
          }
          return cached;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._addTileToCache = function (tileInfo, tileImage) {
          if (this.isValidCachedTile({ info: tileInfo, image: tileImage })) {
              var cached = {
                  image: tileImage,
                  info: tileInfo
              };
              this.tileCache.add(tileInfo.id, cached);
          }
      };
      TileLayerCanvasRenderer.prototype.getTileOpacity = function (tileImage, tileInfo) {
          var opacity = this._getTileFadingOpacity(tileImage);
          if (this.layer.getChildLayer) {
              // in GroupTileLayer
              var childLayer = this.layer.getLayer(tileInfo.layer);
              if (childLayer) {
                  opacity *= childLayer.options['opacity'];
              }
          }
          return opacity;
      };
      //@internal
      TileLayerCanvasRenderer.prototype._getTileFadingOpacity = function (tileImage) {
          if (!this.layer.options['fadeAnimation'] || !tileImage.loadTime) {
              return 1;
          }
          return Math.min(1, (now() - tileImage.loadTime) / this.layer.options['fadeDuration']);
      };
      TileLayerCanvasRenderer.prototype.onRemove = function () {
          this.clear();
          delete this.tileCache;
          delete this._tilePlaceHolder;
          delete this._tileZoom;
          _super.prototype.onRemove.call(this);
      };
      TileLayerCanvasRenderer.prototype.markCurrent = function (tile, isCurrent) {
          tile.current = isCurrent;
      };
      TileLayerCanvasRenderer.prototype.markTiles = function () {
          var a = 0, b = 0;
          if (this.tilesLoading) {
              for (var p in this.tilesLoading) {
                  this.markCurrent(this.tilesLoading[p], false);
                  a++;
              }
          }
          if (this.tilesInView) {
              for (var p in this.tilesInView) {
                  this.markCurrent(this.tilesInView[p], false);
                  b++;
              }
          }
          return [a, b];
      };
      TileLayerCanvasRenderer.prototype.retireTiles = function (force) {
          for (var i in this.tilesLoading) {
              var tile = this.tilesLoading[i];
              if (force || !tile.current) {
                  // abort loading tiles
                  if (tile.image) {
                      this.abortTileLoading(tile.image, tile.info);
                  }
                  this.deleteTile(tile);
                  this.removeTileLoading(tile.info);
              }
          }
          for (var i in this.tilesInView) {
              var tile = this.tilesInView[i];
              if (!tile.current) {
                  delete this.tilesInView[i];
                  if (!this.tileCache.has(i)) {
                      this.deleteTile(tile);
                  }
              }
          }
      };
      TileLayerCanvasRenderer.prototype.deleteTile = function (tile) {
          if (!tile || !tile.image) {
              return;
          }
          var tileId = tile.info.id;
          if (this._tileQueueIds.has(tileId)) {
              this._tileQueueIds.delete(tileId);
          }
          if (tile.image.close) {
              tile.image.close();
          }
          if (tile.image instanceof Image) {
              tile.image.onload = null;
              tile.image.onerror = null;
          }
      };
      //@internal
      TileLayerCanvasRenderer.prototype._generatePlaceHolder = function (res) {
          var map = this.getMap();
          var placeholder = this.layer.options['placeholder'];
          if (!placeholder || map.getPitch()) {
              return null;
          }
          var tileSize = this.layer.getTileSize();
          var scale = res / map._getResolution();
          var canvas = this._tilePlaceHolder = this._tilePlaceHolder || Canvas.createCanvas(1, 1, map.CanvasClass);
          canvas.width = tileSize.width * scale;
          canvas.height = tileSize.height * scale;
          if (isFunction(placeholder)) {
              placeholder(canvas);
          }
          else {
              defaultPlaceholder(canvas);
          }
          return canvas;
      };
      TileLayerCanvasRenderer.prototype.setTerrainHelper = function (helper) {
          this._terrainHelper = helper;
      };
      return TileLayerCanvasRenderer;
  }(CanvasRenderer$1));
  TileLayer.registerRenderer('canvas', TileLayerCanvasRenderer);
  function falseFn() { return false; }
  function defaultPlaceholder(canvas) {
      var ctx = canvas.getContext('2d'), cw = canvas.width, ch = canvas.height, w = cw / 16, h = ch / 16;
      ctx.beginPath();
      for (var i = 0; i < 16; i++) {
          ctx.moveTo(0, i * h);
          ctx.lineTo(cw, i * h);
          ctx.moveTo(i * w, 0);
          ctx.lineTo(i * w, ch);
      }
      ctx.strokeStyle = 'rgba(180, 180, 180, 0.1)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.beginPath();
      var path = [
          [0, 0], [cw, 0], [0, ch], [cw, ch], [0, 0], [0, ch], [cw, 0], [cw, ch], [0, ch / 2], [cw, ch / 2], [cw / 2, 0], [cw / 2, ch]
      ];
      for (var i = 1; i < path.length; i += 2) {
          ctx.moveTo(path[i - 1][0], path[i - 1][1]);
          ctx.lineTo(path[i][0], path[i][1]);
      }
      ctx.lineWidth = 1 * 4;
      ctx.stroke();
  }
  function compareTiles(a, b) {
      return Math.abs(this._tileZoom - a.info.z) - Math.abs(this._tileZoom - b.info.z);
  }

  var TILE_POINT = new Point(0, 0);
  var MESH_TO_TEST = { properties: {} };
  /**
   * 基于 HTML5 WebGL 的 TileLayers 渲染器
   *
   * @english
   * Renderer class based on HTML5 WebGL for TileLayers
   * @class
   * @protected
   * @group renderer
   * @extends {renderer.TileLayerCanvasRenderer}
   * @param layer - TileLayer to render
   */
  var TileLayerGLRenderer = /** @class */ (function (_super) {
      __extends(TileLayerGLRenderer, _super);
      function TileLayerGLRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      //override to set to always drawable
      TileLayerGLRenderer.prototype.isDrawable = function () {
          return true;
      };
      TileLayerGLRenderer.prototype.needToRedraw = function () {
          var map = this.getMap();
          if (this.isGL() && !map.getPitch() && map.isZooming() && !map.isMoving() && !map.isRotating()) {
              return true;
          }
          return _super.prototype.needToRedraw.call(this);
      };
      TileLayerGLRenderer.prototype.onDrawTileStart = function (context, parentContext) {
          var gl = this.gl;
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.enable(gl.POLYGON_OFFSET_FILL);
          gl.enable(gl.STENCIL_TEST);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          var depthMask = !!this.layer.options['depthMask'];
          gl.depthMask(depthMask);
          if (parentContext && parentContext.renderTarget) {
              var fbo = parentContext.renderTarget.fbo;
              if (fbo) {
                  var framebuffer = parentContext.renderTarget.getFramebuffer(fbo);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
              }
          }
      };
      TileLayerGLRenderer.prototype.onDrawTileEnd = function (context, parentContext) {
          var gl = this.gl;
          if (parentContext && parentContext.renderTarget) {
              var fbo = parentContext.renderTarget.fbo;
              if (fbo) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              }
          }
      };
      TileLayerGLRenderer.prototype.drawTile = function (tileInfo, tileImage, parentContext) {
          if (parentContext && parentContext.sceneFilter) {
              if (!parentContext.sceneFilter(MESH_TO_TEST)) {
                  return;
              }
          }
          var map = this.getMap();
          if (!tileInfo || !map || !tileImage) {
              return;
          }
          var scale = tileInfo._glScale = tileInfo._glScale || tileInfo.res / map.getGLRes();
          var w = tileInfo.extent2d.xmax - tileInfo.extent2d.xmin;
          var h = tileInfo.extent2d.ymax - tileInfo.extent2d.ymin;
          if (tileInfo.cache !== false) {
              this._bindGLBuffer(tileImage, w, h);
          }
          if (!this.isGL()) {
              // fall back to canvas 2D, which is faster
              _super.prototype.drawTile.call(this, tileInfo, tileImage);
              return;
          }
          var extent2d = tileInfo.extent2d, offset = tileInfo.offset;
          var point = TILE_POINT.set(extent2d.xmin - offset[0], tileInfo.extent2d.ymax - offset[1]);
          var x = point.x * scale, y = point.y * scale;
          var opacity = this.getTileOpacity(tileImage, tileInfo);
          var debugInfo = null;
          if (this.layer.options['debug']) {
              debugInfo = this.getDebugInfo(tileInfo.id);
          }
          var gl = this.gl;
          gl.stencilFunc(gl.LEQUAL, Math.abs(this.getCurrentTileZoom() - tileInfo.z), 0xFF);
          var layerPolygonOffset = this.layer.getPolygonOffset();
          var polygonOffset = this.drawingCurrentTiles ? layerPolygonOffset : layerPolygonOffset + 1;
          gl.polygonOffset(polygonOffset, polygonOffset);
          this.drawGLImage(tileImage, x, y, w, h, scale, opacity, debugInfo);
          if (this._getTileFadingOpacity(tileImage) < 1) {
              this.setToRedraw();
          }
          else {
              this.setCanvasUpdated();
          }
      };
      //@internal
      TileLayerGLRenderer.prototype._bindGLBuffer = function (image, w, h) {
          if (!image.glBuffer) {
              image.glBuffer = this.bufferTileData(0, 0, w, h);
          }
      };
      TileLayerGLRenderer.prototype.loadTileImage = function (tileImage, url) {
          // image must set cors in webgl
          var crossOrigin = this.layer.options['crossOrigin'];
          tileImage.crossOrigin = crossOrigin !== null ? crossOrigin : '';
          tileImage.src = url;
          return;
      };
      /**
       * prepare gl, create program, create buffers and fill unchanged data: image samplers, texture coordinates
       */
      TileLayerGLRenderer.prototype.onCanvasCreate = function () {
          //not in a GroupGLLayer
          if (!this.canvas.gl || !this.canvas.gl.wrap) {
              this.createCanvas2();
          }
      };
      TileLayerGLRenderer.prototype.createContext = function () {
          _super.prototype.createContext.call(this);
          this.createGLContext();
      };
      TileLayerGLRenderer.prototype.resizeCanvas = function (canvasSize) {
          if (!this.canvas) {
              return;
          }
          _super.prototype.resizeCanvas.call(this, canvasSize);
          this.resizeGLCanvas();
      };
      TileLayerGLRenderer.prototype.clearCanvas = function () {
          if (!this.canvas) {
              return;
          }
          _super.prototype.clearCanvas.call(this);
          this.clearGLCanvas();
      };
      TileLayerGLRenderer.prototype.getCanvasImage = function () {
          if (!this.isGL() || !this.canvas2) {
              return _super.prototype.getCanvasImage.call(this);
          }
          var img = _super.prototype.getCanvasImage.call(this);
          if (img) {
              img.image = this.canvas2;
          }
          return img;
      };
      /**
       * decide whether the layer is renderer with gl.
       * when map is pitching, or fragmentShader is set in options
       */
      TileLayerGLRenderer.prototype.isGL = function () {
          if (this.canvas.gl && this.canvas.gl.wrap) {
              //in GroupGLLayer
              return true;
          }
          var map = this.getMap();
          return (map && (map.getPitch() || map.getBearing()) || this.layer && !!this.layer.options['fragmentShader']);
      };
      TileLayerGLRenderer.prototype.deleteTile = function (tile) {
          _super.prototype.deleteTile.call(this, tile);
          if (tile && tile.image) {
              this.disposeImage(tile.image);
          }
          delete tile.image;
      };
      TileLayerGLRenderer.prototype.onRemove = function () {
          _super.prototype.onRemove.call(this);
          this.removeGLCanvas();
      };
      return TileLayerGLRenderer;
  }(ImageGLRenderable(TileLayerCanvasRenderer)));
  TileLayer.registerRenderer('gl', TileLayerGLRenderer);

  function loadTile(tile) {
      var _this = this;
      var tileSize = this.layer.getTileSize();
      var canvasClass = this.canvas.constructor;
      var map = this.getMap();
      var r = map.getDevicePixelRatio();
      var tileCanvas = Canvas.createCanvas(tileSize['width'] * r, tileSize['height'] * r, canvasClass);
      tileCanvas['layer'] = this.layer;
      var point = new Point(tile['extent2d'].xmin, tile['extent2d'].ymax);
      var extent = new Extent(map.pointToCoordinate(point), map.pointToCoordinate(point.add(tileSize.width, tileSize.height)), map.getProjection());
      this.layer.drawTile(tileCanvas, {
          'url': tile['url'],
          'point': point,
          'center': map.pointToCoordinate(point.add(tileSize['width'] / 2, tileSize['height'] / 2)),
          'extent': extent,
          'z': tile['z'],
          'x': tile['x'],
          'y': tile['y']
      }, function (error) {
          if (error) {
              _this.onTileError(tileCanvas, tile);
              return;
          }
          _this.onTileLoad(tileCanvas, tile);
      });
      return tileCanvas;
  }
  var CanvasRenderer = /** @class */ (function (_super) {
      __extends(CanvasRenderer, _super);
      function CanvasRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasRenderer.prototype.loadTile = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return loadTile.apply(this, args);
      };
      return CanvasRenderer;
  }(TileLayerCanvasRenderer));
  var GLRenderer = /** @class */ (function (_super) {
      __extends(GLRenderer, _super);
      function GLRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      GLRenderer.prototype.loadTile = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return loadTile.apply(this, args);
      };
      return GLRenderer;
  }(TileLayerGLRenderer));
  CanvasTileLayer.registerRenderer('canvas', CanvasRenderer);
  CanvasTileLayer.registerRenderer('gl', GLRenderer);

  var quadVertices = typeof Int8Array !== 'undefined' ? new Int8Array([
      // positions
      -1, 1, 0,
      -1, -1, 0,
      1, 1, 0,
      1, -1, 0,
  ]) : [];
  var vert = "\n    attribute vec3 a_position;\n    uniform mat4 transform;\n\n    void main()\n    {\n        gl_Position = transform * vec4(a_position, 1.0);\n    }\n";
  var frag = "\n    precision mediump float;\n    uniform vec3 color;\n    void main()\n    {\n        gl_FragColor = vec4(color, 1.0);\n    }\n";
  var QuadStencil = /** @class */ (function () {
      function QuadStencil(gl, vertices, debug) {
          this.gl = gl;
          this.quadVertices = vertices || quadVertices;
          this.attributes = ['a_position', 3, getType(vertices)];
          this.debug = debug;
      }
      QuadStencil.prototype.start = function () {
          var gl = this.gl;
          gl.enable(gl.STENCIL_TEST);
          gl.stencilMask(0xFF);
          gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
          gl.depthMask(false);
          this._save();
          if (!this.buffer) {
              this._createBuffer();
              this._createProgram();
          }
          gl.useProgram(this.program);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
          enableVertexAttrib(gl, this.program, this.attributes);
          if (!this.transformLoc) {
              this.transformLoc = gl.getUniformLocation(this.program, 'transform');
          }
          if (!this.colorLoc) {
              this.colorLoc = gl.getUniformLocation(this.program, 'color');
          }
          if (this.debug) {
              return;
          }
          gl.colorMask(false, false, false, false);
      };
      QuadStencil.prototype.end = function () {
          var gl = this.gl;
          gl.depthMask(true);
          this._restore();
          if (this.debug) {
              return;
          }
          gl.colorMask(true, true, true, true);
      };
      QuadStencil.prototype.draw = function (transform) {
          var gl = this.gl;
          gl.uniformMatrix4fv(this.transformLoc, false, transform);
          gl.uniform3fv(this.colorLoc, [Math.random(), Math.random(), Math.random()]);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      };
      QuadStencil.prototype.remove = function () {
          var gl = this.gl;
          if (this.buffer) {
              gl.deleteBuffer(this.buffer);
          }
          if (this.program) {
              gl.deleteShader(this.program.fragmentShader);
              gl.deleteShader(this.program.vertexShader);
              gl.deleteProgram(this.program);
          }
          delete this.transformLoc;
          delete this.gl;
          return this;
      };
      QuadStencil.prototype.stencilMask = function (mask) {
          this.gl.stencilMask(mask);
          return this;
      };
      QuadStencil.prototype.stencilFunc = function (func, ref, mask) {
          this.ref = ref;
          this.gl.stencilFunc(func, ref, mask);
          return this;
      };
      QuadStencil.prototype.stencilOp = function (fail, zfail, zpass) {
          this.gl.stencilOp(fail, zfail, zpass);
          return this;
      };
      QuadStencil.prototype.resetFunc = function () {
          this.ref = 1;
          this.gl.stencilFunc(this.gl.ALWAYS, 1, 0xFF);
          return this;
      };
      //@internal
      QuadStencil.prototype._save = function () {
          var gl = this.gl;
          this._savedProgram = gl.program;
      };
      //@internal
      QuadStencil.prototype._restore = function () {
          var gl = this.gl;
          gl.program = this._savedProgram;
          if (gl.program) {
              gl.useProgram(gl.program);
          }
      };
      //@internal
      QuadStencil.prototype._createBuffer = function () {
          var gl = this.gl;
          this.buffer = gl.createBuffer();
          if (!this.buffer) {
              throw new Error('Failed to create the buffer object');
          }
          gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, this.quadVertices, gl.STATIC_DRAW);
      };
      //@internal
      QuadStencil.prototype._createProgram = function () {
          var _a = createProgram(this.gl, vert, frag), program = _a.program, vertexShader = _a.vertexShader, fragmentShader = _a.fragmentShader;
          program.vertexShader = vertexShader;
          program.fragmentShader = fragmentShader;
          this.program = program;
      };
      return QuadStencil;
  }());
  function getType(arr) {
      if (arr instanceof Float32Array) {
          return 'FLOAT';
      }
      else if (arr instanceof Int16Array) {
          return 'SHORT';
      }
      else if (arr instanceof Uint16Array) {
          return 'UNSIGNED_SHORT';
      }
      else if (arr instanceof Int8Array) {
          return 'BYTE';
      }
      else if (arr instanceof Uint8Array || arr instanceof Uint8ClampedArray) {
          return 'UNSIGNED_BYTE';
      }
      return 'FLOAT';
  }

  /**
   * OverlayLayer 的父呈现器类，供 OverlayLayer 的子类继承。
   *
   * @english
   *
   * A parent renderer class for OverlayLayer to inherit by OverlayLayer's subclasses.
   * @protected
   * @memberOf renderer
   * @name OverlayLayerCanvasRenderer
   * @extends renderer.CanvasRenderer
   */
  var OverlayLayerRenderer = /** @class */ (function (_super) {
      __extends(OverlayLayerRenderer, _super);
      function OverlayLayerRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @english
       * possible memory leaks:
       * 1. if geometries' symbols with external resources change frequently,
       * resources of old symbols will still be stored.
       * 2. removed geometries' resources won't be removed.
       */
      OverlayLayerRenderer.prototype.checkResources = function () {
          var geometries = this._geosToCheck || [];
          if (!this._resourceChecked && this.layer._geoList) {
              pushIn(geometries, this.layer._geoList);
          }
          if (!isArrayHasData(geometries)) {
              return [];
          }
          var resources = [];
          var cache = {};
          for (var i = geometries.length - 1; i >= 0; i--) {
              var geo = geometries[i];
              var res = geo._getExternalResources();
              if (!res.length) {
                  continue;
              }
              if (!this.resources) {
                  // @tip 解构会有一定的性能影响，对于少量数据是否可以忽略
                  resources.push.apply(resources, __spreadArray([], __read(res), false));
              }
              else {
                  for (var i_1 = 0; i_1 < res.length; i_1++) {
                      var url = res[i_1][0];
                      if (!this.resources.isResourceLoaded(res[i_1]) && !cache[url]) {
                          resources.push(res[i_1]);
                          cache[url] = 1;
                      }
                  }
              }
          }
          this._resourceChecked = true;
          delete this._geosToCheck;
          return resources;
      };
      OverlayLayerRenderer.prototype.render = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          this.layer._sortGeometries();
          return _super.prototype.render.apply(this, args);
      };
      //@internal
      OverlayLayerRenderer.prototype._addGeoToCheckRes = function (res) {
          if (!res) {
              return;
          }
          if (!Array.isArray(res)) {
              res = [res];
          }
          if (!this._geosToCheck) {
              this._geosToCheck = [];
          }
          pushIn(this._geosToCheck, res);
      };
      OverlayLayerRenderer.prototype.onGeometryAdd = function (geometries) {
          this._addGeoToCheckRes(geometries);
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryRemove = function (params) {
          redraw(this);
      };
      OverlayLayerRenderer.prototype.onGeometrySymbolChange = function (e) {
          this._addGeoToCheckRes(e.target);
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryShapeChange = function (params) {
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryPositionChange = function (params) {
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryZIndexChange = function (params) {
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryShow = function (params) {
          redraw(this);
      };
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      OverlayLayerRenderer.prototype.onGeometryHide = function (params) {
          redraw(this);
      };
      OverlayLayerRenderer.prototype.onGeometryPropertiesChange = function (_) {
          redraw(this);
      };
      return OverlayLayerRenderer;
  }(CanvasRenderer$1));
  function redraw(renderer) {
      if (renderer.layer.options['drawImmediate']) {
          renderer.render();
      }
      renderer.setToRedraw();
  }

  var TEMP_EXTENT = new PointExtent();
  var TEMP_VEC3 = [];
  var TEMP_FIXEDEXTENT = new PointExtent();
  var PLACEMENT_CENTER = 'center';
  var tempCollisionIndex$1 = new CollisionIndex();
  function clearCanvas(canvas) {
      if (!canvas) {
          return null;
      }
      var ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      return ctx;
  }
  function isDebug(layer) {
      return layer && layer.options.progressiveRender && layer.options.progressiveRenderDebug;
  }
  /**
   * 基于 `HTML5 Canvas2D` 的渲染器类，用于矢量层
   *
   * @english
   * Renderer class based on HTML5 Canvas2D for VectorLayers
   * @protected
   * @group renderer
   * @name VectorLayerCanvasRenderer
   * @extends renderer.OverlaylayerCanvasRenderer
   * @param layer - layer to render
   */
  var VectorLayerRenderer = /** @class */ (function (_super) {
      __extends(VectorLayerRenderer, _super);
      function VectorLayerRenderer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      VectorLayerRenderer.prototype.setToRedraw = function () {
          _super.prototype.setToRedraw.call(this);
          this._resetProgressiveRender();
          return this;
      };
      //@internal
      VectorLayerRenderer.prototype._geoIsCollision = function (geo, collisionIndex) {
          if (!geo) {
              return false;
          }
          var collision = geo.options.collision;
          if (!collision) {
              return false;
          }
          // const type = geo.getType();
          if (geo.isPoint && geo.getContainerExtent) {
              if (!geo.bbox) {
                  geo.bbox = [0, 0, 0, 0];
              }
              var bufferSize = this.layer.options['collisionBufferSize'];
              var extent = geo.getContainerExtent();
              if (!extent) {
                  return false;
              }
              geo.bbox[0] = extent.xmin - bufferSize;
              geo.bbox[1] = extent.ymin - bufferSize;
              geo.bbox[2] = extent.xmax + bufferSize;
              geo.bbox[3] = extent.ymax + bufferSize;
              if (collisionIndex.collides(geo.bbox)) {
                  return true;
              }
              collisionIndex.insertBox(geo.bbox);
          }
          return false;
      };
      VectorLayerRenderer.prototype.getImageData = function () {
          //如果不开启geometry event 或者 渲染频率很高 不要取缓存了，因为getImageData是个很昂贵的操作
          if ((!this._lastRenderTime) || (now() - this._lastRenderTime) < 32) {
              return null;
          }
          if (!this.context || !this.context.canvas) {
              return null;
          }
          if (!this._imageData) {
              var _a = this.context.canvas, width = _a.width, height = _a.height;
              try {
                  this._imageData = this.context.getImageData(0, 0, width, height);
              }
              catch (error) {
                  console.warn('hit detect failed with tainted canvas, some geometries have external resources in another domain:\n', error);
              }
          }
          return this._imageData;
      };
      VectorLayerRenderer.prototype.clearImageData = function () {
          //每次渲染完成清除缓存的imageData
          this._imageData = null;
          delete this._imageData;
          this._lastRenderTime = now();
      };
      VectorLayerRenderer.prototype.checkResources = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var resources = _super.prototype.checkResources.apply(this, args);
          var style = this.layer.getStyle();
          if (style) {
              if (!Array.isArray(style)) {
                  style = [style];
              }
              style.forEach(function (s) {
                  var res = getExternalResources(s['symbol'], true);
                  for (var i = 0, l = res.length; i < l; i++) {
                      if (!_this.resources.isResourceLoaded(res[i])) {
                          resources.push(res[i]);
                      }
                  }
              });
          }
          return resources;
      };
      VectorLayerRenderer.prototype.needToRedraw = function () {
          if (this.isProgressiveRender() && !this.renderEnd) {
              return true;
          }
          var map = this.getMap();
          if (map.isInteracting() && this.layer.options['enableAltitude']) {
              return true;
          }
          // don't redraw when map is zooming without pitch and layer doesn't have any point symbolizer.
          if (map.isZooming() && !map.isRotating() && !map.getPitch() && !this._hasPoint && this.layer.constructor === VectorLayer) {
              return false;
          }
          return _super.prototype.needToRedraw.call(this);
      };
      /**
       * render layer
       */
      VectorLayerRenderer.prototype.draw = function () {
          if (!this.getMap()) {
              return;
          }
          if (!this.layer.isVisible() || this.layer.isEmpty()) {
              this.clearCanvas();
              this.completeRender();
              return;
          }
          this.prepareCanvas();
          this.drawGeos();
          this.completeRender();
      };
      VectorLayerRenderer.prototype.isBlank = function () {
          if (!this.context) {
              return false;
          }
          if (this.isProgressiveRender()) {
              return false;
          }
          return !this.context.canvas._drawn;
      };
      VectorLayerRenderer.prototype.drawOnInteracting = function () {
          if (!this._geosToDraw) {
              return;
          }
          this._updateMapStateCache();
          this._updateDisplayExtent();
          var map = this.getMap();
          //refresh geometries on zooming
          var count = this.layer.getCount();
          var res = this.mapStateCache.resolution;
          if (map.isZooming() &&
              map.options['seamlessZoom'] && this._drawnRes !== undefined && res > this._drawnRes * 1.5 &&
              this._geosToDraw.length < count || map.isMoving() || map.isInteracting()) {
              this.prepareToDraw();
              this._batchConversionMarkers(this.mapStateCache.glRes);
              if (!this._onlyHasPoint) {
                  this._checkGeos();
              }
              this._drawnRes = res;
          }
          this._sortByDistanceToCamera(map.cameraPosition);
          var _a = this.layer.options, collision = _a.collision, collisionDelay = _a.collisionDelay;
          if (collision) {
              var time = now();
              if (!this._lastCollisionTime) {
                  this._lastCollisionTime = time;
              }
              if (time - this._lastCollisionTime <= collisionDelay) {
                  this._geosToDraw = this._lastGeosToDraw || this._geosToDraw;
              }
              else {
                  this._collidesGeos();
                  this._lastCollisionTime = time;
              }
          }
          for (var i = 0, l = this._geosToDraw.length; i < l; i++) {
              var geo = this._geosToDraw[i];
              if (!geo._isCheck) {
                  if (!geo.isVisible()) {
                      delete geo._cPoint;
                      delete geo._inCurrentView;
                      continue;
                  }
              }
              geo._paint(this._displayExtent);
              // https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html
              // https://juejin.cn/post/6972702293636415519
              this._geosToDraw[i]._cPoint = undefined;
              this._geosToDraw[i]._inCurrentView = undefined;
          }
          this.clearImageData();
          this._lastGeosToDraw = this._geosToDraw;
          if (isDebug(this.layer)) {
              console.log('progressiveRender on drawOnInteracting page:', this.page);
          }
      };
      /**
       * Show and render
       * @override
       */
      VectorLayerRenderer.prototype.show = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          this.layer.forEach(function (geo) {
              geo._repaint();
          });
          _super.prototype.show.apply(this, args);
      };
      VectorLayerRenderer.prototype.forEachGeo = function (fn, context) {
          this.layer.forEach(fn, context);
      };
      //@internal
      VectorLayerRenderer.prototype._checkGeos = function () {
          var geos = this._getCurrentNeedRenderGeos();
          for (var i = 0, len = geos.length; i < len; i++) {
              this.checkGeo(geos[i]);
          }
          return this;
      };
      VectorLayerRenderer.prototype.drawGeos = function () {
          this._drawSnapshot();
          this._updateMapStateCache();
          this._drawnRes = this.mapStateCache.resolution;
          this._updateDisplayExtent();
          this.prepareToDraw();
          this._batchConversionMarkers(this.mapStateCache.glRes);
          if (!this._onlyHasPoint) {
              this._checkGeos();
          }
          this._sortByDistanceToCamera(this.getMap().cameraPosition);
          this._collidesGeos();
          for (var i = 0, len = this._geosToDraw.length; i < len; i++) {
              this._geosToDraw[i]._paint();
              this._geosToDraw[i]._cPoint = undefined;
              this._geosToDraw[i]._inCurrentView = undefined;
          }
          this.clearImageData();
          this._lastGeosToDraw = this._geosToDraw;
          if (isDebug(this.layer)) {
              console.log('progressiveRender drawGeos page:', this.page);
          }
          this._snapshot();
          this._setDrawGeosDrawTime();
      };
      VectorLayerRenderer.prototype.prepareToDraw = function () {
          this.layer._drawTime = now();
          this._hasPoint = false;
          this._geosToDraw = [];
          return this;
      };
      //@internal
      VectorLayerRenderer.prototype._setDrawGeosDrawTime = function () {
          var time = now();
          var drawTime = this.layer._drawTime;
          var painterList = this.getGeoPainterList();
          for (var i = 0, len = painterList.length; i < len; i++) {
              var painter = painterList[i];
              if (painter && painter._setDrawTime) {
                  painter._setDrawTime(drawTime);
              }
          }
          if (isDebug(this.layer)) {
              console.log('_setDrawGeosDrawTime time:', (now() - time) + 'ms');
          }
          return this;
      };
      VectorLayerRenderer.prototype.checkGeo = function (geo) {
          //点的话已经在批量处理里判断过了
          if (geo.isPoint && this._onlyHasPoint !== undefined) {
              if (geo._inCurrentView || geo.hasAltitude()) {
                  this._hasPoint = true;
                  geo._isCheck = true;
                  this._geosToDraw.push(geo);
              }
              return;
          }
          // LineString ,Polygon,Circle etc
          geo._isCheck = false;
          if (!geo || !geo.isVisible() || !geo.getMap() ||
              !geo.getLayer() || (!geo.getLayer().isCanvasRender())) {
              return;
          }
          var painter = geo._getPainter();
          var inCurrentView = true;
          if (geo._inCurrentView || !isNil(geo.options.arcDegree) || geo.hasAltitude()) {
              inCurrentView = true;
          }
          else if (geo._inCurrentView === false) {
              inCurrentView = false;
          }
          else {
              var extent2D = painter.get2DExtent(this.resources, TEMP_EXTENT);
              if (!extent2D || !extent2D.intersects(this._displayExtent)) {
                  inCurrentView = false;
              }
          }
          if (!inCurrentView) {
              return;
          }
          if (painter.hasPoint()) {
              this._hasPoint = true;
          }
          geo._isCheck = true;
          this._geosToDraw.push(geo);
      };
      //@internal
      VectorLayerRenderer.prototype._collidesGeos = function () {
          var collision = this.layer.options['collision'];
          if (!collision) {
              return this;
          }
          var collisionScope = this.layer.options['collisionScope'];
          var map = this.layer.getMap();
          var collisionIndex = collisionScope === 'map' ? map.getCollisionIndex() : tempCollisionIndex$1;
          if (collisionIndex === tempCollisionIndex$1) {
              collisionIndex.clear();
          }
          var geos = this._geosToDraw;
          this._geosToDraw = [];
          for (var i = 0, len = geos.length; i < len; i++) {
              if (this._geoIsCollision(geos[i], collisionIndex)) {
                  continue;
              }
              this._geosToDraw.push(geos[i]);
          }
          return this;
      };
      VectorLayerRenderer.prototype.onZoomEnd = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          delete this.canvasExtent2D;
          _super.prototype.onZoomEnd.apply(this, args);
      };
      VectorLayerRenderer.prototype.onRemove = function () {
          this.forEachGeo(function (g) {
              g.onHide();
          });
          delete this._geosToDraw;
          delete this.snapshotCanvas;
          delete this.pageGeos;
          delete this.geoPainterList;
      };
      VectorLayerRenderer.prototype.onGeometryPropertiesChange = function (param) {
          if (param) {
              this.layer._styleGeometry(param['target']);
          }
          _super.prototype.onGeometryPropertiesChange.call(this, param);
      };
      //@internal
      VectorLayerRenderer.prototype._updateDisplayExtent = function () {
          var extent2D = this.canvasExtent2D;
          if (this._maskExtent) {
              if (!this._maskExtent.intersects(extent2D)) {
                  this.completeRender();
                  return;
              }
              extent2D = extent2D.intersection(this._maskExtent);
          }
          this._displayExtent = extent2D;
      };
      VectorLayerRenderer.prototype.identifyAtPoint = function (point, options) {
          if (options === void 0) { options = {}; }
          var geometries = this.getGeosForIdentify();
          if (!geometries) {
              return [];
          }
          return this.layer._hitGeos(geometries, point, options);
      };
      //@internal
      VectorLayerRenderer.prototype._updateMapStateCache = function () {
          var map = this.getMap();
          var offset = map._pointToContainerPoint(this.middleWest)._add(0, -map.height / 2);
          var resolution = map.getResolution();
          var pitch = map.getPitch();
          var bearing = map.getBearing();
          var glScale = map.getGLScale();
          var glRes = map.getGLRes();
          var containerExtent = map.getContainerExtent();
          var _2DExtent = map.get2DExtent();
          var glExtent = map.get2DExtentAtRes(glRes);
          this.mapStateCache = {
              resolution: resolution,
              pitch: pitch,
              bearing: bearing,
              glScale: glScale,
              glRes: glRes,
              //@internal
              _2DExtent: _2DExtent,
              glExtent: glExtent,
              containerExtent: containerExtent,
              offset: offset
          };
          return this;
      };
      /**
       * 使用批量坐标转换提升性能
       * 优化前 11fps
       * 优化后 15fps
       * Better performance of batch coordinate conversion
       * @param glRes
       */
      //@internal
      VectorLayerRenderer.prototype._batchConversionMarkers = function (glRes) {
          this._onlyHasPoint = undefined;
          if (!this._constructorIsThis()) {
              return [];
          }
          var cPoints = [];
          var markers = [];
          var altitudes = [];
          var altitudeCache = {};
          var layer = this.layer;
          var layerOpts = layer.options;
          var layerAltitude = layer.getAltitude ? layer.getAltitude() : 0;
          var isCanvasRender = layer.isCanvasRender();
          this._onlyHasPoint = true;
          //Traverse all Geo
          var idx = 0;
          var geos = this._getCurrentNeedRenderGeos();
          for (var i = 0, len = geos.length; i < len; i++) {
              var geo = geos[i];
              // const type = geo.getType();
              if (geo.isPoint) {
                  var painter = geo._painter;
                  if (!painter) {
                      painter = geo._getPainter();
                  }
                  var point = painter.getRenderPoints(PLACEMENT_CENTER)[0][0];
                  var altitude = layerOpts['enableAltitude'] ? geo._getAltitude() : layerAltitude;
                  //减少方法的调用
                  if (altitudeCache[altitude] === undefined) {
                      altitudeCache[altitude] = painter.getAltitude();
                  }
                  cPoints[idx] = point;
                  altitudes[idx] = altitudeCache[altitude];
                  markers[idx] = geo;
                  idx++;
              }
              else {
                  this._onlyHasPoint = false;
              }
          }
          if (idx === 0) {
              return [];
          }
          var map = this.getMap();
          var pts = getPointsResultPts(cPoints, '_pt');
          pts = map._pointsAtResToContainerPoints(cPoints, glRes, altitudes, pts);
          var containerExtent = map.getContainerExtent();
          var xmax = containerExtent.xmax, ymax = containerExtent.ymax, xmin = containerExtent.xmin, ymin = containerExtent.ymin;
          var extentCache = {};
          for (var i = 0, len = markers.length; i < len; i++) {
              var geo = markers[i];
              geo._cPoint = pts[i];
              if (!geo._cPoint) {
                  geo._inCurrentView = false;
                  continue;
              }
              var _a = pts[i], x = _a.x, y = _a.y;
              //Is the point in view
              geo._inCurrentView = (x >= xmin && y >= ymin && x <= xmax && y <= ymax) || geo.hasAltitude();
              //不在视野内的，再用fixedExtent 精确判断下
              if (!geo._inCurrentView) {
                  var symbolkey = geo.getSymbolHash();
                  var fixedExtent = void 0;
                  if (symbolkey) {
                      //相同的symbol 不要重复计算
                      fixedExtent = extentCache[symbolkey] = (extentCache[symbolkey] || geo._painter.getFixedExtent());
                  }
                  else {
                      fixedExtent = geo._painter.getFixedExtent();
                  }
                  TEMP_FIXEDEXTENT.set(fixedExtent.xmin, fixedExtent.ymin, fixedExtent.xmax, fixedExtent.ymax);
                  TEMP_FIXEDEXTENT._add(pts[i]);
                  geo._inCurrentView = TEMP_FIXEDEXTENT.intersects(containerExtent);
              }
              if (geo._inCurrentView) {
                  if (!geo.isVisible() || !isCanvasRender) {
                      geo._inCurrentView = false;
                  }
                  //如果当前图层上只有点，整个checkGeo都不用执行了,这里已经把所有的点都判断了
                  if (this._onlyHasPoint && geo._inCurrentView) {
                      this._hasPoint = true;
                      geo._isCheck = true;
                      this._geosToDraw.push(geo);
                  }
              }
          }
          return pts;
      };
      //@internal
      VectorLayerRenderer.prototype._sortByDistanceToCamera = function (cameraPosition) {
          if (!this.layer.options['sortByDistanceToCamera']) {
              return;
          }
          if (!this._geosToDraw.length) {
              return;
          }
          var map = this.getMap();
          var p = map.distanceToPoint(1000, 0, map.getGLScale()).x;
          var meterScale = p / 1000;
          var placement = 'center';
          this._geosToDraw.sort(function (a, b) {
              // const type0 = a.getType();
              // const type1 = b.getType();
              if (!a.isPoint || !b.isPoint) {
                  return 0;
              }
              var painter0 = a._painter;
              var painter1 = b._painter;
              if (!painter0 || !painter1) {
                  return 0;
              }
              var point0 = painter0.getRenderPoints(placement)[0][0];
              var point1 = painter1.getRenderPoints(placement)[0][0];
              var alt0 = painter0.getAltitude() * meterScale;
              var alt1 = painter1.getAltitude() * meterScale;
              set(TEMP_VEC3, point0.x, point0.y, alt0);
              var dist0 = distance(TEMP_VEC3, cameraPosition);
              set(TEMP_VEC3, point1.x, point1.y, alt1);
              var dist1 = distance(TEMP_VEC3, cameraPosition);
              return dist1 - dist0;
          });
      };
      //@internal
      VectorLayerRenderer.prototype._constructorIsThis = function () {
          return this.constructor === VectorLayerRenderer;
      };
      VectorLayerRenderer.prototype.isProgressiveRender = function () {
          var layer = this.layer;
          if (!layer) {
              return false;
          }
          var _a = layer.options || {}, progressiveRender = _a.progressiveRender, collision = _a.collision;
          if (collision) {
              return false;
          }
          return progressiveRender;
      };
      VectorLayerRenderer.prototype.getGeosForIdentify = function () {
          if (!this.isProgressiveRender()) {
              return this._geosToDraw || [];
          }
          return this.pageGeos || [];
      };
      VectorLayerRenderer.prototype.getGeoPainterList = function () {
          if (!this.isProgressiveRender()) {
              var list = [];
              var geos = this._geosToDraw || [];
              for (var i = 0, len = geos.length; i < len; i++) {
                  list.push(geos[i]._painter);
              }
              return list;
          }
          return this.geoPainterList || [];
      };
      //@internal
      VectorLayerRenderer.prototype._checkSnapshotCanvas = function () {
          if (!this.isProgressiveRender()) {
              delete this.snapshotCanvas;
              return null;
          }
          var canvas = this.canvas;
          if (!canvas) {
              delete this.snapshotCanvas;
              return null;
          }
          if (!this.snapshotCanvas) {
              this.snapshotCanvas = Canvas.createCanvas(1, 1);
          }
          var snapshotCanvas = this.snapshotCanvas;
          var width = canvas.width, height = canvas.height, style = canvas.style;
          if (snapshotCanvas.width !== width || snapshotCanvas.height !== height) {
              snapshotCanvas.width = width;
              snapshotCanvas.height = height;
          }
          if (snapshotCanvas.style.width !== style.width || snapshotCanvas.style.height !== style.height) {
              snapshotCanvas.style.width = style.width;
              snapshotCanvas.style.height = style.height;
          }
          return snapshotCanvas;
      };
      //@internal
      VectorLayerRenderer.prototype._getCurrentNeedRenderGeos = function () {
          var geos = this.layer._geoList || [];
          if (!this.isProgressiveRender()) {
              return geos;
          }
          // if (this.renderEnd) {
          //     return [];
          // }
          var layer = this.layer;
          var progressiveRenderCount = layer.options.progressiveRenderCount;
          var pageSize = progressiveRenderCount;
          var page = this.page;
          var start = (page - 1) * pageSize, end = page * pageSize;
          var pageGeos = geos.slice(start, end);
          return pageGeos;
      };
      //@internal
      VectorLayerRenderer.prototype._resetProgressiveRender = function () {
          if (isDebug(this.layer)) {
              console.log('progressiveRender resetProgressiveRender');
          }
          this.renderEnd = false;
          this.page = 1;
          this.pageGeos = [];
          this.geoPainterList = [];
          this.maxTolerance = 0;
          this._clearSnapshotCanvas();
      };
      //@internal
      VectorLayerRenderer.prototype._clearSnapshotCanvas = function () {
          var snapshotCanvas = this._checkSnapshotCanvas();
          if (snapshotCanvas) {
              clearCanvas(snapshotCanvas);
          }
      };
      //@internal
      VectorLayerRenderer.prototype._snapshot = function () {
          var progressiveRender = this.isProgressiveRender();
          var geosToDraw = this._geosToDraw || [];
          for (var i = 0, len = geosToDraw.length; i < len; i++) {
              var geo = geosToDraw[i];
              var t = geo._hitTestTolerance() || 0;
              this.maxTolerance = Math.max(this.maxTolerance, t);
              if (progressiveRender) {
                  this.pageGeos.push(geo);
                  var painter = geo._painter;
                  this.geoPainterList.push(painter);
              }
          }
          if (!progressiveRender) {
              return this;
          }
          var time = now();
          var snapshotCanvas = this._checkSnapshotCanvas();
          if (snapshotCanvas && this.canvas) {
              var ctx = clearCanvas(snapshotCanvas);
              ctx.drawImage(this.canvas, 0, 0);
          }
          var layer = this.layer;
          var progressiveRenderCount = layer.options.progressiveRenderCount;
          var geos = layer._geoList || [];
          var pages = Math.ceil(geos.length / progressiveRenderCount);
          this.renderEnd = this.page >= pages;
          if (this.renderEnd) {
              this._setDrawGeosDrawTime();
          }
          if (isDebug(this.layer)) {
              console.log('snapshot time:', (now() - time) + 'ms');
          }
          if (!this.renderEnd) {
              this.page++;
          }
          return this;
      };
      //@internal
      VectorLayerRenderer.prototype._drawSnapshot = function () {
          if (!this.isProgressiveRender()) {
              return this;
          }
          var _a = this, snapshotCanvas = _a.snapshotCanvas, context = _a.context;
          if (!snapshotCanvas || !context) {
              return this;
          }
          var map = this.getMap();
          if (!map) {
              return this;
          }
          var dpr = map.getDevicePixelRatio() || 1;
          var rScale = 1 / dpr;
          this._canvasContextScale(context, rScale);
          context.drawImage(snapshotCanvas, 0, 0);
          this._canvasContextScale(context, dpr);
          return this;
      };
      return VectorLayerRenderer;
  }(OverlayLayerRenderer));
  VectorLayer.registerRenderer('canvas', VectorLayerRenderer);

  /**
   * 所有地图渲染器的基类。
   * @english
   * Base class for all the map renderers.
   * @abstract
   * @protected
   * @memberOf renderer
   * @extends {Class}
   */
  var MapRenderer = /** @class */ (function (_super) {
      __extends(MapRenderer, _super);
      function MapRenderer(map) {
          var _this = _super.call(this) || this;
          _this.map = map;
          _this._handlerQueue = [];
          _this._thisDocVisibilitychange = _this._onDocVisibilitychange.bind(_this);
          _this._thisDocDragStart = _this._onDocDragStart.bind(_this);
          _this._thisDocDragEnd = _this._onDocDragEnd.bind(_this);
          _this._thisDocDPRChange = _this._onDocDPRChange.bind(_this);
          return _this;
      }
      MapRenderer.prototype.callInNextFrame = function (fn) {
          this._handlerQueue.push(fn);
      };
      MapRenderer.prototype.executeFrameCallbacks = function () {
          var running = this._handlerQueue;
          this._handlerQueue = [];
          for (var i = 0, l = running.length; i < l; i++) {
              running[i]();
          }
      };
      /**
       * Move map platform with offset
       * @param offset
       * @param force
       */
      MapRenderer.prototype.offsetPlatform = function (offset, force) {
          if (!this.map.getPanels().front) {
              return this;
          }
          if (!force && offset.x === 0 && offset.y === 0) {
              return this;
          }
          var panels = this.map.getPanels();
          var hasFront = this._frontCount = panels.back.layerDOM.childElementCount;
          var hasBack = this._backCount = panels.front.layerDOM.childElementCount;
          var hasUI = this._uiCount = panels.front.uiDOM.childElementCount;
          if (hasFront || hasBack || hasUI) {
              var pos = this.map.offsetPlatform();
              if (offset) {
                  pos = pos.add(offset)._round();
              }
              else {
                  pos = pos.round();
              }
              if (hasBack) {
                  offsetDom(panels.back, pos);
              }
              if (hasFront || hasUI) {
                  offsetDom(panels.front, pos);
              }
          }
          return this;
      };
      MapRenderer.prototype.domChanged = function () {
          var panels = this.map.getPanels();
          if (!panels.front) {
              return false;
          }
          var frontCount = panels.back.layerDOM.childElementCount;
          if (this._frontCount === undefined || this._frontCount !== frontCount) {
              return true;
          }
          var backCount = panels.front.layerDOM.childElementCount;
          if (this._backCount === undefined || this._backCount !== backCount) {
              return true;
          }
          var uiCount = panels.front.uiDOM.childElementCount;
          if (this._uiCount === undefined || this._uiCount !== uiCount) {
              return true;
          }
          return false;
      };
      MapRenderer.prototype.resetContainer = function () {
          if (!this.map) {
              return;
          }
          this.map._resetMapViewPoint();
          if (this.map.getPanels().front) {
              var pos = new Point(0, 0);
              offsetDom(this.map.getPanels().back, pos);
              offsetDom(this.map.getPanels().front, pos);
          }
      };
      MapRenderer.prototype.onZoomEnd = function () {
          this.resetContainer();
      };
      MapRenderer.prototype.onLoad = function () {
          this._frameLoop();
      };
      //@internal
      MapRenderer.prototype._onDocVisibilitychange = function () {
          if (document.visibilityState !== 'visible') {
              return;
          }
          this.setToRedraw();
      };
      //@internal
      MapRenderer.prototype._getWrapPanel = function () {
          if (!this.map) {
              return null;
          }
          var panels = this.map.getPanels();
          return panels && panels.mapWrapper;
      };
      //@internal
      MapRenderer.prototype._onDocDragStart = function () {
          var wrapPanel = this._getWrapPanel();
          if (wrapPanel) {
              wrapPanel.style.overflow = 'visible';
          }
          return;
      };
      //@internal
      MapRenderer.prototype._onDocDragEnd = function () {
          var wrapPanel = this._getWrapPanel();
          if (wrapPanel) {
              wrapPanel.style.overflow = 'hidden';
          }
          return;
      };
      //@internal
      MapRenderer.prototype._onDocDPRChange = function () {
          var map = this.map;
          if (!map || !map.options || map.options['devicePixelRatio'] || !map.checkSize || !map.getRenderer) {
              return;
          }
          var renderer = map.getRenderer();
          if (renderer) {
              map.checkSize(true);
          }
      };
      //@internal
      MapRenderer.prototype._containerIsOffscreen = function () {
          var container = this.map.getContainer();
          if (!container || !container.style || container.style.display === 'none') {
              return true;
          }
          var minSize = Math.min(container.clientWidth, container.clientHeight);
          return minSize <= 0;
      };
      return MapRenderer;
  }(Class));

  var tempCollisionIndex = new CollisionIndex();
  /**
   * 基于 Canvas2D 的 map 渲染器
   *
   * @english
   * Renderer class based on HTML5 Canvas for maps.
   * @class
   * @protected
   * @extends {renderer.MapRenderer}
   * @memberOf renderer
   */
  var MapCanvasRenderer = /** @class */ (function (_super) {
      __extends(MapCanvasRenderer, _super);
      /**
       * @param map - map for the renderer
       */
      function MapCanvasRenderer(map) {
          var _this = _super.call(this, map) || this;
          //container is a <canvas> element
          _this._containerIsCanvas = !!map.getContainer().getContext;
          _this._registerEvents();
          _this._loopTime = 0;
          _this._resizeEventList = [];
          _this._resizeTime = -Infinity;
          _this._frameCycleRenderCount = 0;
          return _this;
      }
      MapCanvasRenderer.prototype.load = function () {
          this.initContainer();
      };
      /**
       * render layers in current frame
       * @returns return false to cease frame loop
       */
      MapCanvasRenderer.prototype.renderFrame = function (framestamp) {
          var map = this.map;
          if (!map || !map.options['renderable']) {
              return false;
          }
          this._handleResizeEventList(framestamp);
          //not render anything when map container is hide
          if (map.options['stopRenderOnOffscreen'] && this._containerIsOffscreen()) {
              return true;
          }
          this._updateDomPosition(framestamp);
          delete this._isViewChanged;
          map._fireEvent('framestart');
          this.updateMapDOM();
          map.clearCollisionIndex();
          var layers = this._getAllLayerToRender();
          this.drawLayers(layers, framestamp);
          var updated = this.drawLayerCanvas(layers);
          if (updated) {
              // when updated is false, should escape drawing tops and centerCross to keep handle's alpha
              this.drawTops();
              this._drawCenterCross();
              if (map.options['debugSky']) {
                  this._debugSky();
              }
          }
          this._needClear = false;
          // this._drawContainerExtent();
          // CAUTION: the order to fire frameend and layerload events
          // fire frameend before layerload, reason:
          // 1. frameend is often used internally by maptalks and plugins
          // 2. layerload is often used externally by tests or user apps
          map._fireEvent('frameend');
          this._recordView();
          // refresh map's state
          // It must be before events and frame callback, because map state may be changed in callbacks.
          this._mapview = this._getMapView();
          delete this._spatialRefChanged;
          this._fireLayerLoadEvents();
          this.executeFrameCallbacks();
          this._canvasUpdated = false;
          //loop ui Collides
          map.uiCollides();
          return true;
      };
      MapCanvasRenderer.prototype.getFrameTimestamp = function () {
          return this._frameTimestamp || 0;
      };
      MapCanvasRenderer.prototype.updateMapDOM = function () {
          var map = this.map;
          // when map is zooming, container is being transformed with matrix, panel doesn't need to be moved.
          if (map.isZooming()) {
              return;
          }
          var offset = map.getViewPointFrameOffset();
          if (offset) {
              map.offsetPlatform(offset);
          }
          else if (this.domChanged()) {
              this.offsetPlatform(null, true);
          }
      };
      //need redraw all layer,cause by collision/crs change/view change etc...
      //@internal
      MapCanvasRenderer.prototype._needRedrawAllLayers = function (layers) {
          var _this = this;
          if (this.isSpatialReferenceChanged()) {
              return true;
          }
          var needRedrawLayers = [];
          layers.forEach(function (layer) {
              if (!layer) {
                  return;
              }
              //always check layer need to redraw
              var needsRedraw = layer._toRedraw = _this._checkLayerRedraw(layer);
              if (needsRedraw) {
                  needRedrawLayers.push(layer);
                  var childLayers = layer.getLayers && layer.getLayers();
                  if (childLayers && Array.isArray(childLayers)) {
                      pushIn(needRedrawLayers, childLayers);
                  }
              }
          });
          for (var i = 0, len = needRedrawLayers.length; i < len; i++) {
              var layer = needRedrawLayers[i];
              var layerOptions = layer && layer.options;
              if (layerOptions && layerOptions.collision && layerOptions.collisionScope === 'map') {
                  return true;
              }
              //other condition if need
          }
          return false;
      };
      MapCanvasRenderer.prototype.drawLayers = function (layers, framestamp) {
          var needRedrawAllLayers = this._needRedrawAllLayers(layers);
          var map = this.map, isInteracting = map.isInteracting(), 
          // all the visible canvas layers' ids.
          canvasIds = [], 
          // all the updated canvas layers's ids.
          updatedIds = [], fps = map.options['fpsOnInteracting'] || 0, timeLimit = fps === 0 ? 0 : 1000 / fps, 
          // time of layer drawing
          layerLimit = this.map.options['layerCanvasLimitOnInteracting'], l = layers.length;
          var baseLayer = map.getBaseLayer();
          var t = 0;
          for (var i = 0; i < l; i++) {
              var layer = layers[i];
              if (!layer.isVisible()) {
                  continue;
              }
              var isCanvas = layer.isCanvasRender();
              if (isCanvas) {
                  canvasIds.push(layer.getId());
              }
              var renderer = layer._getRenderer();
              if (!renderer) {
                  continue;
              }
              // if need to call layer's draw/drawInteracting
              var needsRedraw = needRedrawAllLayers || layer._toRedraw;
              if (isCanvas && renderer.isCanvasUpdated()) {
                  // don't need to call layer's draw/drawOnInteracting but need to redraw layer's updated canvas
                  if (!needsRedraw) {
                      updatedIds.push(layer.getId());
                  }
                  this.setLayerCanvasUpdated();
              }
              var transformMatrix = renderer.__zoomTransformMatrix;
              delete renderer.__zoomTransformMatrix;
              if (!needsRedraw) {
                  if (isCanvas && isInteracting) {
                      if (map.isZooming() && !map.getPitch()) {
                          // transform layer's current canvas when zooming
                          renderer.prepareRender();
                          renderer.__zoomTransformMatrix = this._zoomMatrix;
                      }
                      else if (map.getPitch() || map.isRotating()) {
                          // when map is pitching or rotating, clear the layer canvas
                          // otherwise, leave layer's canvas unchanged
                          renderer.clearCanvas();
                      }
                  }
                  continue;
              }
              if (isInteracting && isCanvas) {
                  if (layerLimit > 0 && l - 1 - i > layerLimit && layer !== baseLayer) {
                      layer._getRenderer().clearCanvas();
                      continue;
                  }
                  t += this._drawCanvasLayerOnInteracting(layer, t, timeLimit, framestamp);
              }
              else if (isInteracting && renderer.drawOnInteracting) {
                  // dom layers
                  if (renderer.prepareRender) {
                      renderer.prepareRender();
                  }
                  if (renderer.checkAndDraw) {
                      // for canvas renderers
                      renderer.checkAndDraw(renderer.drawOnInteracting, this._eventParam, framestamp);
                  }
                  else {
                      renderer.drawOnInteracting(this._eventParam, framestamp);
                  }
              }
              else {
                  // map is not interacting, call layer's render
                  renderer.render(framestamp);
                  //地图缩放完以后，如果下一次render需要载入资源，仍需要设置transformMatrix
                  //防止在资源载入完成之前，缺少transformMatrix导致的绘制错误
                  if (isCanvas && transformMatrix && renderer.isLoadingResource()) {
                      renderer.__zoomTransformMatrix = transformMatrix;
                  }
              }
              if (isCanvas) {
                  updatedIds.push(layer.getId());
                  this.setLayerCanvasUpdated();
              }
          }
          // compare:
          // 1. previous drawn layers and current drawn layers
          // 2. previous canvas layers and current canvas layers
          // set map to redraw if either changed
          var preCanvasIds = this._canvasIds || [];
          var preUpdatedIds = this._updatedIds || [];
          this._canvasIds = canvasIds;
          this._updatedIds = updatedIds;
          if (!this.isLayerCanvasUpdated()) {
              var sep = '---';
              if (preCanvasIds.join(sep) !== canvasIds.join(sep) || preUpdatedIds.join(sep) !== updatedIds.join(sep)) {
                  this.setLayerCanvasUpdated();
              }
          }
      };
      /**
       * check if need to call layer's draw/drawInteracting
       * @param layer
       */
      //@internal
      MapCanvasRenderer.prototype._checkLayerRedraw = function (layer) {
          if (this.isSpatialReferenceChanged()) {
              return true;
          }
          var map = this.map;
          var renderer = layer._getRenderer();
          if (!renderer) {
              return false;
          }
          if (layer.isCanvasRender()) {
              return renderer.testIfNeedRedraw();
          }
          else {
              if (renderer.needToRedraw && renderer.needToRedraw()) {
                  return true;
              }
              // dom layers, redraw it if map is interacting or state is changed
              return map.isInteracting() || this.isViewChanged();
          }
      };
      /**
       * Draw canvas rendered layer when map is interacting
       * @param layer
       * @param t     current consumed time of layer drawing
       * @param timeLimit time limit for layer drawing
       * @param framestamp
       * @returns time to draw this layer
       * @private
       */
      //@internal
      MapCanvasRenderer.prototype._drawCanvasLayerOnInteracting = function (layer, t, timeLimit, framestamp) {
          var map = this.map, renderer = layer._getRenderer(), drawTime = renderer.getDrawTime(), inTime = timeLimit === 0 || timeLimit > 0 && t + drawTime <= timeLimit;
          if (renderer.mustRenderOnInteracting && renderer.mustRenderOnInteracting()) {
              renderer.render(framestamp);
          }
          else if (renderer.drawOnInteracting &&
              (layer === map.getBaseLayer() || inTime ||
                  map.isZooming() && layer.options['forceRenderOnZooming'] ||
                  map.isMoving() && layer.options['forceRenderOnMoving'] ||
                  map.isRotating() && layer.options['forceRenderOnRotating'])) {
              // call drawOnInteracting to redraw the layer
              renderer.prepareRender();
              renderer.prepareCanvas();
              if (renderer.checkAndDraw) {
                  // for canvas renderers
                  renderer.checkAndDraw(renderer.drawOnInteracting, this._eventParam, framestamp);
              }
              else {
                  renderer.drawOnInteracting(this._eventParam, framestamp);
              }
              return drawTime;
          }
          else if (map.isZooming() && !map.getPitch() && !map.isRotating()) {
              // when:
              // 1. layer's renderer doesn't have drawOnInteracting
              // 2. timeLimit is exceeded
              // then:
              // transform layer's current canvas when zooming
              renderer.prepareRender();
              renderer.__zoomTransformMatrix = this._zoomMatrix;
          }
          else if (map.getPitch() || map.isRotating()) {
              // when map is pitching or rotating, clear the layer canvas
              // otherwise, leave layer's canvas unchanged
              renderer.clearCanvas();
          }
          if (renderer.drawOnInteracting && !inTime) {
              // @ts-expect-error 我也不知道怎么办，不敢乱动，可能插件里需要？
              renderer.onSkipDrawOnInteracting(this._eventParam, framestamp);
          }
          return 0;
      };
      /**
       * Fire layerload events.
       * Make sure layer are drawn on map when firing the events
       * @private
       */
      //@internal
      MapCanvasRenderer.prototype._fireLayerLoadEvents = function () {
          if (this._updatedIds && this._updatedIds.length > 0) {
              var map_1 = this.map;
              //firing order as FIFO, painting as FILO, so the order needs to be reversed
              this._updatedIds.reverse().forEach(function (id) {
                  var layer = map_1.getLayer(id);
                  if (!layer) {
                      return;
                  }
                  var renderer = layer._getRenderer();
                  if (!renderer || !renderer.isRenderComplete()) {
                      return;
                  }
                  /**
                   * layerload event, fired when layer is loaded.
                   *
                   * @event Layer#layerload
                   * @type {Object}
                   * @property {String} type - layerload
                   * @property {Layer} target - layer
                   */
                  layer.fire('layerload');
              });
          }
      };
      MapCanvasRenderer.prototype.isLayerCanvasUpdated = function () {
          return this._canvasUpdated;
      };
      MapCanvasRenderer.prototype.setLayerCanvasUpdated = function () {
          this._canvasUpdated = true;
      };
      /**
       * Renders the layers
       */
      MapCanvasRenderer.prototype.drawLayerCanvas = function (layers) {
          var map = this.map;
          if (!map) {
              return false;
          }
          if (!this.isLayerCanvasUpdated() && !this.isViewChanged() && this._needClear === false) {
              return false;
          }
          if (!this.canvas) {
              this.createCanvas();
          }
          /**
           * renderstart event, an event fired when map starts to render.
           * @event Map#renderstart
           * @type {Object}
           * @property {String} type           - renderstart
           * @property {Map} target            - the map fires event
           * @property {CanvasRenderingContext2D} context  - canvas context
           */
          map._fireEvent('renderstart', {
              'context': this.context
          });
          if (!this._updateCanvasSize()) {
              this.clearCanvas();
          }
          var interacting = map.isInteracting(), limit = map.options['layerCanvasLimitOnInteracting'];
          var len = layers.length;
          var baseLayerImage;
          var images = [];
          for (var i = 0; i < len; i++) {
              if (!layers[i].isVisible() || !layers[i].isCanvasRender()) {
                  continue;
              }
              var renderer = layers[i]._getRenderer();
              if (!renderer) {
                  continue;
              }
              var layerImage = this._getLayerImage(layers[i]);
              if (layerImage && layerImage['image']) {
                  if (layers[i] === map.getBaseLayer()) {
                      baseLayerImage = [layers[i], layerImage];
                  }
                  else {
                      images.push([layers[i], layerImage]);
                  }
              }
          }
          var targetWidth = this.canvas.width;
          var targetHeight = this.canvas.height;
          if (baseLayerImage) {
              this._drawLayerCanvasImage(baseLayerImage[0], baseLayerImage[1], targetWidth, targetHeight);
              this._drawFog();
          }
          len = images.length;
          var start = interacting && limit >= 0 && len > limit ? len - limit : 0;
          for (var i = start; i < len; i++) {
              this._drawLayerCanvasImage(images[i][0], images[i][1], targetWidth, targetHeight);
          }
          /**
           * renderend event, an event fired when map ends rendering.
           * @event Map#renderend
           * @type {Object}
           * @property {String} type                      - renderend
           * @property {Map} target              - the map fires event
           * @property {CanvasRenderingContext2D} context - canvas context
           */
          map._fireEvent('renderend', {
              'context': this.context
          });
          return true;
      };
      MapCanvasRenderer.prototype.setToRedraw = function () {
          var layers = this._getAllLayerToRender();
          //set maprender for clear canvas
          this._needClear = true;
          for (var i = 0, l = layers.length; i < l; i++) {
              var renderer = layers[i].getRenderer();
              if (renderer && renderer.canvas && renderer.setToRedraw) {
                  //to fix lost webgl context
                  renderer.setToRedraw();
              }
          }
      };
      MapCanvasRenderer.prototype.updateMapSize = function (size) {
          if (!size || this._containerIsCanvas) {
              return;
          }
          var width = size['width'] + 'px', height = size['height'] + 'px';
          var panels = this.map.getPanels();
          panels.mapWrapper.style.width = width;
          panels.mapWrapper.style.height = height;
          this._updateCanvasSize();
      };
      MapCanvasRenderer.prototype.getMainPanel = function () {
          if (!this.map) {
              return null;
          }
          if (this._containerIsCanvas) {
              return this.map.getContainer();
          }
          if (this.map.getPanels()) {
              return this.map.getPanels().mapWrapper;
          }
          return null;
      };
      MapCanvasRenderer.prototype.toDataURL = function (mimeType, quality) {
          if (!this.canvas) {
              return null;
          }
          return this.canvas.toDataURL(mimeType, quality);
      };
      MapCanvasRenderer.prototype.remove = function () {
          if (Browser$1.webgl && typeof document !== 'undefined') {
              GlobalEvent.off(EVENT_DPR_CHANGE, this._thisDocDPRChange, this);
              GlobalEvent.off(EVENT_DOC_VISIBILITY_CHANGE, this._thisDocVisibilitychange, this);
              GlobalEvent.off(EVENT_DOC_DRAGSTART, this._thisDocDragStart, this);
              GlobalEvent.off(EVENT_DOC_DRAGEND, this._thisDocDragEnd, this);
              // removeDomEvent(document, 'visibilitychange', this._thisDocVisibilitychange, this);
              // removeDomEvent(document, 'dragstart', this._thisDocDragStart, this);
              // removeDomEvent(document, 'dragend', this._thisDocDragEnd, this);
          }
          if (this._resizeInterval) {
              clearInterval(this._resizeInterval);
          }
          if (this._resizeObserver) {
              this._resizeObserver.disconnect();
          }
          delete this.context;
          delete this.canvas;
          delete this.map;
          delete this._spatialRefChanged;
          this._cancelFrameLoop();
      };
      MapCanvasRenderer.prototype.hitDetect = function (point) {
          var map = this.map;
          if (!map || !map.options['hitDetect'] || map.isInteracting()) {
              return;
          }
          var layers = map._getLayers();
          var cursor = 'default';
          var limit = map.options['hitDetectLimit'] || 0;
          var counter = 0;
          if (point && point._round) {
              // map size is decimal,containerPoint.x/containerPoint.y is decimal
              point._round();
          }
          for (var i = layers.length - 1; i >= 0; i--) {
              var layer = layers[i];
              // 此处如果未开启，无需执行后面判断
              if (!layer.options['hitDetect'] || (layer.isEmpty && layer.isEmpty()) || !layer.options['geometryEvents']) {
                  continue;
              }
              var renderer = layer._getRenderer();
              if (!renderer || !renderer.hitDetect) {
                  continue;
              }
              if (renderer.isBlank && renderer.isBlank()) {
                  continue;
              }
              // renderer.hitDetect(point)) .  This can't ignore the shadows.
              /**
               * TODO
               *  This requires a better way to judge
               */
              if (layer.options['cursor'] !== 'default' && renderer.hitDetect(point)) {
                  cursor = layer.options['cursor'] || 'pointer';
                  break;
              }
              counter++;
              if (limit > 0 && counter > limit) {
                  break;
              }
          }
          map._trySetCursor(cursor);
      };
      //@internal
      MapCanvasRenderer.prototype._getLayerImage = function (layer) {
          var renderer = layer._getRenderer();
          if (renderer.getCanvasImage) {
              return renderer.getCanvasImage();
          }
          return null;
      };
      /**
       * initialize container DOM of panels
       */
      MapCanvasRenderer.prototype.initContainer = function () {
          var panels = this.map.getPanels();
          function createContainer(name, className, cssText, enableSelect) {
              var c = createEl('div', className);
              if (cssText) {
                  c.style.cssText = cssText;
              }
              panels[name] = c;
              if (!enableSelect) {
                  preventSelection(c);
              }
              return c;
          }
          var containerDOM = this.map.getContainer();
          if (this._containerIsCanvas) {
              //container is a <canvas> element.
              return;
          }
          containerDOM.innerHTML = '';
          var POSITION0 = 'position:absolute;top:0px;left:0px;';
          var mapWrapper = createContainer('mapWrapper', 'maptalks-wrapper', 'position:absolute;overflow:hidden;', true), mapAllLayers = createContainer('allLayers', 'maptalks-all-layers', POSITION0 + 'padding:0px;margin:0px;z-index:0;overflow:visible;', true), backStatic = createContainer('backStatic', 'maptalks-back-static', POSITION0 + 'z-index:0;', true), back = createContainer('back', 'maptalks-back', POSITION0 + 'z-index:1;'), backLayer = createContainer('backLayer', 'maptalks-back-layer', POSITION0), canvasContainer = createContainer('canvasContainer', 'maptalks-canvas-layer', POSITION0 + 'border:none;z-index:2;'), frontStatic = createContainer('frontStatic', 'maptalks-front-static', POSITION0 + 'z-index:3;', true), front = createContainer('front', 'maptalks-front', POSITION0 + 'z-index:4;', true), frontLayer = createContainer('frontLayer', 'maptalks-front-layer', POSITION0 + 'z-index:0;'), 
          // children's zIndex in frontLayer will be set by map.addLayer, ui container's z-index is set to 10000 to make sure it's always on the top.
          ui = createContainer('ui', 'maptalks-ui', POSITION0 + 'border:none;z-index:1;', true), control = createContainer('control', 'maptalks-control', 'z-index:1', true);
          containerDOM.appendChild(mapWrapper);
          mapAllLayers.appendChild(backStatic);
          back.appendChild(backLayer);
          back.layerDOM = backLayer;
          mapAllLayers.appendChild(back);
          mapAllLayers.appendChild(canvasContainer);
          front.appendChild(frontLayer);
          front.layerDOM = frontLayer;
          front.uiDOM = ui;
          mapAllLayers.appendChild(frontStatic);
          mapAllLayers.appendChild(front);
          front.appendChild(ui);
          mapWrapper.appendChild(mapAllLayers);
          mapWrapper.appendChild(control);
          this.createCanvas();
          this.resetContainer();
          var mapSize = this.map._getContainerDomSize();
          this.updateMapSize(mapSize);
      };
      /**
       * Is current map's state changed?
       */
      MapCanvasRenderer.prototype.isViewChanged = function () {
          if (this._isViewChanged !== undefined) {
              return this._isViewChanged;
          }
          var previous = this._mapview;
          var view = this._getMapView();
          this._isViewChanged = !previous || !equalMapView(previous, view);
          return this._isViewChanged;
      };
      //@internal
      MapCanvasRenderer.prototype._recordView = function () {
          var map = this.map;
          if (!map._onViewChange || map.isInteracting() || map.isAnimating()) {
              return;
          }
          if (!equalMapView(map.getView(), map._getCurrentView())) {
              map._onViewChange(map.getView());
          }
      };
      MapCanvasRenderer.prototype.isSpatialReferenceChanged = function () {
          return this._spatialRefChanged;
      };
      //@internal
      MapCanvasRenderer.prototype._getMapView = function () {
          var map = this.map;
          var center = map._getPrjCenter();
          return {
              x: center.x,
              y: center.y,
              zoom: map.getZoom(),
              pitch: map.getPitch(),
              bearing: map.getBearing(),
              width: map.width,
              height: map.height
          };
      };
      //@internal
      MapCanvasRenderer.prototype._lockFrameRenderEnable = function () {
          var maxFPS = (this.map.options || {}).maxFPS;
          if (maxFPS <= 0 || GlobalConfig.maxFPS <= maxFPS) {
              return true;
          }
          var count = Math.ceil(GlobalConfig.maxFPS / maxFPS);
          return this._frameCycleRenderCount >= count;
      };
      /**
      * Main frame loop
      */
      //@internal
      MapCanvasRenderer.prototype._frameLoop = function (framestamp) {
          var _this = this;
          if (!this.map) {
              this._cancelFrameLoop();
              return;
          }
          this._frameCycleRenderCount++;
          if (this._lockFrameRenderEnable()) {
              framestamp = framestamp || 0;
              this._frameTimestamp = framestamp;
              this._resizeCount = 0;
              this.renderFrame(framestamp);
              this._frameCycleRenderCount = 0;
          }
          else if (this.map.options.debug) {
              console.log('skip frame ing,frameCycleRenderCount:', this._frameCycleRenderCount);
          }
          // Keep registering ourselves for the next animation frame
          this._animationFrame = requestAnimFrame(function (framestamp) { _this._frameLoop(framestamp); });
      };
      //@internal
      MapCanvasRenderer.prototype._cancelFrameLoop = function () {
          if (this._animationFrame) {
              cancelAnimFrame(this._animationFrame);
          }
      };
      //@internal
      MapCanvasRenderer.prototype._drawLayerCanvasImage = function (layer, layerImage, targetWidth, targetHeight) {
          var ctx = this.context;
          var point = layerImage['point'].round();
          var dpr = this.map.getDevicePixelRatio();
          if (dpr !== 1) {
              point._multi(dpr);
          }
          var canvasImage = layerImage['image'];
          var width = canvasImage.width, height = canvasImage.height;
          if (point.x + width <= 0 || point.y + height <= 0) {
              return;
          }
          //opacity of the layer image
          var op = layer.options['opacity'];
          if (!isNumber(op)) {
              op = 1;
          }
          if (op <= 0) {
              return;
          }
          var imgOp = layerImage['opacity'];
          if (!isNumber(imgOp)) {
              imgOp = 1;
          }
          if (imgOp <= 0) {
              return;
          }
          var alpha = ctx.globalAlpha;
          if (op < 1) {
              ctx.globalAlpha *= op;
          }
          if (imgOp < 1) {
              ctx.globalAlpha *= imgOp;
          }
          if (layer.options['cssFilter']) {
              ctx.filter = layer.options['cssFilter'];
          }
          var renderer = layer.getRenderer();
          var matrix = renderer.__zoomTransformMatrix;
          var clipped = renderer.clipCanvas(this.context);
          if (matrix) {
              ctx.save();
              ctx.setTransform.apply(ctx, __spreadArray([], __read(matrix), false));
          }
          /*let outlineColor = layer.options['debugOutline'];
          if (outlineColor) {
              if (outlineColor === true) {
                  outlineColor = '#0f0';
              }
              this.context.strokeStyle = outlineColor;
              this.context.fillStyle = outlineColor;
              this.context.lineWidth = 10;
              Canvas2D.rectangle(ctx, point, layerImage.size, 1, 0);
              ctx.fillText([layer.getId(), point.toArray().join(), layerImage.size.toArray().join(), canvasImage.width + ',' + canvasImage.height].join(' '),
                  point.x + 18, point.y + 18);
          }*/
          ctx.drawImage(canvasImage, 0, 0, width, height, point.x, point.y, targetWidth, targetHeight);
          if (matrix) {
              ctx.restore();
          }
          if (clipped) {
              ctx.restore();
          }
          if (ctx.filter !== 'none') {
              ctx.filter = 'none';
          }
          ctx.globalAlpha = alpha;
      };
      //@internal
      MapCanvasRenderer.prototype._drawCenterCross = function () {
          var cross = this.map.options['centerCross'];
          if (cross) {
              var ctx = this.context;
              var p = new Point(this.canvas.width / 2, this.canvas.height / 2);
              if (isFunction(cross)) {
                  cross(ctx, p);
              }
              else {
                  Canvas.drawCross(this.context, p.x, p.y, 2, '#f00');
              }
          }
      };
      //@internal
      MapCanvasRenderer.prototype._drawContainerExtent = function () {
          var cascadePitches = this.map.options.cascadePitches;
          var h30 = this.map.height - this.map._getVisualHeight(cascadePitches[0]);
          var h60 = this.map.height - this.map._getVisualHeight(cascadePitches[1]);
          var extent = this.map.getContainerExtent();
          var ctx = this.context;
          ctx.beginPath();
          ctx.moveTo(0, extent.ymin);
          ctx.lineTo(extent.xmax, extent.ymin);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, h30);
          ctx.lineTo(extent.xmax, h30);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, h60);
          ctx.lineTo(extent.xmax, h60);
          ctx.stroke();
          // console.log(extent.ymin, h30, h60);
      };
      //@internal
      MapCanvasRenderer.prototype._drawFog = function () {
          var map = this.map;
          if (map.getPitch() <= map.options['maxVisualPitch'] || !map.options['fog']) {
              return;
          }
          var fogThickness = 30;
          var r = map.getDevicePixelRatio();
          var ctx = this.context, clipExtent = map.getContainerExtent();
          var top = (map.height - map._getVisualHeight(75)) * r;
          if (top < 0)
              top = 0;
          var bottom = clipExtent.ymin * r, h = Math.ceil(bottom - top), color = map.options['fogColor'].join();
          var gradient = ctx.createLinearGradient(0, top, 0, bottom + fogThickness);
          var landscape = 1 - fogThickness / (h + fogThickness);
          gradient.addColorStop(0, "rgba(".concat(color, ", 0)"));
          gradient.addColorStop(0.3, "rgba(".concat(color, ", 0.3)"));
          gradient.addColorStop(landscape, "rgba(".concat(color, ", 1)"));
          gradient.addColorStop(1, "rgba(".concat(color, ", 0)"));
          ctx.beginPath();
          ctx.fillStyle = gradient;
          ctx.fillRect(0, top, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(h + fogThickness));
      };
      //@internal
      MapCanvasRenderer.prototype._debugSky = function () {
          var map = this.map;
          if (!map) {
              return this;
          }
          var height = map.getContainerExtent().ymin;
          if (height <= 0) {
              return this;
          }
          var ctx = this.context;
          ctx.strokeStyle = 'red';
          ctx.strokeRect(0, 0, map.width, height);
          return this;
      };
      //@internal
      MapCanvasRenderer.prototype._getAllLayerToRender = function () {
          return this.map._getLayers();
      };
      MapCanvasRenderer.prototype.clearCanvas = function () {
          if (!this.canvas) {
              return;
          }
          Canvas.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
      };
      //@internal
      MapCanvasRenderer.prototype._updateCanvasSize = function () {
          if (!this.canvas || this._containerIsCanvas) {
              return false;
          }
          var map = this.map, mapSize = map.getSize(), canvas = this.canvas, r = map.getDevicePixelRatio();
          // width/height不变并不意味着 css width/height 不变
          var _a = calCanvasSize(mapSize, r), width = _a.width, height = _a.height, cssWidth = _a.cssWidth, cssHeight = _a.cssHeight;
          if (canvas.style && (canvas.style.width !== cssWidth || canvas.style.height !== cssHeight)) {
              canvas.style.width = cssWidth;
              canvas.style.height = cssHeight;
          }
          if (width === canvas.width && height === canvas.height) {
              return false;
          }
          //retina屏支持
          canvas.height = height;
          canvas.width = width;
          this.topLayer.width = canvas.width;
          this.topLayer.height = canvas.height;
          return true;
      };
      MapCanvasRenderer.prototype.createCanvas = function () {
          this.topLayer = createEl('canvas');
          this.topCtx = this.topLayer.getContext('2d');
          if (this._containerIsCanvas) {
              this.canvas = this.map.getContainer();
          }
          else {
              this.canvas = createEl('canvas');
              this._updateCanvasSize();
              this.map.getPanels().canvasContainer.appendChild(this.canvas);
          }
          this.context = this.canvas.getContext('2d');
      };
      //@internal
      MapCanvasRenderer.prototype._updateDomPosition = function (framestamp) {
          if (this._checkPositionTime === undefined) {
              this._checkPositionTime = -Infinity;
          }
          var dTime = Math.abs(framestamp - this._checkPositionTime);
          if (dTime >= 500) {
              // refresh map's dom position
              computeDomPosition(this.map.getContainer());
              this._checkPositionTime = Math.min(framestamp, this._checkPositionTime);
          }
          return this;
      };
      //@internal
      MapCanvasRenderer.prototype._handleResizeEventList = function (time) {
          if (!this._resizeEventList) {
              return this;
          }
          var len = this._resizeEventList.length;
          if (len === 0) {
              return this;
          }
          if (this._resizeTime && time - this._resizeTime < 60) {
              return this;
          }
          var contentRect = this._resizeEventList[len - 1].contentRect;
          this.map.setContainerDomRect(contentRect);
          this._resizeEventList = [];
          this._checkSize();
          this._resizeCount = this._resizeCount || 0;
          //force render all layers,这两句代码不能颠倒，因为要先重置所有图层的size，才能正确的渲染所有图层
          this.renderFrame((this._frameTimestamp || 0) + (++this._resizeCount) / 100);
          this._resizeTime = time;
          return this;
      };
      //@internal
      MapCanvasRenderer.prototype._checkSize = function () {
          if (!this.map) {
              return;
          }
          this.map.checkSize();
      };
      //@internal
      MapCanvasRenderer.prototype._setCheckSizeInterval = function (interval) {
          var _this = this;
          // ResizeObserver priority of use
          // https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver
          if (Browser$1.resizeObserver) {
              if (this._resizeObserver) {
                  this._resizeObserver.disconnect();
              }
              if (this.map) {
                  // eslint-disable-next-line no-unused-vars
                  this._resizeObserver = new ResizeObserver(function (entries) {
                      if (!_this.map || _this.map.isRemoved()) {
                          _this._resizeObserver.disconnect();
                      }
                      else if (entries.length) {
                          _this._resizeEventList = _this._resizeEventList || [];
                          _this._resizeEventList.push(entries[0]);
                      }
                  });
                  this._resizeObserver.observe(this.map.getContainer());
              }
          }
          else {
              clearInterval(this._resizeInterval);
              this._checkSizeInterval = interval;
              this._resizeInterval = setInterval(function () {
                  if (!_this.map || _this.map.isRemoved()) {
                      //is deleted
                      clearInterval(_this._resizeInterval);
                  }
                  else {
                      _this._checkSize();
                  }
              }, this._checkSizeInterval);
          }
      };
      //@internal
      MapCanvasRenderer.prototype._registerEvents = function () {
          var _this = this;
          var map = this.map;
          if (map.options['checkSize'] && !IS_NODE && (typeof window !== 'undefined')) {
              this._setCheckSizeInterval(map.options['checkSizeInterval']);
          }
          if (!Browser$1.mobile) {
              map.on('_mousemove', this._onMapMouseMove, this);
          }
          map.on('_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart', function (param) {
              _this._eventParam = param;
          });
          map.on('_zooming', function (param) {
              if (!map.getPitch()) {
                  _this._zoomMatrix = param['matrix']['container'];
              }
              _this._eventParam = param;
          });
          map.on('_zoomend', function (param) {
              _this._eventParam = param;
              delete _this._zoomMatrix;
          });
          map.on('_spatialreferencechange', function () {
              _this._spatialRefChanged = true;
          });
          if (Browser$1.webgl && typeof document !== 'undefined') {
              GlobalEvent.on(EVENT_DPR_CHANGE, this._thisDocDPRChange, this);
              GlobalEvent.on(EVENT_DOC_VISIBILITY_CHANGE, this._thisDocVisibilitychange, this);
              GlobalEvent.on(EVENT_DOC_DRAGSTART, this._thisDocDragStart, this);
              GlobalEvent.on(EVENT_DOC_DRAGEND, this._thisDocDragEnd, this);
              // addDomEvent(document, 'visibilitychange', this._thisDocVisibilitychange, this);
              // addDomEvent(document, 'dragstart', this._thisDocDragStart, this);
              // addDomEvent(document, 'dragend', this._thisDocDragEnd, this);
          }
      };
      //@internal
      MapCanvasRenderer.prototype._onMapMouseMove = function (param) {
          var _this = this;
          var map = this.map;
          if (map.isInteracting() || !map.options['hitDetect']) {
              return;
          }
          if (this._hitDetectFrame) {
              cancelAnimFrame(this._hitDetectFrame);
          }
          this._hitDetectFrame = requestAnimFrame(function () {
              _this.hitDetect(param['containerPoint']);
          });
      };
      //@internal
      MapCanvasRenderer.prototype._getCanvasLayers = function () {
          return this.map._getLayers(function (layer) { return layer.isCanvasRender(); });
      };
      //----------- top elements methods -------------
      // edit handles or edit outlines
      MapCanvasRenderer.prototype.addTopElement = function (e) {
          if (!this._tops) {
              this._tops = [];
          }
          this._tops.push(e);
      };
      MapCanvasRenderer.prototype.removeTopElement = function (e) {
          if (!this._tops) {
              return;
          }
          var idx = this._tops.indexOf(e);
          if (idx >= 0) {
              this._tops.splice(idx, 1);
          }
      };
      MapCanvasRenderer.prototype.getTopElements = function () {
          return this._tops || [];
      };
      MapCanvasRenderer.prototype.sortTopElements = function () {
          this._tops = this._tops.sort(function (top1, top2) {
              var zIndex1 = top1.options.zIndex || 0;
              var zIndex2 = top2.options.zIndex || 0;
              return zIndex2 - zIndex1;
          });
      };
      MapCanvasRenderer.prototype.drawTops = function () {
          // clear topLayer
          this.topCtx.clearRect(0, 0, this.topLayer.width, this.topLayer.height);
          var collisionIndex = tempCollisionIndex;
          collisionIndex.clear();
          this.map.fire('drawtopstart');
          this.map.fire('drawtops');
          var tops = this.getTopElements();
          var updated = false;
          var dpr = this.map.getDevicePixelRatio();
          var geos = [];
          for (var i = 0; i < tops.length; i++) {
              var top_1 = tops[i];
              if (top_1.needCollision && top_1.needCollision()) {
                  var bbox = top_1.getRenderBBOX(dpr);
                  if (bbox) {
                      if (collisionIndex.collides(bbox)) {
                          var geometry = top_1.target && top_1.target._geometry;
                          if (geometry && geos.indexOf(geometry) === -1) {
                              geos.push(geometry);
                              geometry.fire('handlecollision');
                          }
                          continue;
                      }
                      else {
                          collisionIndex.insertBox(bbox);
                      }
                  }
              }
              if (top_1.render(this.topCtx)) {
                  updated = true;
              }
          }
          if (updated) {
              this.context.drawImage(this.topLayer, 0, 0);
          }
          this.map.fire('drawtopsend');
      };
      return MapCanvasRenderer;
  }(MapRenderer));
  Map$1.registerRenderer('canvas', MapCanvasRenderer);
  Map$1.mergeOptions({
      'fog': false,
      'fogColor': [233, 233, 233]
  });

  /** @namespace renderer */

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CanvasLayerRenderer: CanvasLayerRenderer,
    CanvasRenderer: CanvasRenderer$1,
    CanvasTileLayerCanvasRenderer: CanvasRenderer,
    CanvasTileLayerGLRenderer: GLRenderer,
    ImageGLRenderable: ImageGLRenderable,
    ImageLayerCanvasRenderer: ImageLayerCanvasRenderer,
    ImageLayerGLRenderer: ImageLayerGLRenderer,
    MapCanvasRenderer: MapCanvasRenderer,
    MapRenderer: MapRenderer,
    OverlayLayerCanvasRenderer: OverlayLayerRenderer,
    QuadStencil: QuadStencil,
    Renderable: Renderable,
    ResourceCache: ResourceCache,
    TileLayerCanvasRenderer: TileLayerCanvasRenderer,
    TileLayerGLRenderer: TileLayerGLRenderer,
    VectorLayerCanvasRenderer: VectorLayerRenderer
  });

  // 有中心点的图形的共同方法
  var CenterPointRenderer = {
      //@internal
      _getRenderPoints: function () {
          return [[this._getCenter2DPoint(this.getMap().getGLRes())], null];
      }
  };
  /**
   * 获取symbolizer所需的数据
   */
  Marker.include(CenterPointRenderer);
  Ellipse.include(CenterPointRenderer);
  Circle.include(CenterPointRenderer);
  Sector.include(CenterPointRenderer);
  Rectangle.include({
      //@internal
      _getRenderPoints: function (placement) {
          var map = this.getMap();
          var glRes = map.getGLRes();
          if (placement === 'vertex') {
              var shell = this._trimRing(this.getShell());
              var points = [];
              for (var i = 0, len = shell.length; i < len; i++) {
                  points.push(map.coordToPointAtRes(shell[i], glRes));
              }
              return [points, null];
          }
          else {
              var c = map.coordToPointAtRes(this.getCenter(), glRes);
              return [
                  [c], null
              ];
          }
      }
  });
  //----------------------------------------------------
  var PolyRenderer = {
      //@internal
      _getRenderPoints: function (placement) {
          var map = this.getMap();
          var glRes = map.getGLRes();
          var points, rotations = null;
          if (placement === 'point') {
              points = this._getPath2DPoints(this._getPrjCoordinates(), false, glRes);
              if (points && points.length > 0 && Array.isArray(points[0])) {
                  //anti-meridian
                  points = points[0].concat(points[1]);
              }
          }
          else if (placement === 'vertex') {
              points = this._getPath2DPoints(this._getPrjCoordinates(), false, glRes);
              rotations = [];
              if (points && points.length > 0 && Array.isArray(points[0])) {
                  for (var i = 0, l = points.length; i < l; i++) {
                      for (var ii = 0, ll = points[i].length; ii < ll; ii++) {
                          if (ii === 0) {
                              rotations.push([points[i][ii], points[i][ii + 1]]);
                          }
                          else {
                              rotations.push([points[i][ii - 1], points[i][ii]]);
                          }
                      }
                  }
                  points = points[0].concat(points[1]);
              }
              else {
                  for (var i = 0, l = points.length; i < l; i++) {
                      if (i === 0) {
                          rotations.push([points[i], points[i + 1]]);
                      }
                      else {
                          rotations.push([points[i - 1], points[i]]);
                      }
                  }
              }
          }
          else if (placement === 'line') {
              points = [];
              rotations = [];
              var vertice = this._getPath2DPoints(this._getPrjCoordinates(), false, glRes), isSplitted = vertice.length > 0 && Array.isArray(vertice[0]);
              if (isSplitted) {
                  //anti-meridian splitted
                  var ring = void 0;
                  for (var i = 1, l = vertice.length; i < l; i++) {
                      ring = vertice[i];
                      if (this instanceof Polygon && ring.length > 0 && !ring[0].equals(ring[ring.length - 1])) {
                          ring.push(ring[0]);
                      }
                      for (var ii = 1, ll = ring.length; ii < ll; ii++) {
                          points.push(ring[ii].add(ring[ii - 1])._multi(0.5));
                          rotations.push([ring[ii - 1], ring[ii]]);
                      }
                  }
              }
              else {
                  if (this instanceof Polygon && vertice.length > 0 && !vertice[0].equals(vertice[vertice.length - 1])) {
                      vertice.push(vertice[0]);
                  }
                  for (var i = 1, l = vertice.length; i < l; i++) {
                      points.push(vertice[i].add(vertice[i - 1])._multi(0.5));
                      rotations.push([vertice[i - 1], vertice[i]]);
                  }
              }
          }
          else if (placement === 'vertex-first') {
              var coords = this._getPrjCoordinates();
              var l = coords.length;
              var point0 = l ? map._prjToPointAtRes(coords[0], glRes) : null;
              points = l ? [point0] : [];
              rotations = l ? [[point0, coords[1] ? map._prjToPointAtRes(coords[1], glRes) : point0]] : [];
          }
          else if (placement === 'vertex-last') {
              var coords = this._getPrjCoordinates();
              var l = coords.length;
              var curretPoint = l ? map._prjToPointAtRes(coords[l - 1], glRes) : null;
              points = l ? [curretPoint] : [];
              var previous = l > 1 ? l - 2 : l - 1;
              rotations = l ? [[coords[previous] ? map._prjToPointAtRes(coords[previous], glRes) : curretPoint, curretPoint]] : [];
          }
          else {
              var center = this.getCenter();
              if (!center) {
                  points = [];
              }
              else {
                  var pcenter = this._getProjection().project(center);
                  points = [map._prjToPointAtRes(pcenter, glRes)];
              }
          }
          return [points, rotations];
      }
  };
  LineString.include(PolyRenderer);
  Polygon.include(PolyRenderer);

  var TEMP_WITHIN = {
      within: false,
      center: [0, 0]
  };
  // bbox in pixel
  function isWithinPixel(painter) {
      if (!painter || !painter._containerBbox) {
          TEMP_WITHIN.within = false;
      }
      else {
          TEMP_WITHIN.within = false;
          var _a = painter._containerBbox, minx = _a.minx, miny = _a.miny, maxx = _a.maxx, maxy = _a.maxy;
          var offsetx = Math.abs(maxx - minx);
          var offsety = Math.abs(maxy - miny);
          if (offsetx <= 1 && offsety <= 1) {
              TEMP_WITHIN.within = true;
              TEMP_WITHIN.center[0] = (minx + maxx) / 2;
              TEMP_WITHIN.center[1] = (miny + maxy) / 2;
          }
          delete painter._containerBbox;
      }
      return TEMP_WITHIN;
  }
  var geometryInclude = {
      //@internal
      _redrawWhenPitch: function () { return false; },
      //@internal
      _redrawWhenRotate: function () { return false; },
      //@internal
      _getRenderBBOX: function (ctx, points) {
          if (!ctx.isHitTesting) {
              resetBBOX(BBOX_TEMP);
              pointsBBOX(points, BBOX_TEMP);
              return BBOX_TEMP;
          }
          return null;
      }
  };
  Geometry.include(geometryInclude);
  function _computeRotatedPrjExtent() {
      var coord = this._getPrjShell();
      var bbox = getDefaultBBOX();
      //cal all points center
      pointsBBOX(coord, bbox);
      var _a = __read(bbox, 4), minx = _a[0], miny = _a[1], maxx = _a[2], maxy = _a[3];
      return new Extent(minx, miny, maxx, maxy);
  }
  function getRotatedShell() {
      var prjs = this._getPrjShell();
      if (!prjs || !Array.isArray(prjs)) {
          return [];
      }
      var projection = this._getProjection();
      var coordinates = this.getCoordinates() || {};
      return prjs.map(function (prj) {
          var c = projection.unproject(prj);
          c.z = coordinates.z || 0;
          return c;
      });
  }
  //for Ellipse,Circle,
  var el = {
      //@internal
      _redrawWhenPitch: function () { return true; },
      //@internal
      _redrawWhenRotate: function () {
          return (this instanceof Ellipse) || (this instanceof Sector);
      },
      //@internal
      _computeRotatedPrjExtent: _computeRotatedPrjExtent,
      getRotatedShell: getRotatedShell,
      //@internal
      _paintAsPath: function () {
          //why? when rotate need draw by path
          if (this.isRotated()) {
              return true;
          }
          var map = this.getMap();
          var altitude = this._getAltitude();
          // when map is tilting, draw the circle/ellipse as a polygon by vertexes.
          return altitude > 0 || map.getPitch() || ((this instanceof Ellipse) && map.getBearing());
      },
      //@internal
      _getPaintParams: function () {
          var map = this.getMap();
          if (this._paintAsPath()) {
              return Polygon.prototype._getPaintParams.call(this, true);
          }
          var pcenter = this._getPrjCoordinates();
          var pt = map._prjToPointAtRes(pcenter, map.getGLRes());
          var size = this._getRenderSize(pt);
          return __spreadArray([pt], __read(size), false);
      },
      //@internal
      _paintOn: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this._paintAsPath()) {
              // @ts-expect-error
              return Canvas.polygon.apply(Canvas, __spreadArray([], __read(args), false));
          }
          else {
              // @ts-expect-error
              return Canvas.ellipse.apply(Canvas, __spreadArray([], __read(args), false));
          }
      },
      //@internal
      _getRenderSize: function (pt) {
          var map = this.getMap(), glRes = map.getGLRes();
          var prjExtent = this._getPrjExtent();
          var pmin = map._prjToPointAtRes(prjExtent.getMin(), glRes), pmax = map._prjToPointAtRes(prjExtent.getMax(), glRes);
          return [Math.abs(pmax.x - pmin.x) / 2, Math.abs(pmax.y - pt.y), Math.abs(pt.y - pmin.y)];
      }
  };
  Ellipse.include(el);
  Circle.include(el);
  var rectangleInclude = {
      //@internal
      _getPaintParams: function () {
          var map = this.getMap();
          var shell = this._getPrjShell();
          var points = this._getPath2DPoints(shell, false, map.getGLRes());
          return [points];
      },
      //@internal
      _paintOn: Canvas.polygon,
      //@internal
      _computeRotatedPrjExtent: _computeRotatedPrjExtent,
      getRotatedShell: getRotatedShell
  };
  Rectangle.include(rectangleInclude);
  var sectorInclude = {
      //@internal
      _redrawWhenPitch: function () { return true; },
      //@internal
      _getPaintParams: function () {
          if (this._paintAsPath()) {
              return Polygon.prototype._getPaintParams.call(this, true);
          }
          var map = this.getMap();
          var pt = map._prjToPointAtRes(this._getPrjCoordinates(), map.getGLRes());
          var size = this._getRenderSize(pt);
          var _a = __read(this._correctAngles(), 2), startAngle = _a[0], endAngle = _a[1];
          return [
              pt,
              size[0],
              [startAngle, endAngle]
          ];
      },
      //@internal
      _paintOn: function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this._paintAsPath()) {
              // @ts-expect-error
              return Canvas.polygon.apply(Canvas, __spreadArray([], __read(args), false));
          }
          else {
              var r = this.getMap().getBearing();
              if (r) {
                  args[3] = args[3].slice(0);
                  args[3][0] += r;
                  args[3][1] += r;
              }
              // @ts-expect-error
              return Canvas.sector.apply(Canvas, __spreadArray([], __read(args), false));
          }
      }
  };
  Sector.include(el, sectorInclude);
  Path.include({
      //@internal
      _paintAsPath: function () { return true; }
  });
  var lineStringInclude = {
      arrowStyles: {
          'classic': [3, 4]
      },
      //@internal
      _getArrowShape: function (prePoint, point, lineWidth, arrowStyle, tolerance) {
          if (!prePoint || !point || prePoint.equals(point)) {
              return null;
          }
          if (!tolerance) {
              tolerance = 0;
          }
          var width = lineWidth * arrowStyle[0], height = lineWidth * arrowStyle[1] + tolerance, hw = width / 2 + tolerance;
          var normal;
          if (point.nextCtrlPoint || point.prevCtrlPoint) {
              // use control points to caculate normal if it's a bezier curve
              if (point.prevCtrlPoint) {
                  normal = point.sub(new Point(point.prevCtrlPoint));
              }
              else {
                  normal = point.sub(new Point(point.nextCtrlPoint));
              }
          }
          else {
              normal = point.sub(prePoint);
          }
          normal._unit();
          var p1 = point.sub(normal.multi(height));
          normal._perp();
          var p0 = p1.add(normal.multi(hw));
          normal._multi(-1);
          var p2 = p1.add(normal.multi(hw));
          return [p0, point, p2, p0];
      },
      //@internal
      _getPaintParams: function () {
          var prjVertexes = this._getPrjCoordinates();
          var points = this._getPath2DPoints(prjVertexes, false, this.getMap().getGLRes());
          return [points];
      },
      //@internal
      _paintOn: function (ctx, points, lineOpacity, fillOpacity, dasharray) {
          var r = isWithinPixel(this._painter);
          if (r.within) {
              Canvas.pixelRect(ctx, r.center, lineOpacity, fillOpacity);
          }
          else if (this.options['smoothness']) {
              Canvas.paintSmoothLine(ctx, points, lineOpacity, this.options['smoothness'], false, this._animIdx, this._animTailRatio);
          }
          else {
              Canvas.path(ctx, points, lineOpacity, null, dasharray);
          }
          this._paintArrow(ctx, points, lineOpacity);
          return this._getRenderBBOX(ctx, points);
      },
      //@internal
      _getArrowPlacement: function () {
          return this.options['arrowPlacement'];
      },
      //@internal
      _getArrowStyle: function () {
          var arrowStyle = this.options['arrowStyle'];
          if (arrowStyle) {
              return Array.isArray(arrowStyle) ? arrowStyle : this.arrowStyles[arrowStyle];
          }
          return null;
      },
      //@internal
      _getArrows: function (points, lineWidth, tolerance) {
          var _this = this;
          var arrowStyle = this._getArrowStyle();
          if (!arrowStyle || points.length < 2) {
              return [];
          }
          var isSplitted = points.length > 0 && Array.isArray(points[0]);
          var segments = (isSplitted ? points : [points]);
          var placement = this._getArrowPlacement();
          var arrows = [];
          // const map = this.getMap();
          // first = map.coordToContainerPoint(this.getFirstCoordinate()),
          //     last = map.coordToContainerPoint(this.getLastCoordinate());
          var p1, p2;
          var createArrow = function () {
              if (p1 && p2) {
                  var arrow = _this._getArrowShape(p1, p2, lineWidth, arrowStyle, tolerance);
                  if (arrow) {
                      arrows.push(arrow);
                  }
              }
          };
          //关于弧线或者平滑曲线的箭头节点分布
          /**
           * P0--arrowNextPoint----------arrowPrePoint--P1-------------arrowPrePoint--P2------------arrowPrePoint--P3.............arrowPrePoint--Pn
           */
          for (var i = segments.length - 1; i >= 0; i--) {
              var path = segments[i];
              var len = path.length;
              var first = path[0];
              var last = path[len - 1];
              //忽略closeTo判断，因为点可能有海拔，比如两个点可能是垂直关系
              if (placement === 'vertex-first') {
                  //如果有箭头专用节点使用箭头专用节点,一般是弧线或者平滑曲线
                  //第一个节点有箭头专用后置节点
                  p1 = first.arrowNextPoint || path[1];
                  p2 = first;
              }
              else if (placement === 'vertex-last') {
                  //如果有箭头专用节点使用箭头专用节点,一般是弧线或者平滑曲线
                  //其他节点有箭头专用的前置节点
                  p1 = last.arrowPrePoint || path[len - 2];
                  p2 = last;
              }
              createArrow();
              if (placement === 'vertex-firstlast') {
                  p1 = first.arrowNextPoint || path[1];
                  p2 = first;
                  createArrow();
                  p1 = last.arrowPrePoint || path[len - 2];
                  p2 = last;
                  createArrow();
              }
              if (placement === 'point') {
                  this._getArrowPoints(arrows, path, lineWidth, arrowStyle, tolerance);
              }
              // if (placement === 'vertex-first' || placement === 'vertex-firstlast' && segments[i][0].closeTo(first, 0.01)) {
              //     const arrow = this._getArrowShape(segments[i][1], segments[i][0], lineWidth, arrowStyle, tolerance);
              //     if (arrow) {
              //         arrows.push(arrow);
              //     }
              // }
              // if (placement === 'vertex-last' || placement === 'vertex-firstlast' && segments[i][segments[i].length - 1].closeTo(last, 0.01)) {
              //     const arrow = this._getArrowShape(segments[i][segments[i].length - 2], segments[i][segments[i].length - 1], lineWidth, arrowStyle, tolerance);
              //     if (arrow) {
              //         arrows.push(arrow);
              //     }
              // } else if (placement === 'point') {
              //     this._getArrowPoints(arrows, segments[i], lineWidth, arrowStyle, tolerance);
              // }
          }
          return arrows;
      },
      //@internal
      _getArrowPoints: function (arrows, segments, lineWidth, arrowStyle, tolerance) {
          for (var ii = 0, ll = segments.length - 1; ii < ll; ii++) {
              var pre = segments[ii];
              var next = segments[ii + 1];
              //如果有箭头专用节点使用箭头专用节点
              var arrow = this._getArrowShape(next.arrowPrePoint || pre, next, lineWidth, arrowStyle, tolerance);
              if (arrow) {
                  arrows.push(arrow);
              }
          }
      },
      //@internal
      _paintArrow: function (ctx, points, lineOpacity) {
          var lineWidth = this._getInternalSymbol()['lineWidth'];
          if (!isNumber(lineWidth) || lineWidth < 3) {
              lineWidth = 3;
          }
          var arrows = this._getArrows(points, lineWidth);
          if (!arrows.length) {
              return;
          }
          if (ctx.setLineDash) {
              //remove line dash effect if any
              ctx.setLineDash([]);
          }
          for (var i = arrows.length - 1; i >= 0; i--) {
              ctx.fillStyle = ctx.strokeStyle;
              Canvas.polygon(ctx, arrows[i], lineOpacity, lineOpacity);
          }
      }
  };
  LineString.include(lineStringInclude);
  var polygonInclude = {
      //@internal
      _getPaintParams: function (disableSimplify) {
          var glRes = this.getMap().getGLRes();
          var prjVertexes = this._getPrjShell();
          var points = this._getPath2DPoints(prjVertexes, disableSimplify, glRes);
          //splitted by anti-meridian
          var isSplitted = points.length > 0 && Array.isArray(points[0]);
          if (isSplitted) {
              points = [
                  [points[0]],
                  [points[1]]
              ];
          }
          var prjHoles = this._getPrjHoles();
          var holePoints = [];
          if (prjHoles && prjHoles.length > 0) {
              //outer ring  simplify result;
              var simplified = this._simplified;
              for (var i = 0; i < prjHoles.length; i++) {
                  var hole = this._getPath2DPoints(prjHoles[i], disableSimplify, glRes);
                  if (Array.isArray(hole) && isSplitted) {
                      if (Array.isArray(hole[0])) {
                          points[0].push(hole[0]);
                          points[1].push(hole[1]);
                      }
                      else {
                          points[0].push(hole);
                      }
                  }
                  else {
                      holePoints.push(hole);
                  }
              }
              // if outer ring  simplify==true , Ignore inner ring  simplify result
              if (simplified) {
                  this._simplified = simplified;
              }
          }
          if (!isSplitted) {
              points = [points];
              pushIn(points, holePoints);
          }
          return [points];
      },
      //@internal
      _paintOn: function (ctx, points, lineOpacity, fillOpacity, dasharray) {
          var r = isWithinPixel(this._painter);
          if (r.within) {
              Canvas.pixelRect(ctx, r.center, lineOpacity, fillOpacity);
          }
          else {
              Canvas.polygon(ctx, points, lineOpacity, fillOpacity, dasharray, this.options['smoothness']);
          }
          return this._getRenderBBOX(ctx, points);
      }
  };
  Polygon.include(polygonInclude);

  Map$1.VERSION = version;
  /**
   * @namespace worker
   */
  var worker = {
      Actor: Actor
  };

  exports.Ajax = Ajax;
  exports.ArcConnectorLine = ArcConnectorLine;
  exports.ArcCurve = ArcCurve;
  exports.AreaTool = AreaTool;
  exports.BBOXUtil = bbox;
  exports.Browser = Browser$1;
  exports.COLOR_PROPERTIES = COLOR_PROPERTIES;
  exports.CRS = CRS;
  exports.Canvas = Canvas;
  exports.CanvasLayer = CanvasLayer;
  exports.CanvasTileLayer = CanvasTileLayer;
  exports.Circle = Circle;
  exports.Class = Class;
  exports.CollisionIndex = CollisionIndex;
  exports.ConnectorLine = ConnectorLine;
  exports.Coordinate = Coordinate;
  exports.CubicBezierCurve = CubicBezierCurve;
  exports.Curve = Curve;
  exports.DEFAULT_TEXT_SIZE = DEFAULT_TEXT_SIZE;
  exports.DistanceTool = DistanceTool;
  exports.DomUtil = dom;
  exports.DragHandler = DragHandler;
  exports.DrawTool = DrawTool;
  exports.Ellipse = Ellipse;
  exports.Eventable = Eventable;
  exports.Extent = Extent;
  exports.GEOJSON_TYPES = GEOJSON_TYPES;
  exports.GEOMETRY_COLLECTION_TYPES = GEOMETRY_COLLECTION_TYPES;
  exports.GeoJSON = GeoJSON;
  exports.Geometry = Geometry;
  exports.GeometryCollection = GeometryCollection;
  exports.GlobalConfig = GlobalConfig;
  exports.GlobalEvent = GlobalEvent;
  exports.GroupTileLayer = GroupTileLayer;
  exports.Handler = Handler;
  exports.Handlerable = Handlerable;
  exports.INTERNAL_LAYER_PREFIX = INTERNAL_LAYER_PREFIX;
  exports.ImageLayer = ImageLayer;
  exports.JSONAble = JSONAble;
  exports.LRUCache = LRUCache;
  exports.Label = Label;
  exports.Layer = Layer;
  exports.LineString = LineString;
  exports.Map = Map$1;
  exports.MapTool = MapTool;
  exports.MapboxUtil = index$6;
  exports.Marker = Marker;
  exports.MicroTask = MicroTask;
  exports.MultiLineString = MultiLineString;
  exports.MultiPoint = MultiPoint;
  exports.MultiPolygon = MultiPolygon;
  exports.NUMERICAL_PROPERTIES = NUMERICAL_PROPERTIES;
  exports.OverlayLayer = OverlayLayer;
  exports.ParticleLayer = ParticleLayer;
  exports.Point = Point;
  exports.PointExtent = PointExtent;
  exports.Polygon = Polygon;
  exports.QuadBezierCurve = QuadBezierCurve;
  exports.RESOURCE_PROPERTIES = RESOURCE_PROPERTIES;
  exports.RESOURCE_SIZE_PROPERTIES = RESOURCE_SIZE_PROPERTIES;
  exports.Rectangle = Rectangle;
  exports.ResourceProxy = ResourceProxy;
  exports.Sector = Sector;
  exports.Size = Size;
  exports.SpatialReference = SpatialReference;
  exports.StringUtil = strings;
  exports.TextBox = TextBox;
  exports.TextMarker = TextMarker;
  exports.TileConfig = TileConfig;
  exports.TileLayer = TileLayer;
  exports.TileSystem = TileSystem;
  exports.Transformation = Transformation;
  exports.Util = index$5;
  exports.VectorLayer = VectorLayer;
  exports.WMSTileLayer = WMSTileLayer;
  exports.animate = animate;
  exports.animation = Animation$1;
  exports.control = index$1;
  exports.formatResourceUrl = formatResourceUrl;
  exports.measurer = index$4;
  exports.parseSVG = parseSVG;
  exports.projection = projections;
  exports.registerWorkerAdapter = registerWorkerAdapter;
  exports.renderer = index;
  exports.symbolizer = index$3;
  exports.ui = index$2;
  exports.worker = worker;

  typeof console !== 'undefined' && console.log && console.log('maptalks v1.0.0-rc.33');

}));
//# sourceMappingURL=maptalks.js.map
